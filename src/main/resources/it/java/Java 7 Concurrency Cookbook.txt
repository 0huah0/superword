No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form or by any means, without the prior written permission of the publisher, except in the case of brief quotations embedded in critical articles or reviews.
Every effort has been made in the preparation of this book to ensure the accuracy of the information presented.
However, the information contained in this book is sold without warranty, either express or implied.
Neither the author, nor Packt Publishing, and its dealers and distributors will be held liable for any damages caused or alleged to be caused directly or indirectly by this book.
Packt Publishing has endeavored to provide trademark information about all of the companies and products mentioned in this book by the appropriate use of capitals.
However, Packt Publishing cannot guarantee the accuracy of this information.
Javier Fernández González is a software architect with over 10 years experience with Java technologies.
He has worked as a teacher, researcher, programmer, analyst, and now as an architect in all types of projects related to Java, especially J2EE.
As a researcher, he has worked in the field of information retrieval, developing applications for processing large amount of data in Java and has participated as a co-author on several journal articles and conference presentations.
In recent years, he has worked on developing J2EE web applications for various clients from different sectors (public administration, insurance, healthcare, transportation, and so on)
He currently works as a software architect at Capgemini developing and maintaining applications for an insurance company.
Griebel Jr’s first introduction to computers was in elementary school through LOGO on an Apple and The Oregon Trail on a VAX.
Pursuing his interest in computers, he graduated from Bucknell University with a degree in Computer Engineering.
At his first job, he quickly realized he didn’t know everything that there was to know about computer programming.
He has spent the past 20 years honing his skills in the securities trading, telecommunications, payroll processing, and machine-to-machine communications industries as a developer, team leader, consultant, and mentor.
Currently working on enterprise development in Java EE, he feels that any day spent writing a code is a good day.
I would like to thank my wife and three children who are used to letting me sleep late after long nights at the computer.
Jacek Laskowski is a professional software specialist using a variety of commercial and open source solutions to meet customer’s demands.
He develops applications, writes articles, guides less-experienced engineers, records screen casts, delivers courses, and has been a technical reviewer for many IT books.
He’s recently been appointed to the IBM Academy of Technology.
Without you, I wouldn’t have achieved so much! Love you all immensely.
Abraham Tehrani, over a decade, has software development experience as a developer and QA engineer.
I would like to thank my fiancé for her support and love and my friends and family for supporting me in all of my endeavors.
Support files, eBooks, discount offers and more You might want to visit www.PacktPub.com for support files and downloads related to your book.
Did you know that Packt offers eBook versions of every book published, with PDF and ePub files available? You can upgrade to the eBook version at www.PacktPub.com and as a print book customer, you are entitled to a discount on the eBook copy.
Get in touch with us at service@ packtpub.com for more details.
At www.PacktPub.com, you can also read a collection of free technical articles, sign up for a range of free newsletters and receive exclusive discounts and offers on Packt books and eBooks.
Do you need instant solutions to your IT questions? PacktLib is Packt’s online digital book library.
Here, you can access, read and search across Packt’s entire library of books.
Why Subscribe? f Fully searchable across every book published by Packt f Copy and paste, print and bookmark content f On demand and accessible via web browser.
Free Access for Packt account holders If you have an account with Packt at www.PacktPub.com, you can use this to access PacktLib today and view nine entirely free books.
Preface When you work with a computer, you can do several things at once.
You can hear music while you edit a document in a word processor and read your e-mail.
This can be done because your operating system allows the concurrency of tasks.
Concurrent programming is about the elements and mechanisms a platform offers to have multiple tasks or programs running at once and communicate with each other to exchange data or to synchronize with each other.
Java is a concurrent platform and offers a lot of classes to execute concurrent tasks inside a Java program.
With each version, Java increases the functionalities offered to programmers to facilitate the development of concurrent programs.
This book covers the most important and useful mechanisms included in Version 7 of the Java concurrency API, so you will be able to use them directly in your applications, which are as follows:
What this book covers Chapter 1, Thread Management will teach the readers how to make basic operations with threads.
Creation, execution, and status management of the threads are explained through basic examples.
Chapter 2, Basic Thread Synchronization will teach the readers to use the low-level Java mechanisms to synchronize a code.
Chapter 3, Thread Synchronization Utilities will teach the readers to use the high-level utilities of Java to manage the synchronization between the threads in Java.
It includes an explanation of how to use the new Java 7 Phaser class to synchronize tasks divided into phases.
Chapter 4, Thread Executors will teach the readers to delegate the thread management to executors.
They allow running, managing, and getting the results of concurrent tasks.
It’s a special kind of executor oriented to execute tasks that will be divided into smaller ones using the divide and conquer technique.
Chapter 6, Concurrent Collections will teach the readers to how to use some concurrent data structures provided by the Java language.
These data structures must be used in concurrent programs to avoid the use of synchronized blocks of code in their implementation.
Chapter 7, Customizing Concurrency Classes will teach the readers how to adapt some of the most useful classes of the Java concurrency API to their needs.
The readers will also learn how to use some free tools to debug concurrent applications, such as the Eclipse, NetBeans IDE, or FindBugs applications to detect possible bugs on their applications.
Chapter 9, Additional Information is not present in the book but is available as a free download from the following link: http://www.packtpub.com/sites/default/files/ downloads/Additional.
This chapter will teach the readers the notions of synchronization, the Executor, and Fork/Join frameworks, concurrent data structures, and monitoring of concurrent objects that was not included in the respective chapters.
Appendix, Concurrent Programming Design is not present in the book but is available as a free download from the following link: http://www.packtpub.com/sites/default/ files/downloads/Concurrent.
This appendix will teach the readers some tips that every programmer should consider when he or she is going to develop a concurrent application.
What you need for this book To follow this book, you need a basic knowledge of the Java programming language.
You should know how to use an IDE, such as Eclipse or NetBeans, but this is not a necessary prerequisite.
You should already be comfortable with general Java development practices and a basic grasp of threads would be an advantage.
Conventions In this book, you will find a number of styles of text that distinguish between different kinds of information.
Here are some examples of these styles, and an explanation of their meaning.
Code words in text are shown as follows: “Extending the Thread class and overriding the.
Warnings or important notes appear in a box like this.
Let us know what you think about this book—what you liked or may have disliked.
Reader feedback is important for us to develop titles that you really get the most out of.
To send us general feedback, simply send an e-mail to feedback@packtpub.com, and mention the book title via the subject of your message.
If there is a topic that you have expertise in and you are interested in either writing or contributing to a book, see our author guide on www.packtpub.com/authors.
Customer support Now that you are the proud owner of a Packt book, we have a number of things to help you to get the most from your purchase.
Downloading the example code You can download the example code files for all Packt books you have purchased from your account at http://www.PacktPub.com.
If you purchased this book elsewhere, you can visit http://www.PacktPub.com/support and register to have the files e-mailed directly to you.
Errata Although we have taken every care to ensure the accuracy of our content, mistakes do happen.
By doing so, you can save other readers from frustration and help us improve subsequent versions of this book.
If you find any errata, please report them by visiting http://www.packtpub.com/support, selecting your book, clicking on the errata submission form link, and entering the details of your errata.
Once your errata are verified, your submission will be accepted and the errata will be uploaded on our website, or added to any list of existing errata, under the Errata section of that title.
Any existing errata can be viewed by selecting your title from http://www.packtpub.com/support.
Piracy Piracy of copyright material on the Internet is an ongoing problem across all media.
At Packt, we take the protection of our copyright and licenses very seriously.
If you come across any illegal copies of our works, in any form, on the Internet, please provide us with the location address or website name immediately so that we can pursue a remedy.
Please contact us at copyright@packtpub.com with a link to the suspected pirated material.
We appreciate your help in protecting our authors, and our ability to bring you valuable content.
Questions You can contact us at questions@packtpub.com if you are having a problem with any aspect of the book, and we will do our best to address it.
Introduction In the computer world, when we talk about concurrency, we talk about a series of tasks that run simultaneously in a computer.
This simultaneity can be real if the computer has more than one processor or a multi-core processor, or apparent if the computer has only one core processor.
All modern operating systems allow the execution of concurrent tasks.
You can read your e-mails while you listen to music and read the news in a web page.
We can say that this kind of concurrency is a process-level concurrency.
But inside a process, we can also have various simultaneous tasks.
The concurrent tasks that run inside a process are called threads.
There are different definitions and relations with the concurrency concept.
Some authors talk about concurrency when you execute your application with multiple threads in a single-core processor, so simultaneously you can see when your program execution is apparent.
Also, you can talk about parallelism when you execute your application with multiple threads in a multi-core processor or in a computer with more than one processor.
Other authors talk about concurrency when the threads of the application are executed without a predefined order, and talk about parallelism when you use various threads to simplify the solution of a problem, where all these threads are executed in an ordered way.
This chapter presents a number of recipes that show how to perform basic operations with threads using the Java 7 API.
You will see how to create and run threads in a Java program, how to control their execution, and how to group some threads to manipulate them as a unit.
Creating and running a thread In this recipe, we will learn how to create and run a thread in a Java application.
As with every element in the Java language, threads are objects.
We have two ways of creating a thread in Java:
In this recipe, we will use the second approach to create a simple program that creates and runs 10 threads.
Each thread calculates and prints the multiplication table of a number between one and 10
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or another IDE such as NetBeans, open it and create a new Java project.
Create a class named Calculator that implements the Runnable interface.
Declare a private int attribute named number and implement the constructor of the class that initializes its value.
Run the program and see how the different threads work in parallel.
The following screenshot shows part of the output of the program.
We can see that all the threads we have created, run in parallel to do their job, as shown in the following screenshot:
A Java program ends when all its threads finish (more specifically, when all its non-daemon of the threads will continue with their execution until they finish.
Creating an object of the Thread class doesn't create a new execution thread.
As we mentioned in the introduction of this recipe, there is another way of creating a new execution thread.
You can implement a class that extends the Thread class and overrides.
See also f The Creating threads through a factory recipe in Chapter 1, Thread Management.
Getting and setting thread information The Thread class saves some information attributes that can help us to identify a thread, know its status, or control its priority.
It's not recommended to change the priority of the threads, but it's a possibility that you can use if you want.
In Java, Thread can be in one of these six states: new, runnable, blocked, waiting, time waiting, or terminated.
In this recipe, we will develop a program that establishes the name and priority for 10 threads and then shows information about their status until they finish.
The threads will calculate the multiplication table of a number.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare an int private attribute named number and implement the constructor of the class that initializes this attribute.
Set the priority of five of them to the maximum value and set the priority of the rest to the minimum value.
Create a PrintWriter object to write to a file on the evolution of the status of the threads.
Write on this file the status of the 10 threads.
Until the 10 threads end, we are going to check their status.
If we detect a change in the status of a thread, we write them on the file.
Run the example and open the log.txt file to see the evolution of the 10 threads.
The following screenshot shows some lines of the log.txt file in an execution of this program.
In this file, we can see that the threads with the highest priority end before the ones with the lowest priority.
We also can see the evolution of the status of every thread.
The program shown in the console is the multiplication tables calculated by the threads and the evolution of the status of the different threads in the file log.txt.
By this way, you can better see the evolution of the threads.
The class Thread has attributes to store all the information of a thread.
The JVM uses the priority of the threads to select the one that uses the CPU at each moment and actualizes the status of every thread according to its situation.
If you don't specify a name for a thread, the JVM automatically assigns it one with the format, Thread-XX where XX is a number.
You can't modify the ID or status of a thread.
There's more… In this recipe, you learned how to access the information attributes using a Thread object.
But you can also access these attributes from an implementation of the Runnable interface.
IllegalArgumentException exception if you try to establish a priority that isn't between one and 10
Interrupting a thread A Java program with more than one execution thread only finishes when the execution of all of its threads end (more specifically, when all its non-daemon threads end its execution or when thread, because you want to terminate a program, or when a user of the program wants to cancel the tasks that a Thread object is doing.
Java provides the interruption mechanism to indicate to a thread that we want to finish it.
One peculiarity of this mechanism is that Thread has to check if it has been interrupted or not, and it can decide if it responds to the finalization request or not.
In this recipe, we will develop a program that creates Thread and, after 5 seconds, will force its finalization using the interruption mechanism.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class called PrimeGenerator that extends the Thread class.
For each number, we will calculate if it's a prime number and, in that case, we are going to write it to the console.
After processing a number, check if the thread has been interrupted by calling the end the execution of the thread.
Now, implement the main class of the example by implementing a class called Main.
The following screenshot shows the result of execution of the previous example.
We can see how the PrimeGenerator thread writes the message and ends its execution when it detects that it has been interrupted.
The Thread class has an attribute that stores a boolean value indicating whether the that attribute.
The Thread class has another method to check whether Thread has been interrupted or not.
As I mentioned earlier, Thread can ignore its interruption, but this is not the expected behaviour.
Controlling the interruption of a thread In the previous recipe, you learned how you can interrupt the execution of a thread and what you have to do to control this interruption in the Thread object.
The mechanism shown in the previous example can be used if the thread that can be interrupted is simple.
But if the thread implements a complex algorithm divided into some methods, or it has methods with recursive calls, we can use a better mechanism to control the interruption of the thread.
In this recipe, we will implement Thread that looks for files with a determined name in a folder and in all its subfolders to show how to use the InterruptedException exception to control the interruption of a thread.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare two private attributes, one for the name of the file we are going to search for and one for the initial folder.
Implement the constructor of the class, which initializes these attributes.
This method can throw an InterruptedException exception, so we have to catch them.
For each directory, the method will make a recursive call passing the directory as a parameter.
For each file, the the method checks if Thread has been interrupted and, in this case, throws an InterruptedException exception.
If the names are equal, we will write a message in the console.
After this comparison, Thread will check if it has been interrupted and, in this case, it throws an InterruptedException exception.
Create and initialize an object of the FileSearch class and Thread to execute its task.
The following screenshot shows the result of an execution of this example.
You can see how the FileSearch object ends its execution when it detects that it has been interrupted.
In this example, we use Java exceptions to control the interruption of Thread.
When you run the example, the program starts going through folders by checking if they have the file or not.
For example, if you enter in the folder \b\c\d, the program will have three recursive calls to no matter how many recursive calls have been made.
The InterruptedException exception is thrown by some Java methods related with the.
Sleeping and resuming a thread Sometimes, you'll be interested in interrupting the execution of Thread during a determined period of time.
For example, a thread in a program checks a sensor state once per minute.
During this time, the thread doesn't use any resources of the computer.
After this time, the thread will be ready to continue with its Thread class for this purpose.
This method receives an integer as the parameter indicates the number of milliseconds that the thread suspends its execution.
When the sleeping time calls, when the JVM assigns them CPU time.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Create a class called FileClock and specify that it implements the Runnable interface.
In each iteration, create a Date object, write it to the to suspend the execution of the thread for one second.
With this value, the thread InterruptedException exception, we have to include the code to catch it.
It's a good practice to include code that frees or closes the resources the thread is using when it's interrupted.
Create an object of the FileClock class and a thread to execute it.
How it works… When you run the example, you can see how the program writes a Date object per second and then, the message indicating that the FileClock thread has been interrupted.
During this time, it's not consuming CPU time, so the CPU can be executing other tasks.
When Thread is sleeping and is interrupted, the method throws an InterruptedException exception immediately and doesn't wait until the sleeping time finishes.
There's more… The Java concurrency API has another method that makes a Thread object leave the CPU.
The JVM does not guarantee that it will comply with this request.
Waiting for the finalization of a thread In some situations, we will have to wait for the finalization of a thread.
For example, we may have a program that will begin initializing the resources it needs before proceeding with the rest of the execution.
We can run the initialization tasks as threads and wait for its finalization before continuing with the rest of the program.
In this recipe, we will learn the use of this method with the initialization example.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
System.out.printf("Beginning data sources loading: %s\n",new System.out.printf("Data sources loading has finished:
Create a class called NetworkConnectionsLoader and specify that it implements method of the DataSourcesLoader class, but this will sleep for 6 seconds.
Create an object of the DataSourcesLoader class and Thread to run it.
Create an object of the NetworkConnectionsLoader class and Thread to run it.
Write a message to indicate the end of the program.
How it works… When you run this program, you can see how both Thread objects start their execution.
Then, the NetworkConnectionsLoader class finishes its execution and, at that moment, the main Thread object continues its execution and writes the final message.
Creating and running a daemon thread Java has a special kind of thread called daemon thread.
These kind of threads have very low priority and normally only executes when no other thread of the same program is running.
When daemon threads are the only threads running in a program, the JVM ends the program finishing these threads.
With these characteristics, the daemon threads are normally used as service providers for normal (also called user) threads running in the same program.
They usually have an infinite loop that waits for the service request or performs the tasks of the thread.
They can't do finish any time if there aren't any other threads running.
A typical example of these kind of threads is the Java garbage collector.
In this recipe, we will learn how to create a daemon thread developing an example with two threads; one user thread that writes events on a queue and a daemon one that cleans that queue, removing the events which were generated more than 10 seconds ago.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
This class only stores information about the events our program will work with.
Declare the queue that stores the events and implement the constructor of the class, which initializes this queue.
In each iteration, we create a new Event, save it in the queue, and sleep for one second.
Create the CleanerTask class and specify that it extends the Thread class.
Declare the queue that stores the events and implement the constructor of the class, which initializes this queue.
If an event is deleted, it writes the message of the event and the new size of the queue, so you can see its evolution.
Create the queue to store the events using the Deque class.
Each Thread writes an event and sleeps for one second.
You can play with the time until the WriterTask threads are sleeping.
If you use a smaller value, you will see that CleanerTask has less CPU time and the size of the queue will increase because CleanerTask doesn't delete any event.
There's more… thread is running, you can't modify its daemon status.
Fortunately, Java provides us with a mechanism to catch and treat the unchecked exceptions thrown in a Thread object to avoid the program ending.
In this recipe, we will learn this mechanism using an example.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
First of all, we have to implement a class to treat the unchecked exceptions.
This class must implement the UncaughtExceptionHandler interface and implement this class ExceptionHandler and make the method to write information about Exception and Thread that threw it.
Call this class Task, and force the exception, for example, try to convert a string value into an int value.
How it works… In the following screenshot, you can see the results of the execution of the example.
The exception is thrown and captured by the handler that writes the information in console about Exception and Thread that threw it.
When an exception is thrown in a thread and is not caught (it has to be an unchecked exception), the JVM checks if the thread has an uncaught exception handler set by the corresponding method.
If it has, the JVM invokes this method with the Thread object and Exception as arguments.
If the thread has not got an uncaught exception handler, the JVM prints the stack trace in the console and exits the program.
There's more… The Thread class has another method related to the process of uncaught exceptions.
It's the handler for all the Thread objects in the application.
When an uncaught exception is thrown in Thread, the JVM looks for three possible handlers for this exception.
First, it looks for the uncaught exception handler of the Thread objects as we learned in this recipe.
If this handler doesn't exist, then the JVM looks for the uncaught exception handler for ThreadGroup of the Thread objects as was explained in the Processing uncontrolled exceptions in a group of threads recipe.
If this method doesn't exist, the JVM looks for the default uncaught exception handler as we learned in this recipe.
If none of the handlers exits, the JVM writes the stack trace of the exception in the console and exits the program.
See also f The Processing uncontrolled exceptions in a group of threads recipe in Chapter 1,
Using local thread variables One of the most critical aspects of a concurrent application is shared data.
This has special importance in those objects that extend the Thread class or implement the Runnable interface.
If you create an object of a class that implements the Runnable interface and then start various Thread objects using the same Runnable object, all the threads share the same attributes.
This means that, if you change an attribute in a thread, all the threads will be affected by this change.
Sometimes, you will be interested in having an attribute that won't be shared between all the threads that run the same object.
The Java Concurrency API provides a clean mechanism called thread-local variables with a very good performance.
In this recipe, we will develop a program that has the problem exposed in the first paragraph and another program that solves this problem using the thread-local variables mechanism.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
First, we are going to implement a program that has the problem exposed previously.
Create a class called UnsafeTask and specify that it implements the Runnable interface.
Now, let's implement the main class of this problematic application.
Create a UnsafeTask class and start three threads using that object, sleeping for 2 seconds between each thread.
Thread has a different start time but, when they finish, all have the same value in its startDate attribute.
As mentioned earlier, we are going to use the thread-local variables mechanism to solve this problem.
The main class of this example is the same as the unsafe example, changing the name of the Runnable class.
How it works… In the following screenshot, you can see the results of the execution of the safe sample.
Now, the three Thread objects have their own value of the startDate attribute.
Thread-local variables store a value of an attribute for each Thread that uses one of these method to assign a value for that Thread and returns the initial value.
There's more… the thread-local variable for the thread that it's calling.
The Java Concurrency API includes the InheritableThreadLocal class that provides inheritance of values for threads created from a thread.
If a thread A has a value in a threadlocal variable and it creates another thread B, the thread B will have the same value as the called to initialize the value of the child thread in the thread-local variable.
It receives the value of the parent thread in the thread-local variable as a parameter.
Grouping threads into a group An interesting functionality offered by the concurrency API of Java is the ability to group the threads.
This allows us to treat the threads of a group as a single unit and provides access to the Thread objects that belong to a group to do an operation with them.
For example, you have some threads doing the same task and you want to control them, irrespective of how many threads are still running, the status of each one will interrupt all of them with a single call.
Java provides the ThreadGroup class to work with groups of threads.
A ThreadGroup object can be formed by Thread objects and by another ThreadGroup object, generating a tree structure of threads.
In this recipe, we will learn to work with ThreadGroup objects developing a simple example.
We will have 10 threads sleeping during a random period of time (simulating a search, for example) and, when one of them finishes, we are going to interrupt the rest.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
It will store the name of Thread that finishes first.
Declare a private String attribute called name and the methods to read and set the value.
Declare a private attribute of the Result class and implement the constructor of the class that initializes this attribute.
The method will write messages to indicate the start, end, or interruption of this Thread.
Now, create the main class of the example by creating a class called Main.
When you call the constructor of the Thread class, pass it as the first argument of the ThreadGroup object.
We can use this method to get, for example, the state of each Thread.
How it works… output generated when we write the status of each Thread object, as shown in the following screenshot:
The ThreadGroup class stores the Thread objects and the other ThreadGroup objects associated with it, so it can access all of their information (status, for example) and perform operations over all its members (interrupt, for example)
Check the API documentation to have a complete explanation of all of these methods.
A very important aspect in every programming language is the mechanism that provides management of error situations in your application.
Java language, as almost all modern programming languages, implements an exception-based mechanism to manage error situations.
It provides a lot of classes to represent different errors.
Those exceptions are thrown by the Java classes when an error situation is detected.
You can also use those exceptions, or implement your own exceptions, to manage the errors produced in your classes.
Java also provides a mechanism to capture and process those exceptions.
There are exceptions that must be captured or re-thrown using the throws clause of a method.
There are exceptions that don't have to be specified or caught.
In the recipe, Controlling the interruption of a Thread, you learned how to use a generic method to process all the uncaught exceptions that are thrown in a Thread object.
Another possibility is to establish a method that captures all the uncaught exceptions thrown by any Thread of the ThreadGroup class.
In this recipe, we will learn to set this handler using an example.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
We have to declare a constructor with one parameter, because the ThreadGroup class doesn't have a constructor without it.
In this case, this method will write in the console information about the exception and Thread that throws it and interrupts the rest of the threads in the ThreadGroup class.
Create a class called Task and specify that it implements the Runnable interface.
For this, we will divide 1000 between random numbers until the random generator generates a zero and the exception is thrown.
Now, we are going to implement the main class of the example by creating a class.
Create two Thread objects with this Task and start them.
How it works… When you run the example, you will see how one of the Thread objects threw the exception and the other one was interrupted.
When an uncaught exception is thrown in Thread, the JVM looks for three possible handlers for this exception.
First, it looks for the uncaught exception handler of the thread, as was explained in the Processing uncontrolled exceptions in a Thread recipe.
If this handler doesn't exist, then the JVM looks for the uncaught exception handler for the ThreadGroup class of the thread, as we learned in this recipe.
If this method doesn't exist, the JVM looks for the default uncaught exception handler, as was explained in the Processing uncontrolled exceptions in a Thread recipe.
If none of the handlers exit, the JVM writes the stack trace of the exception in the console and exits the program.
See also f The Processing uncontrolled exceptions in a thread recipe in Chapter 1,
Creating threads through a factory The factory pattern is one of the most used design patterns in the object-oriented programming world.
It is a creational pattern and its objective is to develop an object whose mission will be creating other objects of one or several classes.
Then, when we want to create an object of one of those classes, we use the factory instead of using the new operator.
With this factory, we centralize the creation of objects with some advantages:
For example, we can only have n objects of a type.
Java provides an interface, the ThreadFactory interface to implement a Thread object factory.
Some advanced utilities of the Java concurrency API use thread factories to create threads.
In this recipe, we will learn how to implement a ThreadFactory interface to create Thread objects with a personalized name while we save statistics of the Thread objects created.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Declare three attributes: an integer number called counter, which we will use to store the number of the Thread object created, a String called name with the base name of every Thread created, and a List of String objects called stats to save statistical data about the Thread objects created.
We also implement the constructor of the class that initializes these attributes.
In our case, we generate the name of the Thread object, create the new Thread object, and save the statistics.
Create a class called Task and specify that it implements the Runnable interface.
For this example, these tasks are going to do nothing apart from sleeping for one second.
Create 10 Thread objects using the MyThreadFactory object and start them.
Write in the console the statistics of the thread factory.
How it works… The ThreadFactory interface has only one method called newThread.
It receives a Runnable object as a parameter and returns a Thread object.
When you implement a ThreadFactory interface, you have to implement that interface and override this method.
You can improve this implementation by adding some variants by:
The use of the factory design pattern is a good programming practice but, if you implement a ThreadFactory interface to centralize the creation of threads, you have to review the code to guarantee that all threads are created using that factory.
See also f The Implementing the ThreadFactory interface to generate custom threads recipe in.
Introduction One of the most common situations in concurrent programming occurs when more than one execution thread shares a resource.
In a concurrent application, it is normal that multiple threads read or write the same data or have access to the same file or database connection.
These shared resources can provoke error situations or data inconsistency and we have to implement mechanisms to avoid these errors.
The solution for these problems comes with the concept of critical section.
A critical section is a block of code that accesses a shared resource and can't be executed by more than one thread at the same time.
To help programmers to implement critical sections, Java (and almost all programming languages) offers synchronization mechanisms.
When a thread wants access to a critical section, it uses one of those synchronization mechanisms to find out if there is any other thread executing the critical section.
Otherwise, the thread is suspended by the synchronization mechanism until the thread that is executing the critical section ends it.
When more than one thread is waiting for a thread to finish the execution of a critical section, the JVM chooses one of them, and the rest wait for their turn.
This chapter presents a number of recipes that teaches how to use the two basic synchronization mechanisms offered by the Java language:
Synchronizing a method In this recipe, we will learn how to use one of the most basic methods for synchronization in Java, that is, the use of the synchronized keyword to control the concurrent access to a method.
Only one execution thread will access one of the methods of an object declared with the synchronized keyword.
If another thread tries to access any method declared with the synchronized keyword of the same object, it will be suspended until the first thread finishes the execution of the method.
In other words, every method declared with the synchronized keyword is a critical section and Java only allows the execution of one of the critical sections of an object.
Only one execution thread will access one of the static methods declared with the synchronized keyword, but another thread can access other nonstatic methods of an object of that class.
You have to be very careful with this point, because two threads can access two different synchronized methods if one is static and the other one is not.
If both methods change the same data, you can have data inconsistency errors.
To learn this concept, we will implement an example with two threads accessing a common object.
We will have a bank account and two threads; one that transfers money to the account and another one that withdraws money from the account.
Synchronization mechanisms ensures that the final balance of the account will be correct.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class called Account that will model our bank account.
Only one thread should change the value of the balance, so use the synchronized keyword to convert this method into a critical section.
Only one thread should change the value of the balance, so use the synchronized keyword to convert this method into a critical section.
This class must implement the Runnable interface to be executed as a thread.
Implement the constructor of the class that initializes that Account object.
This class must implement the Runnable interface to be executed as a thread.
Implement the constructor of the class that initializes that account object.
Implement the main class of the application by creating a class named Main that.
Create an Account object and initialize its balance to 1000
In this recipe, you have developed an application that increments and decrements the balance of a class that simulates a bank account.
The program makes 100 calls to the expect the final and initial balances to be equal.
You have tried to force an error situation using a variable named tmp to store the value of the account's balance, so you read the account's balance, you increment the value of the temporal variable, and then you establish the value of the account's balance again.
If you want to see the problems of concurrent access to shared data, delete the the program.
Without the synchronized keyword, while a thread is sleeping after reading the value of the account's balance, another method will read the account's balance, so both the methods will modify the same balance and one of the operations won't be reflected in the final result.
As you can see in the following screenshot, you can obtain inconsistent results:
If you run the program often, you will obtain different results.
The order of execution of the threads is not guaranteed by the JVM.
So every time you execute them, the threads will read and modify the account's balance in a different order, so the final result will be different.
Now, add the synchronize keyword as you learned before and run the program again.
As you can see in the following screenshot, now you obtain the expected result.
If you run the program often, you will obtain the same result.
Using the synchronized keyword, we guarantee correct access to shared data in concurrent applications.
As we mentioned in the introduction of this recipe, only a thread can access the methods of an object that use the synchronized keyword in their declaration.
If a thread (A) is executing a synchronized method and another thread (B) wants to execute other synchronized methods of the same object, it will be blocked until the thread (A) ends.
But if threadB has access to different objects of the same class, none of them will be blocked.
The synchronized keyword penalizes the performance of the application, so you must only use it on methods that modify shared data in a concurrent environment.
If you have multiple threads calling a synchronized method, only one will execute them at a time while the others will be waiting.
If the operation doesn't use the synchronized keyword, all the threads can execute the operation at the same time, reducing the total execution time.
If you know that a method will not be called by more than one thread, don't use the synchronized keyword.
As the thread has access to the synchronized methods of an object, you can call other synchronized methods of that object, including the method that is executing.
It won't have to get access to the synchronized methods again.
We can use the synchronized keyword to protect the access to a block of code instead of an entire method.
We should use the synchronized keyword in this way to protect the access to the shared data, leaving the rest of operations out of this block, obtaining a better performance of the application.
The objective is to have the critical section (the block of code that can be accessed only by one thread at a time) be as short as possible.
We have used the synchronized keyword to protect the access to the instruction that updates the number of persons in the building, leaving out the long operations of this block that don't use the shared data.
When you use the synchronized keyword in this way, you must pass an object reference as a parameter.
Only one thread can access the synchronized code (blocks or methods) of that object.
Normally, we will use the this keyword to reference the object that is executing the method.
When you use the synchronized keyword to protect a block of code, you must pass an object reference as a parameter.
Normally, you will use the this keyword to reference the object that executes the method, but you can use other object references.
Normally, these objects will be created exclusively with this purpose.
For example, if you have two independent attributes in a class shared by multiple threads, you must synchronize the access to each variable, but there is no problem if there is one thread accessing one of the attributes and another thread accessing the other at the same time.
In this recipe, you will learn how to resolve this situation's programming with an example that simulates a cinema with two screens and two ticket offices.
When a ticket office sells tickets, they are for one of the two cinemas, but not for both, so the numbers of free seats in each cinema are independent attributes.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Implement the constructor of the Cinema class that initializes all the attributes of the class.
It uses the controlCinema1 object to control the access to the synchronized block of code.
It uses the controlCinema2 object to control the access to the synchronized block of code.
It uses the controlCinema1 object to control the access to the synchronized block of code.
It uses the controlCinema2 object to control the access to the synchronized block of code.
Implement another two methods that return the number of vacancies in each cinema.
Implement the class TicketOffice1 and specify that it implements the Runnable interface.
Declare a Cinema object and implement the constructor of the class that initializes that object.
Implement the class TicketOffice2 and specify that it implements the Runnable interface.
Declare a Cinema object and implement the constructor of the class that initializes that object.
Implement the main class of the example by creating a class called Main and add to.
Write to the console the vacancies of the two cinemas.
When you use the synchronized keyword to protect a block of code, you use an object as a parameter.
When you run this example, you can see how the final result is always the expected number of vacancies for each cinema.
In the following screenshot, you can see the results of an execution of the application:
See the See also section for other recipes that explain the use of this keyword.
See also f The Using conditions in synchronized code recipe in Chapter 2, Basic.
Using conditions in synchronized code A classic problem in concurrent programming is the producer-consumer problem.
We have a data buffer, one or more producers of data that save it in the buffer and one or more consumers of data that take it from the buffer.
As the buffer is a shared data structure, we have to control the access to it using a synchronization mechanism such as the synchronized keyword, but we have more limitations.
A producer can't save data in the buffer if it's full and the consumer can't take data from the buffer if it's empty.
When the thread controls the synchronized block of code that it's executing and allows the other threads to execute other blocks of synchronized code protected by that object.
In this recipe, you will learn how to implement the producer-consumer problem using the.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
It has two attributes: an int attribute called maxSize and a LinkedList<Date> attribute called storage.
Implement the constructor of the class that initializes the attributes of the class.
At the end of the method, we call the method.
Create a class named Producer and specify that it implements the Runnable interface.
Declare an EventStore object and implement the constructor of the class that initializes that object.
Create a class named Consumer and specify that it implements the Runnable interface.
Declare an EventStorage object and implement the constructor of the class that initializes that object.
Create the main class of the example by implementing a class named Main and add.
If you run this example, you will see how producer and consumer are setting and getting the events, but the storage never has more than 10 events.
See the See also section for other recipes that explain the use of this keyword.
See also f The Arranging independent attributes in synchronized classes recipe in Chapter 2,
Synchronizing a block of code with a Lock Java provides another mechanism for the synchronization of blocks of code.
It's a more powerful and flexible mechanism than the synchronized keyword.
It's based on the Lock interface and classes that implement it (as ReentrantLock)
With the synchronized keyword, you have to get and free the control over a synchronized block of code in a structured way.
The Lock interfaces allow you to get more complex structures to implement your critical section.
With the synchronized keyword, when a thread (A) tries to execute a synchronized block of code, if there is another thread (B) executing it, the thread (A) is suspended until the thread (B) finishes the execution method returns a Boolean value indicating if there is another thread running the code protected by this lock.
In this recipe, you will learn how to use locks to synchronize a block of code and create a critical section using the Lock interface and the ReentrantLock class that implements it, implementing a program that simulates a print queue.
Getting Ready… The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Create a class named PrintQueue that will implement the print queue.
Then, include the following code to simulate the printing of a document: PrintQueue: Printing a Job during "+(duration/1000)+
Create a class named Job and specify that it implements the Runnable interface.
Declare an object of the PrintQueue class and implement the constructor of the class that initializes that object.
Create the main class of the application by implementing a class named Main and.
How it works… In the following screenshot, you can see a part of the output of one execution, of this example:
At the beginning of the thread (A) calls this method, if no other thread has the control of the lock, the method gives the thread (A) the control of the lock and returns immediately to permit the execution of the critical section to this thread.
Otherwise, if there is another thread (B) executing the critical thread (B) finishes the execution of the critical section.
There's more… The Lock interface (and the ReentrantLock class) includes another method to get the method is that this method, if the thread that uses it can't get the control of the Lock interface, returns immediately and doesn't put the thread to sleep.
This method returns a boolean value, true if the thread gets the control of the lock, and false if not.
Take into consideration that it is the responsibility of the programmer to take into account the result of this method and act accordingly.
If the method returns the false value, it's expected that your program doesn't execute the critical section.
If it does, you probably will have wrong results in your application.
The ReentrantLock class also allows the use of recursive calls.
When a thread has the control of a lock and makes a recursive call, it continues with the control of the lock, so the execution of the recursive call.
More Info You have to be very careful with the use of Locks to avoid deadlocks.
This situation occurs when two or more threads are blocked waiting for locks that never will be unlocked.
For example, a thread (A) locks a Lock (X) and a thread (B) locks a Lock (Y)
If now, the thread (A) tries to lock the Lock (Y) and the thread (B) simultaneously tries to lock the Lock (X), both threads will be blocked indefinitely, because they are waiting for locks that will never be liberated.
Note that the problem occurs, because both threads try to get the locks in the opposite order.
The Appendix, Concurrent programming design, explains some good tips to design concurrent applications adequately and avoid these deadlocks problems.
One of the most significant improvements offered by locks is the ReadWriteLock interface and the ReentrantReadWriteLock class, the unique one that implements it.
This class has two locks, one for read operations and one for write operations.
There can be more than one thread using read operations simultaneously, but only one thread can be using write operations.
When a thread is doing a write operation, there can't be any thread doing read operations.
In this recipe, you will learn how to use a ReadWriteLock interface implementing a program that uses it to control the access to an object that stores the prices of two products.
Getting Ready… You should read the Synchronizing a block of code with a Lock recipe for a better understanding of this recipe.
How to do it… Follow these steps to implement the example:
Create a class named PricesInfo that stores information about the prices of two products.
Implement the constructor of the class that initializes the three attributes.
For the lock attribute, we create a new ReentrantReadWriteLock object.
It uses the read lock to control the access to the value of this attribute.
It uses the read lock to control the access to the value of this attribute.
It uses the write lock to control access to them.
Create a class named Reader and specify that it implements the Runnable interface.
This class implements a reader of the values of the PricesInfo class attributes.
Declare a PricesInfo object and implement the constructor of the class that initializes that object.
Create a class named Writer and specify that it implements the Runnable interface.
This class implements a modifier of the values of the PricesInfo class attributes.
Declare a PricesInfo object and implement the constructor of the class that initializes that object.
Implement the main class of the example by creating a class named Main and add.
Create five Reader objects and five Threads to execute them.
How it works… In the following screenshot, you can see a part of the output of one execution of this example:
As we mentioned previously, the ReentrantReadWriteLock class has two locks, one for read operations and one for write operations.
The lock used in read operations is obtained method declared in the ReadWriteLock interface.
This lock is an object that implements the responsibility of the programmer to ensure the correct use of these locks, using them with the same purposes for which they were designed.When you get the read lock of a Lock interface, you can't modify the value of the variable.
See also f The Synchronizing a block of code with a Lock recipe in Chapter 2,
Modifying Lock fairness The constructor of the ReentrantLock and ReentrantReadWriteLock classes admits a boolean parameter named fair that allows you to control the behavior of both classes.
The false value is the default value and it's called the non-fair mode.
In this mode, when there are some threads waiting for a lock (ReentrantLock or ReentrantReadWriteLock) and the lock has to select one of them to get the access to the critical section, it selects one without any criteria.
In this mode, when there are some threads waiting for a lock (ReentrantLock or ReentrantReadWriteLock) and the lock has to select one to get access to a critical section, it selects the thread that has been waiting for the most time.
Take into account that the behavior explained previously is only thread to sleep if the Lock interface is used, the fair attribute doesn't affect its functionality.
In this recipe, we will modify the example implemented in the Synchronizing a block of code with a Lock recipe to use this attribute and see the difference between the fair and non-fair modes.
Getting Ready… We are going to modify the example implemented in the Synchronizing a block of code with a Lock recipe, so read that recipe to implement this example.
How to do it… Follow these steps to implement the example:
Implement the example explained in the Synchronizing a block of code with a Lock recipe.
In the PrintQueue class, modify the construction of the Lock object.
Modify in the Main class the block of code that starts the threads.
How it works… In the following screenshot you can see a part of the output of one execution of this example:
All threads are created with a difference of 0.1 seconds.
While Thread 0 is running the first block of code protected by the lock, we have nine threads waiting to execute that block of code.
As the fair mode is enabled, the Lock interface will choose Thread 1, so it's the thread that has been waiting for more time for the lock.
Until all the threads have passed the first block protected by the lock, none of them will execute the second block protected by the lock.
Once all the threads have executed the first block of code protected by the lock, it's the turn of Thread 0 again.
Then, it's the turn of Thread 1, and so on.
To see the difference with the non-fair mode, change the parameter passed to the lock constructor and put the false value.
In the following screenshot, you can see the result of one execution of the modified example:
In this case, the threads are executed in the order that have been created but each thread executes the two protected blocks of code.
However, this behavior is not guaranteed because, as explained earlier, the lock could choose any thread to give it access to the protected code.
The JVM does not guarantee, in this case, the order of execution of the threads.
There's more… Read/write locks also have the fair parameter in their constructor.
The behaviour of this parameter in this kind of lock is the same as we explained in the introduction of this recipe.
See also f The Synchronizing a block of code with a Lock recipe in Chapter 2,
Using multiple conditions in a Lock A lock may be associated with one or more conditions.
The purpose of these conditions is to allow threads to have control of a lock and check whether a condition is true or not and, if it's false, be suspended until another thread wakes them up.
The Condition interface provides the mechanisms to suspend a thread and to wake up a suspended thread.
A classic problem in concurrent programming is the producer-consumer problem.
We have a data buffer, one or more producers of data that save it in the buffer, and one or more consumers of data that take it from the buffer as explained earlier in this chapter.
In this recipe, you will learn how to implement the producer-consumer problem using locks and conditions.
Getting Ready… You should read the Synchronizing a block of code with a Lock recipe for a better understanding of this recipe.
How to do it… Follow these steps to implement the example:
FileMock with two attributes: a String array named content and int named index.
They will store the content of the file and the line of the simulated file that will be retrieved.
Implement the constructor of the class that initializes the content of the file with random characters.
Now, implement a class named Buffer that will implement the buffer shared by producers and consumers.
A LinkedList<String> attribute named buffer that will store the shared data.
An int type named maxSize that stores the length of the buffer.
A ReentrantLock object called lock that controls the access to the blocks of code that modify the buffer.
A boolean type called pendingLines that will indicate if there are lines in the buffer.
When it has it, it then method in the space condition to wait for free space.
When that happens, the thread stores the line in the buffer and calls condition will wake up all the threads that were waiting for lines in the buffer.
When it has it, it checks if there are lines in the buffer.
This thread will be woken up when another thread calls the space condition and returns String.
It will be called by the producer when it has no more lines to produce.
Implement a class named Producer and specify that it implements the Runnable interface.
Implement the constructor of the class that initializes both attributes.
Implement a class named Consumer and specify that it implements the Runnable interface.
Declare a Buffer object and implement the constructor of the class that initializes it.
Implement the main class of the example by creating a class named Main and add.
Create three Consumer objects and three threads to run it.
How it works… All the Condition objects are associated with a lock and are created using the with a condition, you have to have the control of the lock associated with the condition, so.
You can't leave that loop until the condition is true.
You can use conditions with the ReadLock and WriteLock locks of a read/write lock.
See also f The Synchronizing a block of code with a Lock recipe in Chapter 2, Basic Thread.
Introduction In Chapter 2, Basic thread synchronization, we learned the concepts of synchronization and critical section.
Basically, we talk about synchronization when more than one concurrent task shares a resource, for example, an object or an attribute of an object.
The blocks of code that access this shared resource are called critical sections.
If you don't use the appropriate mechanisms, you can have the wrong results, data inconsistency, or error conditions, so we have to adopt one of the synchronization mechanisms provided by the Java language to avoid all these problems.
Chapter 2, Basic thread synchronization, taught us about the following basic synchronization mechanisms:
In this chapter, we will learn how to use high-level mechanisms to get the synchronization of multiple threads.
This mechanism is one of the basic tools of concurrent programming and is provided by most of the programming languages.
All the threads must finish one phase before they can continue with the next one.
This is a new feature of the Java 7 API.
Semaphores are a generic synchronization mechanism that you can use to protect any critical section in any problem.
The other mechanisms are thought to be used in applications with specific features as it was described previously.
Be sure to select the appropriate mechanism according to the characteristics of your application.
This chapter presents seven recipes that show you how to use the mechanisms described.
Controlling concurrent access to a resource In this recipe, you will learn how to use the semaphore mechanism provided by the Java language.
A semaphore is a counter that protects the access to one or more shared resources.
The concept of a semaphore was introduced by Edsger Dijkstra in 1965 and was used for the first time in the THEOS operating system.
When a thread wants to access one of these shared resources, first, it must acquire the semaphore.
If the internal counter of the semaphore is greater than 0, the semaphore decrements the counter and allows access to the shared resource.
A counter bigger than 0 means there are free resources that can be used, so the thread can access and use one of them.
A value of 0 in the counter means all the shared resources are used by other threads, so the thread that wants to use one of them must wait until one is free.
When the thread has finished the use of the shared resource, it must release the semaphore so that the other thread can access the shared resource.
In this recipe, you will learn how to use the Semaphore class to implement special kinds of semaphores called binary semaphores.
To show how to use it, you are going to implement a print queue that can be used by concurrent tasks to print their jobs.
This print queue will be protected by a binary semaphore, so only one thread can print at a time.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named PrintQueue that will implement the print queue.
It initializes the semaphore object that will protect the access from the print queue.
Inside the method, first of all, you must acquire the semaphore calling the exception, so you must include some code to process it.
Then, implement the lines that simulate the printing of a document waiting for a random period of time.
Create a class called Job and specify that it implements the Runnable interface.
This class implements a job that sends a document to the printer.
First, the method writes a message to the console that shows that the job has started its execution.
Finally, the method writes a message to the console that shows that it has finished its execution.
Implement the main class of the example by creating a class named Main and.
Each one of those threads will execute a Job object that will send a document to the print queue.
Then, you do the necessary operations with the shared resource.
Another important point in this example is the constructor of the PrintQueue class and the initialization of the Semaphore object.
You pass the value 1 as the parameter of this constructor, so you are creating a binary semaphore.
The initial value of the internal counter is 1, so you will protect the access to one shared resource, in this case, the print queue.
When you start the 10 threads, the first one acquires the semaphore and gets the access to the critical section.
The rest are blocked by the semaphore until the thread that has acquired it, releases it.
When this occurs, the semaphore selects one of the waiting threads and gives it the access to the critical section.
All the jobs print their documents, but one by one.
During this blocked time, the thread may be interrupted and then this method throws an InterruptedException exception.
This version of the acquire operation ignores the interruption of the thread and doesn't throw any exceptions.
But if it can't, the method returns the false value instead of being blocked and waits for the release of the semaphore.
It's your responsibility to take the correct action based on the return value.
Fairness in semaphores The concept of fairness is used by the Java language in all classes that can have various threads blocked waiting for the release of a synchronization resource (for example, a semaphore)
In this mode, when the synchronization resource is released, one of the waiting threads is selected to get this resource, but it's selected without any criteria.
The fair mode changes this behavior and forces to select the thread that has been waiting for more time.
As occurs with other classes, the Semaphore class admits a second parameter in its constructor.
If you give it the false value, you are creating a semaphore that will work in non-fair mode.
You will get the same behavior if you don't use this parameter.
If you give it the true value, you are creating a semaphore that will work in fair mode.
In the Controlling concurrent access to a resource recipe, you learned the basis of semaphores.
In that recipe, you implemented an example using binary semaphores.
These kinds of semaphores are used to protect the access to one shared resource, or to a critical section that can only be executed by one thread at a time.
But semaphores can also be used when you need to protect various copies of a resource, or when you have a critical section that can be executed by more than one thread at the same time.
In this recipe, you will learn how to use a semaphore to protect more than one copy of a resource.
You are going to implement an example, which has one print queue that can print documents in three different printers.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Implement the example described in the Controlling concurrent access to a resource recipe in this chapter.
As we mentioned earlier, you are going to modify the print queue example implemented with semaphores.
Open the PrintQueue class and declare a boolean array called freePrinters.
This array stores printers that are free to print a job and printers that are printing a document.
You will use this object to protect the access to the freePrinters array.
Modify the constructor of the class to initialize the new declared objects.
The freePrinters array has three elements, all initialized to the true value.
As this method can throw an InterruptedException exception, you must include the code to process it.
Then you get the number of the printer assigned to print this job using the private.
Then, implement the lines that simulate the printing of a document waiting for a random period of time.
First of all, declare an int variable to store the index of the printer.
Then, find the first true value in the freePrinters array and save its index in a variable.
Modify this value to false, because this printer will be busy.
Finally, free the lockPrinters object and return the index of the true value.
The key of this example is in the PrintQueue class.
The Semaphore object is created method will get the access to the critical section of this example, while the rest will be blocked.
When a thread finishes the critical section and releases the semaphore, another thread will acquire it.
In this critical section, the thread gets the index of the printer assigned to print this job.
This part of the example is used to give more realism to the example, but it doesn't use any code related with semaphores.
The following screenshot shows the output of an execution of this example:
This parameter represents the number of permits that the thread that uses them wants to acquire or release, so as to say, the number of units that this thread wants to delete or to add to the internal counter blocked until the counter gets this value or a greater one.
See also f The Controlling concurrent access to a resource recipe in Chapter 3, Thread.
Waiting for multiple concurrent events The Java concurrency API provides a class that allows one or more threads to wait until a set of operations are made.
This class is initialized with an integer number, which is the number of operations the threads are going to wait for.
When This method puts the thread to sleep until the operations are completed.
When the counter arrives to 0, the class wakes up all the.
In this recipe, you will learn how to use the CountDownLatch class implementing a videoconference system.
The video-conference system will wait for the arrival of all the participants before it begins.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Implement the constructor of the class that initializes the CountDownLatch attribute.
The Videoconference class will wait for the arrival of the number of participants received as a parameter.
It receives a String type named name as the parameter.
First, it writes a message with the parameter it has received.
Finally, it writes another message with the number of participants, whose arrival is System.out.printf("VideoConference: Waiting for %d.
Finally, write a message to indicate that all the participants have arrived.
Create the Participant class and specify that it implements the Runnable interface.
Implement the constructor of the class that initializes both attributes.
First, put the thread to sleep for a random period of time.
Finally, implement the main class of the example by creating a class named Main.
Create a Videoconference object named conference that waits for 10 participants.
Create Thread to run this Videoconference object and start it.
Create 10 Participant objects, a Thread object to run each of them, and start all the threads.
When you create a CountDownLatch object, the object uses the constructor's parameter CountDownLatch object decrements the internal counter in one unit.
When the internal counter arrives to 0, the CountDownLatch object wakes up all the threads that were waiting.
There's no way to re-initialize the internal counter of the CountDownLatch object or to modify its value.
Once the counter is initialized, the only method you can use to modify its value is have no effect.
There are some differences with respect to other synchronization methods, which are as follows:
It is used to synchronize one or more threads with the execution of various tasks.
As we explained earlier, once the counter of CountDownLatch arrives at 0, all the calls to its methods have no effect.
You have to create a new object if you want to do the same synchronization again.
The following screenshot shows the output of an execution of the example:
You can see how the last participants arrive and, once the internal counter arrives to 0, the CountDownLatch object wakes up the Videoconference object that writes the messages indicating that the video conference should start.
Synchronizing tasks in a common point The Java concurrency API provides a synchronizing utility that allows the synchronization of two or more threads in a determined point.
This class is similar to the CountDownLatch class explained in the Waiting for multiple concurrent events recipe in this chapter, but presents some differences that make them a more powerful class.
The CyclicBarrier class is initialized with an integer number, which is the number of threads that will be synchronized in a determined point.
When one of those threads arrives to the calls that method, the CyclicBarrier class blocks the thread that is sleeping until the other it wakes up all the threads that were waiting and continues with its job.
One interesting advantage of the CyclicBarrier class is that you can pass an additional Runnable object as an initialization parameter, and the CyclicBarrier class executes this object as a thread when all the threads have arrived to the common point.
This characteristic makes this class adequate for the parallelization of tasks using the divide and conquer programming technique.
In this recipe, you will learn how to use the CyclicBarrier class to synchronize a set of threads in a determined point.
You will also use a Runnable object that will execute after all the threads have arrived to that point.
In the example, you will look for a number in a matrix of numbers.
The matrix will be divided in subsets (using the divide and conquer technique), so each thread will look for the number in one subset.
Once all the threads have finished their job, a final task will unify the results of them.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
We're going to start the example by implementing two auxiliary classes.
This class will generate a random matrix of numbers between one and 10 where the threads are going to look for a number.
This constructor will receive the number of rows of the matrix, the length of each row, and the number we are going to look for as parameters.
Each time you generate a number, compare it with the number you are going to look for.
Finally, print a message in the console, which shows the number of occurrences of the number you are going to look for in the generated matrix.
This message will be used to check that the threads get the correct result.
This class will store, in an array, the number of occurrences of the searched number in each row of the matrix.
This constructor receives an integer parameter with the number of elements of the array.
Now that you have the auxiliary classes, it's time to implement the threads.
This class will look for a number in determined rows of the matrix of random numbers.
Create a class named Searcher and specify that it implements the Runnable interface.
These two attributes will determine the subset of rows where this object will look for.
Declare a private int attribute named number that will store the number we are going to look for.
Implement the constructor of the class that initializes all the attributes declared before.
Print a message in the console with the rows assigned to this object.
For each row, count the number of occurrences of the number you are searching for and store this number in the corresponding position of the Results object.
Print a message in the console to indicate that this object has finished searching.
Now, implement the class that calculates the total number of occurrences of the number in the matrix.
It uses the Results object that stores the number of appearances of the number in each row of the matrix to make the calculation.
Create a class named Grouper and specify that it implements the Runnable interface.
Implement the constructor of the class that initializes the Results attribute.
Declare an int variable and write a message to the console to indicate the start of the process.
Then, process all the elements of the array and add their value to the finalResult variable.
Finally, implement the main class of the example by creating a class named Main.
Declare and initialize five constants to store the parameters of the application.
Now, you are going to search for the number five.
When this thread finishes, it will execute the Grouper object created previously.
Create five Searcher objects, five threads to execute them, and start the five threads.
The following screenshot shows the results of an execution of this example:
We have a big matrix of random integer numbers and you want to know the total number of occurrences of a number in this matrix.
To get a better performance, we use the divide and conquer technique.
We divide the matrix in five subsets and use a thread to look for the number in each subset.
We use a CyclicBarrier object to synchronize the completion of the five threads and to execute the Grouper task to process the partial results, and calculate the final one.
As we mentioned earlier, the CyclicBarrier class has an internal counter to control how many threads have to arrive to the synchronization point.
Each time a thread arrives to the has arrived to its synchronization point.
CyclicBarrier puts the thread to sleep until all the threads arrive to their synchronization point.
When all the threads have arrived to their synchronization point, the CyclicBarrier object new thread that executes a Runnable object passed as the parameter in the construction of CyclicBarrier (in our case, a Grouper object) to do additional tasks.
Resetting a CyclicBarrier object The CyclicBarrier class has some points in common with the CountDownLatch class, but they also have some differences.
One of the most important differences is that a CyclicBarrier object can be reset to its initial state, assigning to its internal counter the value with which it was initialized.
This exception was processed in the example presented in this recipe by printing the stack trace, but in a more complex application, it could perform some other operation, such as restarting their execution or recovering their operation at the point it was interrupted.
Broken CyclicBarrier objects A CyclicBarrier object can be in a special state denoted by broken.
When there are receives an InterruptedException exception, but the other threads that were waiting receive a BrokenBarrierException exception and CyclicBarrier is placed in the broken state.
See also f The Waiting for multiple concurrent events recipe in Chapter 3, Thread.
Running concurrent phased tasks One of the most complex and powerful functionalities offered by the Java concurrency API is the ability to execute concurrent-phased tasks using the Phaser class.
This mechanism is useful when we have some concurrent tasks divided into steps.
The Phaser class provides us with the mechanism to synchronize the threads at the end of each step, so no thread starts its second step until all the threads have finished the first one.
As with other synchronization utilities, we have to initialize the Phaser class with the number of tasks that participate in the synchronization operation,  but we can dynamically modify this number by increasing or decreasing it.
In this recipe, you will learn how to use the Phaser class to synchronize three concurrent tasks.
The three tasks look for files with the extension .log modified in the last 24 hours in three different folders and their subfolders.
Get a list of the files with the extension .log in the assigned folder and its subfolders.
Filter the list created in the first step by deleting the files modified more than 24 hours ago.
If it hasn't any element, the thread ends its execution and is eliminated from the the phaser class.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE like NetBeans, open it and create a new Java project.
Create a class named FileSearch and specify that it implements the Runnable interface.
This class implements the operation of searching for files with a determined extension modified in the last 24 hours in a folder and its subfolders.
Declare a private String attribute to store the folder in which the search operation will begin.
Declare another private String attribute to store the extension of the files we are going to look for.
Declare a private List attribute to store the full path of the files we will find with the desired characteristics.
Finally, declare a private Phaser attribute to control the synchronization of the different phases of the task.
Implement the constructor of the class that will initialize the attributes of the class.
It receives as parameters the full path of the initial folder, the extension of the files, and the phaser.
For each folder, the method will make a recursive call passing the folder as a parameter.
If they are equal, this method adds the absolute path of the file to the list of results.
First, create a new empty list and get the actual date.
Then, go through all the elements of the results list.
For each path in the list of results, create a File object for that file and get the last modified date for it.
Then, compare that date with the actual date and, if the difference is less than one day, add the full path of the file to the new list of results.
Finally, change the old results list for the new one.
If it's 0, the object writes a message to the method of the Phaser object to notify it that this thread has finished the actual phase, and it leaves the phased operation.
Otherwise, if the results list has elements, the object writes a message to the console method of the Phaser object to notify it that this thread has finished the actual phase and it wants to be blocked until all the participant threads in the phased operation finish the actual phase.
The search won't begin until all the threads have been created.
Then, write a message to the console indicating the start of the search task.
Check that the initPath attribute stores the name of a folder and use the in that folder and all its subfolders.
If there are no results, finish the execution of the thread with the return keyword.
Now, implement the main class of the example by creating a class named Main and.
Create three FileSearch objects with a different initial folder for each one.
Create and start a thread to execute the first FileSearch object.
Create and start a thread to execute the second FileSearch object.
Create and start a thread to execute the third FileSearch object.
The program starts creating a Phaser object that will control the synchronization of the threads at the end of each phase.
The constructor of Phaser receives the number of participants as a parameter.
This number indicates to Phaser Phaser changes the phase and wakes up the threads that were sleeping.
Once Phaser has been created, we launch three threads that execute three different FileSearch objects.
In this example, we use paths of the Windows operating system.
If you work with another operating system, modify the paths to adapt them to existing paths in your environment.
Phaser knows the number of threads that we want to synchronize.
When a thread calls this method, Phaser decreases the number of threads that have to finalize the actual phase and puts this thread to sleep until all the remaining threads finish this phase.
Calling this method job until all the threads have been created.
At the end of phase one and phase two, we check if the phase has generated results and the list with the results has elements, or otherwise the phase hasn't generated results and the list as explained earlier.
In the second case, if the list is empty, there's no point in the thread continuing with its execution, so it returns.
But you have to notify the phaser that there will be that this thread has finished the actual phase, but it won't participate in the future phases, so the phaser won't have to wait for it to continue.
When this method ends its execution, there is a call to the of the phaser as we explained before, so when all the threads finish, the phaser will have zero participants.
As we deregister all the threads of the phaser, it will be in the termination state and this call will print true to the console.
In this state, Phaser works as it has been explained in this recipe.
This state is not mentioned in the Java concurrency API.
If you override that method, you can change the default behavior.
A notable feature of the Phaser class is that you haven't had to control any exception from the methods related with the phaser.
Unlike other synchronization utilities, threads that are sleeping in a phaser don't respond to interruption events and don't throw an InterruptedException exception.
There is only one exception that is explained in the There's more section below.
The following screenshot shows the results of one execution of the example:
You can see how the Apps thread finishes its execution in phase two because its results list is empty.
When you execute the example, you will see how some threads finish a phase before the rest, but they wait until all have finished one phase before continuing with the rest.
The Phaser class provides other methods related to the change of phase.
Be careful with the utilization of this method, because it doesn't synchronize with other threads.
If the parameter and the actual phase of the phaser aren't equal, the method returns immediately.
Registering participants in the Phaser When you create a Phaser object, you indicate how many participants will have that phaser.
But the Phaser class has two methods to increment the number of participants of a phaser.
These new participants will be considered as unarrived to the actual phase.
The only method provided by the Phaser class to decrement the number of participants is the actual phase, and it doesn't want to continue with the phased operation.
Forcing the termination of a Phaser When a phaser has zero participants, it enters a state denoted by Termination.
The Phaser in the Termination state independently of the number of participants registered in the phaser.
This mechanism may be useful when one of the participants has an error situation, to force the termination of the phaser.
If you know that your phaser could be terminated, you should verify the return value of those methods to know if the phaser has been terminated.
The Phaser class provides a method that is executed each time the phaser changes the phase and the number of registered participants; it returns a Boolean value, false if the phaser continues its execution, or true if the phaser has finished and has to enter into the termination state.
The default implementation of this method returns true if the number of registered participants is zero, and false otherwise.
But you can modify this behavior if you extend the Phaser class and you override this method.
Normally, you will be interested in doing this when you have to execute some actions when you advance from one phase to the next one.
In this recipe, you will learn how to control the phase change in a phaser that is implementing some actions in every phase change.
You are going to implement a simulation of an exam, where there will be some students who have to do three exercises.
All the students have to finish one exercise before they can proceed with the next one.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named MyPhaser and specify that it extends from the Phaser class.
If the phase is equal to zero, you have to call that the phaser has terminated.
Create a class named Student and specify that it implements the Runnable interface.
Implement the constructor of the class that initializes the Phaser object.
First, the method writes a message in the console to indicate that this student has phaser to wait for the rest of the threads.
Implement the same code for second exercise and third execise.
Implement the main class of the example by creating a class named Main and add.
Write a message to show that the phaser is in the termination state using the.
This exercise simulates the realization of an exam that has three exercises.
All the students have to finish one exercise before they can start the next one.
To implement this synchronization requirement, we use the Phaser class, but you have implemented your own.
This method is called by the phaser before making a phase change and before waking up all receives as parameters the number of the actual phase, where 0 is the number of the first phase and the number of registered participants.
If you execute a different operation depending on the actual phase, you have to use an alternative structure (if/else or switch) to select the operation you want to execute.
In the example, we used a switch structure to select a different method for each change of phase.
If the phaser returns a false value, it indicates that it hasn't terminated, so the threads will continue with the execution of other phases.
If the phaser returns a true value, then the phaser still wakes up the pending threads, but moves the phaser to the terminated state, so all the future calls to any method of the phaser will return immediately,
In the Core class, when you created the MyPhaser object, you didn't specify the number of object created to register a participant in the phaser.
This calling doesn't establish a relation between the Student object or the thread that executes it and the phaser.
Really, the number of participants in a phaser is only a number.
There is no relationship between the phaser and the participants.
The following screenshot shows the results of an execution of this example:
You can see how the students finish the first exercise at different times.
When all have finished console and then all the students start the second exercise at the same time.
See also f The Running concurrent phased tasks recipe in Chapter 3, Thread.
Changing data between concurrent tasks The Java concurrency API provides a synchronization utility that allows the interchange of data between two concurrent tasks.
In more detail, the Exchanger class allows the definition of a synchronization point between two threads.
When the two threads arrive to this point, they interchange a data structure so the data structure of the first thread goes to the second one and the data structure of the second thread goes to the first one.
This class may be very useful in a situation similar to the producer-consumer problem.
This is a classic concurrent problem where you have a common buffer of data, one or more producers of data, and one or more consumers of data.
As the Exchanger class only synchronizes two threads, you can use it if you have a producer-consumer problem with one producer and one consumer.
In this recipe, you will learn how to use the Exchanger class to solve the producer-consumer problem with one producer and one consumer.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE like NetBeans, open it and create a new Java project.
Create a class named Producer and specify that it implements the Runnable interface.
This will be the data structure that the producer will interchange with the consumer.
This will be the exchanger object that will be used to synchronize producer and consumer.
Implement the constructor of the class that initializes the two attributes.
Create a class named Consumer and specify that it implements the Runnable interface.
This will be the data structure that the producer will interchange with the consumer.
This will be the exchanger object that will be used to synchronize producer and consumer.
Implement the constructor of the class that initializes the two attributes.
As this method can throw an InterruptedException exception, you have to add the code to process it.
Write the 10 strings the producer sent in its buffer to the console and delete them from the buffer, to leave it empty.
Now, implement the main class of the example by creating a class named Core and.
Create the two buffers that will be used by the producer and the consumer.
Create the Exchanger object that will be used to synchronize the producer and the consumer.
Create the threads to execute the producer and the consumer and start the threads.
The consumer begins with an empty buffer and calls Exchanger to synchronize with the producer.
It creates 10 strings, stores it in the buffer, and uses the exchanger to synchronize with the consumer.
At this point, both threads (producer and consumer) are in Exchanger and it changes the an empty buffer to fill again.
If you execute the example, you will see how producer and consumer do their jobs concurrently and how the two objects interchange their buffers in every step.
As it occurs with sleep until the other threads arrived.
The Exchanger class has another version of the exchange method: exchange(V data, long time, TimeUnit unit) where V is the type used as a parameter in the declaration of Phaser (List<String> in our case)
The thread will be sleeping until it's interrupted, the other thread arrives, or the specified time passes.
Introduction Usually, when you develop a simple, concurrent-programming application in Java, you create some Runnable objects and then create the corresponding Thread objects to execute them.
If you have to develop a program that runs a lot of concurrent tasks, this approach has the following disadvantages:
If you have to execute a big number of tasks, this can affect the throughput of the application.
If you create too many threads, you can saturate the system.
Since Java 5, the Java concurrency API provides a mechanism that aims at resolving problems.
This mechanism is called the Executor framework and is around the Executor interface, its subinterface ExecutorService, and the ThreadPoolExecutor class that implements both interfaces.
With an executor, you only have to implement the Runnable objects and send them to the executor.
It is responsible for their execution, instantiation, and running with necessary threads.
But it goes beyond that and improves performance using a pool of threads.
When you send a task to the executor, it tries to use a pooled thread for the execution of this task, to avoid continuous spawning of threads.
Another important advantage of the Executor framework is the Callable interface.
It's similar to the Runnable interface, but offers two improvements, which are as follows:
You can use this object to control the status and the result of the Callable object.
This chapter presents 11 recipes that show you how to work with the Executor framework using the classes mentioned earlier and other variants provided by the Java Concurrency API.
Creating a thread executor The first step to work with the Executor framework is to create an object of the ThreadPoolExecutor class.
You can use the four constructors provided by that class or use a factory class named Executors that creates ThreadPoolExecutor.
Once you have an executor, you can send Runnable or Callable objects to be executed.
In this recipe, you will learn how these two operations implement an example that will simulate a web server processing requests from various clients.
Getting ready You should read the Creating and running a thread recipe in Chapter 1 to learn the basic mechanism of thread creation in Java.
You can compare both mechanisms and select the best one depending on the problem.
The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
First, you have to implement the tasks that will be executed by the server.
Create a class named Task that implements the Runnable interface.
Declare a Date attribute named initDate to store the creation date of the task and a String attribute named name to store the name of the task.
Implement the constructor of the class that initializes both attributes.
First, write to the console the initDate attribute and the actual date, which is the starting date of the task.
Then, put the task to sleep for a random period of time.
Finally, write to the console the completion date of the task.
Now, implement the Server class that will execute every task it receives using an executor.
Implement the constructor of the class that initializes the ThreadPoolExecutor object using the Executors class.
First, write a message to the console indicating that a new task has arrived.
Finally, write some executor data to the console to see its status.
Finally, implement the main class of the example by creating a class named Main.
The first important point is the creation of ThreadPoolExecutor in the constructor of the Server class.
The ThreadPoolExecutor class has four different constructors but, due to their complexity, the Java concurrency API provides the Executors class to construct executors and other related objects.
Although we can create ThreadPoolExecutor directly using one of its constructors, it's recommended to use the Executors class.
This method returns an ExecutorService object, so it's been cast to ThreadPoolExecutor to have access to all its methods.
The cached thread pool you have created creates new threads if needed to execute the new tasks, and reuses the existing ones if they have finished the execution of the task they were running, which are now available.
The reutilization of threads has the advantage that it reduces the time taken for thread creation.
The cached thread pool has, however, a disadvantage of constant lying threads for new tasks, so if you send too many tasks to this executor, you can overload the system.
Once you have created the executor, you can send tasks of the Runnable or Callable type that implements the Runnable interface.
You also have printed some log messages with information about the executor.
One critical aspect of the ThreadPoolExecutor class, and of the executors in general, is that you have to end it explicitly.
If you don't do this, the executor will continue its execution and the program won't end.
If the executor doesn't have tasks to execute, it continues waiting for new tasks and it doesn't end its execution.
A Java application won't end until all its non-daemon threads finish their execution, so, if you don't terminate the executor, your application will never end.
When the executor finishes the execution if you try to send another task to the executor, it will be rejected and the executor will throw a RejectedExecutionException exception.
The following screenshot shows part of one execution of this example:
The ThreadPoolExecutor class provides a lot of methods to obtain information about the number of threads, and the number of completed tasks of the executor.
You can also that has been in the pool at a time.
The ThreadPoolExecutor class also provides other methods related with the finalization of the executor.
The tasks that are running when you call this method continue with their execution, but the method doesn't wait for their finalization.
If you want to wait for the completion of the tasks, regardless of their duration, use a big timeout, for example, DAYS.
See also f The Controlling rejected tasks of an executor recipe in Chapter 4, Thread Executors.
Creating a fixed-size thread executor method of the Executors class, you can have a problem with the number of threads the executor is running at a time.
The executor creates a new thread for each task that receives, (if there is no pooled thread free) so, if you send a large number of tasks and they have long duration, you can overload the system and provoke a poor performance of your application.
If you want to avoid this problem, the Executors class provides a method to create a fixed-size thread executor.
If you send more tasks than the number of threads, the executor won't create additional threads and the remaining tasks will be blocked until the executor has a free thread.
With this behavior, you guarantee that the executor won't yield a poor performance of your application.
In this recipe, you are going to learn how to create a fixed-size thread executor modifying the example implemented in the first recipe of this chapter.
Getting ready You should read the Creating a thread executor recipe in this chapter and implement the example explained in it, because you're going to modify this example.
The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Implement the example described in the first recipe of this chapter.
Open the Server create the executor and pass the number 5 as the parameter.
This method creates an executor with a maximum number of threads.
If you send more tasks than the number of threads, the remaining tasks will be blocked until there is a free thread to process them This method receives the maximum number of threads as a parameter you want to have in your executor.
In your case, you have created an executor with five threads.
The following screenshot shows part of the output of one execution of this example:
To write the output of the program, you have used some methods of the ThreadPoolExecutor class, including:
You can see how the output of these methods is 5, indicating that the executor has five threads.
It does not exceed the established maximum number of threads.
When you send the last task to the executor, it has only 5 active threads.
It creates an executor with only one thread, so it can only execute one task at a time.
One of the advantages of the Executor framework is that you can run concurrent tasks that return a result.
The Java Concurrency API achieves this with the following two interfaces:
In this recipe, you will learn how to implement tasks that return a result and run them on an executor.
Getting ready… The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a private Integer attribute called number to store the number that this task will use for its calculations.
Implement the constructor of the class that initializes the attribute of the class.
First, create and initialize the internal variables used in the method.
Between two multiplications, and for educational purposes, put this task to sleep for 20 milliseconds.
Write a message to the console with the result of the operation.
Implement the main class of the example by creating a class named Main.
Create a FactorialCaculator object passing this random number as a parameter.
This method returns a Future<Integer> object to manage the task, and eventually get its result.
Create a do loop to monitor the status of the executor.
First, write a message to the console indicating the number of completed tasks System.out.printf("Main: Number of Completed Tasks:
Repeat this loop while the number of completed tasks of the executor is less than 10
Write to the console the results obtained by each task.
In this recipe, you have learned how to use the Callable interface to launch concurrent tasks that return a result.
You have implemented the FactorialCalculator class that implements the Callable interface with Integer as the type of the result.
The other critical point of this example is in the Main class.
You send a Callable object to be as a parameter and returns a Future object that you can use with two main objectives:
If the specified period of time passes and the result isn't yet available, the method returns a null value.
A common problem in concurrent programming is when you have various concurrent tasks that solve a problem, and you are only interested in the first result of those tasks.
You can launch all of them and get the result of the first one that sorts these, that is, the fastest sorting algorithm for a given array.
In this recipe, you will learn how to implement this scenario using the ThreadPoolExecutor class.
You are going to implement an example where a user can be validated by two mechanisms.
The user will be validated if one of those mechanisms validates it.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named UserValidator that will implement the process of user validation.
Declare a private String attribute named name that will store the name of a user validation system.
Implement the constructor of the class that initializes its attributes.
Wait for a random period of time to simulate the process of user validation.
The method returns a true value when the user is validated and a false value when the user is not validated.
Now, create a class named TaskValidator that will execute a validation process with a UserValidation object as a concurrent task.
Specify that it implements the Callable interface parameterized with the String class.
Implement the constructor of the class that will initialize all the attributes.
If the user is not validated by the UserValidator object, write a message to the console indicating this circumstance and throw an Exception exception.
Otherwise, write a message to the console indicating that the user has been validated and return the name of the UserValidator object.
Now, implement the main class of the example by creating a class named Main and.
Create two String objects named user and password and initialize them with the test value.
Create a list of TaskValidator objects and add to it the two objects that you have created.
Also, it writes the String object returned by this method to the console.
ThreadPoolExecutor class receives a list of tasks, launches them, and returns the result of the first task that finishes without throwing an exception.
The following screenshot shows the output of an execution of the example when one task validates the user:
The example has two UserValidator objects that return a random boolean value.
Each UserValidator object is used by a Callable object, implemented by the TaskValidator TaskValidator class throws Exception.
So, we have two tasks that can return the true value or throw an Exception exception.
If you run the examples several times, you get the four possible solutions you can get.
The following screenshot shows the output of the application when both tasks throw an exception:
See also f The Running multiple tasks and processing all the results recipe in Chapter 4,
The Executor framework allows you to execute concurrent tasks without worrying about thread creation and execution.
It provides you the Future class that you can use to control the status and get the results of any task executed in an executor.
When you want to wait for the finalization of a task, you can use the following two methods:
With the first one, you can only control the completion of a task, and with the second one, you have to shutdown the executor to wait for a thread, otherwise the method's call returns immediately.
The ThreadPoolExecutor class provides a method that allows you to send to the executor a list of tasks and wait for the finalization of all the tasks in the list.
In this recipe, you will learn how to use this feature by implementing an example with three tasks executed and their results printed out when they finish.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named Result to store the results generated in the concurrent tasks of this example.
One String attribute named name and one int attribute named value.
Create a class named Task that implements the Callable interface parameterized with the Result class.
Implement the constructor of the class that initializes its attribute.
First, write a message to the console to indicate that the task is starting.
To generate an int value to return in the Result object, calculate the sum of five random numbers.
Create a Result object and initialize it with the name of this task and the result of the operation done earlier.
Write a message to the console to indicate that the task has finished.
Finally, implement the main class of the example by creating a class named Main.
Create three Task objects and save them on that list.
Write the results of the tasks processing the list of the Future objects.
In this recipe, you have learned how to send a list of tasks to an executor and wait for the the Callable objects and returns a list of the Future objects.
This list will have a Future object per task in the list.
The first object in the list of the Future objects will be the object that controls the first task in the list of the Callable objects, and so on.
The first point to take into consideration is that the type of data used for the parameterization of the Future interface in the declaration of the list that stores the result objects must be compatible with the one used to parameterized the Callable objects.
In this case, you have used the same type of data: the Result class.
As the method finishes when all the tasks have will return the true value.
See also f The Executing tasks in an executor that returns a result recipe in Chapter 4,
Running a task in an executor after a delay The Executor framework provides the ThreadPoolExecutor class to execute Callable and Runnable tasks with a pool of threads, which avoid you all the thread creation operations.
When you send a task to the executor, it's executed as soon as possible, according to the configuration of the executor.
There are used cases when you are not interested in executing a task as soon as possible.
You may want to execute a task after a period of time or to execute a task periodically.
For these purposes, the Executor framework provides the ScheduledThreadPoolExecutor class.
In this recipe, you will learn how to create ScheduledThreadPoolExecutor and how to use it to schedule execution of a task after a given period of time.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named Task that implements the Callable interface parameterized with the String class.
Declare a private String attribute named name that will store the name of the task.
Implement the constructor of the class that initializes the name attribute.
Implement the main class of the example by creating a class named Main.
Create an executor of the ScheduledThreadPoolExecutor class using as a parameter.
Write a message to indicate the time when the program finishes.
The key point of this example is the Main class and the management of ScheduledThreadPoolExecutor.
As with class ThreadPoolExecutor, to create a scheduled executor, Java recommends the utilization of the Executors class.
This parameter is the number of threads you want to have in the pool.
To execute a task in this scheduled executor after a period of time, you have to use the.
In this case, each task will wait for a number of seconds (TimeUnit.SECONDS) equal to its position in the array of tasks plus one.
If you want to execute a task at a given time, calculate the difference between that date and the current date and use that difference as the delay of the task.
The following screenshot shows the output of an execution of this example:
You can see how the tasks start their execution one per second.
All the tasks are sent to the executor at the same time, but each one with a delay of 1 second later than the previous task.
Although the ScheduledThreadPoolExecutor class is a child class of the ThreadPoolExecutor class and, therefore, inherits all its features, Java recommends the utilization of ScheduledThreadPoolExecutor only for scheduled tasks.
Finally, you can configure the behavior of the ScheduledThreadPoolExecutor the end of their delay time.
The default behavior is that those tasks will be executed despite the finalization of the executor.
You can change this behavior using the pending tasks won't get executed.
See also f The Executing tasks in an executor that returns a result recipe in Chapter 4,
Running a task in an executor periodically The Executor framework provides the ThreadPoolExecutor class to execute concurrent tasks using a pool of threads that avoids you all the thread creation operations.
When you send a task to the executor, according to its configuration, it executes the task as soon as possible.
When it ends, the task is deleted from the executor and, if you want to execute them again, you have to send it again to the executor.
But the Executor framework provides the possibility of executing periodic tasks through the ScheduledThreadPoolExecutor class.
In this recipe, you will learn how to use this functionality of that class to schedule a periodic task.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named Task and specify that it implements the Runnable interface.
Declare a private String attribute named name that will store the name of the task.
Implement the constructor of the class that initializes that attribute.
Implement the main class of the example by creating a class named Main and.
Create ScheduledThreadPoolExecutor using the 1 as the parameter to that method.
Write a message to the console with the actual date.
This method returns a ScheduledFuture object that you can use to control the status of the task.
Create a loop with 10 steps to write the time remaining for the next  execution of the get the number of milliseconds until the next execution of the task.
Put the thread to sleep for 5 seconds to verify that the periodic tasks have finished.
Write a message to indicate the end of the program.
When you want to execute a periodic task using the Executor framework, you need a ScheduledExecutorService object.
To create it (as with every executor), Java recommends the use of the Executors class.
This class works as a factory of executor ScheduledExecutorService object.
That method receives as a parameter the number of threads of the pool.
As you have only one task in this example, you have passed the value 1 as a parameter.
Once you have the executor needed to execute a periodic task, you send the task to the four parameters: the task you want to execute periodically, the delay of time until the first execution of the task, the period between two executions, and the time unit of the second and third parameters.
An important point to consider is that the period between two executions is the period of time between these two executions that begins.
In this example, as your task is a Runnable object that is not parameterized, you have to parameterize them with the ? symbol as a parameter.
This method receives a TimeUnit constant with the time unit in which you want to receive the results.
The following screenshot shows the output of an execution of the example:
That's how long the main thread has been put to sleep.
When you shut down the executor, the scheduled task ends its execution and you don't see more messages in the console.
You can also configure the behavior of an instance of the ScheduledThreadPoolExecutor tasks finish when you call that method.
You can change this behavior using the ScheduledThreadPoolExecutor class with a true value.
Canceling a task in an executor When you work with an executor, you don't have to manage threads.
You only implement the Runnable or Callable tasks and send them to the executor.
It's the executor that's responsible for creating threads, managing them in a thread pool, and finishing them if they are not needed.
Sometimes, you may want to cancel a task that you sent to the executor.
In this recipe, you will learn how to use this method to cancel the tasks that you have sent to an executor.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named Task and specify that it implements the Callable interface message to the console and put it to sleep for 100 milliseconds inside an infinite loop.
Implement the main class of the example by creating a class named Main and add.
If the task is already running, Boolean value as a parameter.
If the value of that parameter is true and the task is running, it will be canceled.
If the value of the parameter is false and the task is running, it won't be canceled.
The following screenshot shows the output of an execution of this example:
See also f The Executing tasks in an executor that returns a result recipe in Chapter 4,
Controlling a task finishing in an executor code after the finalization of a task executed in an executor.
It can be used to make some post-process operations, generating a report, sending results by e-mail, or releasing some resources.
This method is called internally by the FutureTask class when the execution of the task that this FutureTask object is controlling finishes.
The method is called after the result of the task is set and its status is changed to the isDone status, regardless of whether the task has been canceled or finished normally.
You can override the FutureTask class and implement this method to change this behavior.
In this recipe, you will learn how to override this method to execute code after the finalization of the tasks.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project..
Implement the constructor of the class to initialize the name of the task.
Implement a class named ResultTask that extends the FutureTask class parameterized with the String class.
It has to receive a Callable object as a parameter.
Call the constructor of the parent class and initialize the name attribute using the attribute of the task received.
Implement the main class of the example by creating a class named Main and add.
For each position in the array, first, you have to create ExecutorTask and then ResultTask using that object.
Cancel all the tasks you have sent to the executor.
Write to the console the result of those tasks that haven't been canceled using the.
In this example, you have implemented a Callable object, the ExecutableTask class, and then, a subclass of the FutureTask class that controls the execution of the ExecutableTask objects.
You can't change the result value of the task or change its status, but you can close resources used by the task, write log messages, or send notifications.
See also f The Executing tasks in an executor that returns a result recipe in Chapter 4,
Separating the launching of tasks and the processing of their results in an executor.
Normally, when you execute concurrent tasks using an executor, you will send Runnable or Callable tasks to the executor and get Future objects to control the method.
You can find situations, where you need to send the tasks to the executor in one object and process the results in another one.
This CompletionService class has a method to send the tasks to an executor and a method to get the Future object for the next task that has finished its execution.
Internally, it uses an Executor object to execute the tasks.
This behavior has the advantage to share a CompletionService object, and sends tasks to the executor so the others can process the results.
The limitation is that the second object can only get the Future objects for those tasks that have finished its execution, so these Future objects can only be used to get the results of the tasks.
In this recipe, you will learn how to use the CompletionService class to separate launching tasks in an executor from processing their results.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare two private String attributes named sender and title that will represent data for the report.
Implement the constructor of the class that initializes the two attributes.
Then, generate the report as a string with the sender and title attributes and return that string.
Create a class named ReportRequest and specify that it implements the Runnable interface.
Implement the constructor of the class that initializes the two attributes.
CompletionService interface is a parameterized interface, use the String class as parameter of this CompletionService interface.
Implement the constructor of the class to initialize the two attributes.
Implement the main class of the example by creating a class named Main and add.
Create CompletionService using the executor created earlier as a parameter of the constructor.
Create two ReportRequest objects and the threads to execute them.
Create a ReportProcessor object and the thread to execute it.
Finish the execution of the ReportSender object setting the value of its end attribute to true.
In the main class of the example, you have created ThreadPoolExecutor using the object to initialize a CompletionService object because the completion service uses an executor to execute its tasks.
To execute a task using the completion service, you use the.
When one of these tasks is executed when the completion service finishes its execution, the completion service stores the Future object used to control its execution in a queue.
The and, if so, returns the first element of that queue which is a Future object for a task that has the queue.
In this case, you have passed two attributes to that method to indicate the time you want to wait for the finalization of a task, in case the queue with the results of the finished tasks is empty.
Once the CompletionService object is created, you create two ReportRequest objects that execute three ReportGenerator tasks, each one in CompletionService, and a ReportSender task that will process the results generated by the tasks sent by the two ReportRequest objects.
In this example, you have used Callable, but you could also send Runnable objects.
Since Runnable objects don't produce a result, the philosophy of the CompletionService class doesn't apply in such cases.
This class also provides two other methods to obtain the Future objects of the finished tasks.
Otherwise, it returns its first element and removes it from the queue.
If it is empty, it blocks the thread until the queue has an element.
When the queue has elements, it returns and deletes its first element from the queue.
See also f The Executing tasks in an executor that returns a result recipe in Chapter 4,
Controlling rejected tasks of an executor to indicate that it should finish.
The executor waits for the completion of the tasks that are running or waiting for their execution, and then finishes its execution.
The ThreadPoolExecutor class provides a mechanism, which is called when a task is rejected.
In this recipe, you will learn how to manage rejecting tasks in an executor that is implementing with RejectedExecutionHandler.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Write to the console the name of the task that has been rejected and the name and status of the executor.
Write a message to the console to indicate the finalization of the method.
Implement the main class of the example by creating a class named Main and add.
Write a message to the console to indicate the finalization of the program.
In the following screenshot, you can see the result of an execution of the example:
You can see that the task is rejected when execution has been shut down and RejectecTaskController writes to the console information about the task and the executor.
To manage rejected tasks for an executor, you should create a class that implements the RejectedExecutionHandler interface.
This method is called for every task that is rejected by the executor.
First, it looks for the handler established with method of that class, otherwise it throws RejectedExecutionExeption.
This is a runtime exception, so you don't need to put a catch clause to control it.
Introduction Normally, when you implement a simple, concurrent Java application, you implement some Runnable objects and then the corresponding Thread objects.
You control the creation, execution, and status of those threads in your program.
Java 5 introduced an improvement with the Executor and ExecutorService interfaces and the classes that implement them (for example, the ThreadPoolExecutor class)
The Executor framework separates the task creation and its execution.
With it, you only have to implement the Runnable objects and use an Executor object.
You send the Runnable tasks to the executor and it creates, manages, and finalizes the necessary threads to execute those tasks.
Java 7 goes a step further and includes an additional implementation of the ExecutorService interface oriented to a specific kind of problem.
This framework is designed to solve problems that can be broken into smaller tasks using the divide and conquer technique.
Inside a task, you check the size of the problem you want to resolve and, if it's bigger than an established size, you divide it in smaller tasks that are executed using the framework.
If the size of the problem is smaller than the established size, you solve the problem directly in the task and then, optionally, it returns a result.
There is no formula to determine the reference size of a problem that determines if a task is subdivided or not, depending on its characteristics.
You can use the number of elements to process in the task and an estimation of the execution time to determine the reference size.
Test different reference sizes to choose the best one to your problem.
You can consider ForkJoinPool as a special kind of Executor.
The main difference between the Fork/Join and the Executor frameworks is the work-stealing algorithm.
Unlike the Executor framework, when a task is waiting for the finalization of the subtasks it has created using the join operation, the thread that is executing that task (called worker thread) looks for other tasks that have not been executed yet and begins its execution.
By this way, the threads take full advantage of their running time, thereby improving the performance of the application.
To achieve this goal, the tasks executed by the Fork/Join framework have the following limitations:
If they use other synchronization mechanisms, the worker threads can't execute other tasks when they are in the synchronization operation.
It has to include the code necessary to process them.
The core of the Fork/Join framework is formed by the following two classes:
It manages the worker threads and offers information about the status of the tasks and their execution.
Usually, to implement your Fork/Join tasks, you will implement a subclass of two subclasses of this class: RecursiveAction for tasks with no return result and RecursiveTask for tasks that return one.
This chapter presents five recipes that show you how to work efficiently with the Fork/Join framework.
Creating a Fork/Join pool In this recipe, you will learn how to use the basic elements of the Fork/Join framework.
The main characteristics of the Fork/Join framework you're going to use in this example are as follows:
When a task executes two or more subtasks, it waits for their finalizations.
By this way, the thread that was executing that task (called worker-thread) will look for other tasks to execute, taking full advantage of their execution time.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
In this recipe, you are going to implement a task to update the price of a list of products.
The initial task will be responsible for updating all the elements in a list.
Create a class named Product that will store the name and price of a product.
Declare a private String attribute named name and a private double attribute named price.
Implement both the methods and establish the values of both attributes.
Create a class named ProductListGenerator to generate a list of random products.
Assign the same price to all of the products, for example, 10 to check that the program works well.
This element is necessary, because the parent class of the RecursiveAction class, the ForkJoinTask class, implements the Serializable interface.
These attributes will determine the block of products this task has to process.
Declare a private double attribute named increment to store the increment of the price of the products.
Implement the constructor of the class that will initialize all the attributes of the class.
Implement the main class of the example by creating a class named Main and add.
Create a list of 10,000 products using the ProductListGenerator class.
Create a new Task object to update the products of all the products of the list.
Implement a block of code that shows information about the evolution of the pool every five milliseconds writing to the console the value of some parameters of the pool until the task finishes its execution.
The expected price of all products, after the increment, is 12
Write the name and the price of all the products that have a price difference of 12 to check that all of them have increased their price correctly.
Write a message to indicate the finalization of the program.
In this example, you have created a ForkJoinPool object and a subclass of the ForkJoinTask class that you execute in the pool.
To create the ForkJoinPool object, you have used the constructor without arguments, so it will be executed with its default configuration.
It creates a pool with a number of threads equal to the number of processors of the computer.
When the ForkJoinPool object is created, those threads are created and they wait in the pool until some tasks arrive for their execution.
Since the Task class doesn't return a result, it extends the RecursiveAction class.
In the recipe, you have used the recommended structure for the implementation of the task.
If the task has to update more than 10 products, it divides those set of elements into two blocks, creates two tasks, and assigns a block to each task.
You have used the first and last attributes in the Task class to know the range of positions that this task has to update in the list of products.
You have used the first and last attributes to use only one copy of the products list and not create different lists for each task.
While the task is waiting for its subtasks, the worker thread that was executing it takes another task that was waiting for execution and executes it.
With this behavior, the Fork/Join framework offers a more efficient task management than the Runnable and Callable objects themselves.
In the Executor framework, all the tasks have to be sent to the executor, while in this case, the tasks include methods to execute and that extends the RecursiveAction class that extends the ForkJoinTask class.
In this case, it's an asynchronous call, and the main thread continues its execution.
You have used some methods of the ForkJoinPool class to check the status and the evolution of the tasks that are running.
The class includes more methods that can be useful for this purpose.
See the Monitoring a Fork/Join pool recipe for a complete list of those methods.
Finally, like with the Executor framework, you should finish ForkJoinPool using the.
The following screenshot shows part of an execution of this example:
You can see the tasks finishing their work and the price of the products updates.
The ForkJoinPool class provides other methods to execute a task in.
In this case, you send a Runnable task to the ForkJoinPool class.
Note that the ForkJoinPool class doesn't use the work-stealing algorithm with Runnable objects.
The ForkJoinPool class doesn't use the work-stealing algorithm with the Callable objects, so you'd be better off executing them using an executor.
You can pass to it as parameters as many ForkJoinTask objects as you want.
This generic type T must be the ForkJoinTask class or a subclass of it.
Although the ForkJoinPool class is designed to execute an object of ForkJoinTask, you method of the ForkJoinTask class that accepts a Callable object or a Runnable object and returns a ForkJoinTask object to execute that task.
See also f The Monitoring a Fork/Join pool recipe in Chapter 8, Testing concurrent applications.
Joining the results of the tasks The Fork/Join framework provides the ability of executing tasks that return a result.
These kinds of tasks are implemented by the RecursiveTask class.
This class extends the ForkJoinTask class and implements the Future interface provided by the Executor framework.
Inside the task, you have to use the structure recommended by the Java API documentation:
If the task has to resolve a problem bigger than a predefined size, you divide the problem in more subtasks and execute those subtasks using the Fork/Join framework.
When they finish their execution, the initiating task obtains the results generated by all the subtasks, groups them, and returns the final result.
Ultimately, when the initiating task executed in the pool finishes its execution, you obtain its result that is effectively the final result of the entire problem.
In this recipe, you will learn how to use this kind of problem solving with Fork/Join framework developing an application that looks for a word in a document.
All the tasks are going to return the number of appearances of the word in the part of the document or line they process.
It will generate a string matrix that will simulate a document.
This array will be used in the generation of the strings matrix.
First, create the necessary objects to generate the document: the String matrix and a Random object to generate random numbers.
Store in each position the string which is at a random position in the array of words and count the number of appearances of the word the program will look for in the generated array.
You can use this value to check whether the program does its job properly.
Write a message with the number of appearances of the word and return the matrix generated.
This class will implement the task that will calculate the number of appearances of the word in a set of lines.
Declare a private String matrix named document and two private int attributes named start and end.
Implement the constructor of the class to initialize all its attributes.
Otherwise, divide the group of lines in two objects, create two new DocumentTask objects to process those two groups, and execute them in the pool using the.
For each line the task has to process, create a LineTask object to process the complete line, and store them in a list of tasks.
Sum the value returned by all these tasks and return the result.
Create a class named LineTask and specify that it extends the RecursiveTask class parameterized with the Integer class.
This class will implement the task that will calculate the number of appearances of the word in a line.
This element is necessary because the parent class of the RecursiveTask class, the ForkJoinTask class, implements the Serializable interface.
Declare a private String array attribute named line and two private int attributes named start and end.
Implement the constructor of the class to initialize all its attributes.
Otherwise, divide the group of words in the line in two, create two new LineTask objects to process those two groups, and execute them in the pool using the.
Compare the words stored in the positions between the start and end attributes with the word attribute the task is searching for and if they are equal, increment a counter variable.
To slow the execution of the example, put the task to sleep for 10 milliseconds.
Implement the main class of the example by creating a class named Main with a.
Create a new DocumentTask object to update the products of the entire document.
Create a ForkJoinPool object using the constructor without parameters and.
Implement a block of code that shows information about the progress of the pool writing every second to the console the value of some parameters of the pool until the task finishes its execution.
Write the number of the appearances of the word in the document.
Check that this number is the same as the number written by the DocumentMock class.
If this set of lines has a size smaller that 10, it creates LineTask per line, and when they finish their execution, it sums the results of those tasks and returns the result of the sum.
If the set of lines the task has to process has a size of 10 or bigger, it divides the set in two and creates two DocumentTask objects to process those new sets.
When those tasks finish their execution, the tasks sum their results and return that sum as a result.
If this set of words is smaller than 100, the task searches the word directly in that set of words and returns the number of appearances of the word.
Otherwise, it divides the set of words in two and creates two LineTask objects to process those sets.
When those tasks finish their execution, the task sums the results of both tasks and returns that sum as a result.
In the Main class, you have created a ForkJoinPool object using the default constructor and you have executed in it a DocumentTask class that has to process a document of DocumentTask objects and LineTask objects, and when all the tasks finish their execution, you can use the original task to get the total number of appearances of the word in the whole document.
Since the tasks return a result, they extend the RecursiveTask class.
When you execute the program, you can compare the first and the last lines written in the console.
The first line is the number of appearances of the word calculated when the document is generated and the last is the same number calculated by the Fork/Join tasks.
There's more… The ForkJoinTask class provides another method to finish execution of a task and returns in the parameterization of the RecursiveTask class and returns that object as a result of asynchronous tasks.
Since the RecursiveTask class implements the Future interface, there's another version.
If the specified period of time passes and the result isn't yet available, the method returns a null value.
Running tasks asynchronously When you execute ForkJoinTask in ForkJoinPool, you can do it in a synchronous or asynchronous way.
When you do it in a synchronous way, the method that sends the task to the pool doesn't return until the task sent finishes its execution.
When you do it in an asynchronous way, the method that sends the task to the executor returns immediately, so the task can continue with its execution.
You should be aware of a big difference between the two methods.
When you use the synchronized methods, the task that calls one of these methods (for example, the This allows the ForkJoinPool class to use the work-stealing algorithm to assign a new task to the worker thread that executed the sleeping task.
On the contrary, when you use execution, so the ForkJoinPool class can't use the work-stealing algorithm to increase the to wait for the finalization of a task, the ForkJoinPool class can use that algorithm.
In this recipe, you will learn how to use the asynchronous methods provided by the ForkJoinPool and ForkJoinTask classes for the management of tasks.
You are going to implement a program that will search for files with a determined extension inside a folder and its subfolders.
The ForkJoinTask class you're going to implement will process the content of a folder.
For each subfolder inside that folder, it will send a new task to the ForkJoinPool class in an asynchronous way.
For each file inside that folder, the task will check the extension of the file and add it to the result list if it proceeds.
This element is necessary because the parent class of the RecursiveTask class, the ForkJoinTask class, implements the Serializable interface.
This attribute will store the full path of the folder this task is going to process.
This attribute will store the name of the extension of the files this task is going to look for.
Implement the constructor of the class to initialize its attributes.
Declare a list of String objects to store the names of the files stored in the folder.
Declare a list of FolderProcessor tasks to store the subtasks that are going to process the subfolders stored in the folder.
Otherwise, compare the extension of the file with the extension you are looking for in the list of strings declared earlier.
If the list of the FolderProcessor subtasks has more than 50 elements, write a message to the console to indicate this circumstance.
Pass to it as parameters the list of strings and the list of the FolderProcessor subtasks.
If so, the method returns the true value, otherwise it returns the false value.
Implement the main class of the example by creating a class named Main with a.
Write to the console information about the status of the pool every second until the three tasks have finished their execution.
Write the number of results generated by each task to the console.
The following screenshot shows part of an execution of this example:
The key of this example is in the FolderProcessor class.
As you know, this content has the following two kinds of elements:
If the task finds a folder, it creates another Task object to process that folder and sends it to if it has a free worker-thread or it can create a new one.
The method returns immediately, so the task can continue processing the content of the folder.
For every file, a task compares its extension with the one it's looking for and, if they are equal, adds the name of the file to the list of results.
Once the task has processed all the content of the assigned folder, it waits for the finalization method.
The task groups the results of all the tasks it sent with its own results and returns.
The ForkJoinPool class also allows the execution of tasks in an asynchronous way.
You the status and the evolution of the tasks that are running in it.
The ForkJoinPool class includes more methods that can be useful for this purpose.
See the Monitoring a Fork/Join pool recipe to see a complete list of those methods.
If the specified period of time passes and the result isn't yet available, the method returns a null value.
Throwing exceptions in the tasks There are two kinds of exceptions in Java:
You have to include the necessary code to handle exceptions.
On the other hand, you can throw (or it can be thrown by any method or object used inside the method) an unchecked exception.
The behavior of the ForkJoinTask and ForkJoinPool classes is different from what you may expect.
The program doesn't finish execution and you won't see any information about the exception in the console.
You can, however, use some methods of the ForkJoinTask class to know if a task threw an exception and what kind of exception it was.
In this recipe, you will learn how to get that information.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Specify that it implements the RecursiveTask class parameterized with the Integer class.
It will simulate the array of data you are going to process in this example.
These attributes will determine the elements of the array this task has to process.
Implement the constructor of the class that initializes its attributes.
RecursiveTask class with the Integer class, this method has to return an Integer object.
First, write a message to the console with the value of the start and end attributes.
If the block of elements that this task has to process, determined by the start and end attributes, has a size smaller than 10, check if the element in the fourth position in the array (index number three) is in that block.
Otherwise (the block of elements that this task has to process has a size of 10 or bigger), divide the block of elements in two, create two Task objects to process.
Write a message to the console indicating the end of the task writing the value of the start and end attributes.
Implement the main class of the example by creating a class named Main with a.
Check if the task, or one of its subtasks, has thrown an exception using the method of the ForkJoinTask class.
The Task class you have implemented in this recipe processes an array of numbers.
It checks if the block of numbers it has to process has 10 or more elements.
In that case, it splits the block in two and creates two new Task objects to process those blocks.
Otherwise, it looks for the element in the fourth position of the array (index number three)
If that element is in the block the task has to process, it throws a RuntimeException exception.
When you execute the program, the exception is thrown, but the program doesn't stop.
This method returns true if that task, or one same object to get the Exception object that it has thrown.
When you throw an unchecked exception in a task, it also affects its parent task (the task that sent it to the ForkJoinPool class) and the parent task of its parent task, and so on.
If you revise all the output of the program, you'll see that there aren't output messages for the finalization of some tasks.
These tasks are the ones that threw the exception and its parent tasks.
Take this into account, when you develop a program with the ForkJoinPool and ForkJoinTask objects that can throw exceptions if you don't want this behavior.
The following screenshot shows part of an execution of this example:
There's more… You can obtain the same result obtained in the example, if instead of throwing an exception, would be like the following:
Canceling a task When you execute the ForkJoinTask objects in a ForkJoinPool class, you can cancel method for this purpose.
There are some points you have to take into account when you want to cancel a task, which are as follows:
In this recipe, you will implement an example of cancelation of ForkJoinTask objects.
You will look for the position of a number in an array.
The first task that finds the number will cancel the remaining tasks.
As that functionality is not provided by the Fork/Join framework, you will implement an auxiliary class to do this cancelation.
Getting ready… The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE NetBeans, open it and create a new Java project.
This class will generate an array of random integer numbers with the specified size.
Implement a method named of the array as a parameter.
We will use this class to store all the tasks executed in ForkJoinPool used in the example.
Due to the limitations of the ForkJoinPool and ForkJoinTask classes, you will use this class to cancel all the tasks of the ForkJoinPool class.
Declare a list of objects parameterized with the ForkJoinTask class parameterized with the Integer class named List.
This class will look for a number in a block of elements of an integer array.
These attributes will determine the elements of the array this task has to process.
Declare a private int attribute named number to store the number you are going to look for.
You will use this object to cancel all the tasks.
Declare a private int constant and initialize it to the -1 value.
It will be the returned value by the task when it doesn't find the number.
Implement the constructor of the class to initialize its attributes.
If the difference between the start and end attributes are bigger than 10 (the method to divide the work of this task in two subtasks.
Otherwise, look for the number in the block of the array this task that is calling the.
For all the elements in the block of elements this task has to process, compare the value stored in that element with the number you are looking for.
If they are equal, write a message to the console indicating that in such a circumstance use the return the position of the element, where you found the number.
Inside the loop, put the task to sleep for one second.
Wait for the finalization of the tasks and return the result of the first task if it is different, to -1, or the result of the second task.
Implement the main class of the example by creating a class named Main with a.
Create an array of 1,000 numbers using the ArrayGenerator class.
Create a Task object to process the array generated before.
Write a message to the console indicating the end of the program.
If the task has begun its as a Boolean value called mayInterruptIfRunning.
This name may make you think that, if you pass the true value to the method, the task will be canceled even if it is running.
The Java API documentation specifies that, in the default implementation of the ForkJoinTask class, this attribute has no effect.
The tasks are only canceled if they haven't started their execution.
The cancelation of a task has no effect over the tasks that this task sent to the pool.
A limitation of the Fork/Join framework is that it doesn't allow the cancelation of all the tasks that are in ForkJoinPool.
To overcome that limitation, you have implemented the TaskManager class.
It stores all the tasks that have been sent to the pool.
It has a method that cancels all the tasks it has stored.
If a task can't be canceled because it's running or it the tasks without being afraid of possible collateral effects.
In the example, you have implemented a task that looks for a number in an array of numbers.
You divide the problem into smaller sub-problems as the Fork/Join framework recommends.
You are only interested in one occurrence of the number so, when you find it, you cancel the other tasks.
The following screenshot shows part of an execution of this example:
Almost every program uses one or more types of data structures to store and manage their data.
Java API provides the Java Collections framework that contains interfaces, classes, and algorithms, which implement a lot of different data structures that you can use in your programs.
When you need to work with data collections in a concurrent program, you must be very careful with the implementation you choose.
Most collection classes are not ready to work with concurrent applications because they don't control the concurrent access to its data.
If some concurrent tasks share a data structure that is not ready to work with concurrent tasks, you can have data inconsistency errors that will affect the correct operation of the program.
One example of this kind of data structures is the ArrayList class.
Java provides data collections that you can use in your concurrent programs without any problems or inconsistency.
Basically, Java provides two kinds of collections to use in concurrent applications:
If the operation can't be made immediately, because the collection is full or empty, the thread that makes the call will be blocked until the operation can be made.
If the operation can't be made immediately, the operation returns a null value or throws an exception, but the thread that makes the call won't be blocked.
Through the recipes of this chapter, you will learn how to use some Java collections that you can use in your concurrent applications.
Using non-blocking thread-safe lists The most basic collection is the list.
A list has an undetermined number of elements and you can add, read, or remove the element of any position.
Concurrent lists allow the various threads to add or remove elements in the list at a time without producing any data inconsistency.
In this recipe, you will learn how to use non-blocking lists in your concurrent programs.
Non-blocking lists provide operations that, if the operation can't be done immediately (for example, you want to get an element of the list and the list is empty), they throw an exception or return a null value, depending on the operation.
Java 7 has introduced the ConcurrentLinkedDeque class that implements a non-blocking concurrent list.
We are going to implement an example with the following two different tasks:
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a private ConcurrentLinkedDeque attribute parameterized with the String class named list.
Implement the constructor of the class to initialize its attribute.
Implement the constructor of the class to initialize its attribute.
Implement the main class of the example by creating a class named Main and add.
Create a ConcurrentLinkedDeque object parameterized with the String class named list.
Create 100 AddTask objects and a thread to run each of them.
Store every thread in the array created earlier and start the threads.
Create 100 PollTask objects and a thread to run each of them.
Store every thread in the array created earlier and start the threads.
In this recipe, we have used the ConcurrentLinkedDeque object parameterized with the String class to work with a non-blocking concurrent list of data.
The following screenshot shows the output of an execution of this example:
First, you have executed 100 AddTask tasks to add elements to the list.
Each one of those elements at the end of the list.
When all those tasks have finished, you have written in the console the number of elements of the list.
Then, you have executed 100 PollTask tasks to remove elements from the list.
When all those tasks have finished, you have written in the console the number of elements of the list.
The method has to traverse the entire list to count the elements and the contents of the list can change for this operation.
Only if you use them when there aren't any threads modifying the list, you will have the guarantee that the returned result is correct.
The ConcurrentLinkedDeque class provides more methods to get elements form the list:
If the list is empty, these methods throw a NoSuchElementExcpetion exception.
If the list is empty, these methods return a null value.
If the list is empty, these methods throw a NoSuchElementException exception.
Using blocking thread-safe lists The most basic collection is the list.
A list has an undetermined number of elements and you can add, read, or remove the element from any position.
A concurrent list allows various threads to add or remove elements in the list at a time without producing any data inconsistency.
In this recipe, you will learn how to use blocking lists in your concurrent programs.
The main difference between blocking lists and non-blocking lists is that blocking lists has methods to insert and delete elements on it that, if they can't do the operation immediately, because the list is full or empty, they block the thread that make the call until the operation can be made.
Java includes the LinkedBlockingDeque class that implements a blocking list.
You are going to implement an example with the following two tasks:
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a private LinkedBlockingDeque attribute parameterized with the String class named requestList.
Implement the constructor of the class to initialize its attributes.
Create the main class of the example by creating a class named Main and add the.
Declare and create LinkedBlockingDeque parameterized with the String class named list.
Create and start a Thread object to execute a client task.
Get three String objects of the list every 300 milliseconds using the strings in the console.
Write a message to indicate the end of the program.
In this recipe, you have used LinkedBlockingDeque parameterized with the String class to work with a non-blocking concurrent list of data.
Both the methods of the LinkedBlockingDeque class used in this example, can throw an InterruptedException exception if they are interrupted while they are blocked, so you have to include the necessary code to catch that exception.
There's more… The LinkedBlockingDeque class also provides the methods to put and get elements from the list that, instead of being block, throw an exception or return the null value.
If the list is empty, these methods block the thread until there are elements in the list.
If the list is empty, these methods throw a NoSuchElementExcpetion exception.
If the list is empty, these methods return a null value.
If the list is empty, these methods return a null value.
If the list is full (you have created it with a fixed capacity), these methods throw an IllegalStateException exception.
A typical need when you work with data structures is to have an ordered list.
All the elements you want to add to PriorityBlockingQueue have to implement the of the same type, so you have two objects to compare: the one that is executing the method and the one that is received as a parameter.
The method must return a number less than zero if the local object is less than the parameter, a number bigger that zero if the local object is greater than the parameter, and the number zero if both objects are equal.
The greater elements will be the tail of the queue.
Another important characteristic of PriorityBlockingQueue is that it's a blocking data structure.
It has methods that, if they can't do their operation immediately, block the thread until they can do it.
In this recipe, you will learn how to use the PriorityBlockingQueue class implementing an example, where you are going to store a lot of events with different priorities in the same list, to check that the queue will be ordered as you want.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named Event and specify that it implements the Comparable interface parameterized with the Event class.
Declare a private int attribute named thread to store the number of the thread that has created the event.
Declare a private int attribute named priority to store the priority of the event.
Implement the constructor of the class to initialize its attributes.
Create a class named Task and specify that it implements the Runnable interface.
Declare a private int attribute named id to store the number that identifies the task.
Declare a private PriorityBlockingQueue attribute parameterized with the Event class named queue to store the events generated by the task.
Implement the constructor of the class to initialize its attributes.
Implement the main class of the example by creating a class named Main and add.
Create a PriorityBlockingQueue object parameterized with the Event class named queue.
Create an array of five Thread objects to store the threads that is going to execute five tasks.
Write to the console the actual size of the queue and the events stored in it.
Write a message to the console with the final size of the queue.
In this example, you have implemented a priority queue of Event objects using PriorityBlockingQueue.
As we mentioned in the introduction, all the elements stored in PriorityBlockingQueue have to implement the Comparable interface, so you have.
The elements that have a higher value of priority will be the event executing the method has a priority higher than the priority of the event passed as parameter, it returns -1 as the result.
In the other case, if the event executing the method has a priority lower than the priority of the event passed as parameter, it returns 1 as the result.
We have implemented the Task class to add the Event objects to the priority queue.
When all the threads have finished their execution, you have written all method.
That method returns and removes the first element from the queue.
The following screenshot shows part of the output of an execution of the program:
You can see how the queue has a size of 5,000 elements and how the first elements have the biggest priority values.
This method inserts the element passed as a parameter into the queue.
An interesting data structure provided by the Java API, and that you can use in concurrent applications, is implemented in the DelayedQueue class.
In this class, you can store elements with an activation date.
The methods that return or extract elements of the queue will ignore those elements whose data is in the future.
To obtain this behavior, the elements you want to store in the DelayedQueue class have to implement the Delayed interface.
This interface allows you to work with delayed objects, so you will implement the activation date of the objects stored in the DelayedQueue class as the time remaining until the activation date.
This method will return a value less than zero if the object that is executing the method has a delay smaller than the object passed as a parameter, a value greater than zero if the object that is executing the method has a delay bigger than the object passed as a parameter, and the zero value if both objects have the same delay.
In this example, you will learn how to use the DelayedQueue class storing in it some events with different activation dates.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named Event and specify that it implements the Delayed interface.
Implement the constructor of the class to initialize its attribute.
Return the difference between the delay of the current object and the one passed as parameter.
Create a class named Task and specify that it implements the Runnable interface.
Declare a private int attribute named id to store a number that identifies this task.
Declare a private DelayQueue attribute parameterized with the Event class named queue.
Implement the constructor of the class to initialize its attributes.
Add to the actual date a number of seconds equal to the ID of the object.
Implement the main class of the example by creating a class named Main and add.
Create an array of five Thread objects to store the tasks you're going to execute.
Write to the console the events stored in the queue.
While the size of the queue null, put the main thread for 500 milliseconds to wait for the activation of more events.
That class has a unique attribute, the activation date of the events, and implements the Delayed interface, so you can store Event objects in the DelayedQueue class.
The DelayedQueue class works in nanoseconds, but at this point, it's transparent to you.
When a Task object is executed, it adds a number of seconds equal to the ID of the task to the actual date and that is the activation date of the events stored by this task in the DelayedQueue class.
Each Task object stores 100 events in the queue using the.
When those threads finish their execution, you and removes the first element of the queue.
If the queue does not have any active element, the value of the counter in the console and put the thread to sleep during half a second to wait for more active events.
When you have obtained the 500 events stored in the queue, the execution of the program finishes.
The following screenshot shows part of the output of an execution of the program:
You can see how the program only gets 100 events when it is activated.
There's more… The DelayQueue class has other interesting methods, which are as follows:
This method inserts the element passed as a parameter in the queue.
Using thread-safe navigable maps An interesting data structure provided by the Java API that you can use in your concurrent programs is defined by the ConcurrentNavigableMap interface.
The classes that implement the ConcurrentNavigableMap interface stores elements within two parts:
Java API also provides a class that implements that interface, which is the ConcurrentSkipListMap interface that implements a non-blocking list with the behavior of the ConcurrentNavigableMap interface.
Internally, it uses a Skip List to store the data.
A Skip List is a data structure based on parallel lists that allows us to get efficiency similar to a binary tree.
With it, you can get a sorted data structure with a better access time to insert, search, or delete elements than a sorted list.
When you insert an element in the map, it uses the key to order them, so all the elements will be ordered.
The class also provides methods to obtain a submap of the map, in addition to the ones that return a concrete element.
In this recipe, you will learn how to use the ConcurrentSkipListMap class to implement a map of contacts.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Implement the constructor of the class to initialize its attributes.
Implement the methods to return the values of the name and phone attributes.
Create a class named Task and specify that it implements the Runnable interface.
Declare a private String attribute named id to store the ID of the current task.
Implement the constructor of the class to store its attributes.
Implement the main class of the example by creating a class named Main and add.
Create an array for 25 Thread objects to store all the Task objects that you're going to execute.
Create and launch 25 task objects assigning a capital letter as the ID of each task.
In this recipe, we have implemented a Task class to store Contact objects in the navigable map.
We have used a concatenation of those values as the key for the contacts.
Each Task object creates 1,000 contacts that are stored in the.
If you insert an element with a key that exists in the map, the element associated with that key will be replaced by the new element.
Then, you have used some methods to obtain data from the map.
The following screenshot shows the output of an execution of the program:
This method returns a submap of the first elements of the map with the elements that have a key smaller than the one passed as parameter.
This method returns a submap of the last elements of the map with the elements that have a key greater than the one passed as parameter.
Generating concurrent random numbers The Java concurrency API provides a specific class to generate pseudo-random numbers in concurrent applications.
It's the ThreadLocalRandom class and it's new in the Java 7 Version.
Every thread that wants to generate random numbers has a different generator, but all of them are managed from the same class, in a transparent way to the programmer.
With this mechanism, you will get a better performance than using a shared Random object to generate the random numbers of all the threads.
In this recipe, you will learn how to use the ThreadLocalRandom class to generate random numbers in a concurrent application.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Implement the main class of the example by creating a class named Main and add.
How it works… The key of this example is in the TaskLocalRandom class.
In the constructor of the class, method that returns the ThreadLocalRandom object associated with the current thread, so you can generate random numbers using that object.
If the thread that makes the call does not have any object associated yet, the class creates a new one.
In this case, you use this method to initialize the random generator associated with this task, so it will be created in the next call to the method.
The ThreadLocalRandom class also provides methods to generate long, float, and double numbers, and Boolean values.
There are methods that allow you to provide a number as a parameter to generate random numbers between zero and that number.
Other methods allow you to provide two parameters to generate random numbers between those numbers.
See also f The Using local thread variables recipe in Chapter 1, Thread management.
Using atomic variables Atomic variables were introduced in Java Version 5 to provide atomic operations on single variables.
When you work with a normal variable, each operation that you implement in Java is transformed in several instructions that is understandable by the machine when you compile the program.
For example, when you assign a value to a variable, you only use one instruction in Java, but when you compile this program, this instruction is transformed in various instructions in the JVM language.
This fact can provide data inconsistency errors when you work with multiple threads that share a variable.
When a thread is doing an operation with an atomic variable, if other threads want to do an operation with the same variable, the implementation of the class includes a mechanism to check that the operation is done in one step.
Basically, the operation gets the value of the variable, changes the value in a local variable, and then tries to change the old value for the new one.
If the old value is still the same, it does the change.
Atomic variables don't use locks or other synchronization mechanisms to protect the access to their values.
All their operations are based on the Compare and Set operation.
It's guaranteed that several threads can work with an atomic variable at a time without generating data inconsistency errors and its performance is better than using a normal variable protected by a synchronization mechanism.
In this recipe, you will learn how to use atomic variables implementing a bank account and two different tasks, one that adds money to the account and one that subtracts money from it.
You will use the AtomicLong class in the implementation of the example.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you are using Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Create a class named Account to simulate a bank account.
Declare a private AtomicLong attribute named balance to store the balance of the account.
Implement the constructor of the class to initialize its attribute.
Create a class named Company and specify that it implements the Runnable interface.
This class will simulate the payments made by a company.
Implement the constructor of the class to initialize its attribute.
Create a class named Bank and specify that it implements the Runnable interface.
This class will simulate the withdrawal of money from the account.
Implement the constructor of the class to initialize its attribute.
Implement the main class of the example by creating a class named Main and add.
Create an Account object and set its balance to 1000
Create a new Company task and a thread to execute it.
Create a new Bank task and a thread to execute it.
Write in the console the initial balance of the account.
The key of this example is in the Account class.
In that class, we declared an AtomicLong variable named balance to store the balance of the account and then we implemented the methods to work with that balance using the methods provided by the AtomicLong class.
In the Main class, you have created an Account object with a balance of 1,000
Then, you have executed a bank task and a company task, so the final balance of the account must be the same as the initial one.
When you execute the program, you will see how the final balance is the same as the initial one.
The following screenshot shows the output of an execution of this example:
As we mentioned in the introduction, there are other atomic classes in Java.
AtomicBoolean, AtomicInteger, and AtomicReference are other examples of atomic classes.
See also f The Synchronizing a method recipe in Chapter 2, Basic thread synchronization.
Using atomic arrays When you implement a concurrent application that has one or more objects shared by several threads, you have to protect the access to their attributes using a synchronization mechanism as locks or the synchronized keyword to avoid data inconsistency errors.
This situation blocks the program, so it will never finish.
To provide a better performance to this situation, the compare-and-swap operation was developed.
This operation implements the modification of the value of a variable in the following three steps:
You get the value of the variable, which is the old value of the variable.
You change the value of the variable in a temporal variable, which is the new value of the variable.
You substitute the old value with the new value, if the old value is equal to the actual value of the variable.
The old value may be different from the actual value if another thread has changed the value of the variable.
With this mechanism, you don't need to use any synchronization mechanism, so you avoid deadlocks and you obtain a better performance.
These variables provide the and other methods based on it.
Java also introduced atomic arrays that provide atomic operations for arrays of integer or long numbers.
In this recipe, you will learn how to use the AtomicIntegerArray class to work with atomic arrays.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Declare a private AtomicIntegerArray attribute named vector to store an array of integer numbers.
Implement the constructor of the class to initialize its attribute.
Declare a private AtomicIntegerArray attribute named vector to store an array of integer numbers.
Implement the constructor of the class to initialize its attribute.
Implement the main class of the example by creating a class named Main and add.
Create an Incrementer task to work with the atomic array created earlier.
Create a Decrementer task to work with the atomic array created earlier.
Write in the console the elements of the atomic array distinct from zero.
Write a message in the console to indicate the finalization of the example.
In this example, you have implemented two different tasks to work with an AtomicIntegerArray object:
At the end of those tasks, if there were no inconsistency errors, all the elements of the array must have the value 0
If you execute the program, you will see how the program only writes to the console the final message because all the elements are zero.
It's the AtomicLongArray class that provides the same methods as the IntegerAtomicArray class.
Introduction Java concurrency API provides a lot of interfaces and classes to implement concurrent applications.
They provide low-level mechanisms, such as the Thread class, the Runnable or Callable interfaces, or the synchronized keyword, and also high-level mechanisms, such as the Executor framework and the Fork/Join framework added in the Java 7 release.
Despite this, you may find yourself developing a program where none of the java classes meet your needs.
In this case, you may need to implement your own custom-concurrent utilities based on the ones provided by Java.
For example, useful and is supposed to be overridden to offer some functionality.
Through the recipes of this chapter, you will learn how to change the behavior of some Java concurrency API classes without the need to design a concurrency framework from scratch.
You can use these recipes as an initial point to implement your own customizations.
Customizing the ThreadPoolExecutor class The Executor framework is a mechanism that allows you to separate the thread creation from its execution.
It's based on the Executor and ExecutorService interfaces with the ThreadPoolExecutor class that implements both interfaces.
It has an internal pool of threads and provides methods that allow you to send two kinds of tasks for their execution in the pooled threads.
In both cases, you only send the task to the executor.
The executor uses one of its pooled threads or creates a new one to execute those tasks.
The executor also decides the moment in which the task is executed.
In this recipe, you will learn how to override some methods of the ThreadPoolExecutor class to calculate the execution time of the tasks that you execute in the executor and to write in the console statistics about the executor when it completes its execution.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named MyExecutor that extends the ThreadPoolExecutor class.
Declare a private ConcurrentHashMap attribute parameterized with the String and Date classes named startTimes.
Call a constructor of the parent class using the super keyword and initialize the startTime attribute.
Store the start date in HashMap using the hash code of the task as the key.
Create a class named SleepTwoSecondsTask that implements the Callable Put the current thread to sleep for 2 seconds and return the current date converted to a String type.
Implement the main class of the example by creating a class named Main with a.
Create a list of Future objects parameterized with the String class to store the resultant objects of the tasks you're going to send to the executor.
Write a message indicating the end of the execution of the program.
In this recipe, we have implemented our custom executor extending the executed after the execution of a task.
You get startTime of the task that has finished from HashMap and then, calculate the difference between the actual date and that date to get the methods to write statistics about the tasks executed in the executor to the console:
Execute the program and you will see how the program shows the time span of each task that.
In the first versions of the Java concurrency API, you had to create and run all the threads of your application.
In Java Version 5, with the appearance of the Executor framework, a new mechanism was introduced for the execution of concurrency tasks.
With the Executor framework, you only have to implement your tasks and send them to the executor.
The executor is responsible for the creation and execution of the threads that execute your tasks.
Internally, an executor uses a blocking queue to store pending tasks.
These are stored in the order of their arrival to the executor.
One possible alternative is the use of a priority queue to store new tasks.
In this way, if a new task with high priority arrives to the executor, it will be executed before other threads that have already been waiting for a thread to execute, but have lower priority.
In this recipe, you will learn how to implement an executor that will use a priority queue to store the tasks you send for execution.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Implement the constructor of the class to initialize its attributes.
Implement a method to return the value of the priority attribute.
It receives a MyPriorityTask object as a parameter and compares the priorities of the two objects, the current one and the parameter.
You let the tasks with higher priority execute before the tasks with lower priority.
Implement the main class of the example by creating a class named Main.
PriorityBlockingQueue parameterized with the Runnable interface as the queue that this executor will use to store its pending tasks.
Send four tasks to the executor using the counter of the loop as priority of the tasks.
Send four additional tasks to the executor using the counter of the loop as priority of.
Write a message in the console indicating the finalization of the program.
To convert an executor to a priority-based one is simple.
You only have to pass a PriorityBlockingQueue object parameterized with the Runnable interface as a parameter.
But with the executor, you should know that all the objects stored in a priority queue have to implement the Comparable interface.
You have implemented the MyPriorityTask class that implements the Runnable interface, to be a task, and the Comparable interface, to be stored in the priority queue.
This class has a Priority attribute that is used to store the priority of the tasks.
If a task determines the order of the tasks in the priority queue.
In the Main class, you sent eight tasks to the executor with different priorities.
The first tasks you sent to the executor are the first tasks that are executed.
As the executor is idle waiting for tasks to be executed, and as the first tasks arrive to the executor, it executes them immediately.
You have created the executor with two execution threads, so the first two tasks will be the first ones that are executed.
Then, the rest of the tasks are executed based on their priority.
There's more… You can configure Executor to use any implementation of the BlockingQueue interface.
This class is used to store elements with a delayed activation.
You can use this class to implement your own version of the ScheduledThreadPoolExecutor class.
The factory pattern is a widely used design pattern in the object-oriented programming world.
It is a creational pattern and its objective is to develop a class whose mission will be creating objects of one or several classes.
Then, when we want to create an object of one of those classes, we use the factory instead of using the new operator.
For example, we can only have N objects of a type that is easily generating statistical data about the creation of objects.
Java provides the ThreadFactory interface to implement a Thread object factory.
Some advanced utilities of the Java concurrency API, as the Executor framework or the Fork/Join framework, use thread factories to create threads.
Another example of the factory pattern in the Java Concurrency API is the Executors class.
It provides a lot of methods to create different kinds of Executor objects.
In this recipe, you will extend the Thread class by adding new functionalities and you will implement a thread factory class to generate threads of that new class.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or another IDE such as NetBeans, open it and create a new Java project.
Create a class named MyThread that extends the Thread class.
Declare three private Date attributes named creationDate, startDate, and finishDate.
It receives the name and the Runnable object to execute as parameters.
Implement a method to establish the value of the creationDate attribute.
Implement a method to establish the value of the startDate attribute.
Implement a method to establish the value of the finishDate attribute.
Implement the constructor of the class to initialize its attributes.
Create a class named MyTask that implements the Runnable interface.
Implement the main class of the example by creating a class named Main with a.
In this recipe, you have implemented a custom MyThread class extending the Thread class.
The class has three attributes to store the creation date, the start date of its execution, and the end date of its execution.
Using the start date and the end date attributes, you have information about a thread.
Once you had your own thread class, you have implemented a factory to create objects of that class implementing the ThreadFactory interface.
It's not mandatory to make use of the interface if you're going to use your factory as an independent object, but if you want to use this factory with other classes of the Java concurrency API, you must construct your factory by implementing that interface.
The ThreadFactory interface only has one method, Thread object to execute that Runnable object.
To check these two classes, you have implemented the MyTask class that implements the Runnable object.
This is the task to be executed in threads managed by the MyThread object.
A MyTask instance puts its execution thread to sleep for 2 seconds.
In the main method of the example, you have created a MyThread object using a MyThreadFactory factory to execute a Task object.
Execute the program and you will see a message with the start date and the execution time of the thread executed.
The following screenshot shows the output generated by this example:
The Java Concurrency API provides the Executors class to generate thread executors, usually objects of the ThreadPoolExecutor class.
You can also use this class to obtain the most basic implementation of the ThreadFactory interface using the basic Thread objects belonging to all of them to the same ThreadGroup object.
You can use the ThreadFactory interface in your program for any purposes, not necessarily related to the Executor framework.
In the previous recipe, Implementing the ThreadFactory interface to generate custom threads, we introduced the factory pattern and provided an example of how to implement a factory of threads implementing the ThreadFactory interface.
The Executor framework is a mechanism that allows you the separation of the thread creation and its execution.
It's based on the Executor and ExecutorService interfaces and in the ThreadPoolExecutor class that implements both interfaces.
It has an internal pool of threads and provides methods that allow you to send two kinds of tasks for their execution in the pooled threads.
Internally, an Executor framework uses a ThreadFactory interface to create the threads that it uses to generate the new threads.
In this recipe, you will learn how to implement your own thread class, a thread factory to create threads of that class, and how to use that factory in an executor, so the executor will execute your threads.
Getting ready… Read the previous recipe, Implementing a ThreadFactory interface to generate custom threads, and implement its example.
The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or another IDE such as NetBeans, open it and create a new Java project.
Copy into the project the classes MyThread, MyThreadFactory, and MyTask implemented in the recipe Implementing a ThreadFactory interface to generate custom threads, so you are going to use them in this example.
Implement the main class of the example by creating a class named Main with a.
The new Executor object will use that factory to create the necessary threads, so it will execute MyThread threads.
Write a message to indicate the end of the program.
In the How it works… section of the previous recipe, Implementing a ThreadFactory interface to generate custom threads, you can read a detailed explanation of how the MyThread, MyThreadFactory, and MyTask classes works.
Execute the program and you will see a message with information about the thread's start date and its execution time.
The following screenshot shows the output generated by this example:
See also f The Implementing a ThreadFactory interface to generate custom threads recipe in.
The scheduled thread pool is an extension of the basic thread pool of the Executor framework that allows you to schedule the execution of tasks to be executed after a period of time.
It's implemented by the ScheduledThreadPoolExecutor class and it permits the execution of the following two kinds of tasks:
Delayed tasks can execute both, the Callable and Runnable objects, but the periodic tasks can only execute Runnable objects.
All the tasks executed by a scheduled pool are an implementation of the RunnableScheduledFuture interface.
In this recipe, you will learn how to implement your own implementation of the RunnableScheduledFuture interface to execute delayed and periodic tasks.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named MyScheduledTask parameterized with a generic type named V.
It extends the FutureTask class and implements the RunnableScheduledFuture interface.
It receives the Runnable object that is going to be executed by a task, the result that will be returned by this task, the RunnableScheduledFuture task that will be used to create the MyScheduledTask object, and the ScheduledThreadPoolExecutor object that is going to execute the task.
Call the constructor of its parent class and store the task and executor attributes.
Otherwise, return the delay of the original task stored in the task attribute.
Don't forget that you have to return the result in the time unit passed as a parameter.
Calculate it as the sum of the actual date and the period.
Then, add the task again to the queue of the ScheduledThreadPoolExecutor object.
Print a message with the actual date to the console, execute the task calling the the console.
Implement a constructor of the class which merely calls the constructor of its parent class.
Create and return a MyScheduledTask task using those objects to construct them.
Create a class named Task that implements the Runnable interface.
Implement the main class of the example by creating a class named Main.
Use 2 as a parameter to have two threads in the pool.
Write a message in the console indicating the end of the program.
In this recipe, you have implemented the MyScheduledTask class to implement a custom task that can execute on a ScheduledThreadPoolExecutor executor.
This class extends the FutureTask class and implements the RunnableScheduledFuture interface.
It implements the RunnableScheduledFuture interface, because all the tasks executed in a scheduled executor must implement that interface and extend the FutureTask class, because this class provides valid implementations of the methods declared in the RunnableScheduledFuture interface.
All the interfaces and classes mentioned earlier are parameterized classes, with the type of data that will be returned by the tasks.
To use a MyScheduledTask task in a scheduled executor, you have overridden the class extends the ScheduledThreadPoolExecutor executor and that method provides a mechanism to convert the default scheduled tasks implemented by the ScheduledThreadPoolExecutor executor to MyScheduledTask tasks.
So, when you implement your own version of scheduled tasks, you have to implement your own version of a scheduled executor.
A resultant object that is going to be returned by that task.
In this case, the task won't return a result, so you used the null value.
An original task is used to execute the Runnable object.
This is the task that the new object is going to replace in the pool; an executor that is going to execute the task.
In this case, you use the this keyword to reference the executor that is creating the task.
You have implemented two methods with all the necessary logic to execute both kinds of tasks.
The behavior of this method changes in delayed and periodic tasks.
As we mentioned earlier, the constructor of the MyScheduledClass class receives the original ScheduledRunnableFuture object that was going to execute the Runnable object and stores it as an attribute of the class to have access to its methods and its data.
When we are between the startDate attribute and the actual date.
So, if you're executing a periodic task, you establish the startDate attribute value adding to the actual date and the period of execution of the task and store the task again in the queue of the executor.
The startDate attribute stores the date when the next execution of the task will begin.
Then, you execute the task using the you don't have to put them in the queue of the executor, because they only execute once.
You have also to take into account if the executor has been shutdown.
In that case, you don't have to store again the periodic tasks into the queue of the executor.
We mentioned earlier that, for periodic tasks, you establish the value of the startDate attribute using the period of the task, but you haven't initialized that period yet.
You have to override this method that receives that period as a parameter, to pass it to the MyScheduledTask class so it can use it.
The example is complete with the Task class that implements the Runnable interface and is the task executed in the scheduled executor.
The main class of the example creates a MyScheduledThreadPoolExecutor executor and sends the following two tasks to them:
The following screenshot shows part of the execution of this example.
You can check as the two kinds of tasks are executed properly:
There's more… The ScheduledThreadPoolExecutor class provides another version of the of a Runnable object.
See also f The Running a task in an executor after a delay recipe in Chapter 4, Thread Executors.
Implementing the ThreadFactory interface to generate custom threads for the Fork/Join framework.
One of the most interesting features of Java 7 is the Fork/Join framework.
It's an implementation of the Executor and ExecutorService interfaces that allow you the execution of the Callable and Runnable tasks without managing the threads that execute them.
This executor is oriented to execute tasks that can be divided into smaller parts.
When a task is waiting for its subtasks, the thread that was executing it is used to execute another thread.
The main class of the Fork/Join framework is the ForkJoinPool class.
In this recipe, you will learn how to implement a customized worker thread to be used in a ForkJoinPool class and how to use it using a factory.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Create a class  named MyRecursiveTask that extends the RecursiveTask class parameterized with the Integer class.
Implement the constructor of the class that initializes its attributes.
First, convert the thread that is executing the task into a of tasks for that thread.
Put the thread to sleep for 10 milliseconds and return the result of the task.
Implement the  main class of the example by creating a class named Main.
Create a new Task object to sum all the elements of the array.
Write a message in the console indicating the end of the example.
Threads used by the Fork/Join framework are called worker threads.
Java includes the ForkJoinWorkerThread class that extends the Thread class and implements the worker threads used by the Fork/Join framework.
In this recipe, you have implemented the MyWorkerThread class that extends the ForkJoinWorkerThread class and overrides two methods of that class.
Your objective is to implement a counter of tasks in each worker thread so you can know how many tasks a worker thread has executed.
This way, each thread will have its own counter in a transparent way for you, the programmer.
This method is called when the worker thread begins its execution.
This method is called when the worker thread finishes its execution.
The ForkJoinPool class, as all the executors in the Java concurrency API, creates its threads using a factory, so if you want to use the MyWorkerThread threads in a ForkJoinPool class, you have to implement your thread factory.
For the Fork/Join framework, this factory has to implement the ForkJoinPool.ForkJoinWorkerThreadFactory class.
This class only has one method that creates a new MyWorkerThread object.
Finally, you only have to initialize a ForkJoinPool class with the factory you have created.
You have done this in the Main class, using the constructor of the ForkJoinPool class.
The following screenshot shows part of the output of the program:
You can see how the ForkJoinPool object has executed four worker threads and how many tasks have executed each of them.
ForkJoinWorkerThread class is called when a thread finishes normally or throws an Exception exception.
If the parameter takes the null value, the worker thread finishes normally, but if the parameter takes a value, the thread throws an exception.
You have to include the necessary code to process that situation.
The Executor framework separates the task creation and its execution.
With it, you only have to implement the Runnable objects and use an Executor object.
You send the Runnable tasks to the executor and it creates, manages, and finalizes the necessary threads to execute those tasks.
Java 7 provides a special kind of executor in the Fork/Join framework.
This framework is designed to solve those problems that can be broken into smaller tasks using the divide and conquer technique.
Inside a task, you have to check the size of the problem you want to resolve and, if it's bigger than an established size, you divide the problem in two or more tasks and execute those tasks using the framework.
If the size of the problem is smaller than the established size, you resolve the problem directly in the task and then, optionally, it returns a result.
The Fork/Join framework implements the work-stealing algorithm that improves the overall performance of these kinds of problems.
The main class of the Fork/Join framework is the ForkJoinPool class.
By default, the tasks executed by a ForkJoinPool class are objects of the ForkJoinTask class.
You also can send to a ForkJoinPool class the Runnable and Callable objects, but they can't take advantage of all the benefits of the Fork/Join framework.
Normally, you will send to the ForkJoinPool objects one of two subclasses of the ForkJoinTask class:
In this recipe, you will learn how to implement your own tasks for the Fork/Join framework implementing a task that extends the ForkJoinTask class.
The task you're going to implement measures and writes in the console its execution time, so you can control its evolution.
You can also implement your own Fork/Join task to write log information, to get resources used in the tasks, or to post-process the results of the tasks.
How to do it… Follow these steps to implement the example:
Declare a private String attribute named name to store the name of the task.
Implement the constructor of the class to initialize its attribute.
As the MyWorkerTask tasks won't return any result, this method must return the null value.
As the MyWorkerTask tasks won't return any result, leave the body of this method empty.
Create a class named Task that extends the MyWorkerTask class.
Implement a constructor of the class that initializes its attributes.
If this block of elements has more than 100 elements, divide the block in two parts and create two Task objects.
If the block of elements has less than 100 elements, increment all the elements using a for loop.
Finally, put the thread that is executing the task to sleep for 50 milliseconds.
Implement the main class of the example by creating a class named Main with.
Create a Task object to increment all the elements of the array.
Write a message in the console indicating the end of the program.
How it works… In this recipe, you have implemented the MyWorkerTask class that extends the ForkJoinTask class.
It's your own base class to implement tasks that can be executed in a ForkJoinPool executor and that can take advantage of all the benefits of that executor, as the work-stealing algorithm.
This class is equivalent to the RecursiveAction and RecursiveTask classes.
When you extend the ForkJoinTask class, you have to implement the following three methods:
Finally, in the main class of the example, you have created an array of 10,000 elements, a ForkJoinPool executor, and a Task object to process the whole array.
Execute the program and you'll see how the different tasks that are executed write their execution time in the console.
Implementing a custom Lock class Locks are one of the basic synchronization mechanisms provided by the Java concurrency API.
It allows the programmers to protect a critical section of code, so only one thread can execute that block of code at a time.
In the Java Concurrency API, locks are declared in the Lock interface and implemented in some classes, for example, the ReentrantLock class.
In this recipe, you will learn how to implement your own Lock object implementing a class that implements the Lock interface that can be used to protect a critical section.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Implement the constructor of the class to initialize its attribute.
If it can, it returns the true value else it returns false.
If it can, it returns the true value else it returns the false value.
Create a class named MyLock and specify that it implements the Lock interface.
Implement the constructor of the class to initialize the sync attribute with a new MyAbstractQueueSynchronizer object.
A long parameter named time and a TimeUnit parameter named unit.
Implement the constructor of the class to initialize its attributes.
Implement the main class of the example by creating a class named Main.
Write a message indicating that you got the lock and release it.
Java Concurrency API provides a class that can be used to implement synchronization mechanisms with features of locks or semaphores.
It's AbstractQueuedSynchronizer and, as its name suggests, it's an abstract class.
It provides operations to control access to a critical section and to manage a queue of threads that are blocked awaiting access to the critical section.
If the thread that calls it can access the critical section, the method returns the true value.
If the thread that calls it can release the access, the method returns the true value.
In these methods, you have to implement the mechanism you use to control the access to the critical section.
In your case, you have implemented the MyQueuedSynchonizer class that extends the AbstractQueuedSyncrhonizer class and implements the abstract methods using an AtomicInteger variable to control the access of the critical section.
You have to implement this class because other implementations of the AbstractQueuedSynchronizer class (for example, the one used by the ReentrantLock class), are implemented as private classes internally in the class that uses it, so you don't have access to it.
This class implements the Lock interface and has a MyQueuedSynchronizer object as an attribute.
To implement all the methods of the Lock interface, you have used methods of the MyQueuedSynchronizer object.
Finally, you have implemented the Task class, that implements the Runnable interface and uses a MyLock object to get the access to a critical section.
That critical section puts the thread to sleep for 2 seconds.
The main class creates a MyLock object and runs 10 Task objects that share that lock.
The main class also tries to get the access to the lock using the.
When you execute the example, you can see how only one thread has access to the critical section and when that thread finishes, another one gets the access to it.
You can use your own Lock to write log messages about its utilization, control the time that is locked, or implement advanced synchronization mechanisms, to control, for example, the access to a resource so that it's only available at certain times.
The AbstractQueuedSynchronizer class provides two methods that can be used to methods receive and return an integer value with the state of the lock.
You could have used those methods instead of the AtomicInteger attribute to store the state of the lock.
Java concurrency API provides another class to implement synchronization mechanisms.
It's the AbstractQueuedLongSynchronizer class, that is equivalent to the AbstractQueuedSynchronizer class, but uses a long attribute to store the state of the threads.
See also f The Synchronizing a block of code with locks recipe in Chapter 2,
Java 7 API provides several data structures to work with concurrent applications.
From these, we want to highlight the following two data structures:
In those applications, you have one or more producers of data and one or more consumers of data and a data structure is shared by all of them.
The producers put data in the data structure and the consumers take data from the data structure.
If the data structure is empty, the consumers are blocked until they have data to consume.
If the data structure is full, the producers are blocked until they have space to put their data.
The elements have to implement the Comparable interface with the to the elements of the structure until it finds its position.
Elements of the LinkedTransferQueue are stored in the same order as they arrive, so earlier arrivals are consumed first.
It may be the case when you want to develop a producer/ consumer program, where data is consumed according to some priority instead of arrival time.
In this recipe, you will learn how to implement a data structure to be used in the producer/ consumer problem, whose elements will be ordered by their priority.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Declare a private AtomicInteger attribute named counter to store the number of consumers that are waiting for elements to consume.
Implement the constructor of the class to initialize its attributes.
If there isn't any waiting consumer, the method returns the false value.
If there isn't a waiting consumer, the method stores the element in a special queue to be sent to the first consumer that tries to get an element and blocks the thread until the element is consumed.
If there is a consumer waiting, it sends the element immediately.
When the consumer takes the element, if the thread is method as you'll see in a moment.
If the counter has a value bigger than zero, return true.
First, get the lock defined earlier and increment the number of waiting consumers.
If there aren't any elements in the transferred queue, free the lock and try to get an aren't any elements in the queue, this method will put the thread to sleep until there are elements to consume.
Otherwise, take the element from the transferred queue and wake up the thread that is waiting for the consummation of that element, if there is one.
Finally, decrement the counter of waiting consumers and free the lock.
Implement a class named Event that extends the Comparable interface parameterized with the Event class.
Declare a private String attribute named thread to store the name of the thread that creates the event.
Declare a private int attribute named priority to store the priority of the event.
Implement the constructor of the class to initialize its attributes.
Implement a method to return the value of the thread attribute.
Implement a method to return the value of the priority attribute.
You will get the list ordered by priority in the descending order.
Events with higher priority will be stored first in the queue.
Implement a class named Producer that implements the Runnable interface.
Declare a private MyPriorityTransferQueue attribute parameterized with the Event class named buffer to store the events generated by this producer.
Implement the constructor of the class to initialize its attributes.
Declare a private MyPriorityTransferQueue attribute parameterized with the Event class named buffer to get the events consumed by this class.
Implement the constructor of the class to initialize its attribute.
Implement the main class of the example by creating a class named Main.
Create a Producer task and launch 10 threads to execute that task.
In this recipe, you have implemented the MyPriorityTransferQueue data structure.
It's a data structure to be used in the producer/consumer problem, but its elements are ordered by priority, not by their arrival order.
As Java doesn't allow multiple inheritance, the first decision you have taken is the base class of the MyPriorityTransferQueue class.
You have extended the PriorityBlockingQueue class, to have implemented the operations that insert the elements in the structure ordered by priority.
You also have implemented the TransferQueue interface to add the methods related with the producer/consumer.
Only one thread can be working with the data structure.
If there is a consumer waiting, the method stores the element in the priority queue to be consumed immediately by the consumer and then returns the true value.
If there isn't a consumer waiting, the method returns the false value.
It there is a consumer waiting, the method stores the element in the priority queue to be consumed immediately by the consumer.
Otherwise, the element is stored in the list for transferred elements and the thread is blocked until the element is consumed.
While the thread is put to sleep, you have to free the lock because if not, you block the queue.
While the thread is put to sleep, you have to free the lock because, if not, you block the queue.
Once you have implemented the data structure, you have implemented the Event class.
It is the class of the elements you have stored in the data structure.
The Event class has two attributes to store the ID of the producer and the priority of the event, and implements the Comparable interface, because it is a requirement of your data structure.
Then, you have implemented the Producer and the Consumer classes.
In the example, you have 10 producers and a consumer and they share the same buffer.
Each producer generates 100 events with incremental priority, so the events with higher priority are the last generated ones.
The main class of example creates a MyPriorityTransferQueue object, 10 producers, buffer to transfer two events to the buffer.
The following screenshot shows part of the output of an execution of the program:
You can see how the events with higher priority are consumed first, and that a consumer consumes the transferred event.
See also f The Using blocking thread-safe lists ordered by priority recipe in Chapter 6,
Implementing your own atomic object Atomic variables were introduced in Java Version 5 and provide atomic operations on single variables.
When a thread is doing an operation with an atomic variable, the implementation of the class includes a mechanism to check that the operation is done in one step.
Basically, the operation gets the value of the variable, changes the value in a local variable, and then tries to change the old value for the new one.
If the old value is still the same, it does the change.
In this recipe, you will learn how to extend an atomic object and how to implement two operations that follow the mechanisms of the atomic objects to guarantee that all the operations are done in one step.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Declare a private int attribute named maxNumber to store the maximum number of cars admitted in the parking lot.
Implement the constructor of the class to initialize its attributes.
If the value is equal to the maxNumber attribute, the counter can't be incremented (the parking lot is full and the car can't enter)
This method returns the false value; the counter was not incremented, so you have to begin the loop again.
If it returns the true value, it means the change was made and then, you return the true value.
Construct an infinite loop and get the value System.out.printf("ParkingCounter: The parking lot is return false; System.out.printf("ParkingCounter: A car has gone return true;
Create a class named Sensor1 that implements the Runnable interface.
Implement the constructor of the class to initialize its attribute.
Create a class named Sensor2 that implements the Runnable interface.
Implement the constructor of the class to initialize its attribute.
Implement the main class of the example by creating a class named Main with a.
Write in the console the actual value of the counter.
Write in the console a message indicating the end of the program.
The ParkingCounter class extends the AtomicInteger class with two atomic the number of cars inside a parking lot.
The parking lot can admit a number of cars, represented by the maxNumber attribute.
If they are equal, the car can't enter the parking lot and the method returns the false value.
Otherwise, it uses the following structure of the atomic operations:
Get the value of the atomic object in a local variable.
If this method returns the true value, the old value you sent as a parameter was the value of the variable, so it makes the change of values.
The operation was a parameter is not the value of the variable (the other thread modified it), so the operation can't be done in an atomic way.
The operation begins again until it can be done in an atomic way.
When you execute the program, you can see that the parking lot never overcomes the maximum value of cars in the parking lot.
Before the application is ready for end users, you have to demonstrate its correctness.
You use a test process to prove that correctness is achieved and errors are fixed.
The testing phase is a common task in any software development and also quality assurance processes.
You can find a lot of literature about testing processes and the different approaches you can apply to your developments.
There are also a lot of libraries, such as JUnit, and applications, such as Apache JMetter that you can use to test your Java applications in an automated way.
The fact that concurrent applications have two or more threads that share data structures and interact with each other adds more difficulty to the testing phase.
The biggest problem you will face when you test concurrent applications is that the execution of threads is non-deterministic.
You can't guarantee the order of the execution of the threads, so it's difficult to reproduce errors.
Monitoring a Lock interface A Lock interface is one of the basic mechanisms provided by the Java concurrency API to get the synchronization of a block of code.
A critical section is a block of code that accesses a shared resource and can't be executed by more than one thread at the same time.
This mechanism is implemented by the Lock interface and the ReentrantLock class.
In this recipe, you will learn what information you can obtain about a Lock object and how to obtain that information.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named MyLock that extends the ReentrantLock class.
Create a class named Task that implements the Runnable interface.
Implement a constructor of the class to initialize its attribute.
Create the main class of the example by creating a class named Main with.
Create and start five threads to execute five Task objects.
Write in the console the name of the owner of the lock.
Display the number and the name of the threads queued for the lock.
Display information about the fairness and the status of the Lock object.
Put the thread to sleep for 1 second and close the loop and the class.
In this recipe, you have implemented the MyLock class that extends the ReentrantLock class to return information that otherwise wouldn't have been available – it's protected data of the ReentrantLock class.
The lock stores the thread that is executing the critical section.
We have also used other methods that are implemented in the ReentrantLock class:
There's more… There are other methods in the ReentrantLock class that can be used to obtain information about a Lock object:
See also f The Synchronizing a block of code with a lock recipe in Chapter 2, Basic.
Monitoring a Phaser class One of the most complex and powerful functionalities offered by the Java Concurrency API is the ability to execute concurrent phased tasks using the Phaser class.
This mechanism is useful when we have some concurrent tasks divided in steps.
The Phaser class provides us the mechanism to synchronize the threads at the end of each step, so no thread starts its second step until all the threads have finished the first one.
In this recipe, you will learn what information about the status of a Phaser class you can obtain and how to obtain that information.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named Task that implements the Runnable interface.
Implement the constructor of the class to initialize its attributes.
Implement the main class of the example by creating a class named Main with a.
Create a new Phaser object named phaser with three participants.
Create and launch three threads to execute three task objects.
Create a loop with 10 steps to write information about the phaser object.
Write information about the registered parties, the phase of the phaser, the arrived parties, and the un-arrived parties.
Put the thread to sleep for 1 second and close the loop and the class.
In this recipe, we have implemented a phased task in the Task class.
This phased task has three phases and uses a Phaser interface to synchronize with other Task objects.
The main class launches three tasks and while these tasks are executing their phases, it prints information about the status of the phaser object to the console.
We have used the following methods to get the status of the phaser object:
The following screenshot shows part of the output of the program:
See also f The Running concurrent phased tasks recipe in Chapter 3, Thread.
Monitoring an Executor framework The Executor framework provides a mechanism that separates the implementation of tasks from the thread creation and management to execute those tasks.
If you use an executor, you only have to implement the Runnable objects and send them to the executor.
It is the responsibility of an executor to manage threads.
When you send a task to an executor, it tries to use a pooled thread for the execution of this task, to avoid creating new threads.
This mechanism is offered by the Executor interface and its implementing classes as the ThreadPoolExecutor class.
In this recipe, you're going to learn what information you can obtain about the status of a ThreadPoolExecutor executor and how to obtain it.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named Task that implements the Runnable interface.
Implement the constructor of the class to initialize its attribute.
Implement the main class of the example by creating a class named Main with a.
Create another loop with five steps In each step, write information about the executor.
Write information about the size of the pool, the number of tasks, and the status of the executor.
In this recipe, you have implemented a task that blocks its execution thread for a random number of milliseconds.
Then, you have sent 10 tasks to an executor and while you're waiting for their finalization, you have written information about the status of the executor to the console.
You have used the following methods to get the status of the Executor object:
It's the minimum number of threads that will be in the internal thread pool when the executor is not executing any task.
Monitoring a Fork/Join pool The Executor framework provides a mechanism that allows the separation of the task implementation from the creation and management of the threads that execute those tasks.
Java 7 includes an extension of the Executor framework for a specific kind of problem that will improve the performance of other solutions (as using Thread objects directly or the Executor framework)
This framework is designed to solve those problems that can be broken into smaller tasks class that implements this behavior is the ForkJoinPool class.
In this recipe, you're going to learn what information you can obtain about a ForkJoinPool class and how to obtain it.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named Task that extends the RecursiveAction class.
Declare a private int array attribute named array to store the array of elements you want to increment.
Declare two private int attributes named start and end to store the start and end positions of the block of elements this task has to process.
Implement the constructor of the class to initialize its attributes.
Implement the main class of the example by creating a class named Main with a.
Create an array of integer numbers named array with 10,000 elements.
Create a new Task object to process the whole array.
ForkJoinPool class and write a message in the console indicating the end of the program.
In this recipe, you have implemented a task that increments elements of an array using a ForkJoinPool class and a Task class that extends the RecursiveAction class; one of the kind of tasks that you can execute in a ForkJoinPool class.
While the tasks are processing the array, you print information about the status of the ForkJoinPool class to the console.
You have used the following methods to get the status of the ForkJoinPool class:
Writing effective log messages A log system is a mechanism that allows you to write information to one or more destinations.
You can write log messages to the console, a file, or a database.
A Logger also has a level used to decide what messages it is going to write.
It only writes the messages that are as important as, or more important, than its level.
You should use the log system with the following two main purposes:
This will help to localize the error and resolve it.
In this recipe, you will learn how to use the classes provided by the java.util.logging.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
LogRecord object as a parameter and returns a String object with the log message.
If the handler attribute has the null value, create a new FileHandler object to write the log messages in the recipe8.log file.
If the Logger object does not have a handler associated to it, assign the handler.
Create a class named Task that implements the Runnable interface.
It will be the task used to test your Logger object.
Write a log message indicating the beginning of the execution of the method using Sleep the thread for two seconds.
Write a log message indicating the end of the execution of the method using the.
Implement the main class of the example by creating a class named Main with a.
Write a log message indicating the start of the execution of the main program using.
Create five Task objects and five threads to execute them.
Write log messages to indicate that you're going to launch a new thread and to indicate that you have created the thread.
Write a log message to indicate that you have created the threads.
Write a log message to indicate the end of the execution of the main program using.
In this recipe, you have used the Logger class provided for the Java logging API to write log messages in a concurrent application.
First of all, you have implemented the MyFormatter class to give a format to the log messages.
This class extends the Formatter class that the information of the log message and returns a formatted log message.
In your class, you have used the following methods of the LogRecord class to obtain information about the log message:
You returns a different object per name that is passed as a parameter.
You only have created one Handler object, so all the Logger objects will write its log messages in the same file.
You also have configured the logger to write all the log messages, regardless of its level.
Finally, you have implemented a Task object and a main program that writes different log messages in the logfile.
When you work with a log system, you have to take into consideration two important points:
If you write too much information, you will generate too large logfiles that will be unmanageable and make it difficult to get the necessary information.
It will be more difficult to know what happened in an error situation or you will have too much information to know the main cause of the error.
There are other libraries that provide a log system more complete than the java.util.
Analyzing concurrent code with FindBugs The static code analysis tools are a set of tools that analyze the source code of an application looking for potential errors.
These tools, such as Checkstyle, PMD, or FindBugs have a set of predefined rules of good practices and parse the source code looking for violations of those rules.
The objective is to find errors or places causing poor performance early, before it will be executed in production.
Programming languages usually offer such tools and Java is not an exception.
One of these tools to analyze Java code is FindBugs.
It's an open source tool that includes a series of rules to analyze Java-concurrent code.
In this recipe, you will learn how to use this tool to analyze your Java-concurrent applications.
Getting ready Before stating this recipe, you should download FindBugs from the project's web page (http://findbugs.sourceforge.net/)
You can download a standalone application or an Eclipse plugin.
How to do it… Follow these steps to implement the example:
Create a class named Task that extends the Runnable interface.
Create the main class of the example by creating a class named Main with.
Create a new project with the New Project option of the File menu in the menu bar.
In the Classpath for analysis field add the jar file with the project and in the Source directories field add the directory with the source code of the example.
Click on the Analyze button to create the new project and analyze its code.
The FindBugs application shows the result of the analysis of the code.
Click one of the bugs and you'll see the source code of the bug in the right-hand side panel and the description of the bug in the panel of the bottom of the screen.
The following screenshot shows the result of the analysis by FindBugs:
The analysis has detected the following two potential bugs in the application:
If you make a double-click in one of the two bugs, you will see detailed information about it.
As you have included the source-code reference in the configuration of the project, you also will see the source code where the bug was detected.
Be aware that FindBugs can only detect some problematic situations (related or not with the Task class and repeat the analysis, FindBugs won't alert you that you get the lock in the task but you never free it.
Use the tools for the static code analysis as a help to improve the quality of your code, but do not expect to detect all the bugs in your code.
See also f The Configuring NetBeans for debugging concurrency code recipe in Chapter 8,
Nowadays, almost every programmer, regardless of the programming language in use, create their applications with an IDE.
They provide lots of interesting functionalities integrated in the same application, such as:
One of the most helpful features of an IDE is a debugger.
You can execute your application step-by-step and analyze the values of all the objects and variables of your program.
If you work with the Java programming language, Eclipse is one of the most popular IDEs.
It has an integrated debugger that allows you to test your applications.
By default, when you debug a concurrent application and the debugger finds a breakpoint, it only stops the thread that has that breakpoint while the rest of the threads continue with their execution.
In this recipe, you will learn how to change that configuration to help you to test concurrent applications.
Open it and select a project with a concurrent application implemented in it, for example, one of the recipes implemented in the book.
How to do it… Follow these steps to implement the example:
Thread to Suspend VM (marked in red in the screenshot)
As we mentioned in the introduction of this recipe, by default, when you debug a concurrent Java application in Eclipse and the debug process finds a breakpoint, it only suspends the thread that hit the breakpoint first while the other threads continue with their execution.
You can see that only the worker-21 is suspended (marked in red in the screenshot) while the rest of the threads are running.
However, if you change Default suspend policy for new breakpoints to Suspend VM, all the threads suspend their execution while you're debugging a concurrent application and the debug process hits a breakpoint.
With the change, you can see that all the threads are suspended.
In today's world, software is necessary to develop applications that work properly, that meet the quality standards of the company, and that will be easily modified in the future, in a limited time and with a cost as low as possible.
To achieve this goal, it is essential to use an IDE that integrates under one common interface several tools (compilers and debuggers) that facilitate the development of applications.
If you work with the Java programming language, NetBeans is one of the most popular IDEs.
It has an integrated debugger that allows you to test your application.
In this recipe, you will learn how to change that configuration to help you to test concurrent applications.
How to do it… Follow these steps to implement the example:
Create a class named Task1 and specify that it implements the Runnable interface.
Implement the constructor of the class to initialize its attributes.
Create a class named Task2 and specify that it implements the Runnable interface.
Implement the constructor of the class to initialize its attributes.
Implement the main class of the example by creating a class named Main and add.
While the two tasks haven't finished their execution, write a message in the console finished its execution.
You will see the Debugging window in the top left-hand side corner of the main NetBeans window.
The next screenshot presents the appearance of that window with the thread that executes the Task1 object slept because they have arrived at the breakpoint and the other threads running:
The following screenshot shows the new appearance of the Debugging window.
While debugging a concurrent application using NetBeans, when the debugger hits a breakpoint, it suspends the thread that hit the breakpoint and shows the Debugging window in the top left-hand side corner with the threads that are currently running.
You can use the window to pause or resume the threads that are currently running using the Pause or Resume options.
You can also see the values of the variables or attributes of the threads using the Variables tab.
When you select the Check for Deadlock option in the Debug menu, NetBeans performs an analysis of the application that you're debugging to determine if there's a deadlock situation.
The second thread gets the locks just in a reverse manner.
The breakpoint inserted provokes the deadlock, but if you use NetBeans deadlock detector, you'll not find anything, so this option should be used with caution.
Change the locks used in both tasks by the synchronized keyword and debug the program again.
The code of the Task1 will be presented as follows:
The code of the Task2 class will be analogous to this, but changes the order of the locks.
If you debug the example again, you will obtain a deadlock again, but in this case, it's detected by the deadlock detector, as you can see in the following screenshot:
Then, select the Miscellaneous option and the Java Debugger tab.
There are two options on that window that control the behavior described earlier:
You can suspend only the thread that has the breakpoint or all the threads of the application.
You can resume only the current thread or all the threads.
Both options have been marked in the screenshot presented earlier.
See also f The Configuring Eclipse for debugging concurrency code recipe in Chapter 8, Testing.
Its main objective is to solve the problem of concurrent applications being non-deterministic.
For this purpose, it includes an internal metronome to control the order of execution of the different threads that form the application.
Those testing threads are implemented as methods of a class.
In this recipe, you will learn how to use the MultithreadedTC library to implement a test for LinkedTransferQueue.
Getting ready You must also download the MultithreadedTC library from http://code.google.com/p/ multithreadedtc/ and the JUnit library, Version 4.10 from http://www.junit.org/
How to do it… Follow these steps to implement the example:
Declare a private LinkedTransferQueue attribute parameterized with the String class named queue.
Implement the main class of the example by creating a class named Main with a.
In this recipe,  you have implemented a test for the LinkedTransferQueue class using the MultithreadedTC library.
You can implement a test to any concurrent application or class using this library and its metronome.
In the example, you have implemented the classical producer/ consumer problem with two consumers and a producer.
You want to test that the first String object introduced in the buffer is consumed by the first consumer that arrives at the buffer and the second String object introduced in the buffer is consumed by the second consumer that arrives at the buffer.
The MultithreadedTC library is based on the JUnit library, which is the most often used library to implement unit tests in Java.
To implement a basic test using the MultithreadedTC library, you have to extend the MultithreadedTestCase class.
It doesn't extend the junit.framework.TestCase class, so you can't integrate the MultithreadedTC tests with other JUnit tests.
You can use it to close or release resources used during the test or to check the results of the test.
They have to start with the thread keyword followed by a string.
When they are blocked, the MultithreadedTC library resumes the threads that are blocked by a call to the.
The metronome of the MultithreadedTC library has an internal counter.
When all the threads are blocked, the library increments that counter to the next number.
Internally, when the MultithreadedTC library has to execute a test, first it executes the.
If the MultithreadedTC library detects that all the threads of the test are blocked, but none state and a java.lang.IllegalStateException exception is thrown.
See also f The Analyzing concurrent code with FindBugs recipe in Chapter 8,
About Packt Publishing Packt, pronounced 'packed', published its first book "Mastering phpMyAdmin for Effective MySQL Management" in April 2004 and subsequently continued to specialize in publishing highly focused books on specific technologies and solutions.
Our books and publications share the experiences of your fellow IT professionals in adapting and customizing today's systems, applications, and frameworks.
Our solution-based books give you the knowledge and power to customize the software and technologies you're using to get the job done.
Packt books are more specific and less general than the IT books you have seen in the past.
Our unique business model allows us to bring you more focused information, giving you more of what you need to know, and less of what you don't.
Packt is a modern, yet unique publishing company, which focuses on producing quality, cutting-edge books for communities of developers, administrators, and newbies alike.
This book is part of the Packt Enterprise brand, home to books published on enterprise software – software created by major vendors, including (but not limited to) IBM, Microsoft and Oracle, often for use in other corporations.
Its titles will offer information relevant to a range of users of this software, including administrators, developers, architects, and end users.
Writing for Packt We welcome all inquiries from people who are interested in authoring.
If your book idea is still at an early stage and you would like to discuss it first before writing a formal book proposal, contact us; one of our commissioning editors will get in touch with you.
We're not just looking for published authors; if you have strong technical skills but no writing experience, our experienced editors can help you develop a writing career, or simply get some additional reward for your expertise.
A practical, focused mini book for creating Web Services in Java 7
End-to-end application which makes use of the new clientjar option in JAX-WS wsimport tool.
Over 70 highly focused practical recipes to maximize your output with NetBeans.
Learn how to deploy, debug, and test your software using NetBeans IDE.
Another title in Packt's Cookbook series giving clear, real-world solutions to common practical problems.
Learn about the fundamental building blocks of a JVM, such as code generation and memory management, and utilize this knowledge to develop code you can count on.
Realize the full potential of Java applications by learning how to apply advanced tuning and analysis.
Work with the JRockit Mission Control 3.1/4.0 tools suite to debug or profile your Java applications.
Covers exciting features such as the try-withresources block, the monitoring of directory events, asynchronous IO and new GUI enhancements, and more.
A learn-by-example based approach that focuses on key concepts to provide the foundation to solve real world problems.
Cover Copyright Credits About the Author About the Reviewers www.PacktPub.com Table of Contents Preface Chapter 1: Thread Management Introduction Creating and running a thread Getting and setting thread information Interrupting a thread Controlling the interruption of a thread Sleeping and resuming a thread Waiting for the finalization of a thread Creating and running a daemon thread Processing uncontrolled exceptions in a thread Using local thread variables Grouping threads into a group Processing uncontrolled exceptions in a group of threads Creating threads through a factory.
Chapter 2: Basic Thread Synchronization Introduction Synchronizing a method Arranging independent attributes in synchronized classes Using conditions in synchronized code Synchronizing a block of code with a Lock Synchronizing data access with read/write locks Modifying Lock fairness Using multiple conditions in a Lock.
Chapter 3: Thread Synchronization Utilities Introduction Controlling concurrent access to a resource Controlling concurrent access to multiple copies of a resource Waiting for multiple concurrent events Synchronizing tasks in a common point Running concurrent phased tasks Controlling phase change in concurrent phased tasks Changing data between concurrent tasks.
Chapter 4: Thread Executors Introduction Creating a thread executor Creating a fixed-size thread executor Executing tasks in an executor that returns a result Running multiple tasks and processing the first result Running multiple tasks and processing all the results Running a task in an executor after a delay Running a task in an executor periodically Canceling a task in an executor Controlling a task finishing in an executor Separating the launching of tasks and the processing of their results in an executor Controlling rejected tasks of an executor.
Chapter 5: Fork/Join Framework Introduction Creating a Fork/Join pool Joining the results of the tasks Running tasks asynchronously Throwing exceptions in the tasks Canceling a task.
Chapter 6: Concurrent Collections Introduction Using non-blocking thread-safe lists Using blocking thread-safe lists Using blocking thread-safe lists ordered by priority Using thread-safe lists with delayed elements Using thread-safe navigable maps Generating concurrent random numbers Using atomic variables Using atomic arrays.
Chapter 7: Customizing Concurrency Classes Introduction Customizing the ThreadPoolExecutor class Implementing a priority-based Executor class Implementing the ThreadFactory interface to generate custom threads Using our ThreadFactory in an Executor object Customizing tasks running in a scheduled thread pool Implementing the ThreadFactory interface to generate custom threads for the Fork/Join framework Customizing tasks running in the Fork/Join framework Implementing a custom Lock class Implementing a transfer Queue based on priorities Implementing your own atomic object.
