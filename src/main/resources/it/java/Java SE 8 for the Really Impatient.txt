Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and the publisher was aware of a trademark claim, the designations have been printed with initial capital letters or in all capitals.
The author and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions.
No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein.
This publication is protected by copyright, and permission must be obtained from the publisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, recording, or likewise.
To Greg Doench, my editor for two decades, whose patience, kindness,
With Java 8, the Java programming language and library receive a major refresh.
The recipient can choose to execute your computation when appropriate and as often as appropriate.
Each version of Java brings enhancements in the concurrency API, and Java 8 is no exception.
In Chapter 6, you learn about improvements in atomic counters, concurrent hash maps, parallel array operations, and composable futures.
In Chapter 7, you will see how to execute JavaScript on the Java Virtual Machine, and how to interoperate with Java code.
My thanks go, as always, to my editor Greg Doench, who had the idea of a short book that brings experienced programmers up to speed with Java 8
Dmitry Kirsanov and Alina Kirsanova once again turned an XHTML manuscript into an attractive book with amazing speed and attention to detail.
I am grateful to the reviewers who spotted many embarrassing errors and gave excellent suggestions for improvement.
The principal enhancement in Java 8 is the addition of functional programming constructs to its object-oriented roots.
The next chapter shows you how to put that syntax to use with Java collections, and in Chapter 3 you will learn how to build your own functional libraries.
A lambda expression is a block of code with parameters.
Use a lambda expression whenever you want a block of code executed at a later point in time.
Method and constructor references refer to methods or constructors without invoking them.
You can now add default and static methods to interfaces that provide concrete implementations.
Before getting into the syntax (or even the curious name), let’s step back and see where you have used similar code blocks in Java all along.
When you want to do work in a separate thread, you put the work into the run method of a Runnable, like this:
Then, when you want to execute this code, you construct an instance of the Worker class.
You can then submit the instance to a thread pool, or, to keep it simple, start a new thread:
The key point is that the run method contains code that you want to execute in a separate thread.
If you want to sort strings by length instead of the default dictionary order, you can pass a Comparator object to the sort method:
The sort method keeps calling the compare method, rearranging the elements if they are out of order, until the array is sorted.
You give the sort method a snippet of code needed to compare elements, and that code is integrated into the rest of the sorting logic, which you’d probably not care to reimplement.
As another example for deferred execution, consider a button callback.
You put the callback action into a method of a class implementing the listener interface, construct an instance, and register the instance with the button.
NOTE: Since Java 8 positions JavaFX as the successor to the Swing GUI toolkit, I use JavaFX in these examples.
See Chapter 4 for more information on JavaFX.) Of course, the details don’t matter.
In every user interface toolkit, be it Swing, JavaFX, or Android, you give a button some code that you want to run when the button is clicked.
A block of code was passed to someone—a thread pool, a sort method, or a button.
Up to now, giving someone a block of code hasn’t been easy in Java.
Java is an object-oriented language, so you had to construct an object belonging to a class that has a method with the desired code.
In other languages, it is possible to work with blocks of code directly.
The Java designers have resisted adding this feature for a long time.
A language can become an unmaintainable mess if it includes every feature that yields marginally more concise code.
However, in those other languages it isn’t just easier to spawn a thread or to register a button click handler; large swaths of their APIs are simpler, more consistent, and more powerful.
In Java, one could have written similar APIs that take objects of classes implementing a particular function, but such APIs would be unpleasant to use.
We pass code that checks whether one string is shorter than another.
Java is a strongly typed language, and we must specify that as well:
If a lambda expression has no parameters, you still supply empty parentheses, just as with a parameterless method:
If the parameter types of a lambda expression can be inferred, you can omit them.
Here, the compiler can deduce that first and second must be strings because the lambda expression is assigned to a string comparator.
We will have a closer look at this assignment in the next section.)
If a method has a single parameter with inferred type, you can even omit the parentheses:
You never specify the result type of a lambda expression.
As we discussed, there are many existing interfaces in Java that encapsulate blocks of code, such as Runnable or Comparator.
You can supply a lambda expression whenever an object of an interface with a single abstract method is expected.
NOTE: You may wonder why a functional interface must have a single abstract method.
Aren’t all methods in an interface abstract? Actually, it has always been possible for an interface to redeclare methods from the Object class such as toString or clone, and these declarations do not make the methods abstract.
Some interfaces in the Java API redeclare Object methods in order to attach javadoc comments.
To demonstrate the conversion to a functional interface, consider the Arrays.sort method.
Its second parameter requires an instance of Comparator, an interface with a single method.
This conversion to interfaces is what makes lambda expressions so compelling.
That’s a lot easier to read than the alternative with inner classes.
In fact, conversion to a functional interface is the only thing that you can do with a lambda expression in Java.
In other programming languages that support function literals, you can declare function types such as (String, String) -> int, declare variables of those types, and use the variables to save function expressions.
However, the Java designers decided to stick with the familiar concept of interfaces instead of adding function types to the language.
NOTE: You can’t even assign a lambda expression to a variable of type Object—Object is not a functional interface.
But keep in mind that you can equally well convert a lambda expression into a functional interface that is a part of whatever API you use today.
The compiler checks that the annotated entity is an interface with a single abstract method.
And the javadoc page includes a statement that your interface is a functional interface.
Finally, note that checked exceptions matter when a lambda is converted to an instance of a functional interface.
Sometimes, there is already a method that carries out exactly the action that you’d like to pass on to some other code.
For example, suppose you simply want to print the event object whenever a button is clicked.
It would be nicer if you could just pass the println method to the setOnAction method.
As another example, suppose you want to sort strings regardless of letter case.
As you can see from these examples, the :: operator separates the method name from the name of an object or class.
You can capture the this parameter in a method reference.
For example, this::equals is the same as x -> this.equals(x)
When the thread starts, its Runnable is invoked, and super::greet is executed, calling the greet method of the superclass.
Constructor references are just like method references, except that the name of the method is new.
For example, Button::new is a reference to a Button constructor.
Then you can turn it into an array of buttons, by calling the constructor on each of the strings, with the following invocation:
We will discuss the details of the stream, map, and collect methods in Chapter 2
For now, what’s important is that the map method calls the Button(String) constructor for each list element.
There are multiple Button constructors, but the compiler picks the one with a String parameter because it infers from the context that the constructor is called with a string.
For example, int[]::new is a constructor reference with one parameter: the length of the array.
Array constructor references are useful to overcome a limitation of Java.
It is not possible to construct an array of a generic type T.
For example, suppose we want to have an array of buttons.
The Stream interface has a toArray method that returns an Object array:
Often, you want to be able to access variables from an enclosing method or class in a lambda expression.
If you think about it, something nonobvious is going on here.
The code of the lambda expression may run long after the call to repeatMessage has returned and the parameter variables are gone.
In our example, the lambda expression has two free variables, text and count.
The data structure representing the lambda expression must store the values for these variables, in our case, "Hello" and 1000
We say that these values have been captured by the lambda expression.
For example, one can translate a lambda expression into an object with a single method, so that the values of the free variables are copied into instance variables of that object.)
NOTE: The technical term for a block of code together with the values of the free variables is a closure.
If someone gloats that their language has closures, rest assured that Java has them as well.
Consider a sequence of concurrent tasks, each updating a shared counter.
If this code were legal, it would be very, very bad.
The increment matches++ is not atomic, and there is no way of knowing what would happen if multiple threads execute that increment concurrently.
Also, it’s perfectly legal to mutate a shared object, even though it is unsound.
However, the object is mutated, and that is not threadsafe.
There are safe mechanisms for counting and collecting values concurrently.
In Chapter 2, you will see how to use streams to collect values with certain properties.
In other situations, you may want to use threadsafe counters and collections.
See Chapter 6 for more information on this important topic.
NOTE: As with inner classes, there is an escape hatch that lets a lambda expression update a counter in an enclosing local scope.
For a button callback, that doesn’t matter, but in general, you should think twice before using this trick.You will see how to implement a threadsafe shared counter in Chapter 6
Inside a method, you can’t have two local variables with the same name, and therefore, you can’t introduce such variables in a lambda expression either.
When you use the this keyword in a lambda expression, you refer to the this parameter of the method that creates the lambda.
The expression this.toString() calls the toString method of the Application object, not the Runnable instance.
There is nothing special about the use of this in a lambda expression.
The scope of the lambda expression is nested inside the doWork method, and this has the same meaning anywhere in that method.
Many programming languages integrate function expressions with their collections library.
This often leads to code that is shorter and easier to understand than the loop equivalent.
The library designers can supply a forEach method that applies a function to each element.
The Java designers decided to solve this problem once and for all by allowing interface methods with concrete implementations (called default methods)
In this section, we’ll look into default methods in detail.
NOTE: In Java 8, the forEach method has been added to the Iterable interface, a superinterface of Collection, using the mechanism that I will describe in this section.
The interface has two methods: getId, which is an abstract method, and the default method getName.
A concrete class that implements the Person interface must, of course, provide an implementation of getId, but it can choose to keep the implementation of getName or to override it.
Now you can just implement the methods in the interface.
If a superclass provides a concrete method, default methods with the same name and parameter types are simply ignored.
What happens if you form a class that implements both of them?
Now assume that the Named interface does not provide a default implementation for getName:
In that case, only the superclass method matters, and any default method from the interface is simply ignored.
In our example, Student inherits the getName method from Person, and it doesn’t make any difference whether the Named interface provides a default for getName or not.
If you add default methods to an interface, it has no effect on code that worked before there were default methods.
In Java 8, one could have added this method to the Path interface:
For a factory method that doesn’t work since you don’t have an object on which to invoke the method.
It is unlikely that the Java collections library will be refactored in this way, but when you implement your own interfaces, there is no longer a reason to provide a separate companion class for utility methods.
In Java 8, static methods have been added to quite a few interfaces.
Runnable? Write a method uncheck that catches all checked exceptions and turns them into unchecked exceptions.
What happens when a lambda expression captures values in an enhanced for loop such as this one?
Suppose you have a class that implements two interfaces I and J, each of which has a method void f()
Exactly what happens if f is an abstract, default, or static method of I and an abstract, default, or static method of J? Repeat where a class extends a superclass S and implements an interface I, each of which has a method void f()
For example, if you want to compute the average of the values of a certain method, you specify that you want to call the method on each element and get the average of the values.
You leave it to the stream library to parallelize the operation, using multiple threads for computing sums and counts of each segment and combining the results.
You can create streams from collections, arrays, generators, or iterators.
Use filter to select elements and map to transform elements.
Other operations for transforming streams include limit, distinct, and sorted.
To obtain a result from a stream, use a reduction operator such as count, max, min, findFirst, or findAny.
The Optional type is intended as a safe alternative to working with null values.
To use it safely, take advantage of the ifPresent and orElse methods.
You can collect stream results in collections, arrays, strings, or maps.
The groupingBy and partitioningBy methods of the Collectors class allow you to split the contents of a stream into groups, and to obtain a result for each group.
There are specialized streams for the primitive types int, long, and double.
When you work with parallel streams, be sure to avoid side effects, and consider giving up ordering constraints.
You need to be familiar with a small number of functional interfaces in order to use the stream library.
When you process a collection, you usually iterate over its elements and do some work with each of them.
For example, suppose we want to count all long words in a book.
The stream method yields a stream for the words list.
The filter method returns another stream that contains only the words of length greater than twelve.
They may be stored in an underlying collection or generated on demand.
When you work with streams, you set up a pipeline of operations in three stages.
You specify intermediate operations for transforming the initial stream into others, in one or more steps.
This operation forces the execution of the lazy operations that precede it.
In our example, the stream was created with the stream or parallelStream method.
The filter method transformed it, and count was the terminal operation.
You have already seen that you can turn any collection into a stream with the stream method that Java 8 added to the Collection interface.
If you have an array, use the static Stream.of method instead.
The of method has a varargs parameter, so you can construct a stream from any number of arguments:
To make a stream with no elements, use the static Stream.empty method:
NOTE: A number of methods that yield streams have been added to the API with the Java 8 release.
For example, the Pattern class now has a method splitAsStream that splits a CharSequence by a regular expression.You can use the following statement to split a string into words:
A stream transformation reads data from a stream and puts the transformed data into another stream.
You have already seen the filter transformation that yields a new stream with all elements that match a certain condition.
Here, we transform a stream of strings into another stream containing only long words:
The argument of filter is a Predicate<T>—that is, a function from T to boolean.
Often, you want to transform the values in a stream in some way.
Use the map method and pass the function that carries out the transformation.
For example, you can transform all words to lowercase like this:
When you use map, a function is applied to each element, and the return values are collected in a new stream.
Now suppose that you have a function that returns not just one value but a stream of values, such as this one:
Suppose you map this method on a stream of strings:
You can concatenate two streams with the static concat method of the Stream class:
TIP: The peek method yields another stream with the same elements as the original, but a function is invoked every time an element is retrieved.
Of course, you can sort a collection without using streams.
The sorted method is useful when the sorting process is a part of a stream pipeline.
NOTE: The Collections.sort method sorts a collection in place, whereas Stream.sorted returns a new sorted stream.
You have already seen a simple reduction: the count method that returns the number of elements of the stream.
Other simple reductions are max and min that return the largest or smallest value.
In the olden days, it was common to return null in such a situation.
But that can lead to null pointer exceptions when an unusual situation arises in an incompletely tested program.
In Java 8, the Optional type is the preferred way of indicating a missing return value.
We discuss the Optional type in detail in the next section.
Here is how you can get the maximum of a stream:
If you just want to know there is a match, use anyMatch.
That method takes a predicate argument, so you won’t need to use filter.
An Optional<T> object is either a wrapper for an object of type T or for no object.
It is intended as a safer alternative than a reference of type T that refers to an object or null.
But it is only safer if you use it right.
As you saw in the preceding section, the isPresent method reports whether an Optional<T> object has a value.
In the next section, you will see how you should really work with Optional values.
The key to using Optional effectively is to use a method that either consumes the correct value or produces an alternative.
There is a second form of the ifPresent method that accepts a function.
If the optional value exists, it is passed to that function.
For example, if you want to add the value to a set if it is present, call.
When calling this version of ifPresent, no value is returned.
If you want to process the result, use map instead:
Now added has one of three values: true or false wrapped into an Optional, if optionalValue was present, or an empty optional otherwise.
Simply imagine an optional value as a stream of size zero or one.
The result again has size zero or one, and in the latter case, the function has been applied.
You have just seen how to gracefully consume an optional value when it is present.
The other strategy for working with optional values is to produce an alternative if no value is present.
Often, there is a default that you want to use when there was no match, perhaps the empty string:
Or, if you want to throw another exception if there is no value,
So far, we have discussed how to consume an Optional object that someone else created.
If you write a method that creates an Optional object, there are several static methods for that purpose.
The ofNullable method is intended as a bridge from the use of null values to optional values.
If they were normal methods, you could compose them by calling s.f().g()
But that composition doesn’t work here, since s.f() has type Optional<T>,has not T.
If s.f() is present, then g is applied to it.
Clearly, you can repeat that process if you have more methods or lambdas that yield Optional values.
You can then build a pipeline of steps that succeeds only when all parts do, simply by chaining calls to flatMap.
For example, consider the safe inverse method of the preceding section.
Then you can compute the square root of the inverse as.
The method returns an Optional because there is no valid result if the stream is empty.
Often, there is an identity e such that e op x = x, and you can use that element as the start of the computation.
The identity value is returned if the stream is empty, and you no longer need to deal with the Optional class.
Now suppose you have a stream of objects and want to form the sum of some property, such as all lengths in a stream of strings.
It requires a function (T, T) -> T, with the same types for the arguments and the result.
The stream elements have type String, and the accumulated result is an integer.
There is a form of reduce that can deal with this situation.
But when the computation is parallelized, there will be multiple computations of this kind, and you need to combine their results.
When you are done with a stream, you often just want to look at the results instead of reducing them to a value.
You can call the iterator method, which yields an old-fashioned iterator that you can use to visit the elements.
Or you can call toArray and get an array of the stream elements.
Since it is not possible to create a generic array at runtime, the expression stream.toArray() returns an Object[] array.
If you want an array of the correct type, pass in the array constructor:
Now suppose you want to collect the results in a HashSet.
If the collection is parallelized, you can’t put the elements directly into a single HashSet because a HashSet object is not threadsafe.
Each segment needs to start out with its own empty hash set, and reduce only lets you supply one identity value.
A supplier to make new instances of the target object, for example, a constructor for a hash set.
It could be a StringBuilder or an object that tracks a count and a sum.
Here is how the collect method works for a hash set:
In practice, you don’t have to do that because there is a convenient Collector interface for these three functions, and a Collectors class with factory methods for common collectors.
To collect a stream into a list or set, you can simply call.
If you want to control which kind of set you get, use the following call instead:
Suppose you want to collect all strings in a stream by concatenating them.
If you want a delimiter between elements, pass it to the joining method:
NOTE: So far, you have seen how to reduce or collect stream values.
But perhaps you just want to print them or put them in a database.
The function that you pass is applied to each element.
On a parallel stream, it’s your responsibility to ensure that the function can be executed concurrently.
The forEach and forEachOrdered methods are terminal operations.You cannot use the stream again after calling them.
Suppose you have a Stream<Person> and want to collect the elements into a map so that you can later look up people by their ID.
The Collectors.toMap method has two function arguments that produce the map keys and values.
In the common case that the values should be the actual elements, use Function.
You can override that behavior by supplying a third function argument that determines the value for the key, given the existing and the new value.
Your function could return the existing value, the new value, or a combination of them.
Here, we construct a map that contains, for each language in the available locales, as key its name in your default locale (such as "German"), and as value its localized name (such as "Deutsch")
You will see a simpler way of obtaining this map in the next section.
If you want a TreeMap, then you supply the constructor as the fourth argument.
Here is one of the examples from the beginning of the section, now yielding a TreeMap:
In the preceding section, you saw how to collect all languages in a given country.
You had to generate a singleton set for each map value, and then specify how to merge the existing and new values.
Forming groups of values with the same characteristic is very common, and the groupingBy method supports it directly.
Let’s look at the problem of grouping locales by country.
NOTE: A quick refresher on locales: Each locale has a language code (such as en for English) and a country code (such as US for the United States)
For example, ga_IE is Gaelic in Ireland, and, as the preceding example shows, my JVM knows three locales in Switzerland.
The groupingBy method yields a map whose values are lists.
Several other collectors are provided for downstream processing of grouped elements:
Within each state, we produce the names of the cities and reduce by maximum length.
The mapping method also yields a nicer solution to a problem from the preceding section, to gather a set of all languages in a country.
In the preceding section, I used toMap instead of groupingBy.
In this form, you don’t need to worry about combining the individual sets.
Then you can get the sum, count, average, minimum, and maximum of the function values from the summary statistics objects of each group.
Here is an example that gets a comma-separated string of all city names in each state.
We map each city to its name and then concatenate them.
In this case, you can achieve the same result more naturally as.
You should only use them in connection with groupingBy or partitioningBy to process the “downstream” map values.
Otherwise, simply apply methods such as map, reduce, count, max, or min directly on streams.
To create an IntStream, you can call the IntStream.of and Arrays.stream methods:
As with object streams, you can also use the static generate and iterate methods.
In addition, IntStream and LongStream have static methods range and rangeClosed that generate integer ranges with step size one:
The CharSequence interface has methods codePoints and chars that yield an IntStream of the Unicode codes of the characters or of the code units in the UTF-16 encoding.
If you don’t know what code units are, you probably shouldn’t use the chars method.
When you have a stream of objects, you can transform it to a primitive type stream with the mapToInt, mapToLong, or mapToDouble methods.
For example, if you have a stream of strings and want to process their lengths as integers, you might as well do it in an IntStream:
To convert a primitive type stream to an object stream, use the boxed method:
Generally, the methods on primitive type streams are analogous to those on object streams.
Methods that yield an optional result return an OptionalInt, OptionalLong, or OptionalDouble.
These classes are analogous to the Optional class, but they have methods getAsInt, getAsLong, and getAsDouble instead of the get method.
NOTE: The Random class has methods ints, longs, and doubles that return primitive type streams of random numbers.
The process is mostly automatic, but you need to follow a few rules.
The parallel method converts any sequential stream into a parallel one.
As long as the stream is in parallel mode when the terminal method executes, all lazy intermediate stream operations will be parallelized.
When stream operations run in parallel, the intent is that the same result is returned as if they had run serially.
It is important that the operations are stateless and can be executed in an arbitrary order.
Suppose you want to count all short words in a stream of strings:
The function passed to forEach runs concurrently in multiple threads, updating a shared array.
If you run this program multiple times, you are quite likely to get a different sequence of counts in each run, each of them wrong.
It is your responsibility to ensure that any functions that you pass to parallel stream operations are threadsafe.
In our example, you could use an array of AtomicInteger objects for the counters (see Exercise 12)
Or you could simply use the facilities of the streams library and group strings by length (see Exercise 13)
By default, streams that arise from ordered collections (arrays and lists), from ranges, generators, and iterators, or from calling Stream.sorted, are ordered.
Results are accumulated in the order of the original elements, and are entirely predictable.
If you run the same operations twice, you will get exactly the same results.
For example, when computing stream.map(fun), the stream can be partitioned into n segments, each of which is concurrently processed.
You can also speed up the limit method by dropping ordering.
If you just want any n elements from a stream and you don’t care which ones you get, call.
To be exact, since intermediate stream operations are lazy, it is possible to mutate the collection up to the point when the terminal operation executes.
In this chapter, you have seen many operations whose argument is a function.
In the javadoc of the Stream class, the filter method is declared as follows:
To understand the documentation, you have to know what a Predicate is.
It is an interface with one nondefault method returning a boolean value:
In practice, one usually passes a lambda expression or method reference, so the name of the method doesn’t really matter.
When reading the documentation of Stream.filter, just remember that a Predicate is a function returning a boolean.
Table 2–1 summarizes the functional interfaces that occur as parameters of the Stream and Collectors methods.
You will see additional functional interfaces in the next chapter.
A function with argument of type int, long, or double.
Make that many separate threads, each working on a segment of the list, and total up the results as they come in.
You don’t want the threads to update a single counter.
Measure the difference when counting long words with a parallelStream instead of a stream.
Switch to a larger document (such as War and Peace) if you have a fast computer.
Why isn’t that such a good idea? Go ahead and write it anyway.
Show how to do this with the three forms of reduce.
Write a call to reduce that can be used to compute the average of a Stream<Double>
Why can’t you simply compute the sum and divide by count()?
It should be possible to concurrently collect stream results in a single ArrayList, instead of merging multiple array lists, provided it has been constructed with.
Use the atomic getAndIncrement method to safely increment each counter.
The main reason for using a lambda expression is to defer the execution of the code until an appropriate time.
When a lambda expression is executed, make sure to provide any required data as inputs.
Choose one of the existing functional interfaces if you can.
It is often useful to write methods that return an instance of a functional interface.
When you work with transformations, consider how you can compose them.
To compose transformations lazily, you need to keep a list of all pending transformations and apply them in the end.
If you need to apply a lambda many times, you often have a chance to split up the work into subtasks that execute concurrently.
Think what should happen when you work with a lambda expression that throws an exception.
When working with generic types that can be transformed by functions, consider supplying map and flatMap.
After all, if you wanted to execute some code right now, you’d do that, without wrapping it inside a lambda.
There are many reasons for executing code later, such as.
Running the code at the right point in an algorithm (for example, the comparison operation in sorting)
Running the code when something happens (a button was clicked, data has arrived, and so on)
It is a good idea to think through what you want to achieve when you set out programming with lambdas.
What happens if the log level is set to suppress INFO messages? The message string is computed and passed to the info method, which then decides to throw it away.
Wouldn’t it be nicer if the string concatenation only happened when necessary?
Running code only when necessary is a use case for lambdas.
The standard idiom is to wrap the code in a no-arg lambda:
To accept the lambda, we need to pick (or, in rare cases, provide) a functional interface.
We use the isLoggable method of the Logger class to decide whether INFO messages should be logged.
If so, we invoke the lambda by calling its abstract method, which happens to be called get.
When you ask your user to supply a comparator, it is pretty obvious that the comparator has two arguments—the values to be compared.
Why an IntConsumer and not a Runnable? We tell the action in which iteration it occurs, which might be useful information.
The action needs to capture that input in a parameter.
The event object carries information that the action may need.
In general, you want to design your algorithm so that it passes any required information as arguments.
For example, when editing an image, it makes sense to have the user supply a function that computes the color for a pixel.
Such a function might need to know not just the current color, but also where the pixel is in the image, or what the neighboring pixels are.
However, if these arguments are rarely needed, consider supplying a second version that doesn’t force users into accepting unwanted arguments:
In Java, you instead declare the intent of the function, using a functional interface such as Comparator<String>
In the theory of programming languages this is called nominal typing.
There are a number of generic function types for that purpose (see Table 3–1), and it’s a very good idea to use one of them when you can.
NOTE: Most of the standard functional interfaces have nonabstract methods for producing or combining functions.
And there are default methods and, or, negate for combining predicates.
We want to transform images, applying a Color -> Color function to each pixel.
For example, the brightened image in Figure 3–1 is obtained by calling.
That is a good choice, and there is no need to come up with a ColorTransformer interface.
NOTE: This method uses the Color and Image classes from JavaFX, not from java.awt.
In this section, we consider methods whose return type is a functional interface.
The brighten method returns a function (or, technically, an instance of a functional interface)
That function can be passed to another method (here, transform) that expects such an interface.
In general, don’t be shy to write methods that produce functions.
This is useful to customize the functions that you pass to methods with functional interfaces.
For example, consider the Arrays.sort method with a Comparator argument.
NOTE: As you will see in Chapter 8, the Comparator class has several methods that yield or modify comparators.
If you have two such transformations, then doing one after the other is also a transformation.
Just run the program in the companion code to see the effect.
That type has a method compose that, for rather depressing reasons that are explored in Exercise 10, is not useful for us.
Now the composed transformation is directly applied to each pixel, and there is no need for an intermediate image.
Generally, when you build a library where users can carry out one effect after another, it is a good idea to give library users the ability to compose these effects.
In the preceding section, you saw how users of an image transformation method can precompose operations to avoid intermediate images.
But why should they have to do that? Another approach is for the library to accumulate all operations and then fuse them.
If you do lazy processing, your API needs to distinguish between intermediate operations, which accumulate the tasks to be done, and terminal operations which deliver the result.
In the image processing example, we can make transform lazy, but then it needs to return another object that is not an Image.
A LatentImage can simply store the original image and a sequence of image operations.
To avoid duplicate transform methods, you can follow the approach of the stream library where an initial stream() operation is required to turn a collection into a.
Since we can’t add a method to the Image class, we can provide a LatentImage constructor or a static factory method.
We can provide a toImage method that applies all operations and returns the result:
CAUTION: In real life, implementing lazy operations is quite a bit harder.
Usually you have a mixture of operations, and not all of them can be applied lazily.
When expressing operations as functional interfaces, the caller gives up control over the processing details.
As long as the operations are applied so that the correct result is achieved, the caller has nothing to complain about.
For example, in image processing we can split the image into multiple strips and process each strip separately.
Here is a simple way of carrying out an image transformation in parallel.
This code operates on Color[][] arrays instead of Image objects because the JavaFX PixelWriter is not threadsafe.
Supporting image operations that combine multiple pixels would be a major challenge.
In general, when you are given an object of a functional interface and you need to invoke it many times, ask yourself whether you can take advantage of concurrency.
When you write a method that accepts lambdas, you need to spend some thought on handling and reporting exceptions that may occur when the lambda expression is executed.
When an exception is thrown in a lambda expression, it is propagated to the caller.
There is nothing special about executing lambda expressions, of course.
They are simply method calls on some object that implements a functional interface.
Often it is appropriate to let the expression bubble up to the caller.
If first.run() throws an exception, then the doInOrder method is terminated, second is never run, and the caller gets to deal with the exception.
If first.run() throws an exception, the thread is terminated, and second is never run.
However, the doInOrderAsync returns right away and does the work in a separate thread, so it is not possible to have the method rethrow the exception.
In this situation, it is a good idea to supply a handler:
Now suppose that first produces a result that is consumed by second.
It is often inconvenient that methods in functional interfaces don’t allow checked exceptions.
A Callable<T> has a method that is declared as T call() throws Exception.
If you want an equivalent for a Consumer or a Function, you have to create it yourself.
You have seen a number of examples where we wrote generic mechanisms, such as the unchecked method of the preceding section.
There are just a couple of issues to keep in mind.
When you implement such a method, the constructor expression is an IntFunction<T[]>, since the size of the array is passed to the constructor.
In this regard, lambdas help you overcome a limitation of generic types.
Unfortunately, in another common situtation lambdas suffer from a different limitation.
To understand the problem, recall the concept of type variance.
Note that staff and tenants are references to the same list.
We say that the type parameter T of List<T> is invariant.
If List was immutable, as it is in a functional programming language, then the problem would disappear, and one could have a covariant list.
That is what is done in languages such as Scala.
However, when generics were invented, Java had very few immutable generic classes, and the language designers instead embraced a different concept: use-site variance, or “wildcards.”
It is okay to write employees into a List<Person>, so you can pass such a list.
In general, reading is covariant (subtypes are okay) and writing is contravariant (supertypes are okay)
It gives each service the choice which variance, if any, is appropriate.
A function type is always contravariant in its arguments and covariant in its return value.
They will only call it with employees, whereas your function can handle any person.
They will expect the function to return a person, and you give them something even better.
In Java, when you declare a generic functional interface, you can’t specify that function arguments are always contravariant and return types always covariant.
The general rule is that you use super for argument types, extends for return types.
If it is willing to consume any object, surely it can consume strings.
Since T is the argument and return type of BinaryOperator, the type does not vary.
In effect, the contravariance and covariance cancel each other out.
For example, consider the doInOrderAsync method of the preceding section.
When you work with generic types, and with functions that yield values from these types, it is useful to supply methods that let you compose these functions—that is, carry out one after another.
In this section, you will see a design pattern for providing such compositions.
How this works exactly depends on the nature of the generic type G.
For example, applying a function f to a List with elements e1,
Applying f to a Future<T> simply means to apply it whenever it is available.
The CompletableFuture class that we will discuss in Chapter 6 has an operation that does just what map should do, but it is called thenApply.
For example, consider getting the web page for a URL.
Now suppose you have a Future<URL>, a URL that will arrive sometime.
Clearly it makes sense to map the function to that Future.
Wait for the URL to arrive, then feed it to the function and wait for the string to arrive.
NOTE: These operations are important in the theory of monads, but you don’t need to know the theory to understand map and flatMap.
The concept of mapping a function is both straightforward and useful, and the point of this section is to make you aware of it.
Don’t evaluate the condition if the logger won’t log the message.
When you use a ReentrantLock, you are required to lock and unlock with the idiom.
Java 1.4 added assertions to the language, with an assert keyword.
We want to put a frame around an image, like this:
Then call it with an appropriate lambda expression to put a 10 pixel gray frame replacing the pixels on the border of an image.
Write a method that generates a Comparator<String> that can be normal or reversed, case-sensitive or case-insensitive, space-sensitive or space-insensitive, or any combination thereof.
Generalize Exercise 5 by writing a static method that yields a ColorTransformer that adds a frame of arbitrary thickness and color to an image.
Look carefully at the return type of the compose method of UnaryOperator<T>
Why is it not appropriate for the transform method? What does that say about.
Then use these methods to add a gray frame to a brightened image.
Return an object of an anonymous class that implements all methods of the Future interface.
JavaFX is now bundled with all supported versions of Oracle’s Java platform.
In this chapter, you will learn the basics of JavaFX development.
If you develop rich client user interface platforms, you will see how to transition from Swing to JavaFX.
If you don’t, skim over the chapter anyway so you can understand the sample applications we use elsewhere when it is convenient to illustrate a concept with a graphical program.
A scene graph is made up of nodes which may contain other nodes.
A scene is displayed on a stage (a top-level window, the surface of an applet, or the full screen)
Some controls (such as buttons) emit events, but most JavaFX events come from property changes.
When you bind a property to another, it is updated when the other one changes.
JavaFX uses layout panes that work similar to layout managers in Swing.
You can use CSS to change the visual appearance of your application.
JavaFX provides some advanced controls out of the box, such as charts, an embedded WebKit browser, and a media player.
In 2007, Sun Microsystems introduced a new technology, called JavaFX, as a competitor to Flash.
It ran on the Java VM but had its own programming language, called JavaFX Script.
The language was optimized for programming animations and fancy effects.
Programmers complained about the need to learn a new language, and they stayed away in droves.
Of course, Flash is now a bad memory, and most user interfaces live in a browser or a mobile device.
This Font constructor makes a font object representing the default font at 100 points.
In JavaFX, you put everything you want to show onto a scene.
There, you can decorate and animate your “actors”—that is, your controls and shapes.
In our program, we won’t do any decorating or animating, but we still need the scene.
That is a top-level window if the program runs on a desktop, or a rectangular area if it runs as an applet.
The stage is passed as a parameter to the start method that you must override in a subclass of the Application class.
NOTE: As you see from this example, no main method is required to launch a JavaFX application.
In previous versions of JavaFX, you were required to include a main method of the form.
As they carry out these actions, the UI reacts and updates itself.
In this case, it sets the text color to red.
However, you shouldn’t listen to the low-level events that the slider emits to indicate those changes.
Instead, the slider has a JavaFX property called value, and the property emits events when it changes.
We will discuss properties in detail in the next section, but here is how you can listen to the property’s events and adjust the font size of the message:
Let’s see how we can implement a property text in a class Greeting.
It has methods for getting and setting the wrapped value and for managing listeners.
As you can see, implementing a JavaFX property requires some boilerplate code, and there is unfortunately no way in Java to generate the code automatically.
But at least you won’t have to worry about managing listeners.
It is not a requirement to declare property getters and setters as final, but the JavaFX designers recommend it.
NOTE: With this pattern, a property object is needed for each property, whether anyone listens to it or not.
Exercise 2 explores a useful optimization for the pattern, creating the property objects lazily.
NOTE: The property classes have methods getValue and setValue in addition to the get and set methods.
In the StringProperty class, get is identical to getValue, and set to setValue.
For example, in an IntegerProperty, getValue returns an Integer, and get returns an int.
Generally, use get and set unless you write generic code that needs to work with properties of any type.
It doesn’t matter much whether you get the new value as a callback parameter or from the property.
And usually, it is not worth worrying about computed properties that happen to stay unchanged even though one of their inputs changed.
CAUTION: It is a bit tricky to use the ChangeListener interface for numeric properties.
Therefore, the type for oldValue and newValue is Number and not Double, so you have to manually unbox:
This is achieved by binding one property to the other:
Under the hood, a change listener is added to the text property of shipping that sets the text property of billing.
If either of the properties changes, the other is updated.
Of course, in many situations, one property depends on another, but the relationship is more complex.
That is, its centerX property should be one half of the width property of the scene.
To achieve this, we need to produce a computed property.
Figure 4–4 The center of this circle is bound to half the width and height of the scene.
All that remains is to bind that computed property to the circle’s centerX property:
With more complex expressions, the static Bindings methods seems a bit easier to read, particularly if you use.
We want to disable the Smaller and Larger buttons when the gauge is too small or large (Figure 4–5)
Table 4–1 lists all operators that the Bindings class provides.
One or both of the arguments implement the Observable interface or one of its subinterfaces.
The ObservableValue interface adds ChangeListener management and a getValue method.
Its subinterfaces provide methods to get the value in the appropriate type.
Figure 4–5 When the gauge reaches either end, a button is disabled.
A Binding knows about all properties on which it depends.
In practice, you don’t need to worry about all of these interfaces.
You combine properties and you get something that you can bind to another property.
If any of the objects is an ObservableValue that changes, the concatenation changes too.
An optional locale, a MessageFormat string, and a sequence of objects that are formatted.
If any of the objects is an ObservableValue that changes, the formatted string changes too.
An ObservableList and an index, or an ObservableMap and a key.
An Object or ObservableValue and a sequence of public property names, yielding the property obj.p1.p2
The conditional value is recomputed whenever an observable value changes.
Exercise 5 suggests a slightly more elegant way of lazily evaluating bindings with lambda expressions.
Another approach is to specify the layout in a declarative language.
For example, web pages are laid out with HTML and CSS.
Now suppose you want more than one button in the South area.
Of course, there is a VBox for laying out controls vertically.
Without it, the label and the buttons would touch the window border.
There is only so much you can achieve with horizontal and vertical boxes.
Think of a GridPane as an equivalent of an HTML table.
You can set the horizontal and vertical alignment of all cells.
Figure 4–9 A GridPane can arrange the controls for this login dialog.
The buttons are in an HBox that spans two rows.
When you add a child to a GridPane, specify its column and row index (in that order; think x- and y-coordinates)
If a child spans multiple columns or rows, specify the spans after the positions.
For example, the button panel spans two columns and one row:
To set the horizontal alignment of a child, use the static setHalignment method, and pass the child reference and a constant LEFT, CENTER, or RIGHT from the HPos enumeration.
Similarly, for vertical alignment, call setValignment and use TOP, CENTER, or BOTTOM from the VPos enumeration.
NOTE: These static calls look rather inelegant in Java code, but they make sense in the FXML markup language—see the next section.
CAUTION: Do not center the HBox with the buttons inside the grid.
That box has expanded to the full horizontal size, and centering will not change its position.
You will also want to provide some spacing around the rows and columns and some padding around the table:
TIP: For debugging, it can be useful to see the cell boundaries (see Figure 4–10)
Figure 4–10 Use visible grid lines when debugging a GridPane.
Lays out children in a grid, giving them all the same size, similar to the Swing GridLayout.
Children can be positioned in absolute positions, or relative to pane’s boundaries.
Can be useful for decorating components, such as stacking a button over a colored rectangle.
NOTE: In this section, we built up user interfaces by manually nesting panes and controls.
The markup language that JavaFX uses to describe layouts is called FXML.
I discuss it in some detail because the concepts are interesting beyond the needs of JavaFX, and the implementation is fairly general.
Here is the FXML markup for the login dialog of the preceding section:
When an attribute starts with a class name and a static method, that method is invoked.
When a property value is too complex to express as a string, one uses nested elements instead of attributes.
In the controller’s initialize method, you wire up the binders and event handlers.
Any class can be the controller, even the FX application itself.
For example, here is a controller for our login dialog:
In the root element, you also need to declare the controller class, using the fx:controller attribute:
NOTE: If your controller doesn’t have a default constructor (perhaps, because it is being initialized with a reference to a business service), you can set it programmatically:
CAUTION: If you set the controller programmatically, really use the code from the preceding note.
The following code will compile, but it will invoke the static FXMLLoader.load method, ignoring the constructed loader:
JavaFX lets you change the visual appearance of the user interface with CSS, which is usually more convenient than supplying FXML attributes or calling Java methods.
You can load a CSS style sheet programmatically and have it applied to a scene graph:
In the style sheet, you can reference any controls that have an ID.
For example, here is how you can control the appearance of a GridPane.
Using CSS is nicer than cluttering up the code with layout minutiae.
Of course CSS can be used both for good and for evil (see Figure 4–11), and I hope you will resist the temptation to apply gratuitous background textures to your login dialogs.
Instead of styling by individual IDs, you can use style classes.
Every JavaFX control and shape class belongs to a CSS class whose name is the decapitalized Java class name.
Here is how you can change the font for all labels to Comic Sans:
Then you can specify most styling in CSS, and use FXML only for layout.
Unfortunately, you can’t completely remove all styling from the FXML.
For example, there is currently no way to specify grid cell alignment in CSS.
NOTE: You can also apply a CSS style programmatically, such as.
That can be handy for debugging, but in general, it seems better to use an external stylesheet.
I thought you’d enjoy some useful tips on how to bring these animations to the world of business applications.
Figure 4–12 shows an application where the Yes button increases in size while the No button fades into the background and the Maybe button rotates.
The node can be any node in a scene graph, such as a circle in an animation of soap bubbles or the ever more enticing Yes button in our example.
Now the node will get bigger, then smaller, then bigger again, and so on.
Here is how the No button fades into the background:
The following code animates the rotation of the Maybe button:
If you need to animate multiple nodes, you can place them into a Group node and animate that.
When you need to create this kind of behavior, the JavaFX classes are a joy to work with.
If you need a drop shadow for a spiffy caption, make a DropShadow effect and set it as the effect property of a node.
To set a glow or a blur effect is just as simple:
Admittedly, the glow effect looks a bit cheesy and the blur effect doesn’t seem to have many applications in the world of business, but it is impressive how easy it is to produce these effects.
Of course, JavaFX has combo boxes, tab panes, trees, and tables, just like Swing does, as well as a few user interface controls that Swing never got, such as a date picker and an accordion.
It would take an entire book to describe these in detail.
In this section, I want to dispel any remaining Swing nostalgia by showing you three fancy controls that are far beyond what Swing had to offer.
Figure 4–14 shows one of many charts that you can make with JavaFX, out of the box, without having to install any third-party libraries.
Altogether, there are half a dozen chart types that you can use and customize.
In Swing, you could show HTML in a JEditorPane, but the rendering was poor for most real-world HTML.
In fact, it is so hard that most browsers are built on top of the open source WebKit engine.
A WebView displays an embedded native WebKit window (see Figure 4–15)
NOTE: WebView does not support any plugins, so you cannot use it to show Flash animations or PDF documents.
A Java Media Framework was available as an optional download, but it did not get much love from the developers.
Of course, implementing audio and video playback is even harder than writing a browser.
Therefore, JavaFX leverages an existing toolkit, the open source GStreamer framework.
To play a video, construct a Media object from an URL string, construct a MediaPlayer to play it, and a MediaView to show the player:
That brings us to the end of this quick tour through JavaFX.
It has a few rough edges, mostly due to a hurried transformation from the original scripting language.
But it is certainly no harder to use than Swing, and it has many more useful and attractive controls than Swing ever had.
Find out how to set the border of a control without using CSS.
Animate a circle, representing a planet, so it travels along an elliptical orbit.
Using the web viewer, implement a browser with a URL bar and a back button.
An Instant is a point on the time line (similar to a Date)
In Java time, each day has exactly 86,400 seconds (i.e., no leap seconds)
ZonedDateTime is a point in time in a given time zone (similar to GregorianCalendar)
Use a Period, not a Duration, when advancing zoned time, in order to account for daylight savings time changes.
In Java, an Instant represents a point on the time line.
This is the same convention used in the Unix/POSIX time.
Starting from that origin, time is measured in 86,400 seconds per day, forwards and backwards, in nanosecond precision.
The Instant values go back as far as a billion years (Instant.MIN)
That’s not quite enough to express the age of the universe (around 13.5 billion years), but it should be enough for all practical purposes.
After all, a billion years ago, the earth was covered in ice and populated by microsocopic ancestors of today’s plants and animals.
A Duration is the amount of time between two instants.
You can get the length of a Duration in conventional units by calling toNanos, toMillis, toSeconds, toMinutes, toHours, or toDays.
Durations require more than a long value for their internal storage.
The number of seconds is stored in a long, and the number of nanoseconds in an additional int.
If you want to make computations in nanosecond accuracy, and you actually need the entire range of a Duration, then you can use one of the methods in Table 5–1
Otherwise, you can just call toNanos and do your calculations with long values.
Adds a duration to, or subtracts a duration from, this Instant or Duration.
Adds a number of the given time units to this Instant or Duration.
Subtracts a number of the given time units from this Instant or Duration.
Returns a duration that is obtained by multiplying or dividing this Duration by a given long, or by –1
For example, if you want to check whether an algorithm is at least ten times faster than another, you can compute.
NOTE: The Instant and Duration classes are immutable, and all methods, such as multipliedBy or minus, return a new instance.
Now let us turn from absolute time to human time.
There are two kinds of human time in the new Java API, local date/time and zoned time.
Local date/time has a date and/or time of day, but no associated time zone information.
Since that date has neither a time of day nor time zone information, it does not correspond to a precise instant of time.
For that reason, the API designers recommend that you do not use zoned time unless you really want to represent absolute time instances.
Birthdays, holidays, schedule times, and so on are usually best represented as local dates or times.
A LocalDate is a date, with a year, month, and day of the month.
To construct one, you can use the now or of static methods:
Table 5–2 shows the most useful methods for working with LocalDate objects.
These static methods construct a LocalDate, either from the current time or from a given year, month, and day.
Adds a number of days, weeks, months, or years to this LocalDate.
Subtracts a number of days, weeks, months, or years from this LocalDate.
Returns a new LocalDate with the day of month, day of year, month, or year changed to the given value.
Gets the day of the week, returning a value of the DayOfWeek enumeration.
Gets the Period, or the number of the given ChronoUnits, between two dates.
The algorithm is applied for all past years, even though that is historically inaccurate.
For example, Programmer’s Day is the 256th day of the year.
Recall that the difference between two time instants is a Duration.
The equivalent for local dates is a Period, which expresses a number of elapsed years, months, or days.
The until method yields the difference between two local dates.
CAUTION: Some methods in Table 5–2 could potentially create nonexistent dates.
Instead of throwing an exception, these methods return the last valid day of the month.
The getDayOfWeek yields the weekday, as a value of the DayOfWeek enumeration.
The DayOfWeek enumeration has convenience methods plus and minus to compute weekdays modulo 7
NOTE: The weekend days actually come at the end of the week.
As always, the with method returns a new LocalDate object without modifying the original.
You can also roll your own adjuster by implementing the TemporalAdjuster interface.
Note that the parameter of the lambda expression has type Temporal, and it must be cast to LocalDate.
Next or previous date that falls on the given weekday.
Next or previous date that falls on the given weekday, starting from the given date.
A LocalTime represents a time of day, such as 15:30:00
You can create an instance with the now or of methods:
The plus and minus operations wrap around a 24-hour day.
These static methods construct a LocalTime, either from the current time, or from the given hours, minutes, and optionally, seconds and nanoseconds.
Adds a number of hours, minutes, seconds, or nanoseconds to this LocalTime.
Subtracts a number of hours, minutes, seconds, or nanoseconds from this LocalTime.
Returns a new LocalTime with the hour, minute, second, or nanosecond changed to the given value.
Gets the hour, minute, second, or nanosecond of this LocalTime.
Returns the number of seconds or nanoseconds between midnight and this LocalTime.
The bulk of the updates deals with the changing rules for daylight savings time.
Given a time zone ID, the static method ZoneId.of(id) yields a ZoneId object.
Many of the methods of ZonedDateTime are the same as those of LocalDateTime (see Table 5–5)
Most are straightforward, but daylight savings time introduces some complications.
When daylight savings time starts, clocks advance by an hour.
Conversely, when daylight time ends, clocks are set back by an hour, and there are two instants with the same local time! When you construct a time within that span, you get the earlier of the two.
An hour later, the time has the same hours and minutes, but the zone offset has changed.
You also need to pay attention when adjusting a date across daylight savings time boundaries.
For example, if you set a meeting for next week, don’t add a duration of seven days:
These static methods construct a ZonedDateTime from the current time, or from a year, month, day, hour, minute, second, nanosecond (or a LocalDate and LocalTime), and ZoneId, or from an Instant and ZoneId.
Returns a new ZonedDateTime, with one temporal unit changed to the given value.
Returns a new ZonedDateTime in the given time zone, either representing the same instant or the same local time.
Gets the day of the week, returning a value of the DayOfWeek enumeration.
Gets the hour, minute, second, or nanosecond of this ZonedDateTime.
Yields the local date or local time, or the corresponding instant.
The DateTimeFormatter class provides three kinds of formatters to print a date/time value:
To use one of the standard formatters, simply call its format method:
To change to a different locale, simply use the withLocale method.
Finally, you can roll your own date format by specifying a pattern.
To parse a date/time value from a string, use one of the static parse methods.
In Java 8, that class has two added methods: the toInstant method that converts a Date to an Instant, and the static from method that converts in the other direction.
The toZonedDateTime method converts a GregorianCalendar to a ZonedDateTime, and the static from method does the opposite conversion.
Another set of conversions is available for the date and time classes in the java.sql package.
Write an equivalent of the Unix cal program that displays a calendar for a month.
Write a program that prints how many days you have been alive.
Read a set of appointments in different time zones and alert the user which ones are due within the next hour in local time.
Early Java releases had minimal support for concurrency, and programmers busily created code with deadlocks and race conditions.
That package gives us threadsafe collections and thread pools, allowing many application programmers to write concurrent programs without using locks or starting threads.
In this chapter, we focus squarely on the needs of the application programmer.
Updating atomic variables has become simpler with the updateAndGet/ accumulateAndGet methods.
Updating entries in a ConcurrentHashMap has become simpler with the compute and merge methods.
ConcurrentHashMap now has bulk operations search, reduce, forEach, with variants operating on keys, values, keys and values, and entries.
A set view lets you use a ConcurrentHashMap as a Set.
For example, you can safely generate a sequence of numbers like this:
The incrementAndGet method atomically increments the AtomicLong and returns the post-increment value.
That is, the operations of getting the value, adding 1, setting it, and producing the new value cannot be interrupted.
It is guaranteed that the correct value is computed and returned, even if multiple threads access the same instance concurrently.
There are methods for atomically setting, adding, and subtracting values, but if you want to make a more complex update, you have to use the compareAndSet method.
For example, suppose you want to keep track of the largest value that is observed by different threads.
Instead, compute the new value and use compareAndSet in a loop:
If another thread is also updating largest, it is possible that it has beat this thread to it.
Then compareAndSet will return false without setting the new value.
In that case, the loop tries again, reading the updated value and trying to change it.
Eventually, it will succeed replacing the existing value with the new one.
This sounds tedious, but the compareAndSet method maps to a processor operation that is faster than using a lock.
In Java 8, you don’t have to write the loop boilerplate any more.
Instead, you provide a lambda expression for updating the variable, and the update is done for you.
The accumulateAndGet method takes a binary operator that is used to combine the atomic value and the supplied argument.
There are also methods getAndUpdate and getAndAccumulate that return the old value.
If you anticipate high contention, you should simply use a LongAdder instead of an AtomicLong.
Call increment to increment a counter or add to add a quantity, and sum to retrieve the total.
The LongAccumulator generalizes this idea to an arbitrary accumulation operation.
In the constructor, you provide the operation, as well as its neutral element.
Each variable is initialized with the neutral element (0 in our example)
There are also DoubleAdder and DoubleAccumulator that work in the same way, except with double values.
NOTE: A hash map keeps all entries with the same hash code in the same “bucket.” Some applications use poor hash functions, and as a result all entries end up in a small number of buckets, severely degrading performance.
Even generally reasonable hash functions, such as that of the String class, can be problematic.
For example, an attacker can slow down a program by crafting a large number of strings that hash to the same value.
As of Java 8, the concurrent hash map organizes the buckets as trees, not lists, when the key type implements Comparable, guaranteeing O(log(n)) performance.
The original version of ConcurrentHashMap only had a few methods for atomic updates, which made for somewhat awkward programming.
Suppose we want to count how often certain features are observed.
As a simple example, suppose multiple threads encounter words, and we want to count their frequencies.
Another thread might be updating the exact same count at the same time.
NOTE: Some programmers are surprised that a supposedly threadsafe data structure permits operations that are not threadsafe.
If multiple threads modify a plain HashMap, they can destroy the internal structure (an array of linked lists)
Some of the links may go missing, or even go in circles, rendering the data structure unusable.
In the example above, the code for get and put will never corrupt the data structure.
But, since the sequence of operations is not atomic, the result is not predictable.
One remedy is to use the replace operation, replacing a known old value with a new one, just as you have seen in the preceding section:
Java 8 provides methods that make atomic updates more convenient.
The compute method is called with a key and a function to compute the new value.
That function receives the key and the associated value, or null if there is none, and it computes the new value.
For example, here is how we can update a map of integer counters:
There are many methods that use a null value as an indication that a given key is not present in the map.
There are also variants computeIfPresent and computeIfAbsent that only compute a new value when there is already an old one, or when there isn’t yet one.
That is almost like the call to putIfAbsent that you saw before, but the LongAdder constructor is only called when a new counter is actually needed.
See Exercise 5 for another compelling application of the merge method.
NOTE: If the function that is passed to compute or merge returns null, the existing entry is removed from the map.
CAUTION: When you use compute or merge, keep in mind that the function that you supply should not do a lot of work.
While that function runs, some other updates to the map may be blocked.
Of course, that function should also not update other parts of the map.
Then the search terminates and the function’s result is returned.
With each of the operations, you need to specify a parallelism threshold.
If the map contains more elements than the threshold, the bulk operation is parallelized.
If you want the bulk operation to run in a single thread, use a threshold of Long.MAX_VALUE.
If you want the maximum number of threads to be made available for the bulk operation, use a threshold of 1
The reduce operations combine their inputs with an accumulation function.
For example, here is how you can compute the sum of all values.
As with forEach, you can also supply a transformer function.
CAUTION: These specializations act differently from the object versions where there is only one element to be considered.
Suppose you want a large, threadsafe set instead of a map.
There is no ConcurrentHashSet class, and you know better than trying to create your own.
Of course, you can use a ConcurrentHashMap with bogus values, but then you get a map, not a set, and you can’t apply operations of the Set interface.
All map values are Boolean.TRUE, but you don’t actually care since you just use it as a set.)
Of course, if you have an existing map, the keySet method yields the set of keys.
If you remove the set’s elements, the keys (and their values) are removed from the map.
But it doesn’t make sense to add elements to the key set, because there would be no corresponding values to add.
Java 8 adds a second keySet method to ConcurrentHashMap, with a default value, to be used when adding elements to the set:
If "Java" wasn’t already present in words, it now has a value of one.
The Arrays class now has a number of parallelized operations.
With all methods, you can supply the bounds of a range, such as.
Clearly, one can make this computation in parallel in separate regions of the array.
In the next step, update the indicated elements by multiplying them with elements that are one or two positions below:
In the following sections, you will see how completable futures make it possible to compose asynchronous operations.
The method reads a web page in a separate thread, which is going to take a while.
Now suppose we want to extract all URLs from the page in order to build a web crawler.
How can we apply that method to the future object? Unfortunately, there is only one way.
First, call the get method on the future to get its value when it becomes available.
We are really no better off than with a method public String readPage(URL url) that blocks until the result is available.
Unlike a plain Future, a CompleteableFuture has a method thenApply to which you can pass the post-processing function.
With completable futures, you just specify what you want to have done, and in which order.
It won’t all happen right away, of course, but what is important is that all the code is in one place.
Start out by generating a CompletableFuture, usually with the static method supplyAsync.
That method requires a Supplier<T>, that is, a function with no parameters yielding a T.
In our example, we can start out the pipeline with.
This is useful if you simply want to schedule one action after another, without passing data between them.
One of them runs the provided action on the common ForkJoinPool.
Next, you can call thenApply or thenApplyAsync to run another action, either in the same thread or another.
For example, here is a two-stage pipeline for reading and processing the web page:
Eventually, you’ll be done, and you will need to save the results somewhere.
The thenAccept method takes a Consumer—that is, a function with return type void.
The last step in the pipeline simply deposits the result where it belongs.
NOTE: You don’t explicitly start the computation.The static supplyAsync method starts it automatically, and the other methods cause it to be continued.
That sounds rather abstract, but it can be quite natural.
Consider the action of reading a web page from a given URL.
Invoke the function on the result and execute the returned future.
Now, suppose we have another method that gets the URL from user input, perhaps from a dialog that won’t reveal the answer until the user has clicked the OK button.
The third method in Table 6–1 focuses on a different aspect that I have ignored so far: failure.
When an exception is thrown in a CompletableFuture, it is captured and wrapped in an unchecked ExecutionException when the get method is called.
In order to handle an exception, use the handle method.
The supplied function is called with the result (or null if none) and the exception (or null if none), and it gets to make sense of the situation.
The remaining methods have void result and are usually used at the end of a processing pipeline.
Now let us turn to methods that combine multiple futures (see Table 6–2)
Execute both and combine the results with the given function.
When a result is available from one or the other, pass it to the given function.
Complete with void result after any of the given futures completes.
NOTE: Technically speaking, the methods in this section accept parameters of type CompletionStage, not CompletableFuture.
That is an interface type with almost forty abstract methods, currently implemented only by CompletableFuture.
Most programmers wouldn’t casually implement that interface, so I don’t dwell on the distinction.
Use a LongAccumulator to compute the maximum or minimum of the accumulated elements.
Nashorn is a pleasant environment for experimenting with the Java API.
You can run JavaScript through the jjs interpreter, or from Java via the scripting API.
Beware of intricacies in the conversion of strings and numbers between JavaScript and Java.
JavaScript offers a convenient syntax for working with Java lists and maps, as well as JavaBeans properties.
You can convert JavaScript functions to Java interfaces in a way that is very similar to using lambda expressions.
You can extend Java classes and implement Java interfaces in JavaScript, but there are limitations.
Nashorn has good support for writing shell scripts in JavaScript.
You can write JavaFX programs in JavaScript, but the integration is not as good as it might be.
You get what’s called a “read-eval-print” loop, or REPL, in the world of Lisp, Scala, and so on.
NOTE: As a reminder, in JavaScript, strings can be delimited by '...' or "..."
In this chapter, I will use single quotes for JavaScript strings to give you a visual clue that the code is JavaScript, not Java.
Now, when you type contents, you see the contents of the web page.
Running a Nashorn script from Java uses the script engine mechanism that has been introduced in Java 6
You can use that mechanism to execute scripts in any.
There are also script engines for languages that run outside the JVM, such as PHP or Scheme.
To run a script, you need to get a ScriptEngine object.
If the engine is registered, you can simply get it by name.
To make a Java object available to your scripts, use the put method of the ScriptEngine interface.
For example, you can make a JavaFX stage visible, so that you can populate it using JavaScript code:
Instead of putting variables into the global scope, you can collect them in an object of type Bindings and pass that object to the eval method:
This is useful if a set of bindings should not persist for future calls to the eval method.
In the preceding section, you saw how the script engine can make Java objects accessible to JavaScript.
Nashorn supports a convenient property syntax for getters and setters.
If the expression stage.title occurs to the left of the = operator, it is translated to an invocation of the setTitle method.
You can even use the JavaScript bracket notation to access properties:
Note that the argument of the [] operator is a string.
In this context, that isn’t useful, but you can call stage[str] with a string variable and thereby access arbitrary properties.
NOTE: In JavaScript, semicolons at the end of a line are optional.
Many JavaScript programmers put them in anyway, but in this chapter, I omit them so that you can easily distinguish between Java and JavaScript code snippets.
There can be only one method with a given name, and it can have any number of parameters of any type.
Nashorn attempts to pick the correct Java method, following the number and types of the parameters.
In almost all cases, there is only one Java method that matches the supplied parameters.
If there is not, you can manually pick the correct method with the following rather strange syntax:
Here, we specify the remove(Object) method that removes the Integer object 1 from the list.
There is also a remove(int) method that removes the object at position 1.)
When you want to construct objects in JavaScript (as opposed to having them handed to you from the script engine), you need to know how to access Java packages.
There are global objects java, javax, javafx, com, org, and edu that yield package and class objects via the dot notation.
Once you have a class object, you can call static methods:
To construct an object, pass the class object to the JavaScript new operator.
CAUTION: If you use Java.type with new, you need an extra set of parentheses:
If you need to specify an inner class, you can do so with the dot notation:
Alternatively, if you use Java.type, use a $, like the JVM does:
In this case, the JavaScript string is converted to a Java string.
In general, a JavaScript string is converted to a Java string whenever it is passed to a Java method.
Also note that any JavaScript object is converted to a string when it is passed to a Java method with a String parameter.
The Paths.get method wants a String, and it gets one, even though it makes no sense in this situation.
It follows the general JavaScript behavior to turn anything into a string when a string is expected.
It is features such as this one that make programming in a dynamically typed language an exciting adventure.
Its Number type is the same as the Java double type.
When a number is passed to Java code that expects an int or long, any fractional part is silently removed.
Then call the new operator and supply the length of the array:
To iterate through all values of the names array, use.
This is the equivalent of the enhanced for loop in Java.
If you need the index values, use the following loop instead:
CAUTION: Even though this loop looks just like the enhanced for loop in Java, it visits the index values.
When you supply a JavaScript array where a Java array is expected, Nashorn will carry out the conversion.
Given a JavaScript array, use the Java.to method to obtain the equivalent Java array:
Conversely, use Java.from to turn a Java array into a JavaScript array:
You can use the bracket operator with any Java List to invoke the get and set methods:
To visit all elements in the map, you can use the JavaScript for each loops:
If you want to process keys and values together, simply iterate over the entry set:
NOTE: The for each loop works for any Java class that implements the Iterable interface.
Syntactically, such an anonymous function is very similar to a Java lambda expression.
Instead of an arrow after the parameter list, you have the keyword function.
You can use an anonymous function as a functional interface argument of a Java method, just like you could use a lambda expression in Java.
Nashorn supports shorthand for functions whose body is a single expression.
For such functions, you can omit the braces and the return keyword:
Again, note the similarity with a Java lambda expression (a, b) -> Integer.
To extend a Java class, or to implement a Java interface, use the Java.extend function.
Supply the class object of the superclass or interface and a JavaScript object with the methods that you want to override or implement.
NOTE: When calling Java.extend, you can specify any number of superinterfaces as well as a superclass.
Place all class objects before the object with the implemented methods.
If the supertype is abstract and has only one abstract method, you don’t even have to give the method name.
Instead, pass the function as if it was a constructor parameter:
If you want instance variables in your subclass, add them to the JavaScript object.
For example, here is an iterator that produces ten random numbers:
Note that the JavaScript methods next and hasNext refer to the instance variable as this.count.
When a Java method throws an exception, you can catch it in JavaScript in the usual way:
Note that there is only one catch clause, unlike in Java where you can catch expressions by type.
That, too, is in the spirit of dynamic languages where all type inquiry happens at runtime.
Now you can execute shell commands by including them in backquotes, for example.
By convention, an exit code of zero means success, and non-zero codes describe error conditions.)
You can also capture the standard output by assigning the result of the backquoted command to a variable:
If you want to supply standard input for a command, use.
For example, this command passes the output of ls -al to grep -v class:
As with the bash shell, string interpolation does not work inside singly quoted strings.
Note that the name and location of the application are interpolated.
String interpolation and here documents are only available in scripting mode.
When a script starts with a shebang, scripting mode is automatically activated.
With jjs (but not with jrunscript), you can use $ARG instead of arguments.
If you use that variable with string interpolation, you need two dollar signs:
In your script, you can obtain the shell’s environment variables through the ENV object:
In scripting mode, you can prompt the user for input with the readLine function:
Simply put the instructions that you would normally put into the start method of the Application subclass into the script.
You don’t even have to call show on the Stage object—that is done for you.
All the boilerplate is gone, and you have the convenient property notation, that is,
NOTE: If you need to override the init or stop lifecycle methods of the Application class in addition to start, include the methods that you need in your script, at the top level.
With the -fx option, you then get a subclass of Application with the script methods.
That’s more heavyweight than the Java equivalent—not something one wants to see in a lightweight scripting language.
Compatibility with scripting languages was perhaps not their major concern, particularly since they had just abandoned another scripting language.
And there is another sad aspect about the JavaFX support in Nashorn.
Recall how in the olden days of JavaFX Script, it was easy to describe the layout of a scene like this:
Construct a nonliteral JavaScript string by extracting a substring from another string, and invoke the getClass method.
Write a JavaScript function that is a factory for such objects, so that one can generate any number of logging array lists.
Write a script that prints the values of all environment variables.
Write a JavaFX program in JavaScript that reads data from a source of your choice and renders a pie chart.
Use Math.floorMod(x, n) instead of x % n if x might be negative.
There are new mutators in Collection (removeIf) and List (replaceAll, sort)
Files.list lazily lists the entries of a directory, and Files.walk traverses them recursively.
Annotations can now be repeated and applied to type uses.
Convenient support for null parameter checks can be found in the Objects class.
A common task is to combine several strings, separating them with a delimiter such as ", " or "/"
Think of join as the opposite of the String.split instance method.
This is the only method added to the String class in Java 8
All eight primitive type wrappers now have static hashCode methods that return the same hash code as the instance method, but without the need for boxing.
In general, with unsigned numbers, you lose the negative values and get twice the range of positive values.
The Byte and Short classes have methods toUnsignedInt, and Byte, Short, and Integer have methods toUnsignedLong.
You compute the position of the hour hand of a clock.
But what if adjustment is negative? Then you might get a negative number.
NOTE: Unfortunately, floorMod gives negative results for negative divisors, but that situation doesn’t often occur in practice.
NOTE: All methods described in this section also exist in the StrictMath class.
The big change for the collections library is, of course, support for streams which you have seen in Chapter 2
The List interface has a replaceAll method, which is an in-place equivalent of map, and a sort method that is obviously useful.
The Map interface has a number of methods that are particularly important for maps accessed concurrently.
The Iterator interface has a forEachRemaining method that exhausts the iterator by feeding the remaining iterator elements to a function.
Finally, the BitSet class has a method that yields all members of the set as a stream of int values.
The Comparator interface has a number of useful new methods, taking advantage of the fact that interfaces can now have concrete methods.
The function is applied to the objects to be compared, and the comparison is then made on the returned keys.
For example, suppose you have an array of Person objects.
You can chain comparators with the thenComparing method for breaking ties.
If two people have the same last name, then the second comparator is used.
You can specify a comparator to be used for the keys that the comparing and thenComparing methods extract.
For example, here we sort people by the length of their names:
Moreover, both the comparing and thenComparing methods have variants that avoid boxing of int, long, or double values.
An easier way of producing the preceding operation would be.
If your key function can return null, you will like the nullsFirst and nullsLast adapters.
These static methods take an existing comparator and modify it so that it doesn’t throw an exception when encountering null values but ranks them as smaller or larger than regular values.
For example, suppose getMiddleName returns a null when a person has no middle name.
The nullsFirst method needs a comparator—in this case, one that compares two strings.
The naturalOrder method makes a comparator for any class implementing Comparable.
Here is the complete call for sorting by potentially null middle names.
The static reverseOrder method gives the reverse of the natural order.
A checkedQueue wrapper, that has apparently been overlooked all these years, has also been added.
As a reminder, the checked wrappers have a Class parameter and throw a ClassCastException when you insert an element of the wrong type.
Suppose you declare a Queue<Path>, and somewhere in your code there is a ClassCastException trying to cast a String to a Path.
This could have happened because you passed the queue to a method void getMoreWork(Queue q) with no type parameter.
Because the generic type was suppressed, the compiler could not detect that.) Much later, you took out that String, thinking it was a Path, and the error manifested itself.
If you temporarily replace the queue with a CheckedQueue(new LinkedList<Path>, Path.class), then every insertion is checked at runtime, and you can locate the faulty insertion code.
When a stream spawns another, the close methods are chained.
This subterfuge is necessary because stream operations are not declared to throw any checked exceptions.)
With this method, closing the resulting stream does not close the reader.
For that reason, you must place the BufferedReader object, and not the stream object, into the header of the try statement.
NOTE: Almost ten years ago, Java 5 introduced the Scanner class to replace the cumbersome BufferedReader.
It is unfortunate that the Java 8 API designers decided to add the lines method to BufferedReader but not to Scanner.
Since reading a directory involves a system resource that needs to be closed, you should use a try block:
To process all descendants of a directory, use the Files.walk method instead.
It is used for binary data in email messages and “basic” HTTP authentication.
That class has methods to encode an array of bytes or a NIO ByteBuffer.
Alternatively, you can “wrap” an output stream, so that all data sent to it is automatically encoded.
Soon, more and more uses for annotations emerged, leading to situations where one would have liked to repeat the same annotation.
For example, to denote a composite key in a database, you need to specify multiple columns:
Since that wasn’t possible, the annotations were packed into a container annotation, like this:
That’s pretty ugly, and it is no longer necessary in Java 8
As an annotation user, that is all you need to know.
If your framework provider has enabled repeated annotations, you can just use them.
For a framework implementor, the story is not quite as simple.
To solve this problem, the inventor of a repeatable annotation must.
This is because the element is actually annotated with the container annotation TestCases.
Prior to Java 8, an annotation was applied to a declaration.
A declaration is a part of code that introduces a new name.
Here are a couple of examples, with the declared name in bold:
This can be useful in combination with tools that check for common programming errors.
Now suppose you annotated variables that you never want to be null as @NonNull.
Of course, the tool should detect any statement that might cause names to become null:
It sounds tedious to put such annotations everywhere, but in practice, some of the drudgery can be avoided by simple heuristics.
The null checker in the Checker Framework (http://types.cs.washington.edu/checker-framework) assumes that any nonlocal variables are implicitly @NonNull, but that local variables might be null unless the code shows otherwise.
If a method may return a null, it needs to be annotated as @Nullable.
That may not be any worse than documenting the nullness behavior.
In the preceding example, the names variable was declared as @NonNull.
But how can one express that the list elements should be non-null? Logically, that would be.
It is this kind of annotation that was not possible before Java 8 but has now become legal.
There are currently no standard annotations that are meaningful for type use.All examples in this section come from the Checker Framework or from the author’s imagination.
With superclasses and implemented interfaces: class Image implements @Rectangular Shape.
They have no effect on the behavior of a cast or an instanceof check.)
There are a few type positions that cannot be annotated:
You can supply a separate annotation, but it would apply to the name declaration.)
The practical use of these annotations hinges on the viability of the tools.
In almost all cases, the parameter names are the same as the annotation arguments, or they can be made to be the same.
If the annotation processor could read the parameter names, then one could simply write.
The Objects class has static predicate methods isNull and nonNull that can be useful for streams.
The message string is formatted even when the logging level is such that it would never be used.
Now the lambda expression is only evaluated at the FINEST logging level, when the cost of the additional lambda invocation is presumably the least of one’s problems.
The requireNonNull of the Objects class (which is described in Chapter 9) also has a version that computes the message string lazily.
In the common case that directions is not null, this.directions is simply set to directions.
In Java 8, you can use the names in the start, end, and group methods of Matcher:
The Pattern class has a splitAsStream method that splits a CharSequence along a regular expression:
It used to be that locales were simple, consisting of location, language, and (for a few oddball cases, such as the Norwegians who have two spelling systems) variants.
Nynorsk spelling of Norwegian is now expressed with a different language code, nn, instead of a variant NY of the language no.
Given a list of weighted language ranges and a collection of locales, the filter method produces a list of matching locales, in descending order of match quality:
In this case, the best match is de, which isn’t very interesting.
But if locales contains a more restricted set of locales, such as those in which a document was available, then this mechanism can be useful.
The Date, Time, and Timestamp classes in the java.sql package have methods to convert from and to their java.time analogs LocalDate, LocalTime, and LocalDateTime.
Euclid’s algorithm (which is over two thousand years old) computes the greatest common divisor of two numbers as gcd(a, b) = a if b is zero, and gcd(b, rem(a, b)) otherwise, where rem is the remainder.
Clearly, the gcd should not be negative, even if a or b are (since its negation would then be a greater divisor)
Implement the algorithm with %, floorMod, and a rem function that produces the mathematical (non-negative) remainder.
Which of the three gives you the least hassle with negative values?
Do the same with a lambda expression, but without using streams.
Write methods that turn a Scanner into a stream of words, lines, integers, or double values.
Implement the TestCase annotation and a program that loads a class with such annotations and invokes the annotated methods, checking whether they yield the expected values.
Repeat the preceding exercise, but build a source-level annotation processor emitting a program that, when executed, runs the tests in its main method.
Use a regular expression with named capturing groups to parse a line containing a city, state, and zip code.
In this chapter, I will write about some of the library changes that haven’t been discussed so much and that I have found far more useful in daily work than switching on strings or binary literals.
I cover one language change that is very useful in daily work—the try-with-resources statement.
Use the try-with-resources statement with any object that implements AutoCloseable.
The try-with-resources statement rethrows the primary exception if closing a resource throws another exception.
You can catch unrelated exceptions with a single catch clause.
When comparing numbers in a comparator, use the static compare method.
Applets and Java Web Start applications continue to be supported in corporate environments, but they may no longer be viable for home users.
Everyone’s favorite trivial change: "+1" can now be converted to an integer without throwing an exception.
Changes in ProcessBuilder make it simple to redirect standard input, output, and error streams.
Java 7 provides a useful shortcut to the code pattern.
It is a subinterface of AutoCloseable, also with a single close method, but that method is declared to throw an IOException.
In its simplest variant, the try-with-resources statement has the form.
When the block exits normally, or when there is an exception, the in.close() method is called, exactly as if you had used a finally block.
NOTE: A try-with-resources statement can itself have catch clauses and a finally clause.
In practice, it’s probably not a good idea to pile so much onto a single try statement.
Whenever you work with input or output, there is an awkward problem with closing the resource after an exception.
Suppose an IOException occurs and then, when closing the resource, the call to close throws another exception.
Which exception will actually be caught? In Java, an exception thrown in a finally clause discards the previous exception.
After all, the user is likely to be much more interested in the original exception.
When an exception is thrown in a close method of one of the AutoCloseable objects, the original exception gets rethrown, and the exceptions from calling close are caught and attached as “suppressed” exceptions.
This is a very useful mechanism that would be tedious to implement by hand (see Exercise 2)
When you catch the primary exception, you can retrieve those secondary exceptions by calling the getSuppressed method:
If you want to implement such a mechanism yourself in the (hopefully rare) situation when you can’t use the try-with-resources statement, call.
NOTE: The classes Throwable, Exception, RuntimeException, and Error have constructors with an option for disabling suppressed exceptions and for disabling stack traces.
When suppressed exceptions are disabled, calling addSuppressed has no effect, and getSuppressed returns a zero-length array.
When stack traces are disabled, calls to fillInStackTrace have no effect, and getStackTrace returns a zero-length array.
This can be useful for VM errors when memory is low, or for programming languages on the VM that use exceptions to break out of nested method calls.
CAUTION: Detecting secondary exceptions only works when it isn’t actively sabotaged.
In particular, if you use a Scanner, and if input fails, and then closing fails, the Scanner class catches the input exception, closes the resource and catches that exception, and then throws an entirely different exception, without linking the suppressed exceptions.
This feature is only needed when catching exception types that are not subclasses of one another.
Of course, you can use the feature described in the preceding section and combine them in a single clause:
You can also provide a string with separators to the Paths.get method:
The call p.resolve(q) returns a path according to these rules:
There is a convenience method resolveSibling that resolves against a path’s parent, yielding a sibling path.
The call p.relativize(r) yields the path q which, when resolved with p, yields r.
The toAbsolutePath method yields the absolute path of a given path.
The Path interface has many useful methods for taking paths apart and combining them with other paths.
This code sample shows some of the most useful ones:
NOTE: Occasionally, you may need to interoperate with legacy APIs that use the File class instead of the Path interface.
The Path interface has a toFile method, and the File class has a toPath method.
NOTE: By default, all methods of the Files class that read or write characters use the UTF-8 encoding.
In the (hopefully unlikely) case that you need a different encoding, you can supply a Charset argument.
Contrast with the String constructor and getBytes method which use the platform default.
These convenience methods save you from having to deal with FileInputStream, FileOutputStream, BufferedReader, or BufferedWriter.
All but the last component in the path must already exist.
Here, dir is a Path, and prefix/suffix are strings which may be null.
You can also use this command to move an empty directory.
Then you are assured that either the move completed successfully, or the source continues to be present.
The deletion methods can also be used to remove an empty directory.
NOTE: There is no convenient method for removing or copying a nonempty directory.
See the API documentation of the FileVisitor interface for code outlines that achieve these tasks.
Java 7 introduces several methods that make it more convenient to deal with null values in the ubiquitous equals and hashCode, and with numeric comparisons in compareTo.
Suppose you have to implement the equals method for this class:
First, there is the drudgery of casting the parameter to a Person:
The Objects.hashCode method returns a code of 0 for a null argument, so you can implement the body of your hashCode method like this:
The varargs method Objects.hash, introduced in Java 7, lets you specify any sequence of values, and their hash codes get combined:
NOTE: Objects.hash simply calls Arrays.hash, which existed since Java 5
But it isn’t a varargs method, making it less convenient.
When you compare integers in a comparator, it is tempting to return the difference between them since you are allowed to return any negative or positive number—only the sign matters.
NOTE: The static compare method existed for Double and Float since Java 1.2
The designers of Java knew perfectly well that executing remote code is a security risk, so they designed a “sandbox” model that stopped any damaging instructions in their tracks.
Applets were limited to visual effects and network connections to the originating host, which many application writers found limiting.
They wanted local device access for storage, printing, and so on.
Unfortunately, Java Web Start was poorly understood, not integrated with applets, and not maintained with any vigor.
Meanwhile, Microsoft, with an enormous engineering effort, got better at closing Windows loopholes, and it became worthwhile for hackers to look at obscure Java vulnerabilities instead.
When Oracle purchased Sun in 2010, they inherited a very limited infrastructure for dealing with such attacks and no reliable means of updating client virtual machines.
As of today, Oracle signals that it is no longer focused on securing home users’ Java applets and Web Start applications (collectively called rich internet applications, or RIAs)
Oracle continues to close Java vulnerabilities, and develops tools that are suitable for corporate deployment, so that legacy RIAs can be deployed safely.
Home users are expected to migrate away from PCs to tablets and smartphones.
These devices don’t support a Java VM in the browser.
And business users are a plausible revenue target for maintaining legacy applications.
NOTE: It has always been possible to call applets from JavaScript—another dubious decision from the point of view of the security minded.
Java held great promise as a universal execution platform for remote code.
If Java had offered a more compelling sandbox, if nonsandbox code had been more aggressively controlled, if there had.
But there is no use dwelling on what might have been.
At this point, Java is no longer a viable platform for widespread distribution of client applications over the Internet.
If you maintain an applet or Java Web Start application for home users, the message is clear: Move away from it.
If your application serves a specialized audience (for example, software development, image editing, or document processing), make your users install Java or bundle a JVM with your installer.
NOTE: If you decide to make your users install Java, you face another hurdle.
Or you could bundle a JVM, which you are then obligated to update since no effective update mechanism is supplied by Oracle.
In a corporate environment, you can effectively secure Java RIAs, provided you have control over the applications and the client machines.
You will need to tightly manage the application packaging and be ready to update client VMs when security updates become available.
NOTE: To more tightly manage corporate RIAs, you can provide deployment rulesets on end-user machines.
Unfortunately, that instance variable has to be initialized somewhere, and if other logging happens in the static initialization code, it was possible to cause deadlocks.
The Objects class has methods requireNonNull for convenient null checks of parameters.
You can also supply a message string for the exception:
Prior to Java 5, the Runtime.exec method was the only way to execute an external command from within a Java application.
Java 5 added the ProcessBuilder class that gives more control over the generated operating system process.
In particular, with the ProcessBuilder, you can change the working directory.
NOTE: Since Java 8, the Process class has a waitFor method with timeout:
Also new in Java 7 is the inheritIO method of ProcessBuilder.
It sets the standard input, output, and error streams of the process to those of the Java program.
Before Java 7, code such as this could lead to resource leaks.
Java 7 simply adds a close method to close the classloader.
URLClassLoader now implements AutoCloseable, so you can use a try-with-resources statement:
CAUTION: Don’t use any classes after the classloader has been closed.
If you do, and those classes need to load other classes to do their work, they will fail.
NOTE: As of Java 8, BitSet has a method stream that yields an IntStream.
Be sure to close both objects, provided they have been properly constructed.
Improve on the preceding exercise by adding any exceptions thrown by in.close() or out.close() as suppressed exceptions to the original exception, if there was one.
When you rethrow an exception that you caught in a multi-catch clause, how do you declare its type in the throws declaration of the ambient method? For example, consider.
Implement a compareTo method for the LabeledPoint class of the preceding exercise.
Suppose you want to offer it to users as a security scan.
Package it so that it will run on your JRE.
Java Web Start, 190–192 java, javax, javafx global objects (JavaScript),
Horstmann introduces Scala concepts and techniques in  blogsized  chunks that you can quickly master and apply.
Here you will gain access to quality and trusted content and.
Access to supplemental content, including bonus chapters, source code, or project files.
Benefits will be listed on your Account page under Registered Products.
InformIT is a brand of Pearson and the online presence for the world’s leading technology publishers.
It’s your source for reliable and qualified content and knowledge, providing access to the top brands, authors, and contributors from the tech community.
Learn about new releases and special promotions by subscribing to a wide variety of newsletters.
Feed your brain Gain unlimited access to thousands of books and videos about technology,
See it, believe it Watch hundreds of expert-led instructional videos on today’s hottest topics.
WAIT, THERE’S MORE! Gain a competitive edge Be first to learn about the newest technologies and subjects with Rough Cuts.
Accelerate your project Copy and paste code, create smart searches that let you know when new.
Safari Books Online is a digital library providing searchable, on-demand access to thousands of technology, digital media, and professional development books and videos from leading publishers.
With one monthly or yearly subscription price, you get unlimited access to learning tools and information on topics including mobile app and software development, tips and tricks on using your favorite gadgets, networking, project management, graphic design, and much more.
