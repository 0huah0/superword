Oracle and Java are registered trademarks of Oracle and/or its affiliates.
The Specification provided herein is provided to you only under the Limited License Grant included herein as Appendix A.
In addition, numerous corrections and clarifications have been made to align with popular implementations of the Java Virtual Machine, and with concepts common to the Java Virtual Machine and the Java programming language.
Readers may send feedback about errors and ambiguities in The Java Virtual Machine Specification to jvms-comments_ww@oracle.com.
Additions were made to the class file format to support new Java programming language features such as generics and variable arity methods.
Eva Rose, in her Master's Thesis, proposed a radical revision of bytecode verification in the context of the Java Card platform.
This led to an implementation for Java ME CLDC, and eventually to the revision of the Java SE verification process documented in Chapter 4
Antero Taivalsaari led the overall specification of Java ME CLDC and Gilad Bracha was responsible for specifying the verifier.
Alessandro Coglio's analysis of bytecode verification was the most extensive, realistic, and thorough study of the topic, and contributed greatly to the specification.
Wei then implemented the specification "for real" in the HotSpot JVM.
Later, Mingyao Yang improved the design and specification, and implemented the final version that shipped in the Reference Implementation of Java SE 6
More people than we can mention here have, over time, contributed to the design and implementation of the Java Virtual Machine.
The excellent performance we see in the Java Virtual Machine implementations of today would never have been possible without the technological foundation laid by David Ungar and his colleagues at the Self project at Sun Labs.
This technology took a convoluted path, from Self on through the Animorphic Smalltalk VM to eventually become the HotSpot JVM.
Lars Bak and Urs Hölzle are the two people who were present through all these stages, and are more responsible than anyone else for the high performance we take for granted in Java Virtual Machine implementations today.
Jon Courtney and Roger Riggs helped to ensure this specification is applicable to Java ME as much as Java SE.
It also includes many corrections and clarifications that update the presentation of the specification without changing the logical specification itself.
We have attempted to correct typos and errata (hopefully without introducing new ones) and to add more detail to the specification where it was vague or ambiguous.
We thank the many readers who combed through the First Edition of this book and brought problems to our attention.
Several individuals and groups deserve special thanks for pointing out problems or contributing directly to the new material.
Carla Schroer and her teams of compatibility testers in Cupertino, California, and Novosibirsk, Russia (with special thanks to Leonid Arbouzov and Alexei Kaigorodov) painstakingly wrote compatibility tests for each testable assertion in the First Edition.
In the process they uncovered many places where the original specification was unclear or incomplete.
Marilyn Rash and Hilary Selby Polk of Addison Wesley Longman helped us to improve the readability and layout of this edition at the same time as we were incorporating all the technical changes.
His dedication to "computational theology" and his commitment to resolving inconsistencies between The Java Virtual Machine Specification and The Java Language Specification have benefited this book tremendously.
It is essential for compiler writers who wish to target the Java Virtual Machine and for programmers who want to implement a compatible Java Virtual Machine.
References to the Java Virtual Machine throughout this specification refer to this abstract machine rather than to any specific implementation.
This specification serves as documentation for a concrete implementation of the Java Virtual Machine only as a blueprint documents a house.
An implementation of the Java Virtual Machine must embody this specification, but is constrained by it only where absolutely necessary.
We intend that this specification should sufficiently document the Java Virtual Machine to make possible compatible clean-room implementations.
The virtual machine that evolved into the Java Virtual Machine was originally designed by James Gosling in 1992 to support the Oak programming language.
The evolution into its present form occurred through the direct and indirect efforts of many people and spanned Sun's Green project, FirstPerson, Inc., the LiveOak project, the Java Products Group, JavaSoft, and the Java Software group at Sun.
This book began as internal project documentation edited by Kathy Walrath.
It was then converted to HTML by Mary Campione and was made available on our Web site before being expanded into book form.
We owe special thanks to Richard Tuck for his careful review of the manuscript.
Particular thanks to Bill Joy whose comments, reviews, and guidance have contributed greatly to the completeness and accuracy of this book.
The Java® programming language is a general-purpose, concurrent, object-oriented language.
The Java platform was initially developed to address the problems of building software for networked consumer devices.
It was designed to support multiple host architectures and to allow secure delivery of software components.
To meet these requirements, compiled code had to survive transport across networks, operate on any client, and assure the client that it was safe to run.
The popularization of the World Wide Web made these attributes much more interesting.
Web browsers enabled millions of people to surf the Net and access media-rich content in simple ways.
At last there was a medium where what you saw and heard was essentially the same regardless of the machine you were using and whether it was connected to a fast network or a slow modem.
Web enthusiasts soon discovered that the content supported by the Web's HTML document format was too limited.
The HotJava browser first showcased the interesting properties of the Java programming language and platform by making it possible to embed programs inside HTML pages.
Programs are transparently downloaded into the browser along with the HTML pages in which they appear.
Before being accepted by the browser, programs are carefully checked to make sure they are safe.
The programs behave the same way regardless of where they come from or what kind of machine they are being loaded into and run on.
A Web browser incorporating the Java platform is no longer limited to a predetermined set of capabilities.
Visitors to Web pages incorporating dynamic content can be assured that their machines cannot be damaged by that content.
Programmers can write a program once, and it will run on any machine supplying a Java run-time environment.
It is the component of the technology responsible for its hardware- and operating systemindependence, the small size of its compiled code, and its ability to protect users from malicious programs.
Like a real computing machine, it has an instruction set and manipulates various memory areas at run time.
It is reasonably common to implement a programming language using a virtual machine; the best-known virtual machine may be the P-Code machine of UCSD Pascal.
The first prototype implementation of the Java Virtual Machine, done at Sun Microsystems, Inc., emulated the Java Virtual Machine instruction set in software hosted by a handheld device that resembled a contemporary Personal Digital Assistant (PDA)
Oracle's current implementations emulate the Java Virtual Machine on mobile, desktop and server devices, but the Java Virtual Machine does not assume any particular implementation technology, host hardware, or host operating system.
It is not inherently interpreted, but can just as well be implemented by compiling its instruction set to that of a silicon CPU.
It may also be implemented in microcode or directly in silicon.
The Java Virtual Machine knows nothing of the Java programming language, only of a particular binary format, the class file format.
A class file contains Java Virtual Machine instructions (or bytecodes) and a symbol table, as well as other ancillary information.
For the sake of security, the Java Virtual Machine imposes strong syntactic and structural constraints on the code in a class file.
However, any language with functionality that can be expressed in terms of a valid class file can be hosted by the Java Virtual Machine.
Attracted by a generally available, machine-independent platform, implementors of other languages can turn to the Java Virtual Machine as a delivery vehicle for their languages.
Chapter 3 introduces compilation of code written in the Java programming language into the instruction set of the Java Virtual Machine.
Chapter 4 specifies the class file format, the hardware- and operating systemindependent binary format used to represent compiled classes and interfaces.
Chapter 5 specifies the start-up of the Java Virtual Machine and the loading, linking, and initialization of classes and interfaces.
Chapter 6 specifies the instruction set of the Java Virtual Machine, presenting the instructions in alphabetical order of opcode mnemonics.
Chapter 7 gives a table of Java Virtual Machine opcode mnemonics indexed by opcode value.
In The Java Virtual Machine Specification, Second Edition, Chapter 2 gave an overview of the Java programming language that was intended to support the specification of the Java Virtual Machine but was not itself a part of the specification.
References of the form: (JLS §x.y) indicate where this is necessary.
Throughout this specification we refer to classes and interfaces drawn from the Java SE platform API.
Whenever we refer to a class or interface (other than those declared in an example) using a single identifier N, the intended reference is to the class or interface named N in the package java.lang.
We use the fully qualified name for classes or interfaces from packages other than java.lang.
Whenever we refer to a class or interface that is declared in the package java or any of its subpackages, the intended reference is to that class or interface as loaded by the bootstrap class loader (§5.3.1)
Whenever we refer to a subpackage of a package named java, the intended reference is to that subpackage as determined by the bootstrap class loader.
The use of fonts in this specification is as follows:
A fixed width font is used for Java Virtual Machine data types, exceptions, errors, class file structures, Prolog code, and Java code fragments.
Italic is used for Java Virtual Machine "assembly language", its opcodes and operands, as well as items in the Java Virtual Machine's run-time data areas.
It is also used to introduce new terms and simply for emphasis.
Non-normative information, designed to clarify the specification, is given in smaller, indented text.
It does not describe any particular implementation of the Java Virtual Machine.
To implement the Java Virtual Machine correctly, you need only be able to read the class file format and correctly perform the operations specified therein.
Implementation details that are not part of the Java Virtual Machine's specification would unnecessarily constrain the creativity of implementors.
For example, the memory layout of run-time data areas, the garbage-collection algorithm used, and any internal optimization of the Java Virtual Machine instructions (for example, translating them into machine code) are left to the discretion of the implementor.
All references to Unicode in this specification are given with respect to The Unicode Standard, Version 6.0.0, available at http://www.unicode.org/
Compiled code to be executed by the Java Virtual Machine is represented using a hardware- and operating system-independent binary format, typically (but not necessarily) stored in a file, known as the class file format.
The class file format precisely defines the representation of a class or interface, including details such as byte ordering that might be taken for granted in a platform-specific object file format.
Chapter 4, "The class File Format", covers the class file format in detail.
Like the Java programming language, the Java Virtual Machine operates on two kinds of types: primitive types and reference types.
There are, correspondingly, two kinds of values that can be stored in variables, passed as arguments, returned by methods, and operated upon: primitive values and reference values.
The Java Virtual Machine expects that nearly all type checking is done prior to run time, typically by a compiler, and does not have to be done by the Java Virtual Machine itself.
Values of primitive types need not be tagged or otherwise be inspectable to determine their types at run time, or to be distinguished from values of reference types.
Instead, the instruction set of the Java Virtual Machine distinguishes its operand types using instructions intended to operate on values of specific types.
For instance, iadd, ladd, fadd, and dadd are all Java Virtual Machine instructions that add two numeric values and produce numeric results, but each is specialized for its operand type: int, long, float, and double, respectively.
For a summary of type support in the Java Virtual Machine instruction set, see §2.11.1
An object is either a dynamically allocated class instance or an array.
A reference to an object is considered to have Java Virtual Machine type reference.
Values of type reference can be thought of as pointers to objects.
Objects are always operated on, passed, and tested via values of type reference.
The values of the boolean type encode the truth values true and false, and the default value is false.
However, boolean values do have limited support in the Java Virtual Machine.
The values of the returnAddress type are pointers to the opcodes of Java Virtual Machine instructions.
Of the primitive types, only the returnAddress type is not directly associated with a Java programming language type.
The values of the integral types of the Java Virtual Machine are:
The IEEE 754 standard includes not only positive and negative sign-magnitude numbers, but also positive and negative zeros, positive and negative infinities, and a special Not-a-Number value (hereafter abbreviated as "NaN")
The NaN value is used to represent the result of certain invalid operations such as dividing zero by zero.
Every implementation of the Java Virtual Machine is required to support two standard sets of floating-point values, called the float value set and the double value set.
In addition, an implementation of the Java Virtual Machine may, at its option, support either or both of two extended-exponent floating-point value sets, called the float-extended-exponent value set and the double-extended-exponent value set.
These extended-exponent value sets may, under certain circumstances, be used instead of the standard value sets to represent the values of type float or double.
Some values can be represented in this form in more than one way; for example, supposing that a value v in a value set might be represented in this form using certain values for s, m, and e, then if it happened that m were even and e were less than 2K-1, one could halve m and increase e by 1 to produce a second representation for the same value v.
The constraints on the parameters N and K (and on the derived parameters Emin and Emax) for the two required and two optional floating-point value sets are summarized in Table 2.1
Where one or both extended-exponent value sets are supported by an implementation, then for each supported extended-exponent value set there is a specific implementation-dependent constant K, whose value is constrained by Table 2.1; this value K in turn dictates the values for Emin and Emax.
Each of the four value sets includes not only the finite nonzero values that are ascribed to it above, but also the five values positive zero, negative zero, positive infinity, negative infinity, and NaN.
Note that the constraints in Table 2.1 are designed so that every element of the float value set is necessarily also an element of the float-extended-exponent value set, the double value set, and the double-extended-exponent value set.
Likewise, each element of the double value set is necessarily also an element of the doubleextended-exponent value set.
Each extended-exponent value set has a larger range of exponent values than the corresponding standard value set, but does not have more precision.
Note, however, that the elements of the float-extended-exponent and doubleextended-exponent value sets defined here do not correspond to the values that can be represented using IEEE 754 single extended and double extended formats, respectively.
The float, float-extended-exponent, double, and double-extended-exponent value sets are not types.
It is always correct for an implementation of the Java Virtual Machine to use an element of the float value set to represent a value of type float;
Similarly, it is always correct for an implementation to use an element of the double value set to represent a value of type double; however, it may be permissible in certain contexts for an implementation to use an element of the double-extended-exponent value set instead.
Except for NaNs, values of the floating-point value sets are ordered.
When arranged from smallest to largest, they are negative infinity, negative finite values, positive and negative zero, positive finite values, and positive infinity.
NaNs are unordered, so numerical comparisons and tests for numerical equality have the value false if either or both of their operands are NaN.
In particular, a test for numerical equality of a value against itself has the value false if and only if the value is NaN.
A test for numerical inequality has the value true if either operand is NaN.
The values of the returnAddress type are pointers to the opcodes of Java Virtual Machine instructions.
Unlike the numeric primitive types, the returnAddress type does not correspond to any Java programming language type and cannot be modified by the running program.
Although the Java Virtual Machine defines a boolean type, it only provides very limited support for it.
There are no Java Virtual Machine instructions solely dedicated to operations on boolean values.
Instead, expressions in the Java programming language that operate on boolean values are compiled to use values of the Java Virtual Machine int data type.
In Oracle’s Java Virtual Machine implementation, boolean arrays in the Java programming language are encoded as Java Virtual Machine byte arrays, using 8 bits per boolean element.
Where Java programming language boolean values are mapped by compilers to values of Java Virtual Machine type int, the compilers must use the same encoding.
There are three kinds of reference types: class types, array types, and interface types.
Their values are references to dynamically created class instances, arrays, or class instances or arrays that implement interfaces, respectively.
An array type consists of a component type with a single dimension (whose length is not given by the type)
The component type of an array type may itself be an array type.
If, starting from any array type, one considers its component type, and then (if that is also an array type) the component type of that type, and so on, eventually one must reach a component type that is not an array type; this is called the element type of the array type.
The element type of an array type is necessarily either a primitive type, or a class type, or an interface type.
A reference value may also be the special null reference, a reference to no object, which will be denoted here by null.
The null reference initially has no run-time type, but may be cast to any type.
The Java Virtual Machine specification does not mandate a concrete value encoding null.
The Java Virtual Machine defines various run-time data areas that are used during execution of a program.
Some of these data areas are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits.
Per-thread data areas are created when a thread is created and destroyed when the thread exits.
The Java Virtual Machine can support many threads of execution at once (JLS §17)
Each Java Virtual Machine thread has its own pc (program counter) register.
At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (§2.6) for that thread.
If that method is not native, the pc register contains the address of the Java Virtual Machine instruction currently being executed.
If the method currently being executed by the thread is native, the value of the Java Virtual Machine's pc register is undefined.
The Java Virtual Machine's pc register is wide enough to hold a returnAddress or a native pointer on the specific platform.
Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at the same time as the thread.
A Java Virtual Machine stack is analogous to the stack of a conventional language such as C: it holds local variables and partial results, and plays a part in method invocation and return.
Because the Java Virtual Machine stack is never manipulated directly except to push and pop frames, frames may be heap allocated.
The memory for a Java Virtual Machine stack does not need to be contiguous.
This specification permits Java Virtual Machine stacks either to be of a fixed size or to dynamically expand and contract as required by the computation.
If the Java Virtual Machine stacks are of a fixed size, the size of each Java Virtual Machine stack may be chosen independently when that stack is created.
A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of Java Virtual Machine stacks, as well as, in the case of dynamically expanding or contracting Java Virtual Machine stacks, control over the maximum and minimum sizes.
The following exceptional conditions are associated with Java Virtual Machine stacks:
If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a StackOverflowError.
If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java.
The heap is the run-time data area from which memory for all class instances and arrays is allocated.
Heap storage for objects is reclaimed by an automatic storage management system (known as a garbage assumes no particular type of automatic storage management system, and the storage management technique may be chosen according to the implementor's system requirements.
The heap may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger heap becomes unnecessary.
The memory for the heap does not need to be contiguous.
A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the heap, as well as, if the heap can be dynamically expanded or contracted, control over the maximum and minimum heap size.
The following exceptional condition is associated with the heap: • If a computation requires more heap than can be made available by the.
The method area is analogous to the storage area for compiled code of a conventional language or analogous to the "text" segment in an operating system process.
It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods (§2.9) used in class and instance initialization and interface initialization.
Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it.
This version of the Java Virtual Machine specification does not mandate the location of the method area or the policies used to manage compiled code.
The method area may be of a fixed size or may be expanded as.
The memory for the method area does not need to be contiguous.
A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the method area, as well as, in the case of a varying-size method area, control over the maximum and minimum method area size.
The following exceptional condition is associated with the method area: • If memory in the method area cannot be made available to satisfy an allocation.
It contains several kinds of constants, ranging from numeric literals known at compile-time to method and field references that must be resolved at run-time.
The run-time constant pool serves a function similar to that of a symbol table for a conventional programming language, although it contains a wider range of data than a typical symbol table.
Each run-time constant pool is allocated from the Java Virtual Machine's method area (§2.5.4)
The run-time constant pool for a class or interface is constructed when the class or interface is created (§5.3) by the Java Virtual Machine.
The following exceptional condition is associated with the construction of the runtime constant pool for a class or interface:
When creating a class or interface, if the construction of the run-time constant pool requires more memory than can be made available in the method area of the Java Virtual Machine, the Java Virtual Machine throws an OutOfMemoryError.
See §5 for information about the construction of the run-time constant pool.
An implementation of the Java Virtual Machine may use conventional stacks, colloquially called "C stacks," to support native methods (methods written in a language other than the Java programming language)
Native method stacks may also be used by the implementation of an interpreter for the Java Virtual Machine's instruction set in a language such as C.
Java Virtual Machine implementations that cannot load native methods and that do not themselves rely on conventional stacks need not supply native method stacks.
If supplied, native method stacks are typically allocated per thread when each thread is created.
This specification permits native method stacks either to be of a fixed size or to dynamically expand and contract as required by the computation.
If the native method stacks are of a fixed size, the size of each native method stack may be chosen independently when that stack is created.
A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the native method stacks, as well as, in the case of varying-size native method stacks, control over the maximum and minimum method stack sizes.
The following exceptional conditions are associated with native method stacks: • If the computation in a thread requires a larger native method stack than is.
If native method stacks can be dynamically expanded and native method stack.
A frame is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions.
A new frame is created each time a method is invoked.
A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception)
Frames are allocated from the Java Virtual Machine stack (§2.5.2) of the thread creating the frame.
A frame may be extended with additional implementation-specific information, such as debugging information.
The sizes of the local variable array and the operand stack are determined at compile-time and are supplied along with the code for the method associated with the frame (§4.7.3)
Thus the size of the frame data structure depends only on the implementation of the Java Virtual Machine, and the memory for these structures can be allocated simultaneously on method invocation.
Only one frame, the frame for the executing method, is active at any point in a given thread of control.
This frame is referred to as the current frame, and its method is known as the current method.
The class in which the current method is defined is.
Operations on local variables and the operand stack are typically with reference to the current frame.
A frame ceases to be current if its method invokes another method or if its method completes.
When a method is invoked, a new frame is created and becomes current when control transfers to the new method.
On method return, the current frame passes back the result of its method invocation, if any, to the previous frame.
The current frame is then discarded as the previous frame becomes the current one.
Note that a frame created by a thread is local to that thread and cannot be referenced by any other thread.
Each frame (§2.6) contains an array of variables known as its local variables.
The length of the local variable array of a frame is determined at compile-time and supplied in the binary representation of a class or interface along with the code for the method associated with the frame (§4.7.3)
A single local variable can hold a value of type boolean, byte, char, short, int, float, reference, or returnAddress.
A pair of local variables can hold a value of type long or double.
An integer is considered to be an index into the local variable array if and only if that integer is between zero and one less than the size of the local variable array.
A value of type long or type double occupies two consecutive local variables.
Such a value may only be addressed using the lesser index.
However, doing so invalidates the contents of local variable n.
The Java Virtual Machine does not require n to be even.
In intuitive terms, values of types long and double need not be 64-bit aligned in the local variables array.
Implementors are free to decide the appropriate way to represent such values using the two local variables reserved for the value.
The Java Virtual Machine uses local variables to pass parameters on method invocation.
On class method invocation, any parameters are passed in consecutive local variables starting from local variable 0
On instance method invocation, local variable 0 is always used to pass a reference to the object on which the instance method is being invoked (this in the Java programming language)
Each frame (§2.6) contains a last-in-first-out (LIFO) stack known as its operand stack.
The maximum depth of the operand stack of a frame is determined at compile-time and is supplied along with the code for the method associated with the frame (§4.7.3)
Where it is clear by context, we will sometimes refer to the operand stack of the current frame as simply the operand stack.
The operand stack is empty when the frame that contains it is created.
The Java Virtual Machine supplies instructions to load constants or values from local variables or fields onto the operand stack.
Other Java Virtual Machine instructions take operands from the operand stack, operate on them, and push the result back onto the operand stack.
The operand stack is also used to prepare parameters to be passed to methods and to receive method results.
For example, the iadd instruction (§iadd) adds two int values together.
It requires that the int values to be added be the top two values of the operand stack, pushed there by previous instructions.
Both of the int values are popped from the operand stack.
They are added, and their sum is pushed back onto the operand stack.
Subcomputations may be nested on the operand stack, resulting in values that can be used by the encompassing computation.
Each entry on the operand stack can hold a value of any Java Virtual Machine type, including a value of type long or type double.
Values from the operand stack must be operated upon in ways appropriate to their types.
It is not possible, for example, to push two int values and subsequently treat them as a long or to push two float values and subsequently add them with an iadd instruction.
These restrictions on operand stack manipulation are enforced through class file verification (§4.10)
At any point in time, an operand stack has an associated depth, where a value of type long or double contributes two units to the depth and a value of any other type contributes one unit.
The class file code for a method refers to methods to be invoked and variables to be accessed via symbolic references.
Dynamic linking translates these symbolic method references into concrete method references, loading classes as necessary to resolve as-yet-undefined symbols, and translates variable accesses into appropriate offsets in storage structures associated with the run-time location of these variables.
This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.
A method invocation completes normally if that invocation does not cause an exception (§2.10) to be thrown, either directly from the Java Virtual Machine or as a result of executing an explicit throw statement.
If the invocation of the current method completes normally, then a value may be returned to the invoking method.
This occurs when the invoked method executes one of the return instructions (§2.11.8), the choice of which must be appropriate for the type of the value being returned (if any)
The current frame (§2.6) is used in this case to restore the state of the invoker, including its local variables and operand stack, with the program counter of the invoker appropriately incremented to skip past the method invocation instruction.
Execution then continues normally in the invoking method's frame with the returned value (if any) pushed onto the operand stack of that frame.
A method invocation completes abruptly if execution of a Java Virtual Machine instruction within the method causes the Java Virtual Machine to throw an exception (§2.10), and that exception is not handled within the method.
Execution of an athrow instruction (§athrow) also causes an exception to be explicitly thrown and, if the exception is not caught by the current method, results in abrupt method invocation completion.
A method invocation that completes abruptly never returns a value to its invoker.
The Java Virtual Machine does not mandate any particular internal structure for objects.
In some of Oracle’s implementations of the Java Virtual Machine, a reference to a class instance is a pointer to a handle that is itself a pair of pointers: one to a table containing the methods of the object and a pointer to the Class object that represents the type of the object, and the other to the memory allocated from the heap for the object data.
The rounding operations of the Java Virtual Machine always use IEEE 754 round to nearest mode.
Inexact results are rounded to the nearest representable value, with ties going to the value with a zero least-significant bit.
But Java Virtual Machine instructions that convert values of floating-point types to values of integral types round toward zero.
The Java Virtual Machine does not give any means to change the floating-point rounding mode.
The Java Virtual Machine does not support either the IEEE 754 single extended or double extended format, except insofar as the double and double-extendedexponent value sets may be said to support the single extended format.
The float-extended-exponent and double-extended-exponent value sets, which may optionally be supported, do not correspond to the values of the IEEE 754
Every method has a floating-point mode, which is either FP-strict or not FPstrict.
A method for which this flag is set is FP-strict; otherwise, the method is not FP-strict.
We will refer to an operand stack as having a given floating-point mode when the method whose invocation created the frame containing the operand stack has that floating-point mode.
Similarly, we will refer to a Java Virtual Machine instruction as having a given floating-point mode when the method containing that instruction has that floating-point mode.
If a double-extended-exponent value set is supported (§2.3.2), values of type double on an operand stack that is not FP-strict may range over that value set except where prohibited by value set conversion.
In all other contexts, whether on the operand stack or elsewhere, and regardless of floating-point mode, floating-point values of type float and double may only range over the float value set and double value set, respectively.
In particular, class and instance fields, array elements, local variables, and method parameters may only contain values drawn from the standard value sets.
An implementation of the Java Virtual Machine that supports an extended floatingpoint value set is permitted or required, under specified circumstances, to map a value of the associated floating-point type between the extended and the standard value sets.
Such a value set conversion is not a type conversion, but a mapping between the value sets associated with the same type.
Where value set conversion is indicated, an implementation is permitted to perform one of the following operations on a value:
If the value is of type float and is not an element of the float value set, it maps the value to the nearest element of the float value set.
If the value is of type double and is not an element of the double value set, it maps the value to the nearest element of the double value set.
In addition, where value set conversion is indicated, certain operations are required: • Suppose execution of a Java Virtual Machine instruction that is not FP-strict.
If the value is not an element of the float value set, it maps the value to the nearest element of the float value set.
Suppose execution of a Java Virtual Machine instruction that is not FP-strict causes a value of type double to be pushed onto an operand stack that is FPstrict, passed as a parameter, or stored into a local variable, a field, or an element of an array.
If the value is not an element of the double value set, it maps the value to the nearest element of the double value set.
Such required value set conversions may occur as a result of passing a parameter of a floating-point type during method invocation, including native method invocation; returning a value of a floating-point type from a method that is not FPstrict to a method that is FP-strict; or storing a value of a floating-point type into a local variable, a field, or an array in a method that is not FP-strict.
Not all values from an extended-exponent value set can be mapped exactly to a value in the corresponding standard value set.
If a value being mapped is too large to be represented exactly (its exponent is greater than that permitted by the standard value set), it is converted to a (positive or negative) infinity of the corresponding type.
If a value being mapped is too small to be represented exactly (its exponent is smaller than that permitted by the standard value set), it is rounded to the nearest of a representable denormalized value or zero of the same sign.
Value set conversion preserves infinities and NaNs and cannot change the sign of the value being converted.
Value set conversion has no effect on a value that is not of a floating-point type.
Instance initialization methods may be invoked only within the Java Virtual Machine by the invokespecial instruction (§invokespecial), and they may be invoked only on uninitialized class instances.
An instance initialization method takes on the access permissions (JLS §6.6) of the constructor from which it was derived.
A class or interface has at most one class or interface initialization method and is initialized (§5.5) by invoking that method.
Other methods named <clinit> in a class file are of no consequence.
They cannot be invoked by any Java Virtual Machine instruction and are never invoked by the Java Virtual Machine itself.
Because the name <clinit> is not a valid identifier, it cannot be used directly in a program written in the Java programming language.
Class and interface initialization methods are invoked implicitly by the Java Virtual Machine; they are never invoked directly from any Java Virtual Machine instruction, but are invoked only indirectly as part of the class initialization process.
A method is signature polymorphic if and only if all of the following conditions hold : • It is declared in the java.lang.invoke.MethodHandle class.
In Java SE 7, the only signature polymorphic methods are the invoke and invokeExact methods of the class java.lang.invoke.MethodHandle.
The Java Virtual Machine gives special treatment to signature polymorphic methods in the invokevirtual instruction (§invokevirtual), in order to effect.
A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation (§5.4.3.5), with optional transformations of arguments or return values.
These transformations are quite general, and include such patterns as conversion, insertion, deletion, and substitution.
See the java.lang.invoke package in the Java SE platform API for more information.
An exception in the Java Virtual Machine is represented by an instance of the class Throwable or one of its subclasses.
Throwing an exception results in an immediate nonlocal transfer of control from the point where the exception was thrown.
Most exceptions occur synchronously as a result of an action by the thread in which they occur.
An asynchronous exception, by contrast, can potentially occur at any point in the execution of a program.
The Java Virtual Machine throws an exception for one of three reasons:
An abnormal execution condition was synchronously detected by the Java.
These exceptions are not thrown at an arbitrary point in the program, but only synchronously after execution of an instruction that either: ◆ Specifies the exception as a possible result, such as:
When the instruction embodies an operation that violates the semantics of the Java programming language, for example indexing outside the bounds of an array.
When an error occurs in loading or linking part of the program.
Causes some limit on a resource to be exceeded, for example when too much.
The stop method of class Thread or ThreadGroup was invoked, or ◆ An internal error occurred in the Java Virtual Machine implementation.
The stop methods may be invoked by one thread to affect another thread or all the threads in a specified thread group.
They are asynchronous because they may occur at any point in the execution of the other thread or threads.
A Java Virtual Machine may permit a small but bounded amount of execution to occur before an asynchronous exception is thrown.
This delay is permitted to allow optimized code to detect and throw these exceptions at points where it is practical to handle them while obeying the semantics of the Java programming language.
A simple implementation might poll for asynchronous exceptions at the point of each control transfer instruction.
Since a program has a finite size, this provides a bound on the total delay in detecting an asynchronous exception.
Since no asynchronous exception will occur between control transfers, the code generator has some flexibility to reorder computation between control transfers for greater performance.
Exceptions thrown by the Java Virtual Machine are precise: when the transfer of control takes place, all effects of the instructions executed before the point from which the exception is thrown must appear to have taken place.
No instructions that occur after the point from which the exception is thrown may appear to have been evaluated.
If optimized code has speculatively executed some of the instructions which follow the point at which the exception occurs, such code must be prepared to hide this speculative execution from the user-visible state of the program.
Each method in the Java Virtual Machine may be associated with zero or more exception handlers.
An exception handler specifies the range of offsets into the Java Virtual Machine code implementing the method for which the exception handler is active, describes the type of exception that the exception handler is able to handle, and specifies the location of the code that is to handle that exception.
An exception matches an exception handler if the offset of the instruction that caused the exception is in the range of offsets of the exception handler and the exception type is the same class as or a subclass of the class of exception that the exception handler handles.
When an exception is thrown, the Java Virtual Machine searches for a matching exception handler in the current method.
If a matching exception handler is found, the system branches to the exception handling code specified by the matched handler.
If no such exception handler is found in the current method, the current method invocation completes abruptly (§2.6.5)
On abrupt completion, the operand stack and local variables of the current method invocation are discarded, and its frame is popped, reinstating the frame of the invoking method.
The exception is then rethrown in the context of the invoker's frame and so on, continuing up the method invocation chain.
If no suitable exception handler is found before the top of the method invocation chain is reached, the execution of the thread in which the exception was thrown is terminated.
The order in which the exception handlers of a method are searched for a match is a table (§4.7.3)
At run time, when an exception is thrown, the Java Virtual Machine searches the exception handlers of the current method in the order that they appear in the corresponding exception handler table in the class file, starting from the beginning of that table.
Note that the Java Virtual Machine does not enforce nesting of or any ordering of the exception table entries of a method.
The exception handling semantics of the Java programming language are implemented only through cooperation with the compiler (§3.12)
When class files are generated by some other means, the defined search procedure ensures that all Java Virtual Machine implementations will behave consistently.
A Java Virtual Machine instruction consists of a one-byte opcode specifying the operation to be performed, followed by zero or more operands supplying arguments or data that are used by the operation.
Many instructions have no operands and consist only of an opcode.
Ignoring exceptions, the inner loop of a Java Virtual Machine interpreter is effectively.
The number and size of the operands are determined by the opcode.
If an operand is more than one byte in size, then it is stored in big-endian order - high-order byte first.
The decision to limit the Java Virtual Machine opcode to a byte and to forgo data alignment within compiled code reflects a conscious bias in favor of compactness, possibly at the cost of some performance in naive implementations.
Not assuming data alignment means that immediate data larger than a byte must be constructed from bytes at run time on many machines.
Most of the instructions in the Java Virtual Machine instruction set encode type information about the operations they perform.
For instance, the iload instruction (§iload) loads the contents of a local variable, which must be an int, onto the operand stack.
The fload instruction (§fload) does the same with a float value.
The two instructions may have identical implementations, but have distinct opcodes.
For the majority of typed instructions, the instruction type is represented explicitly in the opcode mnemonic by a letter: i for an int operation, l for long, s for short, b for byte, c for char, f for float, d for double, and a for reference.
Some instructions for which the type is unambiguous do not have a type letter in their mnemonic.
For instance, arraylength always operates on an object that is an array.
Some instructions, such as goto, an unconditional control transfer, do not operate on typed operands.
Given the Java Virtual Machine's one-byte opcode size, encoding types into opcodes places pressure on the design of its instruction set.
If each typed instruction supported all of the Java Virtual Machine's run-time data types, there would be more instructions than could be represented in a byte.
Instead, the instruction set of the Java Virtual Machine provides a reduced level of type support for certain operations.
In other words, the instruction set is intentionally not orthogonal.
Separate instructions can be used to convert between unsupported and supported data types as necessary.
Table 2.2 summarizes the type support in the instruction set of the Java Virtual Machine.
A specific instruction, with type information, is built by replacing the T in the instruction template in the opcode column by the letter in the type column.
If the type column for some instruction template and type is blank, then no instruction exists supporting that type of operation.
For instance, there is a load instruction for type int, iload, but there is no load instruction for type byte.
Note that most instructions in Table 2.2 do not have forms for the integral types byte, char, and short.
A compiler encodes loads of literal values of types byte and short using Java Virtual Machine instructions that sign-extend those values to values of type int at compile-time or run-time.
Loads of literal values of types boolean and char are encoded using instructions that zero-extend the literal to a value of type int at compile-time or run-time.
Likewise, loads from arrays of values of type boolean, byte, short, and char are encoded using Java Virtual Machine instructions that sign-extend or zeroTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE Instruction Set Summary 2.11
Thus, most operations on values of actual types boolean, byte, char, and short are correctly performed by instructions operating on values of computational type int.
Type support in the Java Virtual Machine instruction set opcode byte short int long float double char reference.
Tconst iconst lconst fconst dconst aconst Tload iload lload fload dload aload Tstore istore lstore fstore dstore astore Tinc iinc.
Taload baload saload iaload laload faload daload caload aaload Tastore bastore sastore iastore lastore fastore dastore castore aastore Tadd iadd ladd fadd dadd Tsub isub lsub fsub dsub Tmul imul lmul fmul dmul Tdiv idiv ldiv fdiv ddiv Trem irem lrem frem drem Tneg ineg lneg fneg dneg Tshl ishl lshl.
Certain Java Virtual Machine instructions such as pop and swap operate on the operand stack without regard to type; however, such instructions are constrained to use only on values of certain categories of computational types, also given in Table 2.3
Store a value from the operand stack into a local variable: istore, istore_<n>,
Gain access to more local variables using a wider index, or to a larger immediate.
Instructions that access fields of objects and elements of arrays (§2.11.5) also transfer data to and from the operand stack.
Such families of instructions are specializations of an additional generic instruction (iload) that takes one operand.
For the specialized instructions, the operand is implicit and does not need to be stored or fetched.
This notation for instruction families is used throughout this specification.
The arithmetic instructions compute a result that is typically a function of two values on the operand stack, pushing the result back on the operand stack.
There are two main kinds of arithmetic instructions: those operating on integer values and those operating on floating-point values.
Within each of these kinds, the arithmetic instructions are specialized to Java Virtual Machine numeric types.
There is no direct support for integer arithmetic on values of the byte, short, and char types (§2.11.1), or for values of the boolean type; those operations are handled by instructions operating on type int.
Integer and floating-point instructions also differ in their behavior on overflow and divide-by-zero.
The Java Virtual Machine does not indicate overflow during operations on integer data types.
The only integer operations that can throw an exception are the integer divide instructions (idiv and ldiv) and the integer remainder instructions (irem and lrem), which throw an ArithmeticException if the divisor is zero.
Java Virtual Machine operations on floating-point numbers behave as specified in IEEE 754
In particular, the Java Virtual Machine requires full support of IEEE 754 denormalized floating-point numbers and gradual underflow, which make it easier to prove desirable properties of particular numerical algorithms.
The Java Virtual Machine requires that floating-point arithmetic behave as if every floating-point operator rounded its floating-point result to the result precision.
Inexact results must be rounded to the representable value nearest to the infinitely precise result; if the two nearest representable values are equally near, the one having a least significant bit of zero is chosen.
This is the IEEE 754 standard's default rounding mode, known as round to nearest mode.
The Java Virtual Machine uses the IEEE 754 round towards zero mode when converting a floating-point value to an integer.
This results in the number being truncated; any bits of the significand that represent the fractional part of the operand value are discarded.
Round towards zero mode chooses as its result the type's value closest to, but no greater in magnitude than, the infinitely precise result.
The Java Virtual Machine's floating-point operators do not throw run-time exceptions (not to be confused with IEEE 754 floating-point exceptions)
An operation that overflows produces a signed infinity, an operation that underflows produces a denormalized value or a signed zero, and an operation that has no mathematically definite result produces NaN.
All numeric operations with NaN as an operand produce NaN as a result.
Comparisons on values of type long (lcmp) perform a signed comparison.
Comparisons on values of floating-point types (dcmpg, dcmpl, fcmpg, fcmpl) are performed using IEEE 754 nonsignaling comparisons.
The type conversion instructions allow conversion between Java Virtual Machine numeric types.
These may be used to implement explicit conversions in user code or to mitigate the lack of orthogonality in the instruction set of the Java Virtual Machine.
The Java Virtual Machine directly supports the following widening numeric conversions:
Widening numeric conversions do not lose information about the overall magnitude of a numeric value.
Indeed, conversions widening from int to long and int to double do not lose any information at all; the numeric value is preserved exactly.
Conversions widening from float to double that are FP-strict (§2.8.2) also preserve the numeric value exactly; however, such conversions that are not FP-strict may lose information about the overall magnitude of the converted value.
Conversion of an int or a long value to float, or of a long value to double, may lose precision, that is, may lose some of the least significant bits of the value; the resulting floating-point value is a correctly rounded version of the integer value, using IEEE 754 round to nearest mode.
A widening numeric conversion of an int to a long simply sign-extends the two'scomplement representation of the int value to fill the wider format.
A widening numeric conversion of a char to an integral type zero-extends the representation of the char value to fill the wider format.
Despite the fact that loss of precision may occur, widening numeric conversions never cause the Java Virtual Machine to throw a run-time exception (not to be confused with an IEEE 754 floating-point exception)
Note that widening numeric conversions do not exist from integral types byte, char, and short to type int.
As noted in §2.11.1, values of type byte, char, and short are internally widened to type int, making these conversions implicit.
The Java Virtual Machine also directly supports the following narrowing numeric conversions:
A narrowing numeric conversion can result in a value of different sign, a different order of magnitude, or both; it may thereby lose precision.
A narrowing numeric conversion of an int or long to an integral type T simply discards all but the N lowest-order bits, where N is the number of bits used to represent type T.
This may cause the resulting value not to have the same sign as the input value.
Otherwise, if the floating-point value is not an infinity, the floating-point value is rounded to an integer value V using IEEE 754 round towards zero mode.
If T is long and this integer value can be represented as a long, then the result is the long value V.
If T is of type int and this integer value can be represented as an int, then the result is the int value V.
Otherwise: ◆ Either the value must be too small (a negative value of large magnitude or.
Or the value must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type int or long.
A narrowing numeric conversion from double to float behaves in accordance with IEEE 754
The result is correctly rounded using IEEE 754 round to nearest mode.
A value too small to be represented as a float is converted to a positive or negative zero of type float; a value too large to be represented as a float is.
A double NaN is always converted to a float NaN.
Despite the fact that overflow, underflow, or loss of precision may occur, narrowing conversions among numeric types never cause the Java Virtual Machine to throw a run-time exception (not to be confused with an IEEE 754 floating-point exception)
Although both class instances and arrays are objects, the Java Virtual Machine creates and manipulates class instances and arrays using distinct sets of instructions:
Access fields of classes (static fields, known as class variables) and fields.
Load an array component onto the operand stack: baload, caload, saload, iaload, laload, faload, daload, aaload.
Store a value from the operand stack as an array component: bastore, castore, sastore, iastore, lastore, fastore, dastore, aastore.
The control transfer instructions conditionally or unconditionally cause the Java Virtual Machine to continue execution with an instruction other than the one following the control transfer instruction.
The Java Virtual Machine has distinct sets of instructions that conditionally branch on comparison with data of int and reference types.
It also has distinct conditional branch instructions that test for the null reference and thus it is not required to specify a concrete value for null (§2.4)
Conditional branches on comparisons between data of types boolean, byte, char, and short are performed using int comparison instructions (§2.11.1)
A conditional branch on a comparison between data of types long, float, or double is initiated using an instruction that compares the data and produces an int result of the comparison (§2.11.3)
A subsequent int comparison instruction tests this result and effects the conditional branch.
Because of its emphasis on int comparisons, the Java Virtual Machine provides a rich complement of conditional branch instructions for type int.
The following five instructions invoke methods: • invokevirtual invokes an instance method of an object, dispatching on the.
This is the normal method dispatch in the Java programming language.
The call site object was bound to a specific lexical occurrence of the invokedynamic instruction by the Java Virtual Machine as a result of running a bootstrap method before the first execution of the instruction.
Therefore, each occurrence of an invokedynamic instruction has a unique linkage state, unlike the other instructions which invoke methods.
The method return instructions, which are distinguished by return type, are ireturn (used to return values of type boolean, byte, char, short, or int), lreturn, freturn, dreturn, and areturn.
In addition, the return instruction is used to return from.
Exceptions can also be thrown by various Java Virtual Machine instructions if they detect an abnormal condition.
The Java Virtual Machine supports synchronization of both methods and sequences of instructions within a method by a single synchronization construct: the monitor.
Method-level synchronization is performed implicitly, as part of method invocation and return (§2.11.8)
When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly.
During the time the executing thread owns the monitor, no other thread may enter it.
If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method.
Synchronization of sequences of instructions is typically used to encode the synchronized block of the Java programming language.
The Java Virtual Machine supplies the monitorenter and monitorexit instructions to support such language constructs.
Proper implementation of synchronized blocks requires cooperation from a compiler targeting the Java Virtual Machine (§3.14)
Structured locking is the situation when, during a method invocation, every exit on a given monitor matches a preceding entry on that monitor.
Since there is no assurance that all code submitted to the Java Virtual Machine will perform structured locking, implementations of the Java Virtual Machine are permitted but not required to enforce both of the following two rules guaranteeing structured locking.
Let T be a thread and M be a monitor.
At no point during a method invocation may the number of monitor exits performed by T on M since the method invocation exceed the number of monitor entries performed by T on M since the method invocation.
Note that the monitor entry and exit automatically performed by the Java Virtual Machine when invoking a synchronized method are considered to occur during the calling method's invocation.
The Java Virtual Machine must provide sufficient support for the implementation of the class libraries of the Java SE platform.
Some of the classes in these libraries cannot be implemented without the cooperation of the Java Virtual Machine.
Classes that might require special support from the Java Virtual Machine include those that support:
Reflection, such as the classes in the package java.lang.reflect and the class Class.
The example classes cited above fall into this category as well.
Security, such as the classes in the package java.security and other classes such as SecurityManager.
Weak references, such as the classes in the package java.lang.ref.
The list above is meant to be illustrative rather than comprehensive.
An exhaustive list of these classes or of the functionality they provide is beyond the scope of this specification.
See the specifications of the Java SE platform class libraries for details.
Thus far this specification has sketched the public view of the Java Virtual Machine: the class file format and the instruction set.
The implementor may prefer to think of them as a means to securely communicate fragments of programs between hosts each implementing the Java SE platform, rather than as a blueprint to be followed exactly.
It is important to understand where the line between the public design and the able to read class files and must exactly implement the semantics of the Java Virtual Machine code therein.
One way of doing this is to take this document as a specification and to implement that specification literally.
But it is also perfectly feasible and desirable for the implementor to modify or optimize the implementation within the constraints of this specification.
So long as the class file format can be read and the semantics of its code are maintained, the implementor may implement these semantics in any way.
What is "under the hood" is the implementor's business, as long as the correct external interface is carefully maintained.
There are some exceptions: debuggers, profilers, and just-in-time code generators can each require access to elements of the Java Virtual Machine that are normally considered to be “under the hood.” Where appropriate, Oracle works with other Java Virtual Machine implementors and with tool vendors to develop common interfaces to the Java Virtual Machine for use by such tools, and to promote those interfaces across the industry.
The implementor can use this flexibility to tailor Java Virtual Machine implementations for high performance, low memory use, or portability.
What makes sense in a given implementation depends on the goals of that implementation.
The range of implementation options includes the following: • Translating Java Virtual Machine code at load-time or during execution into the.
Translating Java Virtual Machine code at load-time or during execution into the native instruction set of the host CPU (sometimes referred to as just-in-time, or JIT, code generation)
The existence of a precisely defined virtual machine and object file format need not significantly restrict the creativity of the implementor.
The Java Virtual Machine is designed to support many different implementations, providing new and interesting solutions while retaining compatibility between implementations.
Oracle's JDK software contains a compiler from source code written in the Java programming language to the instruction set of the Java Virtual Machine, and a run-time system that implements the Java Virtual Machine itself.
Understanding how one compiler utilizes the Java Virtual Machine is useful to the prospective compiler writer, as well as to one trying to understand the Java Virtual Machine itself.
Note that the term "compiler" is sometimes used when referring to a translator from the instruction set of a Java Virtual Machine to the instruction set of a specific CPU.
One example of such a translator is a just-in-time (JIT) code generator, which generates platform-specific instructions only after Java Virtual Machine code has been loaded.
This chapter does not address issues associated with code generation, only those associated with compiling source code written in the Java programming language to Java Virtual Machine instructions.
This chapter consists mainly of examples of source code together with annotated listings of the Java Virtual Machine code that the javac compiler in Oracle’s JDK release 1.0.2 generates for the examples.
You can use javap to generate additional examples of compiled methods.
The format of the examples should be familiar to anyone who has read assembly code.
The <index> is the index of the opcode of the instruction in the array that contains the bytes of Java Virtual Machine code for this method.
Alternatively, the <index> may be thought of as a byte offset from the beginning of the method.
Some of the material in the comments is emitted by javap; the rest is supplied by the authors.
The <index> prefacing each instruction may be used as the target of a control transfer instruction.
Note that the actual operands of Java Virtual Machine control transfer instructions are offsets from the addresses of the opcodes of those instructions; these operands are displayed by javap (and are shown in this chapter) as more easily read offsets into their methods.
We preface an operand representing a run-time constant pool index with a hash sign and follow the instruction by a comment identifying the run-time constant pool item referenced, as in:
For the purposes of this chapter, we do not worry about specifying details such as operand sizes.
Java Virtual Machine code exhibits a set of general characteristics imposed by the Java Virtual Machine's design and use of types.
In the first example we encounter many of these, and we consider them in some detail.
The spin method simply spins around an empty for loop 100 times:
The Java Virtual Machine is stack-oriented, with most operations taking one or more operands from the operand stack of the Java Virtual Machine's current frame or pushing results back onto the operand stack.
A new frame is created each time a method is invoked, and with it is created a new operand stack and set of local variables for use by that method (§2.6)
At any one point of the computation, there are thus likely to be many frames and equally many operand stacks per thread of control, corresponding to many nested method invocations.
Only the operand stack in the current frame is active.
The instruction set of the Java Virtual Machine distinguishes operand types by using distinct bytecodes for operations on its various data types.
The method spin operates only on values of type int.
The 100 is pushed using a bipush instruction, which fetches the value it pushes as an immediate operand.
A simple virtual machine would have also spent additional time fetching and decoding the explicit operand.
Use of implicit operands makes compiled code more compact and efficient.
The int i in spin is stored as Java Virtual Machine local variable 1
Because most Java Virtual Machine instructions operate on values popped from the operand stack rather than directly on local variables, instructions that transfer values between local variables and the operand stack are common in code compiled for the Java Virtual Machine.
These operations also have special support in the instruction set.
The use (and reuse) of local variables is the responsibility of the compiler writer.
The specialized load and store instructions should encourage the compiler writer to reuse local variables as much as is feasible.
The resulting code is faster, more compact, and uses less space in the frame.
Certain very frequent operations on local variables are catered to specially by the Java Virtual Machine.
The iinc instruction increments the contents of a local variable by a one-byte signed value.
The iinc instruction in spin increments the first local variable (its first operand) by 1 (its second operand)
The iinc instruction is very handy when implementing looping constructs.
The for loop of spin is accomplished mainly by these instructions:
If the spin example had used a data type other than int for the loop counter, the compiled code would necessarily change to reflect the different data type.
For instance, if instead of an int the spin example uses a double, as shown:
The instructions that operate on typed data are now specialized for type double.
The ldc2_w instruction will be discussed later in this chapter.) Recall that double values occupy two local variables, although they are only accessed using the lesser index of the two local variables.
This is also the case for values of type long.
Note that local variables of the local variable pairs used to store double values in doubleLocals must never be manipulated individually.
The Java Virtual Machine's opcode size of 1 byte results in its compiled code being very compact.
However, 1-byte opcodes also mean that the Java Virtual Machine instruction set must stay small.
As a compromise, the Java Virtual Machine does not provide equal support for all data types: it is not completely orthogonal (Table 2.2)
For example, the comparison of values of type int in the for statement of example spin can be implemented using a single if_icmplt instruction; however, there is no single instruction in the Java Virtual Machine instruction set that performs a conditional branch on values of type double.
The Java Virtual Machine provides the most direct support for data of type int.
This is partly in anticipation of efficient implementations of the Java Virtual Machine's operand stacks and local variable arrays.
It is also motivated by the frequency of int data in typical programs.
There are no byte, char, or short versions of the store, load, or add instructions, for instance.
It must be compiled for the Java Virtual Machine, as follows, using instructions operating on another type, most likely int, converting between short and int values as necessary to ensure that the results of operations on short data stay within the appropriate range:
The lack of direct support for byte, char, and short types in the Java Virtual Machine is not particularly painful, because values of those types are internally promoted to int (byte and short are sign-extended to int, char is zero-extended)
Operations on byte, char, and short data can thus be done using int instructions.
The only additional cost is that of truncating the values of int operations to valid ranges.
The long and floating-point types have an intermediate level of support in the Java Virtual Machine, lacking only the full complement of conditional control transfer instructions.
The Java Virtual Machine generally does arithmetic on its operand stack.
Operands for arithmetic operations are popped from the operand stack, and the results of operations are pushed back onto the operand stack.
Results of arithmetic subcomputations can thus be made available as operands of their nesting computation.
For instance, the calculation of ~(grain-1) is handled by these instructions:
These operands are popped from the operand stack and their difference pushed back onto the operand stack.
The difference is thus immediately available the result of the ixor instruction becomes an operand for the subsequent iand instruction.
Many numeric constants, as well as objects, fields, and methods, are accessed via the run-time constant pool of the current class.
The ldc and ldc_w instructions are used to access values in the run-time constant pool (including instances of class String) of types other than double and long.
The ldc_w instruction is used in place of ldc only when there is a large number of run-time constant pool items and a larger index is needed to access an item.
The ldc2_w instruction is used to access all values of types double and long; there is no non-wide variant.
Compilation of for statements was shown in an earlier section (§3.2)
Most of the Java programming language's other control constructs (if-then-else, do, while, break, and continue) are also compiled in the obvious ways.
As a further example, a while loop is compiled in an obvious way, although the specific control transfer instructions made available by the Java Virtual Machine vary by data type.
As usual, there is more support for data of type int, for example:
Note that the test of the while statement (implemented using the if_icmplt instruction) is at the bottom of the Java Virtual Machine code for the loop.
This was also the case in the spin examples earlier.) The test being at the bottom of the loop forces the use of a goto instruction to get to the test prior to the first iteration of the loop.
If that test fails, and the loop body is never entered, this extra instruction is wasted.
However, while loops are typically used when their body is expected to be run, often for many iterations.
For subsequent iterations, putting the test at the bottom of the loop saves a Java Virtual Machine instruction each time around the loop: if the test were at the top of the loop, the loop body would need a trailing goto instruction to get back to the top.
Control constructs involving other data types are compiled in similar ways, but must use the instructions available for those data types.
This leads to somewhat less efficient code because more Java Virtual Machine instructions are needed, for example:
Each floating-point type has two comparison instructions: fcmpl and fcmpg for type float, and dcmpl and dcmpg for type double.
NaN is unordered (§2.3.2), so all floating-point comparisons fail if either of their operands is NaN.
The compiler chooses the variant of the comparison instruction for the appropriate type that produces the same result whether the comparison fails on non-NaN values or encounters a NaN.
The dcmpl instruction achieves the same effect if the comparison is reversed:
Once again, whether the comparison fails on a non-NaN value or because it is passed a NaN, the dcmpl instruction pushes an int value onto the operand stack that causes the ifle to branch.
If both of the dcmp instructions did not exist, one of the example methods would have had to do more work to detect NaN.
If n arguments are passed to an instance method, they are received, by convention, in the local variables numbered 1 through n of the frame created for the new method invocation.
The arguments are received in the order they were passed.
By convention, an instance method is passed a reference to its instance in local variable 0
In the Java programming language the instance is accessible via the this keyword.
Class (static) methods do not have an instance, so for them this use of local variable 0 is unnecessary.
A class method starts using local variables at index 0
If the addTwo method were a class method, its arguments would be passed in a similar way to the first version:
The normal method invocation for a instance method dispatches on the runtime type of the object.
They are virtual, in C++ terms.) Such an invocation is implemented using the invokevirtual instruction, which takes as its argument an index to a run-time constant pool entry giving the internal form of the binary name of the class type of the object, the name of the method to invoke, and that method's descriptor (§4.3.3)
To invoke the addTwo method, defined earlier as an instance method, we might write:
The invocation is set up by first pushing a reference to the current instance, this, on to the operand stack.
When the frame for the addTwo method is created, the arguments passed to the method become the initial values of the new frame's local variables.
When it returns, its int return value is pushed onto the operand stack of the frame of the invoker, the add12and13 method.
The return value is thus put in place to be immediately returned to the invoker of add12and13
The ireturn instruction takes the int value returned by addTwo, on the operand stack of the current frame, and pushes it onto the operand stack of the frame of the invoker.
It then returns control to the invoker, making the invoker's frame current.
The Java Virtual Machine provides distinct return instructions for many of its numeric and reference data types, as well as a return instruction for methods with no return value.
The same set of return instructions is used for all varieties of method invocations.
The operand of the invokevirtual instruction (in the example, the run-time constant pool index #4) is not the offset of the method in the class instance.
The compiler does not know the internal layout of a class instance.
Instead, it generates symbolic references to the methods of an instance, which are stored in the run-time constant pool.
Those run-time constant pool items are resolved at run-time to determine the actual method location.
The same is true for all other Java Virtual Machine instructions that access class instances.
Invoking addTwoStatic, a class (static) variant of addTwo, is similar, as shown:
Compiling an invocation of a class (static) method is very much like compiling an invocation of an instance method, except this is not passed by the invoker.
The invokestatic instruction is always used to invoke class methods.
The invokespecial instruction must be used to invoke instance initialization methods (§3.8)
It is also used when invoking methods in the superclass (super) and when invoking private methods.
Note that methods called using the invokespecial instruction always pass this to the invoked method as its first argument.
To invoke the target of a method handle, a compiler must form a method descriptor that records the actual argument and return types.
A compiler may not perform method invocation conversions on the arguments; instead, it must push them on the stack according to their own unconverted types.
The compiler emits an invokevirtual instruction that references a descriptor which describes the argument and return types.
By special arrangement with method resolution (§5.4.3.3), an invokevirtual instruction which invokes the invokeExact or invoke methods of java.lang.invoke.MethodHandle will always link, provided the method descriptor is syntactically well-formed and the types named in the descriptor can be resolved.
Recall that at the level of the Java Virtual Machine, a constructor appears as a method with the compiler-supplied name <init>
This specially named method is known as the instance initialization method (§2.9)
Multiple instance initialization methods, corresponding to multiple constructors, may exist for a given class.
Once the class instance has been created and its instance variables, including those of the class and all of its superclasses, have been initialized to their default values, an instance initialization method of the new class instance is invoked.
Class instances are passed and returned (as reference types) very much like numeric values, although type reference has its own complement of instructions, for example:
The fields of a class instance (instance variables) are accessed using the getfield and putfield instructions.
If i is an instance variable of type int, the methods setIt and getIt, defined as:
As with the operands of method invocation instructions, the operands of the putfield and getfield instructions (the run-time constant pool index #4) are not the offsets of the fields in the class instance.
Those runtime constant pool items are resolved at run-time to determine the location of the field within the referenced object.
Arrays are created and manipulated using a distinct set of instructions.
The newarray instruction is used to create an array of a numeric type.
The anewarray instruction is used to create a one-dimensional array of object references, for example:
The anewarray instruction can also be used to create the first dimension of a multidimensional array.
Alternatively, the multianewarray instruction can be used to create several dimensions at once.
The first operand of the multianewarray instruction is the run-time constant pool index to the array class type to be created.
The second is the number of dimensions of that array type to actually create.
The multianewarray instruction can be used to create all the dimensions of the type, as the code for create3DArray shows.
Note that the multidimensional array is just an object and so is loaded and returned by an aload_1 and areturn instruction, respectively.
All arrays have associated lengths, which are accessed via the arraylength instruction.
Compilation of switch statements uses the tableswitch and lookupswitch instructions.
The tableswitch instruction is used when the cases of the switch can be efficiently represented as indices into a table of target offsets.
The default target of the switch is used if the value of the expression of the switch falls outside the range of valid indices.
The Java Virtual Machine's tableswitch and lookupswitch instructions operate only on int data.
Because operations on byte, char, or short values are internally promoted to int, a switch whose expression evaluates to one of those types is compiled as though it evaluated to type int.
If the chooseNear method had been written using type short, the same Java Virtual Machine instructions would have been generated as when using type int.
Other numeric types must be narrowed to type int for use in a switch.
Where the cases of the switch are sparse, the table representation of the tableswitch instruction becomes inefficient in terms of space.
The lookupswitch instruction pairs int keys (the values of the case labels) with target offsets in a table.
If one of the keys matches the value of the expression, execution continues at the associated target offset.
If no key matches, execution continues at the default target.
The Java Virtual Machine specifies that the table of the lookupswitch instruction must be sorted by key so that implementations may use searches more efficient than a linear scan.
Even so, the lookupswitch instruction must search its keys for a match rather than simply perform a bounds check and index into a table like tableswitch.
Thus, a tableswitch instruction is probably more efficient than a lookupswitch where space considerations permit a choice.
The Java Virtual Machine has a large complement of instructions that manipulate the contents of the operand stack as untyped values.
These are useful because of the Java Virtual Machine's reliance on deft manipulation of its operand stack.
Note that the Java Virtual Machine never allows its operand stack manipulation instructions to modify or break up individual values on the operand stack.
Looking more closely, the try block is compiled just as it would be if the try were not present:
If no exception is thrown during the execution of the try block, it behaves as though the try were not there: tryItOut is invoked and catchOne returns.
Following the try block is the Java Virtual Machine code that implements the single catch clause:
The invocation of handleExc, the contents of the catch clause, is also compiled like a normal method invocation.
If the value that is thrown is not an instance of TestExc, the catch clause of catchOne cannot handle it.
Instead, the value is rethrown to the invoker of catchOne.
Multiple catch clauses of a given try statement are compiled by simply appending the Java Virtual Machine code for each catch clause one after the other and adding entries to the exception table, as shown:
Control is transferred to the Java Virtual Machine code for the block of that catch clause.
If the value thrown does not match the parameter of any of the catch clauses of catchTwo, the Java Virtual Machine rethrows the value without invoking code in any catch clause of catchTwo.
Nested try-catch statements are compiled very much like a try statement with multiple catch clauses:
The nesting of catch clauses is represented only in the exception table.
The Java Virtual Machine does not enforce nesting of or any ordering of the exception table entries (§2.10)
However, because try-catch constructs are structured, a compiler can always order the entries of the exception handler table such that, for any thrown exception and any program counter value in that method, the first exception handler.
This is so even though the exception occurs within the bounds of the outer catch clause (catching TestExc2) and even though that outer catch clause might otherwise have been able to handle the thrown value.
As a subtle point, note that the range of a catch clause is inclusive on the "from" end and exclusive on the "to" end (§4.7.3)
Return instructions within nested catch clauses are included in the range of instructions covered by nesting catch clauses.
This section assumes a compiler generates class files with version number 50.0 or below, so that the jsr instruction may be used.
See also §4.10.2.5.) Compilation of a try-finally statement is similar to that of try-catch.
Prior to transferring control outside the try statement, whether that transfer is normal or abrupt, because an exception has been thrown, the finally clause must first be executed.
There are four ways for control to pass outside of the try statement: by falling through the bottom of that block, by returning, by executing a break or continue statement, or by raising an exception.
If tryItOut returns without raising an exception, control is transferred to the finally block using a jsr instruction.
In more detail, the subroutine call works as follows: The jsr instruction pushes the address of the following instruction (return at index 7) onto the operand stack before jumping.
The code for the finally block (in this case the aload_0 and invokevirtual instructions) is run.
Assuming execution of that code completes normally, the ret instruction retrieves the address from local variable 2 and resumes execution at that address.
A try statement with a finally clause is compiled to have a special exception handler, one that can handle any exception thrown within the try statement.
If tryItOut throws an exception, the exception table for tryFinally is searched for an appropriate exception handler.
The special handler is found, causing execution to continue at index 8
The following jsr instruction does a subroutine call to the code for the finally block.
Compiling a try statement with both a catch clause and a finally clause is more complex:
If tryItOut throws an instance of TestExc, the first (innermost) applicable exception handler in the exception table is chosen to handle the exception.
If an exception is not thrown by handleExc, tryCatchFinally returns normally.
That exception handler transfers control to index 20, where the thrown value is first stored in local.
The code for the finally block at index 26 is called as a subroutine.
If it returns, the thrown value is retrieved from local variable 1 and rethrown using the athrow instruction.
If a new value is thrown during execution of the finally clause, the finally clause aborts, and tryCatchFinally returns abruptly, throwing the new value to its invoker.
Synchronization in the Java Virtual Machine is implemented by monitor entry and exit, either explicitly (by use of the monitorenter and monitorexit instructions) or implicitly (by the method invocation and return instructions)
For code written in the Java programming language, perhaps the most common form of synchronization is the synchronized method.
A synchronized method is not normally implemented using monitorenter and monitorexit.
The monitorenter and monitorexit instructions enable the compilation of synchronized statements.
The compiler ensures that at any method invocation completion, a monitorexit instruction will have been executed for each monitorenter instruction executed since the method invocation.
To enforce proper pairing of monitorenter and monitorexit instructions on abrupt method invocation completion, the compiler generates exception handlers (§2.10) that will match any exception and whose associated code executes the necessary monitorexit instructions.
When the compiler encounters an annotated package declaration that must be made available at run time, it emits a class file that represents an interface whose name is the internal form (§4.2.1) of package-name.package-info.
The interface has default access (JLS §6.6.1) and no superinterfaces.
Each class file contains the definition of a single class or interface.
Although a class or interface need not have an external representation literally contained in a file (for instance, because the class is generated by a class loader), we will colloquially refer to any valid representation of a class or interface as being in the class file format.
A class file consists of a stream of 8-bit bytes.
Multibyte data items are always stored in big-endian order, where the high bytes come first.
In the Java SE platform, this format is supported by interfaces java.io.DataInput and java.io.DataOutput and classes such as java.io.DataInputStream and java.io.DataOutputStream.
In the Java SE platform, these types may be read by methods such as readUnsignedByte, readUnsignedShort, and readInt of the interface java.io.DataInput.
This chapter presents the class file format using pseudostructures written in a C-like structure notation.
To avoid confusion with the fields of classes and class instances, etc., the contents of the structures describing the class file format are referred to as items.
Successive items are stored in the class file sequentially, without padding or alignment.
Tables, consisting of zero or more variable-sized items, are used in several class file structures.
Although we use C-like array syntax to refer to table items, the fact that tables are streams of varying-sized structures means that it is not possible to translate a table index directly to a byte offset into the table.
Where we refer to a data structure as an array, it consists of zero or more contiguous fixed-sized items and can be indexed like an array.
Reference to an ASCII character in this chapter should be interpreted to mean the Unicode code point corresponding to the ASCII character.
The magic item supplies the magic number identifying the class file format; it has the value 0xCAFEBABE.
Together, a major and a minor version number determine the version of the class file format.
If a class file has major version number M and minor version number m, we denote the version of its class file format as M.m.
The release level of the Java SE platform to which a Java Virtual Machine implementation conforms is responsible for determining the range.
The format of each constant_pool table entry is indicated by its first "tag" byte.
The value of the access_flags item is a mask of flags used to denote access permissions to and properties of this class or interface.
The interpretation of each flag, when set, is as shown in Table 4.1
A class may be marked with the ACC_SYNTHETIC flag to indicate that it was generated by a compiler and does not appear in source code.
The ACC_ENUM flag indicates that this class or its superclass is declared as an enumerated type.
An interface is distinguished by its ACC_INTERFACE flag being set.
If its ACC_INTERFACE flag is not set, this class file defines a class, not an interface.
Compilers to the instruction set of the Java Virtual Machine should set the ACC_SUPER flag.
The ACC_SUPER flag exists for backward compatibility with code compiled by older compilers for the Java programming language.
They should be set to zero in generated class files and should be ignored by Java Virtual Machine implementations.
If the value of the super_class item is zero, then this class file must represent the class Object, the only class or interface without a direct superclass.
The value of the interfaces_count item gives the number of direct superinterfaces of this class or interface type.
The fields table includes only those fields that are declared by this class or interface.
It does not include items representing fields that are inherited from superclasses or superinterfaces.
The methods table does not include items representing methods that are inherited from superclasses or superinterfaces.
A Java Virtual Machine implementation is required to silently ignore any or all attributes in the attributes table of a ClassFile structure that it does not recognize.
Attributes not defined in this specification are not allowed to affect the semantics of the class file, but only to provide additional descriptive information (§4.7.1)
Class and interface names that appear in class file structures are always represented in a fully qualified form known as binary names (JLS §13.1)
For historical reasons, the syntax of binary names that appear in class file structures differs from the syntax of binary names documented in JLS §13.1
In this internal form, the ASCII periods (.) that normally separate the identifiers which make up the binary name are replaced by ASCII forward slashes (/)
For example, the normal binary name of class Thread is java.lang.Thread.
In the internal form used in descriptors in the class file format, a reference to the name of class Thread is implemented using a CONSTANT_Utf8_info structure representing the string java/lang/Thread.
Names of methods, fields, and local variables are stored as unqualified names.
An unqualified name must not contain any of the ASCII characters.
A descriptor is a string representing the type of a field or method.
A signature is a string representing the generic type of a field or method, or generic type information for a class declaration.
This grammar is a set of productions that describe how sequences of characters can form syntactically correct descriptors of various types.
Terminal symbols of the grammar are shown in bold fixed-width font.
The definition of a nonterminal is introduced by the name of the nonterminal being defined, followed by a colon.
One or more alternative right-hand sides for the nonterminal then follow on succeeding lines.
A nonterminal symbol on the right-hand side of a production that is followed by an asterisk (*) represents zero or more possibly different values produced from that nonterminal, appended without any intervening space.
Similarly, a nonterminal symbol on the right-hand side of a production that is followed by an plus sign (+) represents one or more possibly different values produced from that nonterminal, appended without any intervening space.
A field descriptor represents the type of a class, instance, or local variable.
It is a series of characters generated by the grammar:
The characters of BaseType, the L and ; of ObjectType, and the [ of ArrayType are all ASCII characters.
The ClassName represents a binary class or interface name encoded in internal form (§4.2.1)
The interpretation of field descriptors as types is as shown in Table 4.2
A field descriptor representing an array type is valid only if it represents a type with 255 or fewer dimensions.
The field descriptor of an instance variable of type int is simply I.
The field descriptor of an instance variable of type Object is Ljava/lang/Object;
Note that the internal form of the binary name for class Object is used.
A method descriptor represents the parameters that the method takes and the value that it returns:
A parameter descriptor represents a parameter passed to a method:
A return descriptor represents the type of the value returned from a method.
It is a series of characters generated by the grammar:
The character V indicates that the method returns no value (its return type is void)
A method descriptor is valid only if it represents method parameters with a total length of 255 or less, where that length includes the contribution for this in the case of instance or interface method invocations.
The total length is calculated by summing the contributions of the individual parameters, where a parameter of type long or double contributes two units to the length and a parameter of any other type contributes one unit.
Note that the internal forms of the binary names of Thread and Object are used.
The method descriptor for m is the same whether m is a class method or an instance method.
Although an instance method is passed this, a reference to the current class instance, in addition to its intended parameters, that fact is not reflected in the method descriptor.
The reference to this is passed implicitly by the method invocation instructions of the Java Virtual Machine that invoke instance methods (§2.6.1)
A reference to this is not passed to a class method.
Signatures are used to encode Java programming language type information that is not part of the Java Virtual Machine type system, such as generic type and method declarations and parameterized types.
This kind of type information is needed to support reflection and debugging, and by a Java compiler.
In the following, the terminal symbol Identifier is used to denote the name of a type, field, local variable, parameter, method, or type variable, as generated by a Java compiler.
Such a name must not contain any of the ASCII characters.
A class signature, defined by the production ClassSignature, is used to encode type information about a class declaration.
It describes any formal type parameters the class might have, and lists its (possibly parameterized) direct superclass and direct superinterfaces, if any.
A formal type parameter is described by its name, followed by its class and interface bounds.
If the class bound does not specify a type, it is taken to be Object.
A field type signature, defined by the production FieldTypeSignature, encodes the (possibly parameterized) type for a field, parameter or local variable.
A class type signature gives complete type information for a class or interface type.
The class type signature must be formulated such that it can be reliably mapped.
A method signature, defined by the production MethodTypeSignature, encodes the (possibly parameterized) types of the method's formal arguments and of the exceptions it has declared in its throws clause, its (possibly parameterized) return type, and any formal type parameters in the method declaration.
If the throws clause of a method or constructor does not involve type variables, the ThowsSignature may be elided from the MethodTypeSignature.
A Java compiler must output generic signature information for any class, interface, constructor or member whose generic signature in the Java programming language would include references to type variables or parameterized types.
The signature and descriptor (§4.3.3) of a given method or constructor may not correspond exactly, due to compiler-generated artifacts.
In particular, the number of TypeSignatures that encode formal arguments in MethodTypeSignature may be less than the number of ParameterDescriptors in MethodDescriptor.
Oracle's Java Virtual Machine implementation does not check the well-formedness of the signatures described in this subsection during loading or linking.
Instead, these checks are deferred until the signatures are used by reflective methods, as specified in the API of Class and members of java.lang.reflect.
Future versions of a Java Virtual Machine implementation may be required to perform some or all of these checks during loading or linking.
Java Virtual Machine instructions do not rely on the run-time layout of classes, interfaces, class instances, or arrays.
Instead, instructions refer to symbolic information in the constant_pool table.
The contents of the info array vary with the value of tag.
The valid tags and their values are listed in Table 4.3
Each tag byte must be followed by two or more bytes giving information about the specific constant.
The format of the additional information varies with the tag value.
The CONSTANT_Class_info structure is used to represent a class or an interface:
For such array classes, the name of the class is the descriptor of the array type.
For example, the class name representing a two-dimensional int array type.
The class name representing the type array of class Thread.
An array type descriptor is valid only if it represents 255 or fewer dimensions.
Fields, methods, and interface methods are represented by similar structures:
This constant_pool entry indicates the name and descriptor of the field or method.
Otherwise, the indicated descriptor must be a method descriptor (§4.3.3)
The return type of such a method must be void.
The CONSTANT_String_info structure is used to represent constant objects of the type String:
The bytes item of the CONSTANT_Integer_info structure represents the value of the int constant.
The bytes of the value are stored in big-endian (high byte first) order.
The bytes of the single format representation are stored in big-endian (high byte first) order.
The value represented by the CONSTANT_Float_info structure is determined as follows.
The bytes of the value are first converted into an int constant bits.
If bits is 0x7f800000, the float value will be positive infinity.
If bits is 0xff800000, the float value will be negative infinity.
In all other cases, let s, e, and m be three values that might be computed from bits:
In retrospect, making 8-byte constants take two constant pool entries was a poor choice.
The bytes of each item are stored in big-endian (high byte first) order.
The value represented by the CONSTANT_Double_info structure is determined as follows.
If bits is 0x7ff0000000000000L, the double value will be positive infinity.
If bits is 0xfff0000000000000L, the double value will be negative infinity.
In all other cases, let s, e, and m be three values that might be computed from bits:
The CONSTANT_NameAndType_info structure is used to represent a field or method, without indicating which class or interface type it belongs to:
The CONSTANT_Utf8_info structure is used to represent constant string values:
The value of the length item gives the number of bytes in the bytes array (not the length of the resulting string)
Modified UTF-8 strings are encoded so that code point sequences that contain only non-null ASCII characters can be.
The 7 bits of data in the byte give the value of the code point represented.
The three bytes represent the code point with the value:
Each of the surrogate code units is represented by three bytes.
This means supplementary characters are represented by six bytes, u, v, w, x, y, and z :
The six bytes represent the code point with the value:
The bytes of multibyte characters are stored in the class file in big-endian (high byte first) order.
There are two differences between this format and the "standard" UTF-8 format.
The Java Virtual Machine does not recognize the four-byte format of standard UTF-8; it uses its own two-times-three-byte format instead.
The CONSTANT_MethodHandle_info structure is used to represent a method handle:
The value denotes the kind of this method handle, which characterizes its bytecode behavior (§5.4.3.5)
The CONSTANT_MethodType_info structure is used to represent a method type:
No two fields in one class file may have the same name and descriptor (§4.3.2)
The value of the access_flags item is a mask of flags used to denote access permission to and properties of this field.
The interpretation of each flag, when set, is as shown in Table 4.4
A field may be marked with the ACC_SYNTHETIC flag to indicate that it was generated by a compiler and does not appear in source code.
The ACC_ENUM flag indicates that this field is used to hold an element of an enumerated type.
Fields of classes may set any of the flags in Table 4.4
They should be set to zero in generated class files and should be ignored by Java Virtual Machine implementations.
A field can have any number of attributes associated with it.
A Java Virtual Machine implementation is required to silently ignore any or all attributes that it does not recognize in the attributes table of a field_info structure.
Attributes not defined in this specification are not allowed to affect the semantics of the class file, but only to provide additional descriptive information (§4.7.1)
No two methods in one class file may have the same name and descriptor (§4.3.3)
The value of the access_flags item is a mask of flags used to denote access permission to and properties of this method.
The interpretation of each flag, when set, is as shown in Table 4.5
The ACC_VARARGS flag indicates that this method takes a variable number of arguments at the source code level.
The ACC_BRIDGE flag is used to indicate a bridge method generated by a Java compiler.
Methods of classes may set any of the flags in Table 4.5
Class and interface initialization methods (§2.9) are called implicitly by the Java Virtual Machine.
They should be set to zero in generated class files and should be ignored by Java Virtual Machine implementations.
A method can have any number of optional attributes associated with it.
A Java Virtual Machine implementation is required to silently ignore any or all attributes in the attributes table of a method_info structure that it does not recognize.
Attributes not defined in this specification are not allowed to affect the semantics of the class file, but only to provide additional descriptive information (§4.7.1)
The value of the attribute_length item indicates the length of the subsequent information in bytes.
Certain attributes are predefined as part of the class file specification.
They are listed in Table 4.6, accompanied by the version of the Java SE platform and the version of the class file format in which each first appeared.
Within the context of their use in this specification, that is, in the attributes tables of the class file structures in which they appear, the names of these predefined attributes are reserved.
Of the predefined attributes: • The ConstantValue, Code and Exceptions attributes must be recognized and.
The InnerClasses, EnclosingMethod and Synthetic attributes must be recognized and correctly read by a class file reader in order to properly implement the Java SE platform class libraries (§2.12)
Use of the remaining predefined attributes is optional; a class file reader may use the information they contain, or otherwise must silently ignore those attributes.
Compilers are permitted to define and emit class files containing new attributes in the attributes tables of class file structures.
Java Virtual Machine implementations are permitted to recognize and use new attributes found in the attributes tables of class file structures.
However, any attribute not defined as part of this Java Virtual Machine specification must not affect the semantics of class or interface types.
Java Virtual Machine implementations are required to silently ignore attributes they do not recognize.
For instance, defining a new attribute to support vendor-specific debugging is permitted.
Because Java Virtual Machine implementations are required to ignore attributes they do not recognize, class files intended for that particular Java Virtual Machine implementation will be usable by other implementations even if those implementations cannot make use of the additional debugging information that the class files contain.
Java Virtual Machine implementations are specifically prohibited from throwing an exception or otherwise refusing to use class files simply because of the presence of some new attribute.
Of course, tools operating on class files may not run correctly if given class files that do not contain all the attributes they require.
Two attributes that are intended to be distinct, but that happen to use the same attribute name and are of the same length, will conflict on implementations that recognize either attribute.
A ConstantValue attribute represents the value of a constant field.
There can be no more than one ConstantValue attribute in the attributes table of a given field_info structure.
This occurs prior to the invocation of the class or interface initialization method (§2.9) of that class or interface.
If a field_info structure representing a non-static field has a ConstantValue attribute, then that attribute must silently be ignored.
The constant_pool entry at that index gives the constant value represented by this attribute.
If the method is either native or abstract, its method_info structure must not have a Code attribute.
Otherwise, its method_info structure must have exactly one Code attribute.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
The value of the code_length item gives the number of bytes in the code array for this method.
The value of code_length must be greater than zero; the code array must not be empty.
Refer to the descriptions of those instructions for more information on the consequences of code array alignment.) The detailed constraints on the contents of the code array are extensive and are given in a separate section (§4.9)
The value of start_pc must be a valid index into the code array of the opcode of an instruction.
A compiler writer can work around this bug by limiting the maximum size of the generated Java Virtual Machine code for any method, instance initialization method, or static initializer (the size of any code array) to 65534 bytes.
The value of the handler_pc item indicates the start of the exception handler.
The value of the item must be a valid index into the code array and must be the index of the opcode of an instruction.
The exception handler will be called only if the thrown exception is an instance of the given class or one of its subclasses.
If the value of the catch_type item is zero, this exception handler is called for all exceptions.
The value of the attributes_count item indicates the number of attributes of the Code attribute.
A Code attribute can have any number of optional attributes associated with it.
A Java Virtual Machine implementation is required to silently ignore any or all attributes in the attributes table of a Code attribute that it does not recognize.
Attributes not defined in this specification are not allowed to affect the semantics of the class file, but only to provide additional descriptive information (§4.7.1)
The StackMapTable attribute is a variable-length attribute in the attributes table of a Code (§4.7.3) attribute.
A method's Code attribute may have at most one StackMapTable attribute.
A StackMapTable attribute consists of zero or more stack map frames.
Each stack map frame specifies (either explicitly or implicitly) a bytecode offset, the verification types (§4.10.1.2) for the local variables, and the verification types for the operand stack.
The type checker deals with and manipulates the expected types of a method's local variables and operand stack.
Throughout this section, a location refers to either a single local variable or to a single operand stack entry.
We will use the terms stack map frame and type state interchangeably to describe a mapping from locations in the operand stack and local variables of a method to verification types.
We will usually use the term stack map frame when such a mapping is provided in the class file, and the term type state when the mapping is used by the type checker.
In a class file whose version number is greater than or equal to 50.0, if a method's Code attribute does not have a StackMapTable attribute, it has an implicit stack map attribute.
This implicit stack map attribute is equivalent to a StackMapTable attribute with number_of_entries equal to zero.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
Each stack_map_frame structure specifies the type state at a particular bytecode offset.
Each frame type specifies (explicitly or implicitly) a value, offset_delta, that is used to calculate the actual bytecode offset at which a frame applies.
By using an offset delta rather than the actual bytecode offset we ensure, by definition, that stack map frames are in the correctly sorted order.
We say that an instruction in the bytecode has a corresponding stack map frame if the instruction starts at offset i in the code array of a Code attribute, and the Code attribute has a StackMapTable attribute whose entries array has a stack_map_frame structure that applies at bytecode offset i.
The stack_map_frame structure consists of a one-byte tag followed by zero or more bytes, giving more information, depending upon the tag.
A stack map frame may belong to one of several frame types:
All frame types, even full_frame, rely on the previous frame for some of their semantics.
This raises the question of what is the very first frame? The initial frame is implicit, and computed from the method descriptor.
Tags in the range [128-246] are reserved for future use.
If the frame type is same_frame_extended, it means the frame has exactly the same locals as the previous stack map frame and that the number of stack items is zero.
The 0th entry in locals represents the type of the first additional local variable.
It is an error if, for any index i, locals[i] represents a local variable whose index is greater than the maximum number of local variables for the method.
It is an error if, for any index i, locals[i] represents a local variable whose index is greater than the maximum number of local variables for the method.
The 0th entry in stack represents the type of the bottom of the stack, and subsequent entries represent types of stack elements closer to the top of the operand stack.
It is an error if, for any index i, stack[i] represents a stack entry whose index is greater than the maximum operand stack size for the method.
The verification_type_info structure consists of a one-byte tag followed by zero or more bytes, giving more information about the tag.
The Top_variable_info type indicates that the local variable has the verification type top.
The Integer_variable_info type indicates that the location contains the verification type int.
The Float_variable_info type indicates that the location contains the verification type float.
The Long_variable_info type indicates that the location contains the verification type long.
This structure gives the contents of two locations in the operand stack or in the local variable array.
If the location is a local variable, then: ◆ It must not be the local variable with the highest index.
The next higher numbered local variable contains the verification type top.
If the location is an operand stack entry, then: ◆ The current location must not be the topmost location of the operand stack.
The next location closer to the top of the operand stack contains the verification.
The Double_variable_info type indicates that the location contains the verification type double.
This structure gives the contents of two locations in the operand stack or in the local variable array.
If the location is a local variable, then: ◆ It must not be the local variable with the highest index.
The next higher numbered local variable contains the verification type top.
If the location is an operand stack entry, then: ◆ The current location must not be the topmost location of the operand stack.
The next location closer to the top of the operand stack contains the verification.
The Null_variable_info type indicates that location contains the verification type null.
The UninitializedThis_variable_info type indicates that the location contains the verification type uninitializedThis.
The Uninitialized_variable_info type indicates that the location contains the verification type uninitialized(offset)
The Exceptions attribute indicates which checked exceptions a method may throw.
There may be at most one Exceptions attribute in each method_info structure.
The value of the attribute_length item indicates the attribute length, excluding the initial six bytes.
A method should throw an exception only if at least one of the following three criteria is met:
The exception is an instance of RuntimeException or one of its subclasses.
The exception is an instance of Error or one of its subclasses.
The exception is an instance of one of the exception classes specified in the exception_index_table just described, or one of their subclasses.
These requirements are not enforced in the Java Virtual Machine; they are enforced only at compile-time.
The InnerClasses attribute is a variable-length attribute in the attributes table of a ClassFile structure (§4.1)
If the constant pool of a class or interface C contains a CONSTANT_Class_info entry which represents a class or interface that is not a member of a package, then C's ClassFile structure must have exactly one InnerClasses attribute in its attributes table.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
The value of the number_of_classes item indicates the number of entries in the classes array.
If a class has members that are classes or interfaces, its constant_pool table (and hence its InnerClasses attribute) must refer to each such member, even if that member is not otherwise mentioned by the class.
These rules imply that a nested class or interface member will have InnerClasses information for each enclosing class and for each immediate member.
Each classes array entry contains the following four items: inner_class_info_index.
The remaining items in the classes array entry give information about C.
The value of the inner_class_access_flags item is a mask of flags used to denote access permissions to and properties of class or interface C as declared in the source code from which this class file was compiled.
It is used by a compiler to recover the original information when source code is not available.
They should be set to zero in generated class files and should be ignored by Java Virtual Machine implementations.
Oracle's Java Virtual Machine implementation does not check the consistency of an InnerClasses attribute against a class file representing a class or interface referenced by the attribute.
The EnclosingMethod attribute is an optional fixed-length attribute in the attributes table of a ClassFile structure (§4.1)
A class must have an EnclosingMethod attribute if and only if it is a local class or an anonymous class.
A class may have no more than one EnclosingMethod attribute.
If the current class is not immediately enclosed by a method or constructor, then the value of the method_index item must be zero.
It is the responsibility of a Java compiler to ensure that the method identified via the method_index is indeed the closest lexically enclosing method of the class that contains this EnclosingMethod attribute.
A class member that does not appear in the source code must be marked using a Synthetic attribute, or else it must have its ACC_SYNTHETIC flag set.
The only exceptions to this requirement are compiler-generated methods which are not considered implementation artifacts, namely the instance initialization method representing a default constructor of the Java programming language (§2.9), the class initialization.
The Synthetic attribute was introduced in JDK release 1.1 to support nested classes and interfaces.
The Signature attribute records generic signature information for any class, interface, constructor or member whose generic signature in the Java programming language would include references to type variables or parameterized types.
The SourceFile attribute is an optional fixed-length attribute in the attributes table of a ClassFile structure (§4.1)
There can be no more than one SourceFile attribute in the attributes table of a given ClassFile structure.
The string referenced by the sourcefile_index item will be interpreted as indicating the name of the source file from which this class file was compiled.
It will not be interpreted as indicating the name of a directory containing the file or an absolute path name for the file; such platform-specific additional information must be supplied by the run-time interpreter or development tool at the time the file name is actually used.
The SourceDebugExtension attribute is an optional attribute in the attributes table of a ClassFile structure (§4.1)
There can be no more than one SourceDebugExtension attribute in the attributes table of a given ClassFile structure.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
Note that the debug_extension array may denote a string longer than that which can be represented with an instance of class String.
The LineNumberTable attribute is an optional variable-length attribute in the attributes table of a Code (§4.7.3) attribute.
It may be used by debuggers to determine which part of the Java Virtual Machine code array corresponds to a given line number in the original source file.
If LineNumberTable attributes are present in the attributes table of a given Code attribute, then they may appear in any order.
Furthermore, multiple LineNumberTable attributes may together represent a given line of a source file; that is, LineNumberTable attributes need not be one-to-one with source lines.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
The value of the start_pc item must indicate the index into the code array at which the code for a new line in the original source file begins.
The value of the line_number item must give the corresponding line number in the original source file.
The LocalVariableTable attribute is an optional variable-length attribute in the attributes table of a Code (§4.7.3) attribute.
It may be used by debuggers to determine the value of a given local variable during the execution of a method.
If LocalVariableTable attributes are present in the attributes table of a given Code attribute, then they may appear in any order.
There may be no more than one LocalVariableTable attribute per local variable in the Code attribute.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
It also indicates the index into the local variable array of the current frame at which that local variable can be found.
Each entry must contain the following five items: start_pc, length.
The value of start_pc must be a valid index into the code array of this Code attribute and must be the index of the opcode of an instruction.
The given local variable must be at index in the local variable array of the current frame.
The LocalVariableTypeTable attribute is an optional variable-length attribute in the attributes table of a Code (§4.7.3) attribute.
It may be used by debuggers to determine the value of a given local variable during the execution of a method.
If LocalVariableTypeTable attributes are present in the attributes table of a given Code attribute, then they may appear in any order.
There may be no more than one LocalVariableTypeTable attribute per local variable in the Code attribute.
The LocalVariableTypeTable attribute differs from the LocalVariableTable attribute in that it provides signature information rather than descriptor information.
This difference is only significant for variables whose type is a generic reference type.
Such variables will appear in both tables, while variables of other types will appear only in LocalVariableTable.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
It also indicates the index into the local variable array of the current frame at which that local variable can be found.
Each entry must contain the following five items: start_pc, length.
The value of start_pc must be a valid index into the code array of this Code attribute and must be the index of the opcode of an instruction.
The given local variable must be at index in the local variable array of the current frame.
A class, interface, method, or field may be marked using a Deprecated attribute to indicate that the class, interface, method, or field has been superseded.
A run-time interpreter or tool that reads the class file format, such as a compiler, can use this marking to advise the user that a superceded class, interface, method, or field is being referred to.
The presence of a Deprecated attribute does not alter the semantics of a class or interface.
The RuntimeVisibleAnnotations attribute records run-time-visible Java programming language annotations on the corresponding class, field, or method.
The Java Virtual Machine must make these annotations available so they can be returned by the appropriate reflective APIs.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
The value of the attribute_length item is thus dependent on the number of run-time-visible annotations represented by the structure, and their values.
The value of the num_annotations item gives the number of run-time-visible annotations represented by the structure.
Note that a maximum of 65535 run-time-visible Java programming language annotations may be directly attached to a program element.
Each value of the annotations table represents a single run-time-visible annotation on a program element.
The value of the num_element_value_pairs item gives the number of element-value pairs of the annotation represented by this annotation structure.
Note that a maximum of 65535 element-value pairs may be contained in a single annotation.
Each value of the element_value_pairs table represents a single elementvalue pair in the annotation represented by this annotation structure.
The value of the value item represents the value of the element-value pair represented by this element_value_pairs entry.
The element_value structure is a discriminated union representing the value of an element-value pair.
It is used to represent element values in all attributes that describe annotations (RuntimeVisibleAnnotations, RuntimeInvisibleAnnotations, RuntimeVisibleParameterAnnotations, and RuntimeInvisibleParameterAnnotations)
The tag item indicates the type of this annotation element-value pair.
These letters are interpreted as if they were field descriptors (§4.3.2)
The other legal values for tag are listed with their interpretations in Table 4.9
The value item represents the value of this annotation element.
The tag item, above, determines which item of the union is to be used: const_value_index.
The enum_const_value item is used if the tag item is e.
The class_info_index item is used if the tag item is c.
Note that a maximum of 65535 elements are permitted in an array-typed element value.
Each value of the values table gives the value of an element of the array-typed value represented by this element_value structure.
The RuntimeInvisibleAnnotations attribute is similar to the RuntimeVisibleAnnotations attribute, except that the annotations represented by a RuntimeInvisibleAnnotations attribute must not be made available for return by reflective APIs, unless the Java Virtual Machine has been instructed to retain these annotations via some implementation-specific mechanism such as a command line flag.
In the absence of such instructions, the Java Virtual Machine ignores this attribute.
The RuntimeInvisibleAnnotations attribute records run-timeinvisible Java programming language annotations on the corresponding class, method, or field.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
The value of the attribute_length item is thus dependent on the number of run-time-invisible annotations represented by the structure, and their values.
The value of the num_annotations item gives the number of run-time-invisible annotations represented by the structure.
Note that a maximum of 65535 run-time-invisible Java programming language annotations may be directly attached to a program element.
Each value of the annotations table represents a single run-time-invisible annotation on a program element.
The RuntimeVisibleParameterAnnotations attribute records run-time-visible Java programming language annotations on the parameters of the corresponding method.
Each method_info structure may contain at most one RuntimeVisibleParameterAnnotations attribute, which records all the runtime-visible Java programming language annotations on the parameters of the corresponding method.
The Java Virtual Machine must make these annotations available so they can be returned by the appropriate reflective APIs.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
The value of the attribute_length item is thus dependent on the number of parameters, the number of run-time-visible annotations on each parameter, and their values.
This duplicates information that could be extracted from the method descriptor (§4.3.3).)
Each value of the parameter_annotations table represents all of the runtime-visible annotations on a single parameter.
The sequence of values in the table corresponds to the sequence of parameters in the method descriptor.
Each value of the annotations table represents a single run-time-visible annotation on the parameter corresponding to the sequence number of this parameter_annotations element.
The RuntimeInvisibleParameterAnnotations attribute is similar to the RuntimeVisibleParameterAnnotations attribute, except that the annotations represented by a RuntimeInvisibleParameterAnnotations attribute must not be made available for return by reflective APIs, unless the Java Virtual Machine has specifically been instructed to retain these annotations via some implementationspecific mechanism such as a command line flag.
In the absence of such instructions, the Java Virtual Machine ignores this attribute.
The RuntimeInvisibleParameterAnnotations attribute records run-time-invisible Java programming language annotations on the parameters of the corresponding method.
Each method_info structure may contain at most one RuntimeInvisibleParameterAnnotations attribute, which records all the runtime-invisible Java programming language annotations on the parameters of the corresponding method.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
The value of the attribute_length item is thus dependent on the number of parameters, the number of run-time-invisible annotations on each parameter, and their values.
This duplicates information that could be extracted from the method descriptor (§4.3.3).)
Each value of the parameter_annotations table represents all of the runtime-invisible annotations on a single parameter.
The sequence of values in the table corresponds to the sequence of parameters in the method descriptor.
Each value of the annotations table represents a single run-time-invisible annotation on the parameter corresponding to the sequence number of this parameter_annotations element.
The AnnotationDefault attribute records the default value for the element represented by the method_info structure.
Each method_info structure representing an element of an annotation type may contain at most one AnnotationDefault attribute.
The Java Virtual Machine must make this default value available so it can be applied by appropriate reflective APIs.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
The value of the attribute_length item is thus dependent on the default value.
The default_value item represents the default value of the annotation type element whose default value is represented by this AnnotationDefault attribute.
The BootstrapMethods attribute is a variable-length attribute in the attributes table of a ClassFile structure (§4.1)
The BootstrapMethods attribute records bootstrap method specifiers referenced by invokedynamic instructions (§invokedynamic)
There can be no more than one BootstrapMethods attribute in the attributes table of a given ClassFile structure.
The value of the attribute_length item indicates the length of the attribute, excluding the initial six bytes.
The value of the attribute_length item is thus dependent on the number of invokedynamic instructions in this ClassFile structure.
The first four bytes must contain the right magic number.
The class file must not be truncated or have extra bytes at the end.
The constant pool must not contain any superficially unrecognizable information.
This check for basic class file integrity is necessary for any interpretation of the class file contents.
Historically, format checking has been confused with bytecode verification, because both are a form of integrity check.
This section describes the constraints associated with the contents of the Code_attribute structure.
The static constraints on a class file are those defining the well-formedness of the file.
With the exception of the static constraints on the Java Virtual Machine code of the class file, these constraints have been given in the previous sections.
The static constraints on the Java Virtual Machine code in a class file specify how Java Virtual Machine instructions must be laid out in the code array and what the operands of individual instructions must be.
The static constraints on the instructions in the code array are as follows:
The opcode of the first instruction in the code array begins at index 0
Only instances of the instructions documented in §6.5 may appear in the code.
Instances of instructions using the reserved opcodes (§6.2) or any opcodes not documented in this specification must not appear in the code array.
For each instruction in the code array except the last, the index of the opcode of the next instruction equals the index of the opcode of the current instruction plus the length of that instruction, including all its operands.
The wide instruction is treated like any other instruction for these purposes; the opcode specifying the operation that a wide instruction is to modify is treated as one of the operands of that wide instruction.
That opcode must never be directly reachable by the computation.
The static constraints on the operands of instructions in the code array are as follows:
The target of a jump or branch instruction must never be the opcode used to specify the operation to be modified by a wide instruction; a jump or branch target may be the wide instruction itself.
Each target, including the default, of each tableswitch instruction must be the opcode of an instruction within this method.
Each tableswitch instruction must have a number of entries in its jump table that is consistent with the value of its low and high jump table operands, and its low value must be less than or equal to its high value.
No target of a tableswitch instruction may be the opcode used to specify the operation to be modified by a wide instruction; a tableswitch target may be a wide instruction itself.
Each target, including the default, of each lookupswitch instruction must be the opcode of an instruction within this method.
Each lookupswitch instruction must have a number of match-offset pairs that is consistent with the value of its npairs operand.
The match-offset pairs must be sorted in increasing numerical order by signed match value.
No target of a lookupswitch instruction may be the opcode used to specify the operation to be modified by a wide instruction; a lookupswitch target may be a wide instruction itself.
In addition, the subsequent constant pool index must also be a valid index into the constant pool, and the constant pool entry at that index must not be used.
The operands of each getfield, putfield, getstatic, and putstatic instruction must represent a valid index into the constant_pool table.
The constant pool entry referenced by that index must be of type CONSTANT_Fieldref.
The indexbyte operands of each invokevirtual, invokespecial, and invokestatic instruction must represent a valid index into the constant_pool table.
The constant pool entry referenced by that index must be of type CONSTANT_Methodref.
The indexbyte operands of each invokedynamic instruction must represent a valid index into the constant_pool table.
The constant pool entry referenced by that index must be of type CONSTANT_InvokeDynamic.
The third and fourth operand bytes of each invokedynamic instruction must have the value zero.
Only the invokespecial instruction is allowed to invoke an instance initialization method (§2.9)
In particular, the class or interface initialization method specially named <clinit> is never called explicitly from Java Virtual Machine instructions, but only implicitly by the Java Virtual Machine itself.
The indexbyte operands of each invokeinterface instruction must represent a valid index into the constant_pool table.
The constant pool entry referenced by that index must be of type CONSTANT_InterfaceMethodref.
The fourth operand byte of each invokeinterface instruction must have the value zero.
The operands of each instanceof, checkcast, new, and anewarray instruction and the indexbyte operands of each multianewarray instruction must represent a valid index into the constant_pool table.
The constant pool entry referenced by that index must be of type CONSTANT_Class.
No anewarray instruction may be used to create an array of more than 255 dimensions.
The new instruction cannot be used to create an array.
A multianewarray instruction must be used only to create an array of a type that has at least as many dimensions as the value of its dimensions operand.
That is, while a multianewarray instruction is not required to create all of the dimensions of the array type referenced by its indexbyte operands, it must not attempt to create more dimensions than are in the array type.
The dimensions operand of each multianewarray instruction must not be zero.
The structural constraints on the code array specify constraints on relationships between Java Virtual Machine instructions.
Each instruction must only be executed with the appropriate type and number of arguments in the operand stack and local variable array, regardless of the execution path that leads to its invocation.
An instruction operating on values of type int is also permitted to operate on values of type boolean, byte, char, and short.
If an instruction can be executed along several different execution paths, the operand stack must have the same depth (§2.6.2) prior to the execution of the instruction, regardless of the path taken.
At no point during execution can the order of the local variable pair holding a value of type long or double be reversed or the pair split up.
At no point can the local variables of such a pair be operated on individually.
No local variable (or local variable pair, in the case of a value of type long or double) can be accessed before it is assigned a value.
At no point during execution can more values be popped from the operand stack than it contains.
Each invokespecial instruction must name an instance initialization method (§2.9), a method in the current class, or a method in a superclass of the current class.
If an invokespecial instruction names an instance initialization method from a class that is not the current class or a superclass, and the target reference on the operand stack is a class instance created by an earlier new instruction, then invokespecial must name an instance initialization method from the class of that class instance.
When the instance initialization method (§2.9) is invoked, an uninitialized class instance must be in an appropriate position on the operand stack.
An instance initialization method must never be invoked on an initialized class instance.
When any instance method is invoked or when any instance variable is accessed, the class instance that contains the instance method or instance variable must already be initialized.
There must never be an uninitialized class instance on the operand stack or in a local variable at the target of a backwards branch unless the special type of the uninitialized class instance at the branch instruction is merged with itself at the target of the branch (§4.10.2.4)
There must never be an uninitialized class instance in a local variable in code protected by an exception handler (§4.10.2.4)
There must never be an uninitialized class instance on the operand stack or in a local variable when a jsr or jsr_w instruction is executed.
Each instance initialization method (§2.9), except for the instance initialization method derived from the constructor of class Object, must call either another instance initialization method of this or an instance initialization method of its direct superclass super before its instance members are accessed.
However, instance fields of this that are declared in the current class may be assigned before calling any instance initialization method.
The type of every class instance that is the target of a method invocation instruction must be assignment compatible (JLS §5.2) with the class or interface type specified in the instruction.
In addition, the type of the target of an invokespecial instruction must be assignment compatible with the current class, unless an instance initialization method is being invoked.
Each return instruction must match its method's return type: ◆ If the method returns a boolean, byte, char, short, or int, only the ireturn.
If the method returns a float, long, or double, only an freturn, lreturn, or.
If the method returns a reference type, it must do so using an areturn.
All instance initialization methods, class or interface initialization methods, and methods declared to return void must use only the return instruction.
If getfield or putfield is used to access a protected field declared in a superclass that is a member of a different run-time package than the current class, then the type of the class instance being accessed must be the same as or a subclass of the current class.
If invokevirtual or invokespecial is used to access a protected method declared in a superclass that is a member of a different run-time package than the current.
The type of every class instance accessed by a getfield instruction or modified by a putfield instruction must be assignment compatible (JLS §5.2) with the class type specified in the instruction.
If the descriptor type is float, long, or double, then the value must be a float, long, or double, respectively.
If the descriptor type is a reference type, then the value must be of a type that is assignment compatible (JLS §5.2) with the descriptor type.
The type of every value stored into an array by an aastore instruction must be a reference type.
The component type of the array being stored into by the aastore instruction must also be a reference type.
Each athrow instruction must throw only values that are instances of class Throwable or of subclasses of Throwable.
Each class mentioned in a catch_type item of a method's exception table must be Throwable or a subclass of Throwable.
Execution never falls off the bottom of the code array.
No return address (a value of type returnAddress) may be loaded from a local.
The instruction following each jsr or jsr_w instruction may be returned to only.
No jsr or jsr_w instruction that is returned to may be used to recursively call.
Subroutines can be nested when using try-finally constructs from within a finally clause.)
Each instance of type returnAddress can be returned to at most once.
If a ret instruction returns to a point in the subroutine call chain above the ret instruction corresponding to a given instance of type returnAddress, then that instance can never be used as a return address.
Even though a compiler for the Java programming language must only produce class files that satisfy all the static and structural constraints in the previous sections, the Java Virtual Machine has no guarantee that any file it is asked to load was generated by that compiler or is properly formed.
Applications such as web browsers do not download source code, which they then compile; these applications download already-compiled class files.
The browser needs to determine whether the class file was produced by a trustworthy compiler or by an adversary attempting to exploit the Java Virtual Machine.
A user may have successfully compiled a class, say PurchaseStockOptions, to be a subclass of TradingClass.
But the definition of TradingClass might have changed since the time the class was compiled in a way that is not compatible with pre-existing binaries.
Methods might have been deleted or had their return types or modifiers changed.
Fields might have changed types or changed from instance variables to class variables.
The access modifiers of a method or variable may have changed from public to private.
Because of these potential problems, the Java Virtual Machine needs to verify for itself that the desired constraints are satisfied by the class files it attempts to incorporate.
A Java Virtual Machine implementation verifies that each class file satisfies the necessary constraints at linking time (§5.4)
Expensive checks that would otherwise have to be performed to verify constraints at run time for each interpreted instruction can be eliminated.
The Java Virtual Machine can assume that these checks have already been performed.
For example, the Java Virtual Machine will already know the following: • There are no operand stack overflows or underflows.
The arguments to all the Java Virtual Machine instructions are of valid types.
The verifier also performs verification that can be done without looking at the code array of the Code attribute (§4.7.3)
The checks performed include the following: • Ensuring that final classes are not subclassed and that final methods are not.
Checking that every class (except Object) has a direct superclass.
Ensuring that the constant pool satisfies the documented static constraints; for.
Checking that all field references and method references in the constant pool have valid names, valid classes, and a valid type descriptor.
Note that these checks do not ensure that the given field or method actually exists in the given class, nor do they check that the type descriptors given refer to real classes.
More detailed checking is performed when the bytecodes themselves are verified, and during resolution.
There are two strategies that Java Virtual Machine implementations may use for verification:
Verification by type checking must be used to verify class files whose version number is greater than or equal to 50.0
Verification by type inference must be supported by all Java Virtual Machine implementations, except those conforming to the Java ME CLDC and Java Card profiles, in order to verify class files whose version number is less than 50.0
This is a pragmatic adjustment, designed to ease the transition to the new verification discipline.
Many tools that manipulate class files may alter the bytecodes of a method in a manner that requires adjustment of the method's stack map frames.
If a tool does not make the necessary adjustments to the stack map frames, type checking may fail even.
To allow implementors time to adapt their tools, Java Virtual Machine implementations may fall back to the older verification discipline, but only for a limited time.
In cases where type checking fails but type inference is invoked and succeeds, a certain performance penalty is expected.
It also should serve as a signal to tool vendors that their output needs to be adjusted, and provides vendors with additional incentive to make these adjustments.
If a Java Virtual Machine implementation ever attempts to perform verification by type inference on version 50.0 class files, it must do so in all cases where verification by type checking fails.
This means that a Java Virtual Machine implementation cannot choose to resort to type inference in once case and not in another.
It must either reject class files that do not verify via type checking, or else consistently failover to the type inferencing verifier whenever type checking fails.
The type checker enforces type rules that are specified by means of Prolog clauses.
English language text is used to describe the type rules in an informal way, while the Prolog clauses provide a formal specification.
The type checker requires a list of stack map frames for each method with a Code attribute (§4.7.3)
A list of stack map frames is given by the StackMapTable attribute (§4.7.4) of a Code attribute.
The intent is that a stack map frame must appear at the beginning of each basic block in a method.
The stack map frame specifies the verification type of each operand stack entry and of each local variable at the start of each basic block.
The type checker reads the stack map frames for each method with a Code attribute and uses these maps to generate a proof of the type safety of the instructions in the Code attribute.
A class is type safe if all its methods are type safe, and it does not subclass a final class.
The Prolog predicate classIsTypeSafe assumes that Class is a Prolog term representing a binary class that has been successfully parsed and loaded.
This specification does not mandate the precise structure of this term, but does require that certain predicates be defined upon it.
For example, we assume a predicate classMethods(Class, Methods) that, given a term representing a class as described above as its first argument, binds its second argument to a list comprising all the methods of the class, represented in a convenient form described later.
Iff the predicate classIsTypeSafe is not true, the type checker must throw the exception VerifyError to indicate that the class file is malformed.
Otherwise, the class file has type checked successfully and bytecode verification has completed successfully.
The rest of this section explains the process of type checking in detail: • First, we give Prolog predicates for core Java Virtual Machine artifacts like.
Second, we specify the type system known to the type checker (§4.10.1.2)
Third, we specify the Prolog representation of instructions and stack map frames.
Fourth, we specify how a method is type checked, for methods without code.
Finally, we specify the rules to type check each instruction (§4.10.1.9)
We stipulate the existence of 22 Prolog predicates ("accessors") that have certain expected behavior but whose formal definitions are not given in this specification.
Each attribute is represented as a functor application of the form attribute(AttributeName, AttributeContents), where AttributeName is the name of the attribute.
Extracts the instruction stream, ParsedCode, of the method Method in Class, as well as the maximum operand stack size, MaxStack, the maximal number of local variables, FrameSize, the exception handlers, Handlers, and the stack map StackMap.
When type checking a method's body, it is convenient to access information about the method.
For this purpose, we define an environment, a six-tuple consisting of: • a class.
We specify additional predicates to extract higher-level information from the environment.
Finally, we specify a general predicate used throughout the type rules:
The principle guiding the determination as to which accessors are stipulated and which are fully specified is that we do not want to over-specify the representation of the class file.
Providing specific accessors to the Class or Method term would force us to completely specify the format for a Prolog term representing the class file.
The type checker enforces a type system based upon a hierarchy of verification types, illustrated below.
The only exceptions are the field descriptors B, C, S, and Z, all of which correspond to the verification type int.
The verification types which are not reference types in the Java programming language have subtype rules of the form:
That is, v is a subtype of X if the direct supertype of v is a subtype of X.
These subtype rules are not necessarily the most obvious formulation of subtyping.
There is a clear split between subtyping rules for reference types in the Java programming language, and rules for the remaining verification types.
The split allows us to state general subtyping relations between Java programming language reference types and other verification types.
These relations hold independently of a Java reference type's position in the type hierarchy, and help to prevent excessive class loading by a Java Virtual Machine implementation.
For example, we do not want to start climbing the Java superclass hierarchy in response to a query of the form class(foo, L) <: twoWord.
We also have a rule that says subtyping is reflexive, so together these rules cover most verification types that are not reference types in the Java programming language.
Subtype rules for the reference types in the Java programming language are specified recursively with isJavaAssignable.
The intent is also that array types are subtypes of Cloneable and java.io.Serializable.
Subtyping between arrays of primitive type is the identity relation.
Individual bytecode instructions are represented in Prolog as terms whose functor is the name of the instruction and whose arguments are its parsed operands.
For example, an aload instruction is represented as the term aload(N), which includes the index N that is the operand of the instruction.
The instructions as a whole are represented as a list of terms of the form:
The order of instructions in this list must be the same as in the class file.
A few instructions have operands that are constant pool entries representing fields, methods, and dynamic call sites.
Such structures are represented as functor applications of the form: • field(FieldClassName, FieldName, FieldDescriptor) for a field,
For clarity, we assume that field and method descriptors (§4.3.2) are mapped into more readable names: the leading L and trailing ; are dropped from class names, and the BaseType characters used for primitive types are mapped to the names of those types.
For example, a getfield instruction whose operand was an index into the constant pool that refers to a field foo of type F in class Bar would be represented as getfield(field('Bar', 'foo', 'F'))
Stack map frames are represented in Prolog as a list of terms of the form:
The order of stack map frames in this list must be the same as in the class file.
Locals is a list of verification types, such that the Nth element of the list (with 0-based indexing) represents the type of local variable N.
If any local variable in Locals has the type uninitializedThis, then Flags has the single element flagThisUninit, otherwise it is an empty list.
OperandStack is a list of types, such that the first element represents the type of the top of the operand stack, and the elements below the top follow in the appropriate order.
Types of size 2 (long and double) are represented by two entries, with the first entry being top and the second one being the type itself.
Reference types other than array types are represented using the functor class.
Note that L is an initiating loader (§5.3) of the class represented by class(N, L) and may, or may not, be the class's defining loader.
Array types are represented by applying the functor arrayOf to an argument denoting the component type of the array.
The verification type uninitialized(offset) is represented by applying the functor uninitialized to an argument representing the numerical value of the offset.
Other verification types are represented in prolog as atoms whose name denotes the verification type in question.
The class Object would be represented as class('java/lang/Object', BL), where BL is the bootstrap loader.
Flags is a list which may either be empty or have the single element flagThisUninit.
This flag is used in constructors, to mark type states where initialization of this has not yet been completed.
In such type states, it is illegal to return from the method.
The local variable array of a method has a fixed length by construction (see methodInitialStackFrame in §4.10.1.6) while the operand stack grows and shrinks.
Therefore, we require an explicit check on the length of the operand stacks whose assignability is desired.
The length of the operand stack must not exceed the declared maximum stack length.
The following clause accesses the I'th element of the operand stack from a type state.
Manipulation of the operand stack by load and store instructions (§4.10.1.7) is complicated by the fact that some types occupy two entries on the stack.
The predicates given below take this into account, allowing the rest of the specification to abstract from this issue.
More precisely, if the logical top of the stack is some subtype of the specified type, Type, then pop it.
If a type occupies two stack slots, the logical top of stack type is really the type just below the top, and the top of stack is the unusable type top.
The exact behavior varies with the size of the type.
If the pushed type is of size 1, we just push it onto the stack.
If the pushed type is of size 2, we push it, and then push top.
Push a list of types onto the stack if there is space.
Manipulation of the operand stack by the dup instructions is specified entirely in terms of the category of types for values on the stack (§2.11.1)
The result is the incoming stack, with the top slot popped off.
Popping a logical type of category 2, Type, off the stack is possible if the top of the stack is type top, and the slot directly below it is Type.
The result is the incoming stack, with the top 2 slots popped off.
Most of the type rules for individual instructions (§4.10.1.9) depend on the notion of a valid type transition.
A type transition is valid if one can pop a list of expected types off the incoming type state's operand stack and replace them with an expected result type, resulting in a new valid type state.
In particular, the size of the operand stack in the new type state must not exceed its maximum declared size.
Abstract methods and native methods are considered to be type safe if they do not override a final method.
Non-abstract, non-native methods are type correct if they have code and the code is type correct.
A method with code is type safe if it is possible to merge the code and the stack map frames into a single stream such that each stack map frame precedes the instruction it corresponds to, and the merged stream is type correct.
The method's exception handlers, if any, must also be legal.
An exception handler is represented by a functor application of the form:
An exception handler is legal if its start (Start) is less than its end (End), there exists an instruction whose offset is equal to Start, there exists an instruction whose offset equals End, and the handler's exception class is assignable to the class Throwable.
The exception class of a handler is Throwable if the handler's class entry is 0, otherwise it is the class named in the handler.
Let us now turn to the stream of instructions and stack map frames.
Merging instructions and stack map frames into a single stream involves four cases: • Merging an empty StackMap and a list of instructions yields the original list of.
Given a list of stack map frames beginning with the type state for the instruction at Offset, and a list of instructions beginning at Offset, the merged list is the head of the stack frame list, followed by the head of the instruction list, followed by the merge of the tails of the two lists.
Otherwise, given a list of stack frames beginning with the type state for the instruction at OffsetM, and a list of instructions beginning at OffsetP, then, if OffsetP < OffsetM, the merged list consists of the head of the instruction list, followed by the merge of the stack frame list and the tail of the instruction list.
Since the instruction list has monotonically increasing offsets, the merge of the two lists is not defined unless every stack map frame offset has a corresponding instruction offset and the stack map frames are in monotonically increasing order.
To determine if the merged stream for a method is type correct, we first infer the method's initial type state.
The initial type state of a method consists of an empty operand stack and local variable types derived from the type of this and the arguments, as well as the appropriate flag, depending on whether this is an <init> method.
Given a list of types, the following clause produces a list where every type of size 2 has been substituted by two entries: one for itself, and one top entry.
The result then corresponds to the representation of the list as 32-bit words in the Java Virtual Machine.
For the initial type state of an instance method, we compute the type of this and put it in a list.
For the initial type state of a static method, this is irrelevant, so the list is empty.
We now compute whether the merged stream for a method is type correct, using the method's initial type state: • If we have a stack map frame and an incoming type state, the type state must be.
We may then proceed to type check the rest of the stream with the type state given in the stack map.
A merged code stream is type safe relative to an incoming type state T if it begins with an instruction I that is type safe relative to T, and I satisfies its exception handlers (see below), and the tail of the stream is type safe given the type state following that execution of I.
For an unconditional branch instruction, it will have the special value afterGoto.
After an unconditional branch (indicated by an incoming type state of afterGoto), if we have a stack map giving the type state for the following instructions, we can proceed and type check them using the type state provided by the stack map.
It is illegal to have code after an unconditional branch without a stack map frame being provided for it.
If we have an unconditional branch at the end of the code, stop.
Branching to a target is type safe if the target has an associated stack frame, Frame, and the current stack frame, StackFrame, is assignable to Frame.
An instruction satisfies its exception handlers if it satisfies every exception handler that is applicable to the instruction.
An exception handler is applicable to an instruction if the offset of the instruction is greater or equal to the start of the handler's range and less than the end of the handler's range.
An instruction satisfies an exception handler if its incoming type state is StackFrame, and the handler's target (the initial instruction of the handler code) is type safe assuming an incoming type state T.
The type state T is derived from StackFrame by replacing the operand stack with a stack whose sole element is the handler's exception class.
All load instructions are variations on a common pattern, varying the type of the value that the instruction loads.
Loading a value of type Type from local variable Index is type safe, if the type of that local variable is ActualType, ActualType is assignable to Type, and pushing ActualType onto the incoming operand stack is a valid type transition (§4.10.1.4) that yields a new type state NextStackFrame.
After execution of the load instruction, the type state will be NextStackFrame.
All store instructions are variations on a common pattern, varying the type of the value that the instruction stores.
In general, a store instruction is type safe if the local variable it references is of a type that is a supertype of Type, and the top of the operand stack is of a subtype of Type, where Type is the type the instruction is designed to store.
More precisely, the store is type safe if one can pop a type ActualType that "matches" Type (that is, is a subtype of Type) off the operand stack (§4.10.1.4), and then legally assign that type the local variable LIndex.
Given local variables Locals, modifying Index to have type Type results in the local variable list NewLocals.
The modifications are somewhat involved, because some values (and their corresponding types) occupy two local variables.
Given LocalsRest, the suffix of the local variable list starting at index I, modifying local variable Index to have type Type results in the local variable list suffix NextLocalsRest.
This can occur if LI has a type of size 2
Once we set LI+1 to the new type (and the corresponding value), the type/value of LI will be invalidated, as its upper half will be trashed.
When we find the variable, and it only occupies one word, we change it to Type and we're done.
When we find the variable, and it occupies two words, we change its type to Type and the next word to top.
We refer to a local whose index immediately precedes a local whose type will be modified as a pre-index variable.
The future type of a pre-index variable of type InputType is Result.
If the type, Type, of the pre-index local is of size 1, it doesn't change.
If the type of the pre-index local, Type, is 2, we need to mark the lower half of its two word value as unusable, by setting its type to top.
All instructions that access members must contend with the rules concerning protected members.
This section describes the protected check that corresponds to JLS §6.6.2.1
The protected check applies only to protected members of superclasses of the current class.
There are four cases: • If the name of a class is not the name of any superclass, it cannot be a superclass,
If the MemberClassName is the same as the name of a superclass, the class being resolved may indeed be a superclass.
In this case, if no superclass named MemberClassName in a different run-time package has a protected member named MemberName with descriptor MemberDescriptor, the protected check does not apply.
This is because the actual class being resolved will either be one of these superclasses, in which case we know that it is either in the same run-time package, and the access is legal; or the member in question is not protected and the check does not apply; or it will be a subclass, in which case the check would succeed anyway; or it will be some other class in the same run-time package, in which case the access is legal and the check need not take place; or the verifier need not flag this as a problem, since it will be caught anyway because resolution will per force fail.
If there does exist a protected superclass member in a different run-time protected, the check does not apply.
Using a superclass member that is not protected is trivially correct.)
Otherwise, use of a member of an object of type Target requires that Target be assignable to the type of the current class.
The predicate classesInOtherPkgWithProtectedMember(Class, MemberName, MemberDescriptor, MemberClassName, Chain, List) is true if List is the set of classes in Chain with name MemberClassName that are in a different run-time descriptor MemberDescriptor.
In general, the type rule for an instruction is given relative to an environment Environment that defines the class and method in which the instruction occurs (§4.10.1.1), and the offset Offset within the method at which the instruction occurs.
The rule states that if the incoming type state StackFrame fulfills certain requirements, then:
It is provable that the type state after the instruction completes normally has a particular form given by NextStackFrame, and that the type state after the instruction completes abruptly is given by ExceptionStackFrame.
The type state after an instruction completes abruptly is the same as the incoming type state, except that the operand stack is empty.
Many instructions have type rules that are completely isomorphic to the rules for other instructions.
The English language description of each rule is intended to be readable, intuitive, and concise.
As such, the description avoids repeating all the contextual assumptions given above.
In particular: • The description does not explicitly mention the environment.
When the description speaks of the operand stack or local variables in the.
The type state after the instruction completes abruptly is almost always identical to the incoming type state.
The description only discusses the type state after the instruction completes abruptly when that is not the case.
The description speaks of popping and pushing types onto the operand stack, and does not explicitly discuss issues of stack underflow or overflow.
The description assumes these operations can be completed successfully, but the Prolog clauses for operand stack manipulation ensure that the necessary checks are made.
The description abstracts from these representation details, but the Prolog clauses that manipulate data do not.
Any ambiguities can be resolved by referring to the formal Prolog clauses.
An aaload instruction is type safe iff one can validly replace types matching int and an array type with component type ComponentType where ComponentType is a subtype of Object, with ComponentType yielding the outgoing type state.
The component type of an array of X is X.
We define the component type of null to be null.
An aastore instruction is type safe iff one can validly pop types matching Object, int, and an array of Object off the incoming operand stack yielding the outgoing type state.
An aconst_null instruction is type safe if one can validly push the type null onto the incoming operand stack yielding the outgoing type state.
An aload instruction with operand Index is type safe and yields an outgoing type state NextStackFrame, if a load instruction with operand Index and type reference is type safe and yields an outgoing type state NextStackFrame.
An anewarray instruction with operand CP is type safe iff CP refers to a constant pool entry denoting either a class type or an array type, and one can legally replace a type matching int on the incoming operand stack with an array with component type CP yielding the outgoing type state.
An areturn instruction is type safe iff the enclosing method has a declared return type, ReturnType, that is a reference type, and one can validly pop a type matching ReturnType off the incoming operand stack.
An arraylength instruction is type safe iff one can validly replace an array type on the incoming operand stack with the type int yielding the outgoing type state.
An astore instruction with operand Index is type safe and yields an outgoing type state NextStackFrame, if a store instruction with operand Index and type reference is type safe and yields an outgoing type state NextStackFrame.
An athrow instruction is type safe iff the top of the operand stack matches Throwable.
A baload instruction is type safe iff one can validly replace types matching int and a small array type on the incoming operand stack with int yielding the outgoing type state.
An array type is a small array type if it is an array of byte, an array of boolean, or a subtype thereof (null)
A bastore instruction is type safe iff one can validly pop types matching int, int and a small array type off the incoming operand stack yielding the outgoing type state.
A bipush instruction is type safe iff the equivalent sipush instruction is type safe.
A caload instruction is type safe iff one can validly replace types matching int and array of char on the incoming operand stack with int yielding the outgoing type state.
A castore instruction is type safe iff one can validly pop types matching int, int and array of char off the incoming operand stack yielding the outgoing type state.
A checkcast instruction with operand CP is type safe iff CP refers to a constant pool entry denoting either a class or an array, and one can validly replace the type Object on top of the incoming operand stack with the type denoted by CP yielding the outgoing type state.
A d2f instruction is type safe if one can validly pop double off the incoming operand stack and replace it with float, yielding the outgoing type state.
A d2i instruction is type safe if one can validly pop double off the incoming operand stack and replace it with int, yielding the outgoing type state.
A d2l instruction is type safe if one can validly pop double off the incoming operand stack and replace it with long, yielding the outgoing type state.
A dadd instruction is type safe iff one can validly replace types matching double and double on the incoming operand stack with double yielding the outgoing type state.
A daload instruction is type safe iff one can validly replace types matching int and array of double on the incoming operand stack with double yielding the outgoing type state.
A dastore instruction is type safe iff one can validly pop types matching double, int and array of double off the incoming operand stack yielding the outgoing type state.
A dcmpg instruction is type safe iff one can validly replace types matching double and double on the incoming operand stack with int yielding the outgoing type state.
A dcmpl instruction is type safe iff the equivalent dcmpg instruction is type safe.
A dconst_0 instruction is type safe if one can validly push the type double onto the incoming operand stack yielding the outgoing type state.
A ddiv instruction is type safe iff the equivalent dadd instruction is type safe.
A dload instruction with operand Index is type safe and yields an outgoing type state NextStackFrame, if a load instruction with operand Index and type double is type safe and yields an outgoing type state NextStackFrame.
A dmul instruction is type safe iff the equivalent dadd instruction is type safe.
A dneg instruction is type safe iff there is a type matching double on the incoming operand stack.
A drem instruction is type safe iff the equivalent dadd instruction is type safe.
A dreturn instruction is type safe if the enclosing method has a declared return type of double, and one can validly pop a type matching double off the incoming operand stack.
A dstore instruction with operand Index is type safe and yields an outgoing type state NextStackFrame, if a store instruction with operand Index and type double is type safe and yields an outgoing type state NextStackFrame.
A dsub instruction is type safe iff the equivalent dadd instruction is type safe.
A dup instruction is type safe iff one can validly replace a category 1 type, Type, with the types Type, Type, yielding the outgoing type state.
An f2d instruction is type safe if one can validly pop float off the incoming operand stack and replace it with double, yielding the outgoing type state.
An f2i instruction is type safe if one can validly pop float off the incoming operand stack and replace it with int, yielding the outgoing type state.
An f2l instruction is type safe if one can validly pop float off the incoming operand stack and replace it with long, yielding the outgoing type state.
An fadd instruction is type safe iff one can validly replace types matching float and float on the incoming operand stack with float yielding the outgoing type state.
An faload instruction is type safe iff one can validly replace types matching int and array of float on the incoming operand stack with float yielding the outgoing type state.
An fastore instruction is type safe iff one can validly pop types matching float, int and array of float off the incoming operand stack yielding the outgoing type state.
An fcmpg instruction is type safe iff one can validly replace types matching float and float on the incoming operand stack with int yielding the outgoing type state.
An fcmpl instruction is type safe iff the equivalent fcmpg instruction is type safe.
An fconst_0 instruction is type safe if one can validly push the type float onto the incoming operand stack yielding the outgoing type state.
The rules for the other variants of fconst are equivalent.
An fdiv instruction is type safe iff the equivalent fadd instruction is type safe.
An fload instruction with operand Index is type safe and yields an outgoing type state NextStackFrame, if a load instruction with operand Index and type float is type safe and yields an outgoing type state NextStackFrame.
An fmul instruction is type safe iff the equivalent fadd instruction is type safe.
An fneg instruction is type safe iff there is a type matching float on the incoming operand stack.
An frem instruction is type safe iff the equivalent fadd instruction is type safe.
An freturn instruction is type safe if the enclosing method has a declared return type of float, and one can validly pop a type matching float off the incoming operand stack.
An fstore instruction with operand Index is type safe and yields an outgoing type state NextStackFrame, if a store instruction with operand Index and type float is type safe and yields an outgoing type state NextStackFrame.
An fsub instruction is type safe iff the equivalent fadd instruction is type safe.
A getfield instruction with operand CP is type safe iff CP refers to a constant pool entry denoting a field whose declared type is FieldType, declared in a class FieldClass, and one can validly replace a type matching FieldClass with type FieldType on the incoming operand stack yielding the outgoing type state.
A getstatic instruction with operand CP is type safe iff CP refers to a constant pool entry denoting a field whose declared type is FieldType, and one can validly push FieldType on the incoming operand stack yielding the outgoing type state.
A goto instruction is type safe iff its target operand is a valid branch target.
A goto_w instruction is type safe iff the equivalent goto instruction is type safe.
An i2b instruction is type safe iff the equivalent ineg instruction is type safe.
An i2c instruction is type safe iff the equivalent ineg instruction is type safe.
An i2d instruction is type safe if one can validly pop int off the incoming operand stack and replace it with double, yielding the outgoing type state.
An i2f instruction is type safe if one can validly pop int off the incoming operand stack and replace it with float, yielding the outgoing type state.
An i2l instruction is type safe if one can validly pop int off the incoming operand stack and replace it with long, yielding the outgoing type state.
An i2s instruction is type safe iff the equivalent ineg instruction is type safe.
An iadd instruction is type safe iff one can validly replace types matching int and int on the incoming operand stack with int yielding the outgoing type state.
An iaload instruction is type safe iff one can validly replace types matching int and array of int on the incoming operand stack with int yielding the outgoing type state.
An iand instruction is type safe iff the equivalent iadd instruction is type safe.
An iastore instruction is type safe iff one can validly pop types matching int, int and array of int off the incoming operand stack yielding the outgoing type state.
An if_acmpeq instruction is type safe iff one can validly pop types matching reference and reference on the incoming operand stack yielding the outgoing type state NextStackFrame, and the operand of the instruction, Target, is a valid branch target assuming an incoming type state of NextStackFrame.
An if_icmpeq instruction is type safe iff one can validly pop types matching int and int on the incoming operand stack yielding the outgoing type state NextStackFrame, and the operand of the instruction, Target, is a valid branch target assuming an incoming type state of NextStackFrame.
The rules for all other variants of the if_icmp<cond> instruction are identical.
An ifeq instruction is type safe iff one can validly pop a type matching int off the incoming operand stack yielding the outgoing type state NextStackFrame, and the operand of the instruction, Target, is a valid branch target assuming an incoming type state of NextStackFrame.
The rules for all other variations of the if<cond> instruction are identical.
An ifnonnull instruction is type safe iff one can validly pop a type matching reference off the incoming operand stack yielding the outgoing type state NextStackFrame, and the operand of the instruction, Target, is a valid branch target assuming an incoming type state of NextStackFrame.
An ifnull instruction is type safe iff the equivalent ifnonnull instruction is type safe.
An iinc instruction with first operand Index is type safe iff LIndex has type int.
An iload instruction with operand Index is type safe and yields an outgoing type state NextStackFrame, if a load instruction with operand Index and type int is type safe and yields an outgoing type state NextStackFrame.
An imul instruction is type safe iff the equivalent iadd instruction is type safe.
An ineg instruction is type safe iff there is a type matching int on the incoming operand stack.
An instanceof instruction with operand CP is type safe iff CP refers to a constant pool entry denoting either a class or an array, and one can validly replace the type Object on top of the incoming operand stack with type int yielding the outgoing type state.
An invokedynamic instruction is type safe iff all of the following conditions hold: • Its first operand, CP, refers to a constant pool entry denoting an dynamic call site.
One can validly replace types matching the argument types given in Descriptor on the incoming operand stack with the return type given in Descriptor, yielding the outgoing type state.
An invokeinterface instruction is type safe iff all of the following conditions hold: • Its first operand, CP, refers to a constant pool entry denoting an interface method.
Its second operand, Count, is a valid count operand (see below)
One can validly replace types matching the type MethodIntfName and the.
The Count operand of an invokeinterface instruction is valid if it equals the size of the arguments to the instruction.
This is equal to the difference between the size of InputFrame and OutputFrame.
An invokespecial instruction is type safe iff all of the following conditions hold: • Its first operand, CP, refers to a constant pool entry denoting a method.
One can validly replace types matching the current class and the argument.
One can validly replace types matching the class MethodClassName and the argument types given in Descriptor on the incoming operand stack with the return type given in Descriptor.
One can validly pop types matching the argument types given in Descriptor and an uninitialized type, UninitializedArg, off the incoming operand stack, yielding OperandStack.
The outgoing type state is derived from the incoming type state by first replacing the incoming operand stack with OperandStack and then replacing all instances of UninitializedArg with the type of instance being initialized.
To compute what type the uninitialized argument's type needs to be rewritten to, there are two cases:
If we are initializing an object within its constructor, its type is initially uninitializedThis.
This type will be rewritten to the type of the class of the.
The second case arises from initialization of an object created by new.
The uninitialized arg type is rewritten to MethodClass, the type of the method holder of <init>
We check whether there really is a new instruction at Address.
The rule for invokespecial of an <init> method is the sole motivation for passing back a distinct exception stack frame.
The concern is that invokespecial can cause a superclass This situation cannot be created using source code in the Java programming language, but can be created by programming in bytecode directly.
The original frame holds an uninitialized object in a local and has flag uninitializedThis.
Normal termination of invokespecial initializes the uninitialized object and turns off the uninitializedThis flag.
But if the invocation of an <init> method throws an exception, the uninitialized object might be left in a partially initialized state, and needs to be made permanently unusable.
This is represented by an exception frame containing the broken object (the new value of the local) and the uninitializedThis flag (the old flag)
There is no way to get from an apparentlyinitialized object bearing the uninitializedThis flag to a properly initialized object, so the object is permanently unusable.
If not for this case, the exception stack frame could be the same as the input stack frame.
An invokestatic instruction is type safe iff all of the following conditions hold: • Its first operand, CP, refers to a constant pool entry denoting a method named MethodName with descriptor Descriptor.
One can validly replace types matching the argument types given in Descriptor on the incoming operand stack with the return type given in Descriptor, yielding the outgoing type state.
An invokevirtual instruction is type safe iff all of the following conditions hold: • Its first operand, CP, refers to a constant pool entry denoting a method.
One can validly replace types matching the class MethodClassName and the argument types given in Descriptor on the incoming operand stack with the return type given in Descriptor, yielding the outgoing type state.
If the method is protected, the usage conforms to the special rules governing access to protected members (§4.10.1.8)
An ior instruction is type safe iff the equivalent iadd instruction is type safe.
An irem instruction is type safe iff the equivalent iadd instruction is type safe.
An ireturn instruction is type safe if the enclosing method has a declared return type of int, and one can validly pop a type matching int off the incoming operand stack.
An ishl instruction is type safe iff the equivalent iadd instruction is type safe.
An ishr instruction is type safe iff the equivalent iadd instruction is type safe.
An istore instruction with operand Index is type safe and yields an outgoing type state NextStackFrame, if a store instruction with operand Index and type int is type safe and yields an outgoing type state NextStackFrame.
An isub instruction is type safe iff the equivalent iadd instruction is type safe.
An iushr instruction is type safe iff the equivalent iadd instruction is type safe.
An ixor instruction is type safe iff the equivalent iadd instruction is type safe.
An l2d instruction is type safe if one can validly pop long off the incoming operand stack and replace it with double, yielding the outgoing type state.
An l2f instruction is type safe if one can validly pop long off the incoming operand stack and replace it with float, yielding the outgoing type state.
An l2i instruction is type safe if one can validly pop long off the incoming operand stack and replace it with int, yielding the outgoing type state.
An ladd instruction is type safe iff one can validly replace types matching long and long on the incoming operand stack with long yielding the outgoing type state.
An laload instruction is type safe iff one can validly replace types matching int and array of long on the incoming operand stack with long yielding the outgoing type state.
An land instruction is type safe iff the equivalent ladd instruction is type safe.
An lastore instruction is type safe iff one can validly pop types matching long, int and array of long off the incoming operand stack yielding the outgoing type state.
A lcmp instruction is type safe iff one can validly replace types matching long and long on the incoming operand stack with int yielding the outgoing type state.
An lconst_0 instruction is type safe if one can validly push the type long onto the incoming operand stack yielding the outgoing type state.
An ldc instruction with operand CP is type safe iff CP refers to a constant pool entry denoting an entity of type Type, where Type is either int, float, String, Class, java.lang.invoke.MethodType, or java.lang.invoke.MethodHandle, and one can validly push Type onto the incoming operand stack yielding the outgoing type state.
An ldc_w instruction is type safe iff the equivalent ldc instruction is type safe.
An ldc2_w instruction with operand CP is type safe iff CP refers to a constant pool entry denoting an entity of type Tag, where Tag is either long or double, and one can validly push Tag onto the incoming operand stack yielding the outgoing type state.
An ldiv instruction is type safe iff the equivalent ladd instruction is type safe.
An lload instruction with operand Index is type safe and yields an outgoing type state NextStackFrame, if a load instruction with operand Index and type long is type safe and yields an outgoing type state NextStackFrame.
An lmul instruction is type safe iff the equivalent ladd instruction is type safe.
An lneg instruction is type safe iff there is a type matching long on the incoming operand stack.
A lookupswitch instruction is type safe if its keys are sorted, one can validly pop int off the incoming operand stack yielding a new type state BranchStackFrame, and all of the instruction's targets are valid branch targets assuming BranchStackFrame as their incoming type state.
A lor instruction is type safe iff the equivalent ladd instruction is type safe.
An lrem instruction is type safe iff the equivalent ladd instruction is type safe.
An lreturn instruction is type safe if the enclosing method has a declared return type of long, and one can validly pop a type matching long off the incoming operand stack.
An lshl instruction is type safe if one can validly replace the types int and long on the incoming operand stack with the type long yielding the outgoing type state.
An lshr instruction is type safe iff the equivalent lshl instruction is type safe.
An lstore instruction with operand Index is type safe and yields an outgoing type state NextStackFrame, if a store instruction with operand Index and type long is type safe and yields an outgoing type state NextStackFrame.
An lsub instruction is type safe iff the equivalent ladd instruction is type safe.
An lushr instruction is type safe iff the equivalent lshl instruction is type safe.
An lxor instruction is type safe iff the equivalent ladd instruction is type safe.
A monitorenter instruction is type safe iff one can validly pop a type matching reference off the incoming operand stack yielding the outgoing type state.
A monitorexit instruction is type safe iff the equivalent monitorenter instruction is type safe.
A multianewarray instruction with operands CP and Dim is type safe iff CP refers to a constant pool entry denoting an array type whose dimension is greater or equal to Dim, Dim is strictly positive, and one can validly replace Dim int types on the incoming operand stack with the type denoted by CP yielding the outgoing type state.
The dimension of an array type whose component type is also an array type is one more than the dimension of its component type.
A new instruction with operand CP at offset Offset is type safe iff CP refers to a constant pool entry denoting a class type, the type uninitialized(Offset) does not appear in the incoming operand stack, and one can validly push uninitialized(Offset) onto the incoming operand stack and replace uninitialized(Offset) with top in the incoming local variables yielding the outgoing type state.
A newarray instruction with operand TypeCode is type safe iff TypeCode corresponds to the primitive type ElementType, and one can validly replace the type int on the incoming operand stack with the type 'array of ElementType', yielding the outgoing type state.
The correspondence between type codes and primitive types is specified by the following predicate:
A pop instruction is type safe iff one can validly pop a category 1 type off the incoming operand stack yielding the outgoing type state.
A putfield instruction with operand CP is type safe iff CP refers to a constant pool entry denoting a field whose declared type is FieldType, declared in a class FieldClass, and one can validly pop types matching FieldType and FieldClass off the incoming operand stack yielding the outgoing type state.
A putstatic instruction with operand CP is type safe iff CP refers to a constant pool entry denoting a field whose declared type is FieldType, and one can validly pop a type matching FieldType off the incoming operand stack yielding the outgoing type state.
An saload instruction is type safe iff one can validly replace types matching int and array of short on the incoming operand stack with int yielding the outgoing type state.
An sastore instruction is type safe iff one can validly pop types matching int, int, and array of short off the incoming operand stack yielding the outgoing type state.
An sipush instruction is type safe iff one can validly push the type int onto the incoming operand stack yielding the outgoing type state.
A tableswitch instruction is type safe if its keys are sorted, one can validly pop int off the incoming operand stack yielding a new type state BranchStackFrame, and all of the instruction's targets are valid branch targets assuming BranchStackFrame as their incoming type state.
The wide instructions follow the same rules as the instructions they widen.
A class file that does not contain a StackMapTable attribute (which necessarily has a version number of 49.0 or below) must be verified using type inference.
During linking, the verifier checks the code array of the Code attribute for each method of the class file by performing data-flow analysis on each method.
The verifier ensures that at any given point in the program, no matter what code path is taken to reach that point, the following is true:
The operand stack is always the same size and contains the same types of values.
No local variable is accessed unless it is known to contain a value of an.
All opcodes have appropriate type arguments on the operand stack and in the.
There is never an uninitialized class instance in a local variable in code protected.
However, an uninitialized class instance may be on the operand stack in code protected by an exception handler.
When an exception is thrown, the contents of the operand stack are discarded.
For efficiency reasons, certain tests that could in principle be performed by the verifier are delayed until the first time the code for the method is actually invoked.
In so doing, the verifier avoids loading class files unless it has to.
For example, if a method invokes another method that returns an instance of class A, and that instance is assigned only to a field of the same type, the verifier does not bother to check if the class A actually exists.
However, if it is assigned to a field of the type B, the definitions of both A and B must be loaded in to ensure that A is a subclass of B.
First, the bytes that make up the code are broken up into a sequence of instructions, and the index into the code array of the start of each instruction is placed in an array.
The verifier then goes through the code a second time and parses the instructions.
During this pass a data structure is built to hold information about each Java Virtual Machine instruction in the method.
The operands, if any, of each instruction are checked to make sure they are valid.
For instance: • Branches must be within the bounds of the code array for the method.
The targets of all control-flow instructions are each the start of an instruction.
In the case of a wide instruction, the wide opcode is considered the start of the instruction, and the opcode giving the operation modified by that wide instruction is not considered to start an instruction.
No instruction can access or modify a local variable at an index greater than or equal to the number of local variables that its method indicates it allocates.
All references to the constant pool must be to an entry of the appropriate type.
The code does not end in the middle of an instruction.
For each exception handler, the starting and ending point of code protected by.
The exception handler code must start at a valid instruction, and it must not start at an opcode being modified by the wide instruction.
For each instruction of the method, the verifier records the contents of the operand stack and the contents of the local variable array prior to the execution of that instruction.
For the operand stack, it needs to know the stack height and the type of each value on it.
For each local variable, it needs to know either the type of the contents of that local variable or that the local variable contains an unusable or unknown value (it might be uninitialized)
The bytecode verifier does not need to distinguish between the integral types (e.g., byte, short, char) when determining the value types on the operand stack.
For the first instruction of the method, the local variables that represent parameters initially contain values of the types indicated by the method's type descriptor; the operand stack is empty.
For the other instructions, which have not been examined yet, no information is available regarding the operand stack or local variables.
For each instruction, a "changed" bit indicates whether this instruction needs to be looked at.
Initially, the "changed" bit is set only for the first instruction.
Select a Java Virtual Machine instruction whose "changed" bit is set.
If no instruction remains whose "changed" bit is set, the method has successfully been verified.
Otherwise, turn off the "changed" bit of the selected instruction.
Model the effect of the instruction on the operand stack and local variable array by doing the following: • If the instruction uses values from the operand stack, ensure that there are a.
If the instruction uses a local variable, ensure that the specified local variable contains a value of the appropriate type.
If the instruction pushes values onto the operand stack, ensure that there is sufficient room on the operand stack for the new values.
Add the indicated types to the top of the modeled operand stack.
If the instruction modifies a local variable, record that the local variable now contains the new type.
Successor instructions can be one of the following: • The next instruction, if the current instruction is not an unconditional control.
Verification fails if it is possible to "fall off" the last instruction of the method.
The target(s) of a conditional or unconditional branch or switch.
Merge the state of the operand stack and local variable array at the end of the execution of the current instruction into each of the successor instructions.
In the special case of control transfer to an exception handler, the operand stack is set to contain a single object of the exception type indicated by the exception handler information.
There must be sufficient room on the operand stack for this single value, as if an instruction had pushed it.
Set the "changed" bit if there is any modification to the values.
To merge two operand stacks, the number of values on each stack must be identical.
The types of values on the stacks must also be identical, except that differently typed reference values may appear at corresponding places on the two stacks.
In this case, the merged operand stack contains a reference to an instance of the first common superclass of the two types.
Such a reference type always exists because the type Object is a superclass of all class and interface types.
If the operand stacks cannot be merged, verification of the method fails.
To merge two local variable array states, corresponding pairs of local variables are compared.
If the two types are not identical, then unless both contain reference values, the verifier records that the local variable contains an unusable value.
If both of the pair of local variables contain reference values, the merged state contains a reference to an instance of the first common superclass of the two types.
If the data-flow analyzer runs on a method without reporting a verification failure, then the method has been successfully verified by the class file verifier.
Values of the long and double types are treated specially by the verification process.
Whenever a value of type long or double is moved into a local variable at index n, index n+1 is specially marked to indicate that it has been reserved by the value at index n and must not be used as a local variable index.
Whenever a value is moved to a local variable at index n, the index n-1 is examined to see if it is the index of a value of type long or double.
If so, the local variable at index n-1 is changed to indicate that it now contains an unusable value.
Dealing with values of types long or double on the operand stack is simpler; the verifier treats them as single values on the stack.
For example, the verification code for the dadd opcode (add two double values) checks that the top two items on the stack are both of type double.
When calculating operand stack length, values of type long and double have length two.
Untyped instructions that manipulate the operand stack must treat values of type long and double as atomic (indivisible)
For example, the verifier reports a failure if the top value on the stack is a double and it encounters an instruction such as pop or dup.
This instruction sequence leaves the newly created and initialized object on top of the operand stack.
Before that method invokes another instance initialization method of myClass or its direct superclass on this, the only operation the method can perform on this is assigning fields declared within myClass.
After an appropriate instance initialization method is invoked (from the current.
The verifier rejects code that uses the new object before it has been initialized or that initializes the object more than once.
In addition, it ensures that every normal return of the method has invoked an instance initialization method either in the class of this method or in the direct superclass.
Similarly, a special type is created and pushed on the verifier's model of the operand stack as the result of the Java Virtual Machine instruction new.
The special type indicates the instruction by which the class instance was created and the type of the uninitialized class instance created.
When an instance initialization method declared in the class of the uninitialized class instance is invoked on that class instance, all occurrences of the special type are replaced by the intended type of the class instance.
This change in type may propagate to subsequent instructions as the dataflow analysis proceeds.
The instruction number needs to be stored as part of the special type, as there may be multiple not-yet-initialized instances of a class in existence on the operand stack at one time.
For example, the Java Virtual Machine instruction sequence that implements:
When an instance initialization method is invoked on a class instance, only those occurrences of the special type on the operand stack or in the local variable array that are the same object as the class instance are replaced.
A valid instruction sequence must not have an uninitialized object on the operand stack or in a local variable at the target of a backwards branch if the special type of the uninitialized object is merged with a special type other than itself, or in a local variable in code protected by an exception handler or a finally clause.
Otherwise, a devious piece of code might fool the verifier into thinking it had initialized a class instance when it had, in fact, initialized a class instance created in a previous pass through a loop.
To implement the try-finally construct, a compiler for the Java programming language that generates class files with version number 50.0 or below may use the exception-handling facilities together with two special instructions: jsr ("jump to subroutine") and ret ("return from subroutine")
The finally clause is compiled as a subroutine within the Java Virtual Machine code for its method, much like the.
When a jsr instruction that invokes the subroutine is executed, it pushes its return address, the address of the instruction after the jsr that is being executed, onto the operand stack as a value of type returnAddress.
The code for the subroutine stores the return address in a local variable.
At the end of the subroutine, a ret instruction fetches the return address from the local variable and transfers control to the instruction at the return address.
Control can be transferred to the finally clause (the finally subroutine can be invoked) in several different ways.
If the try clause completes normally, the finally subroutine is invoked via a jsr instruction before evaluating the next expression.
A break or continue inside the try clause that transfers control outside the try clause executes a jsr to the code for the finally clause first.
If the try clause executes a return, the compiled code does the following: 1
Saves the return value (if any) in a local variable.
Executes a jsr to the code for the finally clause.
The compiler sets up a special exception handler, which catches any exception thrown by the try clause.
If an exception is thrown in the try clause, this exception handler does the following: 1
For more information about the implementation of the try-finally construct, see §3.13
The code for the finally clause presents a special problem to the verifier.
Usually, if a particular instruction can be reached via multiple paths and a particular local variable contains incompatible values through those multiple paths, then the local variable becomes unusable.
However, a finally clause might be called from several different places, yielding several different circumstances: • The invocation from the exception handler may have a certain local variable that.
The invocation to implement return may have some local variable that contains the return value.
The invocation from the bottom of the try clause may have an indeterminate value in that same local variable.
The code for the finally clause itself might pass verification, but after completing the updating all the successors of the ret instruction, the verifier would note that the local variable that the exception handler expects to hold an exception, or that the return code expects to hold a return value, now contains an indeterminate value.
Each instruction keeps track of the list of jsr targets needed to reach that instruction.
For instructions inside code for the finally clause, it is of length one.
For multiply nested finally code (extremely rare!), it may be longer than one.
For each instruction and each jsr needed to reach that instruction, a bit vector is maintained of all local variables accessed or modified since the execution of the jsr instruction.
When executing the ret instruction, which implements a return from a subroutine, there must be only one possible subroutine from which the instruction can be returning.
Two different subroutines cannot "merge" their execution to a single ret instruction.
To perform the data-flow analysis on a ret instruction, a special procedure is used.
Since the verifier knows the subroutine from which the instruction must be returning, it can find all the jsr instructions that call the subroutine and merge the state of the operand stack and local variable array at the time of the ret instruction into the operand stack and local variable array of the instructions following the jsr.
Merging uses a special set of values for local variables: ◆ For any local variable that the bit vector (constructed above) indicates has been.
For other local variables, use the type of the local variable before the jsr instruction.
The following limitations of the Java Virtual Machine are implicit in the class file format:
This acts as an internal limit on the total complexity of a single class or interface.
Note that the value of the fields_count item of the ClassFile structure does not include fields that are inherited from superclasses or superinterfaces.
Note that the value of the methods_count item of the ClassFile structure does not include methods that are inherited from superclasses or superinterfaces.
Note that values of type long and double are each considered to reserve two local variables and contribute two units toward the max_locals value, so use of local variables of those types further reduces this limit.
Note that values of type long and double are each considered to contribute two units toward the max_stack value, so use of values of these types on the operand stack further reduces this limit.
Note that a method descriptor is defined in terms of a notion of method parameter length in which a parameter of type long or double contributes two units to the length, so parameters of these types further reduce the limit.
The length of field and method names, field and method descriptors, and other constant string values (including those referenced by ConstantValue (§4.7.2)
Note that the limit is on the number of bytes in the encoding and not on the number of encoded characters.
Loading is the process of finding the binary representation of a class or interface type with a particular name and creating a class or interface from that binary representation.
Linking is the process of taking a class or interface and combining it into the run-time state of the Java Virtual Machine so that it can be executed.
In this chapter, §5.1 describes how the Java Virtual Machine derives symbolic references from the binary representation of a class or interface.
The Java Virtual Machine maintains a per-type constant pool (§2.5.5), a run-time data structure that serves many of the purposes of the symbol table of a conventional programming language implementation.
All references in the run-time constant pool are initially symbolic.
For an array class of n dimensions, the name begins with n occurrences of the.
Otherwise, if the element type is a reference type, it is represented by the.
Whenever this chapter refers to the name of a class or interface, it should be understood to be in the form returned by the Class.getName method.
Such a reference gives the name and descriptor of the field, as well as a symbolic reference to the class or interface in which the field is to be found.
Such a reference gives the name and descriptor of the method, as well as a symbolic reference to the class in which the method is to be found.
Such a reference gives the name and descriptor of the interface method, as well as a symbolic reference to the interface in which the method is to be found.
Such a reference gives: ◆ a symbolic reference to a method handle, which will serve as a bootstrap.
The CONSTANT_String_info structure gives the sequence of Unicode code points constituting the string literal.
The Java programming language requires that identical string literals (that is, literals that contain the same sequence of code points) must refer to the same instance of class String (JLS §3.10.5)
In addition, if the method String.intern is called on any string, the result is a reference to the same class instance that would be returned if that string appeared as a literal.
To derive a string literal, the Java Virtual Machine examines the sequence of code points given by the CONSTANT_String_info structure.
If the method String.intern has previously been called on an instance of.
Otherwise, a new instance of class String is created containing the sequence of Unicode code points given by the CONSTANT_String_info structure; a reference to that class instance is the result of string literal derivation.
Finally, the intern method of the new String instance is invoked.
The run-time constant values derived from these structures must thus be values that can be represented using IEEE 754 single and double formats, respectively.
The Java Virtual Machine starts up by creating an initial class, which is specified in an implementation-dependent manner, using the bootstrap class loader (§5.3.1)
The Java Virtual Machine then links the initial class, initializes it, and invokes the public class method void main(String[])
Execution of the Java Virtual Machine instructions constituting the main method may cause linking (and consequently creation) of additional classes and interfaces, as well as invocation of additional methods.
In an implementation of the Java Virtual Machine, the initial class could be provided as a command line argument.
Alternatively, the implementation could provide an initial class that sets up a class loader which in turn loads an application.
Other choices of the initial class are possible so long as they are consistent with the specification given in the previous paragraph.
Creation of a class or interface C denoted by the name N consists of the construction in the method area of the Java Virtual Machine (§2.5.4) of an implementationspecific internal representation of C.
Class or interface creation is triggered by another class or interface D, which references C through its run-time constant pool.
Class or interface creation may also be triggered by D invoking methods in certain Java SE platform class libraries (§2.12) such as reflection.
If C is not an array class, it is created by loading a binary representation of C (§4) using a class loader.
Array classes do not have an external binary representation; they are created by the Java Virtual Machine rather than by a class loader.
There are two kinds of class loaders: the bootstrap class loader supplied by the Java Virtual Machine, and user-defined class loaders.
Every user-defined class loader is an instance of a subclass of the abstract class ClassLoader.
Applications employ user-defined class loaders in order to extend the manner in which the Java Virtual Machine dynamically loads and thereby creates classes.
User-defined class loaders can be used to create classes that originate from user-defined sources.
For example, a class could be downloaded across a network, generated on the fly, or extracted from an encrypted file.
A class loader L may create C by defining it directly or by delegating to another class loader.
If L creates C directly, we say that L defines C or, equivalently, that L is the defining loader of C.
When one class loader delegates to another class loader, the loader that initiates the loading is not necessarily the same loader that completes the loading and defines the class.
If L creates C, either by defining it directly or by delegation, we say that L initiates loading of C or, equivalently, that L is an initiating loader of C.
At run time, a class or interface is determined not by its name alone, but by a pair: its binary name (§4.2.1) and its defining class loader.
Each such class or interface belongs to a single run-time package.
The run-time package of a class or interface is determined by the package name and defining class loader of the class or interface.
The Java Virtual Machine uses one of three procedures to create class or interface C denoted by N: • If N denotes a nonarray class or an interface, one of the two following methods.
If D was defined by a user-defined class loader, then that same user-defined.
However, the defining class loader of D is used in the process of creating array class C.
If an error occurs during class loading, then an instance of a subclass of LinkageError must be thrown at a point in the program that (directly or indirectly) uses the class or interface being loaded.
Therefore, a ClassNotFoundException that results from a class loader failing to load a superclass must be wrapped in a NoClassDefFoundError.)
Given the same name, a good class loader should always return the same Class object.
If a user-defined classloader prefetches binary representations of classes and interfaces, or loads a group of related classes together, then it must reflect loading errors only at points in the program where they could have arisen without prefetching or group loading.
We will also represent a class or interface using the notation NLi, where N denotes the name of the class or interface and Li denotes an initiating loader of the class or interface.
The following steps are used to load and thereby create the nonarray class or interface C denoted by N using the bootstrap class loader.
First, the Java Virtual Machine determines whether the bootstrap class loader has already been recorded as an initiating loader of a class or interface denoted by N.
If so, this class or interface is C, and no class creation is necessary.
Otherwise, the Java Virtual Machine passes the argument N to an invocation of a method on the bootstrap class loader to search for a purported representation of C.
Typically, a class or interface will be represented using a file in a hierarchical file system, and the name of the class or interface will be encoded in the pathname of the file.
Note that there is no guarantee that a purported representation found is valid or is a representation of C.
This phase of loading must detect the following error: • If no purported representation of C is found, loading throws an instance of ClassNotFoundException.
Then the Java Virtual Machine attempts to derive a class denoted by N using the bootstrap class loader from the purported representation using the algorithm found in §5.3.5
The following steps are used to load and thereby create the nonarray class or interface C denoted by N using a user-defined class loader L.
First, the Java Virtual Machine determines whether L has already been recorded as an initiating loader of a class or interface denoted by N.
If so, this class or interface is C, and no class creation is necessary.
The value returned by the invocation is the created class or interface C.
The Java Virtual Machine then records that L is an initiating loader of C (§5.3.4)
The remainder of this section describes this process in more detail.
When the loadClass method of the class loader L is invoked with the name N of a class or interface C to be loaded, L must perform one of the following two operations in order to load C:
Invoking defineClass causes the Java Virtual Machine to derive a class or interface denoted by N using L from the array of bytes using the algorithm found in §5.3.5
The class loader L can delegate the loading of C to some other class loader L'
This is accomplished by passing the argument N directly or indirectly to an invocation of a method on L' (typically the loadClass method)
Since JDK release 1.1, Oracle’s Java Virtual Machine implementation has invoked the loadClass method of a class loader in order to cause it to load a class or interface.
The argument to loadClass is the name of the class or interface to be loaded.
There is also a two-argument version of the loadClass method, where the second argument is a boolean that indicates whether the class or interface is to be linked or not.
Only the twoargument version was supplied in JDK release 1.0.2, and Oracle’s Java Virtual Machine implementation relied on it to link the loaded class or interface.
From JDK release 1.1 onward, Oracle’s Java Virtual Machine implementation links the class or interface directly, without relying on the class loader.
The following steps are used to create the array class C denoted by N using class loader L.
Class loader L may be either the bootstrap class loader or a user-defined class loader.
If L has already been recorded as an initiating loader of an array class with the same component type as N, that class is C, and no array class creation is necessary.
Otherwise, the following steps are performed to create C: 1
If the component type is a reference type, the algorithm of this section (§5.3)
The Java Virtual Machine creates a new array class with the indicated component type and number of dimensions.
If the component type is a reference type, C is marked as having been defined by the defining class loader of the component type.
Otherwise, C is marked as having been defined by the bootstrap class loader.
In any case, the Java Virtual Machine then records that L is an initiating loader for C (§5.3.4)
If the component type is a reference type, the accessibility of the array class is determined by the accessibility of its component type.
Ensuring type safe linkage in the presence of class loaders requires special care.
It is possible that when two different class loaders initiate loading of a class or interface denoted by N, the name N may denote a different class or interface in each loader.
After recording that a loader is an initiating loader of a class, the Java Virtual Machine must immediately check to see if any loading constraints are violated.
If so, the record is retracted, the Java Virtual Machine throws a LinkageError, and the loading operation that caused the recording to take place fails.
If so, the newly imposed loading constraint is retracted, the Java Virtual Machine throws a LinkageError, and the operation that caused the constraint to be imposed (either resolution or preparation, as the case may be) fails.
The situations described here are the only times at which the Java Virtual Machine checks whether any loading constraints have been violated.
A loading constraint is violated if, and only if, all the following four conditions hold: • There exists a loader L such that L has been recorded by the Java Virtual Machine.
There exists a loader L' such that L' has been recorded by the Java Virtual Machine.
The equivalence relation defined by the (transitive closure of the) set of imposed.
A full discussion of class loaders and type safety is beyond the scope of this specification.
The following steps are used to derive a Class object for the nonarray class or interface C denoted by N using loader L from a purported representation in class file format.
If so, this creation attempt is invalid and loading throws a LinkageError.
Otherwise, the Java Virtual Machine attempts to parse the purported representation.
However, the purported representation may not in fact be a valid representation of C.
Otherwise, if the purported representation is not of a supported.
UnsupportedClassVersionError, a subclass of ClassFormatError, was introduced to enable easy identification of a ClassFormatError caused by an attempt to load a class whose representation uses an unsupported version of the class file format.
In JDK release 1.1 and earlier, an instance of NoClassDefFoundError or ClassFormatError was thrown in case of an unsupported version, depending on whether the class was being loaded by the system class loader or a user-defined class loader.
Otherwise, if the purported representation does not actually represent a class named N, loading throws an instance of NoClassDefFoundError or an instance of one of its subclasses.
If C has a direct superclass, the symbolic reference from C to its direct superclass is resolved using the algorithm of §5.4.3.1
Note that if C is an interface it must have Object as its direct superclass, which must already have been loaded.
Any exceptions that can be thrown due to class or interface resolution can be thrown as a result of this phase of loading.
In addition, this phase of loading must detect the following errors: • If the class or interface named as the direct superclass of C is in fact an.
Otherwise, if any of the superclasses of C is C itself, loading throws a ClassCircularityError.
If C has any direct superinterfaces, the symbolic references from C to its direct superinterfaces are resolved using the algorithm of §5.4.3.1
Any exceptions that can be thrown due to class or interface resolution can be thrown as a result of this phase of loading.
In addition, this phase of loading must detect the following errors: • If any of the classes or interfaces named as direct superinterfaces of C is not.
Otherwise, if any of the superinterfaces of C is C itself, loading throws a ClassCircularityError.
The Java Virtual Machine marks C as having L as its defining class loader and records that L is an initiating loader of C (§5.3.4)
Linking a class or interface involves verifying and preparing that class or interface, its direct superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary.
Resolution of symbolic references in the class or interface is an optional part of linking.
This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that all of the following properties are maintained: • A class or interface is completely loaded before it is linked.
A class or interface is completely verified and prepared before it is initialized.
Errors detected during linkage are thrown at a point in the program where some.
For example, a Java Virtual Machine implementation may choose to resolve each symbolic reference in a class or interface individually when it is used ("lazy" or "late" resolution), or to resolve them all at once when the class is being verified ("eager" or "static" resolution)
This means that the resolution process may continue, in some implementations, after a class or interface has been initialized.
Whichever strategy is followed, any error detected during resolution must be.
Because linking involves the allocation of new data structures, it may fail with an OutOfMemoryError.
Verification may cause additional classes and interfaces to be loaded (§5.3) but need not cause them to be verified or prepared.
If the binary representation of a class or interface does not satisfy the static or structural constraints listed in §4.9, then a VerifyError must be thrown at the point in the program that caused the class or interface to be verified.
If an attempt by the Java Virtual Machine to verify a class or interface fails because an error is thrown that is an instance of LinkageError (or a subclass), then subsequent attempts to verify the class or interface always fail with the same error that was thrown as a result of the initial verification attempt.
This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization (§5.5), not preparation.
During preparation of a class or interface C, the Java Virtual Machine also imposes loading constraints (§5.3.4)
Given that the return type of m is Tr, and that the formal parameter types of m are Tf1, ..., Tfn, then:
Given that the return type of m is Tr, and that the formal parameter types of m are Tf1, ..., Tfn, then:
Preparation may occur at any time following creation but must be completed prior to initialization.
The Java Virtual Machine instructions anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, and putstatic make symbolic references to the run-time constant pool.
Execution of any of these instructions requires resolution of its symbolic reference.
Resolution is the process of dynamically determining concrete values from symbolic references in the run-time constant pool.
Resolution of the symbolic reference of one occurrence of an invokedynamic instruction does not imply that the same symbolic reference is considered resolved for any other invokedynamic instruction.
For all other instructions above, resolution of the symbolic reference of one occurrence of an instruction does imply that the same symbolic reference is considered resolved for any other non-invokedynamic instruction.
The above text implies that the concrete value determined by resolution for a specific invokedynamic instruction is a call site object bound to that specific invokedynamic instruction.) Resolution can be attempted on a symbolic reference that has already been resolved.
An attempt to resolve a symbolic reference that has already successfully been resolved always succeeds trivially and always results in the same entity produced by the initial resolution of that reference.
If an error occurs during resolution of a symbolic reference, then an instance of IncompatibleClassChangeError (or a subclass) must be thrown at a point in the program that (directly or indirectly) uses the symbolic reference.
If an attempt by the Java Virtual Machine to resolve a symbolic reference fails because an error is thrown that is an instance of LinkageError (or a subclass), then subsequent attempts to resolve the reference always fail with the same error that was thrown as a result of the initial resolution attempt.
A symbolic reference to a call site specifier by a specific invokedynamic instruction must not be resolved prior to execution of that instruction.
In the case of failed resolution of an invokedynamic instruction, the bootstrap method is not re-executed on subsequent resolution attempts.
Certain of the instructions above require additional linking checks when resolving symbolic references.
For instance, in order for a getfield instruction to successfully resolve the symbolic reference to the field on which it operates, it must not only complete the field resolution steps given in §5.4.3.2 but also check that the field is not static.
If it is a static field, a linking exception must be thrown.
Notably, in order for an invokedynamic instruction to successfully resolve the symbolic reference to a call site specifier, the bootstrap method specified therein must complete normally and return a suitable call site object.
If the bootstrap method completes abruptly or returns an unsuitable call site object, a linking exception must be thrown.
Linking exceptions generated by checks that are specific to the execution of a particular Java Virtual Machine instruction are given in the description of that instruction and are not covered in this general discussion of resolution.
Note that such exceptions, although described as part of the execution of Java Virtual Machine instructions rather than resolution, are still properly considered failures of resolution.
The following sections describe the process of resolving a symbolic reference in the run-time constant pool (§5.1) of a class or interface D.
Details of resolution differ with the kind of symbolic reference to be resolved.
To resolve an unresolved symbolic reference from D to a class or interface C denoted by N, the following steps are performed:
Any exception that can be thrown as a result of failure of class or interface creation can thus be thrown as a result of failure of class and interface resolution.
If C is an array class and its element type is a reference type, then the symbolic reference to the class or interface representing the element type is resolved by invoking the algorithm in §5.4.3.1 recursively.
This condition can occur, for example, if C is a class that was originally declared to be public but was changed to be non-public after D was compiled.
Nevertheless, resolution fails, and D is prohibited from accessing C.
To resolve an unresolved symbolic reference from D to a field in a class or interface C, the symbolic reference to C given by the field reference must first be resolved (§5.4.3.1)
Therefore, any exception that can be thrown as a result of failure of resolution of a class or interface reference can be thrown as a result of field resolution.
If the reference to C can be successfully resolved, an exception relating to the failure of resolution of the field reference itself can be thrown.
When resolving a field reference, field resolution first attempts to look up the referenced field in C and its superclasses:
The declared field is the result of the field lookup.
Otherwise, field lookup is applied recursively to the direct superinterfaces of the specified class or interface C.
Otherwise, if C has a superclass S, field lookup is applied recursively to S.
Otherwise, if field lookup succeeds but the referenced field is not accessible (§5.4.4) to D, field resolution throws an IllegalAccessError.
Given that the type of the referenced field is Tf, let T be Tf if Tf is not an array type, and let T be the element type (§2.4) of Tf otherwise.
To resolve an unresolved symbolic reference from D to a method in a class C, the symbolic reference to C given by the method reference is first resolved (§5.4.3.1)
Therefore, any exception that can be thrown as a result of failure of resolution of a class reference can be thrown as a result of method resolution.
If the reference to C can be successfully resolved, exceptions relating to the resolution of the method reference itself can be thrown.
Method resolution checks whether C is a class or an interface.
If C is an interface, method resolution throws an IncompatibleClassChangeError.
Method resolution attempts to look up the referenced method in C and its superclasses:
If C declares exactly one method with the name specified by the method reference, and the declaration is a signature polymorphic method (§2.9), then method lookup succeeds.
All the class names mentioned in the descriptor are resolved (§5.4.3.1)
It is not necessary for C to declare a method with the descriptor specified by the method reference.
Otherwise, if C declares a method with the name and descriptor specified by the method reference, method lookup succeeds.
Otherwise, if C has a superclass, step 2 of method lookup is recursively invoked on the direct superclass of C.
Otherwise, method lookup attempts to locate the referenced method in any of the superinterfaces of the specified class C.
If any superinterface of C declares a method with the name and descriptor.
Otherwise, if method lookup succeeds and the method is abstract, but C is not abstract, method resolution throws an AbstractMethodError.
Otherwise, if method lookup succeeds but the referenced method is not accessible (§5.4.4) to D, method resolution throws an IllegalAccessError.
Given that the return type of m is Tr, and that the formal parameter types of m are Tf1, ..., Tfn, then:
To resolve an unresolved symbolic reference from D to an interface method in an interface C, the symbolic reference to C given by the interface method reference is first resolved (§5.4.3.1)
Therefore, any exception that can be thrown as a result of failure of resolution of an interface reference can be thrown as a result of interface method resolution.
If the reference to C can be successfully resolved, exceptions relating to the resolution of the interface method reference itself can be thrown.
When resolving an interface method reference: • If C is not an interface, interface method resolution throws an IncompatibleClassChangeError.
Otherwise, if the referenced method does not have the same name and descriptor as a method in C or in one of the superinterfaces of C, or in class Object, interface method resolution throws a NoSuchMethodError.
Given that the return type of m is Tr, and that the formal parameter types of m are Tf1, ..., Tfn, then:
To resolve an unresolved symbolic reference to a method type, all symbolic references to classes mentioned in the method descriptor encapsulated by the method type are resolved (§5.4.3.1)
Therefore, any exception that can be thrown as a result of failure of resolution of a class reference can be thrown as a result of method type resolution.
The result of method type resolution is a reference to an instance of java.lang.invoke.MethodType which represents the method descriptor.
Resolution of an unresolved symbolic reference to a method handle is more complicated.
Each method handle resolved by the Java Virtual Machine has an equivalent instruction sequence called its bytecode behavior, indicated by the method handle's kind.
The integer values and descriptions of the nine kinds of method handle are given in Table 5.1
Let MH be the symbolic reference to a method handle (§5.1) being resolved.
Then: • Let R be the symbolic reference to the field or method contained within MH.
Let C be a symbolic reference to the type referenced by R.
Let f or m be the name of the field or method referenced by R.
Let T and (in the case of a method) A* be the return type and argument type sequence of the field or method referenced by R.
That is, C, f, m, T, and A* are resolved.
Therefore, any exception that can be thrown as a result of failure of resolution of a symbolic reference to a class, field, method, or interface method can be thrown as a result of method handle resolution.
In general, resolving a method handle can be done in exactly the same circumstances that the Java Virtual Machine would successfully resolve the symbolic references in the bytecode behavior.
The result of method handle resolution is a reference o to an instance of java.lang.invoke.MethodHandle which represents the method handle MH.
That is, creation of a variable arity method handle fails.) The type descriptor of the java.lang.invoke.MethodHandle instance referenced by o is the java.lang.invoke.MethodType instance produced by method type resolution mentioned earlier.
The type descriptor of a method handle is such that a valid call to invokeExact in java.lang.invoke.MethodHandle on the method handle has exactly the same stack effects as the bytecode behavior.
Calling this method handle on a valid set of arguments has exactly the same effect and returns the same result (if any) as the corresponding bytecode behavior.) An implementation of the Java Virtual Machine is not required to intern method types or method handles.
That is, two distinct symbolic references to method types or method handles which are structurally identical might not resolve to the same instance of java.lang.invoke.MethodType or java.lang.invoke.MethodHandle respectively.
The java.lang.invoke.MethodHandles class in the Java SE platform API allows creation of method handles with no bytecode behavior.
Their behavior is defined by the method of java.lang.invoke.MethodHandles that creates them.
For example, a method handle may, when invoked, first apply transformations to its argument values, then supply the transformed values to the invocation of another method handle, then apply a transformation to the value returned from that invocation, then return the transformed value as its own result.
To resolve an unresolved symbolic reference to a call site specifier involves three steps:
A call site specifier gives a symbolic reference to a method handle which is to serve as the bootstrap method for a dynamic call site.
The method handle is resolved (§5.4.3.5) to obtain a reference to an instance of java.lang.invoke.MethodHandle.
A reference to an instance of java.lang.invoke.MethodType is obtained as if by resolution of a symbolic reference to a method type (§5.4.3.5) with the same parameter and return types as TD.
A call site specifier gives zero or more static arguments, which communicate application-specific metadata to the bootstrap method.
Any static arguments which are symbolic references to classes, method handles, or method types are resolved, as if by invocation of the ldc instruction (§ldc), to obtain.
Any static arguments that are string literals are used to obtain references to String objects.
The result of call site specifier resolution is a tuple consisting of:
During resolution of the symbolic reference to the method handle in the call site specifier, or resolution of the symbolic reference to the method type for the method descriptor in the call site specifier, or resolution of a symbolic reference to any static argument, any of the exceptions pertaining to method type or method handle resolution (§5.4.3.5) may be thrown.
A class or interface C is accessible to a class or interface D if and only if either of the following conditions is true: • C is public.
A field or method R is accessible to a class or interface D if and only if any of the following conditions are true: • R is public.
Furthermore, if R is not static, then the symbolic reference to R must contain a symbolic reference to a class T, such that T is either a subclass of D, a superclass of D, or D itself.
This discussion of access control omits a related restriction on the target of a protected field access or method invocation (the target must be of class D or a subtype of D)
That requirement is checked as part of the verification process.
Initialization of a class or interface consists of executing its class or interface initialization method (§2.9)
A class or interface may be initialized only as a result of: • The execution of any one of the Java Virtual Machine instructions new, getstatic,
All of these instructions reference a class directly or indirectly through either a field reference or a method reference.
Upon execution of a new instruction, the referenced class or interface is initialized if it has not been initialized already.
Upon execution of a getstatic, putstatic, or invokestatic instruction, the class or interface that declared the resolved field or method is initialized if it has not been initialized already.
Invocation of certain reflective methods in the class library (§2.12), for example, in class Class or in package java.lang.reflect.
Its designation as the initial class at Java Virtual Machine start-up (§5.2)
Prior to initialization, a class or interface must be linked, that is, verified, prepared, and optionally resolved.
Because the Java Virtual Machine is multithreaded, initialization of a class or interface requires careful synchronization, since some other thread may be trying to initialize the same class or interface at the same time.
There is also the possibility that initialization of a class or interface may be requested recursively as part of the initialization of that class or interface.
The implementation of the Java Virtual Machine is responsible for taking care of synchronization and recursive initialization by using the following procedure.
It assumes that the Class object has already been verified and prepared, and that the Class object contains state that indicates one of four situations: • This Class object is verified and prepared but not initialized.
This Class object is being initialized by some particular thread.
This Class object is fully initialized and ready for use.
This Class object is in an erroneous state, perhaps because initialization was.
For each class or interface C, there is a unique initialization lock LC.
The mapping from C to LC is left to the discretion of the Java Virtual Machine implementation.
For example, LC could be the Class object for C, or the monitor associated with that Class object.
If the Class object for C indicates that initialization is in progress for C by the current thread, then this must be a recursive request for initialization.
If the Class object for C indicates that C has already been initialized, then no further action is required.
If the Class object for C is in an erroneous state, then initialization is not possible.
Otherwise, record the fact that initialization of the Class object for C is in progress by the current thread, and release LC.
Next, if C is a class rather than an interface, and its superclass SC has not yet been initialized, then recursively perform this entire procedure for SC.
If the initialization of SC completes abruptly because of a thrown exception, then acquire LC, label the Class object for C as erroneous, notify all waiting threads, release LC, and complete abruptly, throwing the same exception that resulted from initializing SC.
Next, determine whether assertions are enabled for C by querying its defining class loader.
Next, execute the class or interface initialization method of C.
Otherwise, the class or interface initialization method must have completed abruptly by throwing some exception E.
If the class of E is not Error or one of its subclasses, then create a new instance of the class ExceptionInInitializerError with E as the argument, and use this object in place of E in the following step.
If a new instance of ExceptionInInitializerError cannot be created because an OutOfMemoryError occurs, then use an OutOfMemoryError object in place of E in the following step.
Acquire LC, label the Class object for C as erroneous, notify all waiting threads, release LC, and complete this procedure abruptly with reason E or its replacement as determined in the previous step.
Binding is the process by which a function written in a language other than the Java programming language and implementing a native method is integrated into the Java Virtual Machine so that it can be executed.
Although this process is traditionally referred to as linking, the term binding is used in the specification to avoid confusion with linking of classes or interfaces by the Java Virtual Machine.
The Java Virtual Machine exits when some thread invokes the exit method of class Runtime or class System, or the halt method of class Runtime, and the exit or halt operation is permitted by the security manager.
A Java Virtual Machine instruction consists of an opcode specifying the operation to be performed, followed by zero or more operands embodying values to be operated upon.
This chapter gives details about the format of each Java Virtual Machine instruction and the operation it performs.
The description of each instruction is always given in the context of Java Virtual Machine code that satisfies the static and structural constraints of §4
If some constraint (a "must" or "must not") in an instruction description is not satisfied at run time, the behavior of the Java Virtual Machine is undefined.
The Java Virtual Machine checks that Java Virtual Machine code satisfies the static and structural constraints at link time using a class file verifier (§4.10)
Thus, a Java Virtual Machine will only attempt to execute code from valid class files.
Performing verification at link time is attractive in that the checks are performed just once, substantially reducing the amount of work that must be done at run time.
In addition to the opcodes of the instructions specified later in this chapter, which are used in class files (§4), three opcodes are reserved for internal use by a Java Virtual Machine implementation.
If the instruction set of the Java Virtual Machine is extended in the future, these reserved opcodes are guaranteed not to be used.
These instructions are intended to provide "back doors" or traps to implementation-specific functionality implemented in software and hardware, respectively.
Although these opcodes have been reserved, they may be used only inside a Java Virtual Machine implementation.
Tools such as debuggers or JIT code generators (§2.13) that might directly interact with Java Virtual Machine code that has been already loaded and executed may encounter these opcodes.
Such tools should attempt to behave gracefully if they encounter any of these reserved instructions.
A Java Virtual Machine implementation throws an object that is an instance of a subclass of the class VirtualMethodError when an internal error or resource limitation prevents it from implementing the semantics described in this chapter.
This specification cannot predict where internal errors or resource limitations may be encountered and does not mandate precisely when they can be reported.
Thus, any of the VirtualMethodError subclasses defined below may be thrown at any time during the operation of the Java Virtual Machine: • InternalError: An internal error has occurred in the Java Virtual Machine.
This error is delivered asynchronously (§2.10) when it is detected and may occur at any point in a program.
OutOfMemoryError: The Java Virtual Machine implementation has run out of either virtual or physical memory, and the automatic storage manager was unable to reclaim enough memory to satisfy an object creation request.
StackOverflowError: The Java Virtual Machine implementation has run out of stack space for a thread, typically because the thread is doing an unbounded number of recursive invocations as a result of a fault in the executing program.
UnknownError: An exception or error has occurred, but the Java Virtual Machine implementation is unable to report the actual exception or error.
Java Virtual Machine instructions are represented in this chapter by entries of the form shown below, in alphabetical order and each beginning on a new page.
Description A longer description detailing constraints on operand stack contents or constant pool entries, the operation performed, the type of the results, etc.
If any linking exceptions may be thrown by the execution of this instruction, they are set off one to a line, in the order in which they must be thrown.
If any run-time exceptions can be thrown by the execution of an instruction, they are set off one to a line, in the order in which they must be thrown.
Other than the linking and run-time exceptions, if any, listed for an instruction, that instruction must not throw any run-time exceptions except for instances of VirtualMethodError or its subclasses.
Notes Comments not strictly part of the specification of an instruction are set aside as notes at the end of the description.
Each cell in the instruction format diagram represents a single 8-bit byte.
Its opcode is its numeric representation and is given in both decimal and hexadecimal forms.
Only the numeric representation is actually present in the Java Virtual Machine code in a class file.
Keep in mind that there are "operands" generated at compile time and embedded within Java Virtual Machine instructions, as well as "operands" calculated at run time and supplied on the operand stack.
Although they are supplied from several different areas, all these operands represent the same thing: values to be operated upon by the Java Virtual Machine instruction being executed.
By implicitly taking many of its operands from its operand stack, rather than representing them explicitly in its compiled code as additional operand bytes, register numbers, etc., the Java Virtual Machine's code stays compact.
Some instructions are presented as members of a family of related instructions sharing a single description, format, and operand stack diagram.
As such, a family of instructions includes several opcodes and opcode mnemonics; only the family mnemonic appears in the instruction format diagram, and a separate forms line lists all member mnemonics and opcodes.
The remainder of the operand stack, represented by an ellipsis (...), is unaffected by the instruction's execution.
Values of types long and double are represented by a single entry on the operand stack.
In The Java Virtual Machine Specification, First Edition, values on the operand stack of types long and double were each represented in the stack diagram by two entries.
Description The arrayref must be of type reference and must refer to an array whose components are of type reference.
Both arrayref and index are popped from the operand stack.
The reference value in the component of the array at index is retrieved and pushed onto the operand stack.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the aaload instruction throws an ArrayIndexOutOfBoundsException.
Description The arrayref must be of type reference and must refer to an array whose components are of type reference.
The index must be of type int and value must be of type reference.
The arrayref, index, and value are popped from the operand stack.
The reference value is stored as the component of the array at index.
At run time, the type of value must be compatible with the type of the components of the array referenced by arrayref.
Specifically, assignment of a value of reference type S (source) to an array component of reference type T (target) is allowed only if: • If S is a class type, then:
If T is a class type, then S must be the same class as T, or S must be a subclass of T;
If T is an interface type, then S must implement interface T.
If S is an interface type, then: ◆ If T is a class type, then T must be Object.
If T is an interface type, then T must be the same interface as S or a superinterface of S.
If T is an interface type, then T must be one of the interfaces.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the aastore instruction throws an ArrayIndexOutOfBoundsException.
Otherwise, if arrayref is not null and the actual type of value is not assignment compatible (JLS §5.2) with the actual type of the components of the array, aastore throws an ArrayStoreException.
Description Push the null object reference onto the operand stack.
Notes The Java Virtual Machine does not mandate a concrete value for null.
Description The index is an unsigned byte that must be an index into the local variable array of the current frame (§2.6)
The objectref in the local variable at index is pushed onto the operand stack.
Notes The aload instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack.
The aload opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index.
The objectref in the local variable at <n> is pushed onto the operand stack.
Notes An aload_<n> instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack.
The count represents the number of components of the array to be created.
The run-time constant pool item at that index must be a symbolic reference to a class, array, or interface type.
The named class, array, or interface type is resolved (§5.4.3.1)
A new array with components of that type, of length count, is allocated from the garbage-collected heap, and a reference arrayref to this new array object is pushed onto the operand stack.
All components of the new array are initialized to null, the default value for reference types (§2.4)
During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in §5.4.3.1 can be thrown.
Otherwise, if count is less than zero, the anewarray instruction throws a NegativeArraySizeException.
Notes The anewarray instruction is used to create a single dimension of an array of object references or part of a multidimensional array.
If the current method is a synchronized method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a monitorexit instruction (§monitorexit) in the current thread.
If no exception is thrown, objectref is popped from the operand stack of the current frame (§2.6) and pushed onto the operand stack of the frame of the invoker.
Any other values on the operand stack of the current method are discarded.
The interpreter then reinstates the frame of the invoker and returns control to the invoker.
If the Java Virtual Machine implementation does not enforce the rules on structured locking described in §2.11.10, then if the current method is a synchronized method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, areturn throws an IllegalMonitorStateException.
This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.
Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in §2.11.10 and if the first of those rules is violated during invocation of the current method, then areturn throws an IllegalMonitorStateException.
Description The arrayref must be of type reference and must refer to an array.
That length is pushed onto the operand stack as an int.
If the arrayref is null, the arraylength instruction throws a NullPointerException.
Description The index is an unsigned byte that must be an index into the local variable array of the current frame (§2.6)
The objectref on the top of the operand stack must be of type returnAddress or of type reference.
It is popped from the operand stack, and the value of the local variable at index is set to objectref.
Notes The astore instruction is used with an objectref of type returnAddress when implementing the finally clause of the Java programming language (§3.13)
The aload instruction (§aload) cannot be used to load a value of type returnAddress from a local variable onto the operand stack.
The astore opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index.
The objectref on the top of the operand stack must be of type returnAddress or of type reference.
It is popped from the operand stack, and the value of the local variable at <n> is set to objectref.
Description The objectref must be of type reference and must refer to an object that is an instance of class Throwable or of a subclass of Throwable.
If an exception handler that matches objectref is found, it contains the location of the code intended to handle this exception.
The pc register is reset to that location, the operand stack of the current frame is cleared, objectref is pushed back onto the operand stack, and execution continues.
If no matching exception handler is found in the current frame, that frame is popped.
If the current frame represents an invocation of a synchronized method, the monitor entered or reentered on invocation of the method is exited as if by execution of a monitorexit instruction (§monitorexit)
Finally, the frame of its invoker is reinstated, if such a frame exists, and the objectref is rethrown.
If objectref is null, athrow throws a NullPointerException instead of objectref.
Otherwise, if the Java Virtual Machine implementation does not enforce the rules on structured locking described in §2.11.10, then if the method of the current frame is a synchronized method and the current thread is not the owner of the monitor.
This can happen, for example, if an abruptly completing synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.
Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in §2.11.10 and if the first of those rules is violated during invocation of the current method, then athrow throws an IllegalMonitorStateException instead of the object previously being thrown.
Notes The operand stack diagram for the athrow instruction may be misleading: If a handler for this exception is matched in the current method, the athrow instruction discards all the values on the operand stack, then pushes the thrown object onto the operand stack.
However, if no handler is matched in the current method and the exception is thrown farther up the method invocation chain, then the operand stack of the method (if any) that handles the exception is cleared and objectref is pushed onto that empty operand stack.
All intervening frames from the method that threw the exception up to, but not including, the method that handles the exception are discarded.
Description The arrayref must be of type reference and must refer to an array whose components are of type byte or of type boolean.
Both arrayref and index are popped from the operand stack.
The byte value in the component of the array at index is retrieved, sign-extended to an int value, and pushed onto the top of the operand stack.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the baload instruction throws an ArrayIndexOutOfBoundsException.
Notes The baload instruction is used to load values from both byte and boolean arrays.
Other implementations may implement packed boolean arrays; the baload instruction of such implementations must be used to access those arrays.
Description The arrayref must be of type reference and must refer to an array whose components are of type byte or of type boolean.
The index and the value must both be of type int.
The arrayref, index, and value are popped from the operand stack.
The int value is truncated to a byte and stored as the component of the array indexed by index.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the bastore instruction throws an ArrayIndexOutOfBoundsException.
Notes The bastore instruction is used to store values into both byte and boolean arrays.
Other implementations may implement packed boolean arrays; in such implementations the bastore instruction must be able to store boolean values into packed boolean arrays as well as byte values into byte arrays.
Description The immediate byte is sign-extended to an int value.
Description The arrayref must be of type reference and must refer to an array whose components are of type char.
Both arrayref and index are popped from the operand stack.
The component of the array at index is retrieved and zero-extended to an int value.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the caload instruction throws an ArrayIndexOutOfBoundsException.
Description The arrayref must be of type reference and must refer to an array whose components are of type char.
The index and the value must both be of type int.
The arrayref, index, and value are popped from the operand stack.
The int value is truncated to a char and stored as the component of the array indexed by index.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the castore instruction throws an ArrayIndexOutOfBoundsException.
The run-time constant pool item at the index must be a symbolic reference to a class, array, or interface type.
If objectref is null, then the operand stack is unchanged.
Otherwise, the named class, array, or interface type is resolved (§5.4.3.1)
If objectref can be cast to the resolved class, array, or interface type, the operand stack is unchanged; otherwise, the checkcast instruction throws a ClassCastException.
The following rules are used to determine whether an objectref that is not null can be cast to the resolved type: if S is the class of the object referred to by objectref and T is the resolved class, array, or interface type, checkcast determines whether objectref can be cast to type T as follows:
If S is an ordinary (nonarray) class, then: ◆ If T is a class type, then S must be the same class as T, or S.
If T is a class type, then T must be Object.
If T is an interface type, then T must be the same interface as S or a superinterface of S.
If T is an interface type, then T must be one of the interfaces.
If T is an array type TC[], that is, an array of components of.
During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in §5.4.3.1 can be thrown.
Otherwise, if objectref cannot be cast to the resolved class, array, or interface type, the checkcast instruction throws a ClassCastException.
Notes The checkcast instruction is very similar to the instanceof instruction (§instanceof)
It differs in its treatment of null, its behavior when its test fails (checkcast throws an exception, instanceof pushes a result code), and its effect on the operand stack.
Description The value on the top of the operand stack must be of type double.
It is popped from the operand stack and undergoes value set conversion (§2.8.3) resulting in value'
Then value' is converted to a float result using IEEE 754 round to nearest mode.
Where an d2f instruction is not FP-strict, the result of the conversion may be taken from the float-extended-exponent representable value in the float value set.
A finite value' too small to be represented as a float is converted to a zero of the same sign; a finite value' too large to be represented as a float is converted to an infinity of the same sign.
It may lose information about the overall magnitude of value' and may also lose precision.
Description The value on the top of the operand stack must be of type double.
It is popped from the operand stack and undergoes value set conversion (§2.8.3) resulting in value'
Otherwise, if the value' is not an infinity, it is rounded to an.
If this integer value V can be represented as an int, then the result is the int value V.
Otherwise, either the value' must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type int, or the value' must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type int.
It may lose information about the overall magnitude of value' and may also lose precision.
Description The value on the top of the operand stack must be of type double.
It is popped from the operand stack and undergoes value set conversion (§2.8.3) resulting in value'
Otherwise, if the value' is not an infinity, it is rounded to an.
If this integer value V can be represented as a long, then the result is the long value V.
Otherwise, either the value' must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type long, or the value' must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type long.
It may lose information about the overall magnitude of value' and may also lose precision.
The result of a dadd instruction is governed by the rules of IEEE arithmetic:
The sum of two infinities of opposite sign is NaN.
The sum of two infinities of the same sign is the infinity of that sign.
The sum of an infinity and any finite value is equal to the infinity.
The sum of two zeroes of opposite sign is positive zero.
The sum of two zeroes of the same sign is the zero of that sign.
The sum of a zero and a nonzero finite value is equal to the nonzero value.
The sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.
In the remaining cases, where neither operand is an infinity, a zero, or NaN and the values have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using IEEE 754 round to nearest mode.
If the magnitude is too small to represent as a double, we say the operation underflows; the result is then a zero of appropriate sign.
The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754
Despite the fact that overflow, underflow, or loss of precision may occur, execution of a dadd instruction never throws a run-time exception.
Description The arrayref must be of type reference and must refer to an array whose components are of type double.
Both arrayref and index are popped from the operand stack.
The double value in the component of the array at index is retrieved and pushed onto the operand stack.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the daload instruction throws an ArrayIndexOutOfBoundsException.
Description The arrayref must be of type reference and must refer to an array whose components are of type double.
The index must be of type int, and value must be of type double.
The arrayref, index, and value are popped from the operand stack.
The double value undergoes value set conversion (§2.8.3), resulting in value', which is stored as the component of the array indexed by index.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the dastore instruction throws an ArrayIndexOutOfBoundsException.
All values other than NaN are ordered, with negative infinity less than all finite values and positive infinity greater than all finite values.
Notes The dcmpg and dcmpl instructions differ only in their treatment of a comparison involving NaN.
NaN is unordered, so any double comparison fails if either or both of its operands are NaN.
With both dcmpg and dcmpl available, any double comparison may.
The result of a ddiv instruction is governed by the rules of IEEE arithmetic:
Division of an infinity by an infinity results in NaN.
Division of an infinity by a finite value results in a signed.
Division of a finite value by an infinity results in a signed zero,
Division of a zero by a zero results in NaN; division of zero.
Division of a nonzero finite value by a zero results in a signed infinity, with the sign-producing rule just given.
In the remaining cases, where neither operand is an infinity, a zero, or NaN, the quotient is computed and rounded to the nearest double using IEEE 754 round to nearest mode.
If the magnitude is too small to represent as a double, we say the operation underflows; the result is then a zero of appropriate sign.
The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754
Despite the fact that overflow, underflow, division by zero, or loss of precision may occur, execution of a ddiv instruction never throws a run-time exception.
The value of the local variable at index is pushed onto the operand stack.
Notes The dload opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index.
The value of the local variable at <n> is pushed onto the operand stack.
The result of a dmul instruction is governed by the rules of IEEE arithmetic:
Multiplication of an infinity by a zero results in NaN.
Multiplication of an infinity by a finite value results in a signed.
In the remaining cases, where neither an infinity nor NaN is.
If the magnitude is too large to represent as a double, we say the operation overflows; the result is then an infinity of appropriate sign.
If the magnitude is too small to represent as a double, we say the operation underflows; the result is then a zero of appropriate sign.
The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754
It is popped from the operand stack and undergoes value set conversion (§2.8.3), resulting in value'
For double values, negation is not the same as subtraction from zero.
If the operand is NaN, the result is NaN (recall that NaN has no sign)
If the operand is an infinity, the result is the infinity of opposite sign.
If the operand is a zero, the result is the zero of opposite sign.
The result is calculated and pushed onto the operand stack as a double.
The result of a drem instruction is not the same as that of the socalled remainder operation defined by IEEE 754
The IEEE 754 "remainder" operation computes the remainder from a rounding division, not a truncating division, and so its behavior is not analogous to that of the usual integer remainder operator.
Instead, the Java Virtual Machine defines drem to behave in a manner analogous to that of the Java Virtual Machine integer remainder library function fmod.
If the dividend is an infinity or the divisor is a zero or both, the.
If the dividend is finite and the divisor is an infinity, the result equals the dividend.
If the dividend is a zero and the divisor is finite, the result equals the dividend.
Despite the fact that division by zero may occur, evaluation of a drem instruction never throws a run-time exception.
Notes The IEEE 754 remainder operation may be computed by the library routine Math.IEEEremainder.
If the current method is a synchronized method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a monitorexit instruction (§monitorexit) in the current thread.
The value' is pushed onto the operand stack of the frame of the invoker.
Any other values on the operand stack of the current method are discarded.
The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.
If the Java Virtual Machine implementation does not enforce the rules on structured locking described in §2.11.10, then if the current method is a synchronized method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, dreturn throws an IllegalMonitorStateException.
This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.
Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in §2.11.10 and if the first of those rules is violated during invocation of the current method, then dreturn throws an IllegalMonitorStateException.
The value on the top of the operand stack must be of type double.
It is popped from the operand stack and undergoes value set conversion (§2.8.3), resulting in value'
The local variables at index and index+1 are set to value'
Notes The dstore opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index.
The value on the top of the operand stack must be of type double.
It is popped from the operand stack and undergoes value set conversion (§2.8.3), resulting in value'
For double subtraction, it is always the case that a-b produces the same result as a+(-b)
The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754
Despite the fact that overflow, underflow, or loss of precision may occur, execution of a dsub instruction never throws a run-time exception.
Description Duplicate the top value on the operand stack and push the duplicated value onto the operand stack.
Operation Duplicate the top operand stack value and insert two values down.
Description Duplicate the top value on the operand stack and insert the duplicated value two values down in the operand stack.
Operation Duplicate the top operand stack value and insert two or three values down.
Description Duplicate the top value on the operand stack and insert the duplicated value two or three values down in the operand stack.
Operation Duplicate the top one or two operand stack values.
Description Duplicate the top one or two values on the operand stack and push the duplicated value or values back onto the operand stack in the original order.
Operation Duplicate the top one or two operand stack values and insert two or three values down.
Description Duplicate the top one or two values on the operand stack and insert the duplicated values, in the original order, one value beneath the original value or values in the operand stack.
Operation Duplicate the top one or two operand stack values and insert two, three, or four values down.
Description Duplicate the top one or two values on the operand stack and insert the duplicated values, in the original order, into the operand stack.
Description The value on the top of the operand stack must be of type float.
It is popped from the operand stack and undergoes value set conversion (§2.8.3), resulting in value'
Where an f2d instruction is not FP-strict, the result of the conversion may be taken from the double-extended-exponent value set; it is not necessarily rounded to the nearest representable value in the double value set.
However, if the operand value is taken from the float-extended-exponent value set and the target result is constrained to the double value set, rounding of value may be required.
Description The value on the top of the operand stack must be of type float.
It is popped from the operand stack and undergoes value set conversion (§2.8.3), resulting in value'
Otherwise, if the value' is not an infinity, it is rounded to an.
If this integer value V can be represented as an int, then the result is the int value V.
Otherwise, either the value' must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type int, or the value' must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type int.
It may lose information about the overall magnitude of value' and may also lose precision.
Description The value on the top of the operand stack must be of type float.
It is popped from the operand stack and undergoes value set conversion (§2.8.3), resulting in value'
Otherwise, if the value' is not an infinity, it is rounded to an.
If this integer value V can be represented as a long, then the result is the long value V.
Otherwise, either the value' must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type long, or the value' must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type long.
It may lose information about the overall magnitude of value' and may also lose precision.
The result of an fadd instruction is governed by the rules of IEEE arithmetic:
The sum of two infinities of opposite sign is NaN.
The sum of two infinities of the same sign is the infinity of that sign.
The sum of an infinity and any finite value is equal to the infinity.
The sum of two zeroes of opposite sign is positive zero.
The sum of two zeroes of the same sign is the zero of that sign.
The sum of a zero and a nonzero finite value is equal to the nonzero value.
The sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.
In the remaining cases, where neither operand is an infinity, a zero, or NaN and the values have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using IEEE 754 round to nearest mode.
If the magnitude is too small to represent as a float, we say the operation underflows; the result is then a zero of appropriate sign.
The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754
Despite the fact that overflow, underflow, or loss of precision may occur, execution of an fadd instruction never throws a run-time exception.
Description The arrayref must be of type reference and must refer to an array whose components are of type float.
Both arrayref and index are popped from the operand stack.
The float value in the component of the array at index is retrieved and pushed onto the operand stack.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the faload instruction throws an ArrayIndexOutOfBoundsException.
Description The arrayref must be of type reference and must refer to an array whose components are of type float.
The index must be of type int, and the value must be of type float.
The arrayref, index, and value are popped from the operand stack.
The float value undergoes value set conversion (§2.8.3), resulting in value', and value' is stored as the component of the array indexed by index.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the fastore instruction throws an ArrayIndexOutOfBoundsException.
All values other than NaN are ordered, with negative infinity less than all finite values and positive infinity greater than all finite values.
Notes The fcmpg and fcmpl instructions differ only in their treatment of a comparison involving NaN.
NaN is unordered, so any float comparison fails if either or both of its operands are NaN.
With both fcmpg and fcmpl available, any float comparison may.
The result of an fdiv instruction is governed by the rules of IEEE arithmetic:
Division of an infinity by an infinity results in NaN.
Division of an infinity by a finite value results in a signed.
Division of a finite value by an infinity results in a signed zero,
Division of a zero by a zero results in NaN; division of zero.
Division of a nonzero finite value by a zero results in a signed infinity, with the sign-producing rule just given.
In the remaining cases, where neither operand is an infinity, a zero, or NaN, the quotient is computed and rounded to the nearest float using IEEE 754 round to nearest mode.
If the magnitude is too small to represent as a float, we say the operation underflows; the result is then a zero of appropriate sign.
The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754
Despite the fact that overflow, underflow, division by zero, or loss of precision may occur, execution of an fdiv instruction never throws a run-time exception.
Description The index is an unsigned byte that must be an index into the local variable array of the current frame (§2.6)
The value of the local variable at index is pushed onto the operand stack.
Notes The fload opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index.
The value of the local variable at <n> is pushed onto the operand stack.
The result of an fmul instruction is governed by the rules of IEEE arithmetic:
Multiplication of an infinity by a zero results in NaN.
Multiplication of an infinity by a finite value results in a signed.
In the remaining cases, where neither an infinity nor NaN is.
If the magnitude is too large to represent as a float, we say the operation overflows; the result is then an infinity of appropriate sign.
If the magnitude is too small to represent as a float, we say the operation underflows; the result is then a zero of appropriate sign.
The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754
It is popped from the operand stack and undergoes value set conversion (§2.8.3), resulting in value'
For float values, negation is not the same as subtraction from zero.
If the operand is NaN, the result is NaN (recall that NaN has no sign)
If the operand is an infinity, the result is the infinity of opposite sign.
If the operand is a zero, the result is the zero of opposite sign.
The result is calculated and pushed onto the operand stack as a float.
The result of an frem instruction is not the same as that of the socalled remainder operation defined by IEEE 754
The IEEE 754 "remainder" operation computes the remainder from a rounding division, not a truncating division, and so its behavior is not analogous to that of the usual integer remainder operator.
Instead, the Java Virtual Machine defines frem to behave in a manner analogous to that of the Java Virtual Machine integer remainder library function fmod.
If the dividend is an infinity or the divisor is a zero or both, the.
If the dividend is finite and the divisor is an infinity, the result equals the dividend.
If the dividend is a zero and the divisor is finite, the result equals the dividend.
Despite the fact that division by zero may occur, evaluation of an frem instruction never throws a run-time exception.
Notes The IEEE 754 remainder operation may be computed by the library routine Math.IEEEremainder.
If the current method is a synchronized method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a monitorexit instruction (§monitorexit) in the current thread.
The value' is pushed onto the operand stack of the frame of the invoker.
Any other values on the operand stack of the current method are discarded.
The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.
If the Java Virtual Machine implementation does not enforce the rules on structured locking described in §2.11.10, then if the current method is a synchronized method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, freturn throws an IllegalMonitorStateException.
This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.
Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in §2.11.10 and if the first of those rules is violated during invocation of the current method, then freturn throws an IllegalMonitorStateException.
Description The index is an unsigned byte that must be an index into the local variable array of the current frame (§2.6)
The value on the top of the operand stack must be of type float.
It is popped from the operand stack and undergoes value set conversion (§2.8.3), resulting in value'
The value of the local variable at index is set to value'
Notes The fstore opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index.
The value on the top of the operand stack must be of type float.
It is popped from the operand stack and undergoes value set conversion (§2.8.3), resulting in value'
The value of the local variable at <n> is set to value'
For float subtraction, it is always the case that a-b produces the same result as a+(-b)
The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754
Despite the fact that overflow, underflow, or loss of precision may occur, execution of an fsub instruction never throws a run-time exception.
Description The objectref, which must be of type reference, is popped from the operand stack.
The run-time constant pool item at that index must be a symbolic reference to a field (§5.1), which gives the name and descriptor of the field as well as a symbolic reference to the class in which the field is to be found.
The value of the referenced field in objectref is fetched and pushed onto the operand stack.
The type of objectref must not be an array type.
During resolution of the symbolic reference to the field, any of the errors pertaining to field resolution (§5.4.3.2) can be thrown.
Otherwise, if the resolved field is a static field, getfield throws an IncompatibleClassChangeError.
Otherwise, if objectref is null, the getfield instruction throws a NullPointerException.
Notes The getfield instruction cannot be used to access the length field of an array.
The run-time constant pool item at that index must be a symbolic reference to a field (§5.1), which gives the name and descriptor of the field as well as a symbolic reference to the class or interface in which the field is to be found.
On successful resolution of the field, the class or interface that declared the resolved field is initialized (§5.5) if that class or interface has not already been initialized.
The value of the class or interface field is fetched and pushed onto the operand stack.
During resolution of the symbolic reference to the class or interface field, any of the exceptions pertaining to field resolution (§5.4.3.2) can be thrown.
Otherwise, if the resolved field is not a static (class) field or an interface field, getstatic throws an IncompatibleClassChangeError.
Otherwise, if execution of this getstatic instruction causes initialization of the referenced class or interface, getstatic may throw an Error as detailed in §5.5
Execution proceeds at that offset from the address of the opcode of this goto instruction.
The target address must be that of an opcode of an instruction within the method that contains this goto instruction.
Execution proceeds at that offset from the address of the opcode of this goto_w instruction.
The target address must be that of an opcode of an instruction within the method that contains this goto_w instruction.
This limit may be raised in a future release of the Java Virtual Machine.
Description The value on the top of the operand stack must be of type int.
It is popped from the operand stack, truncated to a byte, then signextended to an int result.
It may lose information about the overall magnitude of value.
The result may also not have the same sign as value.
Description The value on the top of the operand stack must be of type int.
It is popped from the operand stack, truncated to char, then zeroextended to an int result.
It may lose information about the overall magnitude of value.
The result (which is always positive) may also not have the same sign as value.
Description The value on the top of the operand stack must be of type int.
It is popped from the operand stack and converted to a double result.
Because all values of type int are exactly representable by type double, the conversion is exact.
Description The value on the top of the operand stack must be of type int.
It is popped from the operand stack and converted to the float result using IEEE 754 round to nearest mode.
Description The value on the top of the operand stack must be of type int.
It is popped from the operand stack and sign-extended to a long result.
Because all values of type int are exactly representable by type long, the conversion is exact.
Description The value on the top of the operand stack must be of type int.
It is popped from the operand stack, truncated to a short, then signextended to an int result.
It may lose information about the overall magnitude of value.
The result may also not have the same sign as value.
The result is the 32 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type int.
If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.
Despite the fact that overflow may occur, execution of an iadd instruction never throws a run-time exception.
Description The arrayref must be of type reference and must refer to an array whose components are of type int.
Both arrayref and index are popped from the operand stack.
The int value in the component of the array at index is retrieved and pushed onto the operand stack.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the iaload instruction throws an ArrayIndexOutOfBoundsException.
Description The arrayref must be of type reference and must refer to an array whose components are of type int.
The arrayref, index, and value are popped from the operand stack.
The int value is stored as the component of the array indexed by index.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the iastore instruction throws an ArrayIndexOutOfBoundsException.
There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for the int type, and the divisor is -1, then overflow occurs, and the result is equal to the dividend.
Despite the overflow, no exception is thrown in this case.
If the value of the divisor in an int division is 0, idiv throws an ArithmeticException.
They are both popped from the operand stack and compared.
Execution then proceeds at that offset from the address of the opcode of this if_acmp<cond> instruction.
The target address must be that of an opcode of an instruction within the method that contains this if_acmp<cond> instruction.
Otherwise, if the comparison fails, execution proceeds at the address of the instruction following this if_acmp<cond> instruction.
They are both popped from the operand stack and compared.
Execution then proceeds at that offset from the address of the opcode of this if_icmp<cond> instruction.
Otherwise, execution proceeds at the address of the instruction following this if_icmp<cond> instruction.
It is popped from the operand stack and compared against zero.
Execution then proceeds at that offset from the address of the opcode of this if<cond> instruction.
Otherwise, execution proceeds at the address of the instruction following this if<cond> instruction.
Execution then proceeds at that offset from the address of the opcode of this ifnonnull instruction.
The target address must be that of an opcode of an instruction within the method that contains this ifnonnull instruction.
Otherwise, execution proceeds at the address of the instruction following this ifnonnull instruction.
Execution then proceeds at that offset from the address of the opcode of this ifnull instruction.
The target address must be that of an opcode of an instruction within the method that contains this ifnull instruction.
Otherwise, execution proceeds at the address of the instruction following this ifnull instruction.
Description The index is an unsigned byte that must be an index into the local variable array of the current frame (§2.6)
The value const is first sign-extended to an int, and then the local variable at index is incremented by that amount.
Notes The iinc opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index and to increment it by a two-byte immediate signed value.
Description The index is an unsigned byte that must be an index into the local variable array of the current frame (§2.6)
The value of the local variable at index is pushed onto the operand stack.
Notes The iload opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index.
The value of the local variable at <n> is pushed onto the operand stack.
The result is the 32 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type int.
If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.
Despite the fact that overflow may occur, execution of an imul instruction never throws a run-time exception.
The int result is the arithmetic negation of value, -value.
For int values, negation is the same as subtraction from zero.
Because the Java Virtual Machine uses two's-complement representation for integers and the range of two's-complement values is not symmetric, the negation of the maximum negative int results in that same maximum negative number.
Despite the fact that overflow has occurred, no exception is thrown.
Description The objectref, which must be of type reference, is popped from the operand stack.
The run-time constant pool item at the index must be a symbolic reference to a class, array, or interface type.
If objectref is null, the instanceof instruction pushes an int result of 0 as an int on the operand stack.
Otherwise, the named class, array, or interface type is resolved (§5.4.3.1)
The following rules are used to determine whether an objectref that is not null is an instance of the resolved type: If S is the class of the object referred to by objectref and T is the resolved class, array, or interface type, instanceof determines whether objectref is an instance of T as follows:
If S is an ordinary (nonarray) class, then: ◆ If T is a class type, then S must be the same class as T, or S.
If S is an interface type, then: ◆ If T is a class type, then T must be Object.
If T is an interface type, then T must be the same interface as S or a superinterface of S.
If T is an interface type, then T must be one of the interfaces.
If T is an array type TC[], that is, an array of components of.
During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in §5.4.3.1 can be thrown.
Notes The instanceof instruction is very similar to the checkcast instruction (§checkcast)
It differs in its treatment of null, its behavior when its test fails (checkcast throws an exception, instanceof pushes a result code), and its effect on the operand stack.
Description Each specific lexical occurrence of an invokedynamic instruction is called a dynamic call site.
The run-time constant pool item at that index must be a symbolic reference to a call site specifier (§5.1)
The values of the third and fourth operand bytes must always be zero.
The call site specifier is resolved (§5.4.3.6) for this specific dynamic call site to obtain a reference to a java.lang.invoke.MethodHandle instance, a reference to a java.lang.invoke.MethodType instance, and references to static arguments.
The method's descriptor has parameter types derived from the items pushed on to the operand stack, as follows.
The first four parameter types in the descriptor are java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandles.Lookup, String, and java.lang.invoke.MethodType, in that order.
If the call site specifier has any static arguments, then a parameter type for each argument is appended to the parameter types of the method descriptor in the order that the arguments were pushed on to the operand stack.
These parameter types may be Class, java.lang.invoke.MethodHandle, java.lang.invoke.MethodType, String, int, long, float, or double.
The method's symbolic reference to the class in which the method is to be found indicates the class java.lang.invoke.MethodHandle.
As long as the bootstrap method can be correctly invoked by the invoke method, its descriptor is arbitrary.
For example, the first parameter type could be Object instead of java.lang.invoke.MethodHandles.Lookup, and the return type could also be Object instead of java.lang.invoke.CallSite.
If the bootstrap method is a variable arity method, then some or all of the arguments on the operand stack specified above may be collected into a trailing array parameter.
The invocation of a bootstrap method occurs within a thread that is attempting resolution of the symbolic reference to the call site specifier of this dynamic call site.
If there are several such threads, the bootstrap method may be invoked in several threads concurrently.
Therefore, bootstrap methods which access global application data must take the usual precautions against race conditions.
The result returned by the bootstrap method must be a reference to an object whose class is java.lang.invoke.CallSite or a subclass of java.lang.invoke.CallSite.
The reference is popped from the operand stack used as if in the execution of an invokevirtual instruction.
If several threads simultaneously execute the bootstrap method for the same dynamic call site, the Java Virtual Machine must choose one returned call site object and install it visibly to all threads.
Any other bootstrap methods executing for the dynamic call site are allowed to complete, but their results are ignored, and the threads' execution of the dynamic call site proceeds with the chosen call site object.
The call site object has a type descriptor (an instance of java.lang.invoke.MethodType) which must be semantically equal to the java.lang.invoke.MethodType object obtained for the method descriptor in the call site specifier.
The result of successful call site specifier resolution is a call site object which is permanently bound to the dynamic call site.
The method handle represented by the target of the bound call site object is invoked.
The invocation occurs as if by execution of an invokevirtual instruction (§invokevirtual) that indicates a run-time.
The method's name is invokeExact; • The method's descriptor is the method descriptor in the call site.
The operand stack will be interpreted as containing a reference to the target of the call site object, followed by nargs argument values, where the number, type, and order of the values must be consistent with the method descriptor in the call site specifier.
If resolution of the symbolic reference to the call site specifier throws an exception E, the invokedynamic instruction throws a BootstrapMethodError that wraps E.
Otherwise, during the continuing resolution of the call site specifier, if invocation of the bootstrap method completes abruptly (§2.6.5) because of a throw of exception E, the invokedynamic instruction throws a BootstrapMethodError that wraps E.
This can occur if the bootstrap method has the wrong arity, parameter type, or return type, causing java.lang.invoke.MethodHandle.
Otherwise, during the continuing resolution of the call site specifier, if the type descriptor of the target of the call site object is not semantically equal to the method descriptor in the call site specifier, the invokedynamic instruction throws a BootstrapMethodError.
If this specific dynamic call site completed resolution of its call site specifier, it implies that a non-null reference to an instance of java.lang.invoke.CallSite is bound to this dynamic call site.
Therefore, the operand stack item which represents a reference to the target of the call site object is never null.
Similarly, it implies that the method descriptor in the call site specifier is semantically equal to the type descriptor of the method handle to be invoked as if by execution of an invokevirtual instruction.
These invariants mean that an invokedynamic instruction which is bound to a call site object never throws a NullPointerException or a java.lang.invoke.WrongMethodTypeException.
The count operand is an unsigned byte that must not be zero.
The objectref must be of type reference and must be followed on the operand stack by nargs argument values, where the number, type, and order of the values must be consistent with the descriptor of the resolved interface method.
The value of the fourth operand byte must always be zero.
The actual method to be invoked is selected by the following lookup procedure: • If C contains a declaration for an instance method with the same.
Otherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C; the method to be invoked is the result of the recursive invocation of this lookup procedure.
If the method is synchronized, the monitor associated with objectref is entered or reentered as if by execution of a monitorenter instruction (§monitorenter) in the current thread.
If the method is not native, the nargs argument values and objectref are popped from the operand stack.
A new frame is created on the Java Virtual Machine stack for the method being invoked.
Any argument value that is of a floating-point type undergoes value set conversion (§2.8.3) prior to being stored in a local variable.
The new frame is then made current, and the Java Virtual Machine pc is set to the opcode of the first instruction of the method to be invoked.
If the method is native and the platform-dependent code that implements it has not yet been bound (§5.6) into the Java Virtual Machine, that is done.
The nargs argument values and objectref are popped from the operand stack and are passed as parameters to the code that implements the method.
Any argument value that is of a floating-point type undergoes value set conversion (§2.8.3) prior to being passed as a parameter.
The parameters are passed and the code is invoked in an implementation-dependent manner.
When the platform-dependent code returns: • If the native method is synchronized, the monitor associated.
If the native method returns a value, the return value of the platform-dependent code is converted in an implementationdependent way to the return type of the native method and pushed onto the operand stack.
During resolution of the symbolic reference to the interface method, any of the exceptions pertaining to interface method resolution (§5.4.3.4) can be thrown.
Otherwise, if objectref is null, the invokeinterface instruction throws a NullPointerException.
Otherwise, if the class of objectref does not implement the resolved interface, invokeinterface throws an IncompatibleClassChangeError.
Otherwise, if no method matching the resolved name and descriptor is selected, invokeinterface throws an AbstractMethodError.
Otherwise, if the selected method is not public, invokeinterface throws an IllegalAccessError.
Otherwise, if the selected method is abstract, invokeinterface throws an AbstractMethodError.
Otherwise, if the selected method is native and the code that implements the method cannot be bound, invokeinterface throws an UnsatisfiedLinkError.
Notes The count operand of the invokeinterface instruction records a measure of the number of argument values, where an argument value of type long or type double contributes two units to the count value and an argument of any other type contributes one unit.
This information can also be derived from the descriptor of the selected method.
The fourth operand byte exists to reserve space for an additional operand used in certain of Oracle's Java Virtual Machine implementations, which replace the invokeinterface instruction by a specialized pseudo-instruction at run time.
The nargs argument values and objectref are not one-to-one with the first nargs+1 local variables.
Argument values of types long and double must be stored in two consecutive local variables, thus more than nargs local variables may be required to pass nargs argument values to the invoked method.
Operation Invoke instance method; special handling for superclass, private, and instance initialization method invocations.
The class of the resolved method is a superclass of the current.
The resolved method is not an instance initialization method (§2.9)
If the above conditions are true, the actual method to be invoked is selected by the following lookup procedure.
Let C be the direct superclass of the current class:
If C contains a declaration for an instance method with the same name and descriptor as the resolved method, then this method will be invoked.
Otherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C.
The method to be invoked is the result of the recursive invocation of this lookup procedure.
The objectref must be of type reference and must be followed on the operand stack by nargs argument values, where the number, type, and order of the values must be consistent with the descriptor of the selected instance method.
If the method is synchronized, the monitor associated with objectref is entered or reentered as if by execution of a monitorenter instruction (§monitorenter) in the current thread.
If the method is not native, the nargs argument values and objectref are popped from the operand stack.
A new frame is created on the Java Virtual Machine stack for the method being invoked.
Any argument value that is of a floating-point type undergoes value set conversion (§2.8.3) prior to being stored in a local variable.
The new frame is then made current, and the Java Virtual Machine pc is set to the opcode of the first instruction of the method to be invoked.
If the method is native and the platform-dependent code that implements it has not yet been bound (§5.6) into the Java Virtual Machine, that is done.
The nargs argument values and objectref are popped from the operand stack and are passed as parameters to the code that implements the method.
Any argument value that is of a floating-point type undergoes value set conversion (§2.8.3) prior.
The parameters are passed and the code is invoked in an implementation-dependent manner.
When the platform-dependent code returns, the following take place: • If the native method is synchronized, the monitor associated.
If the native method returns a value, the return value of the platform-dependent code is converted in an implementationdependent way to the return type of the native method and pushed onto the operand stack.
During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution (§5.4.3.3) can be thrown.
Otherwise, if the resolved method is an instance initialization method, and the class in which it is declared is not the class symbolically referenced by the instruction, a NoSuchMethodError is thrown.
Otherwise, if the resolved method is a class (static) method, the invokespecial instruction throws an IncompatibleClassChangeError.
Otherwise, if objectref is null, the invokespecial instruction throws a NullPointerException.
Otherwise, if no method matching the resolved name and descriptor is selected, invokespecial throws an AbstractMethodError.
Otherwise, if the selected method is abstract, invokespecial throws an AbstractMethodError.
Otherwise, if the selected method is native and the code that implements the method cannot be bound, invokespecial throws an UnsatisfiedLinkError.
Notes The difference between the invokespecial instruction and the invokevirtual instruction (§invokevirtual) is that invokevirtual invokes a method based on the class of the object.
The invokespecial instruction was named invokenonvirtual prior to JDK release 1.0.2
The nargs argument values and objectref are not one-to-one with the first nargs+1 local variables.
Argument values of types long and double must be stored in two consecutive local variables, thus more than nargs local variables may be required to pass nargs argument values to the invoked method.
On successful resolution of the method, the class that declared the resolved method is initialized (§5.5) if that class has not already been initialized.
The operand stack must contain nargs argument values, where the number, type, and order of the values must be consistent with the descriptor of the resolved method.
If the method is synchronized, the monitor associated with the resolved Class object is entered or reentered as if by execution of a monitorenter instruction (§monitorenter) in the current thread.
If the method is not native, the nargs argument values are popped from the operand stack.
A new frame is created on the Java Virtual Machine stack for the method being invoked.
Any argument value that is of a floating-point type undergoes value set conversion (§2.8.3) prior to being stored in a local variable.
The new frame is then made current, and the Java Virtual Machine pc is set to the opcode of the first instruction of the method to be invoked.
If the method is native and the platform-dependent code that implements it has not yet been bound (§5.6) into the Java Virtual Machine, that is done.
The nargs argument values are popped from the operand stack and are passed as parameters to the code that implements the method.
Any argument value that is of a floatingpoint type undergoes value set conversion (§2.8.3) prior to being passed as a parameter.
The parameters are passed and the code is invoked in an implementation-dependent manner.
When the platform-dependent code returns, the following take place: • If the native method is synchronized, the monitor associated.
If the native method returns a value, the return value of the platform-dependent code is converted in an implementationdependent way to the return type of the native method and pushed onto the operand stack.
During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution (§5.4.3.3) can be thrown.
Otherwise, if the resolved method is an instance method, the invokestatic instruction throws an IncompatibleClassChangeError.
Otherwise, if execution of this invokestatic instruction causes initialization of the referenced class, invokestatic may throw an Error as detailed in §5.5
Otherwise, if the resolved method is native and the code that implements the method cannot be bound, invokestatic throws an UnsatisfiedLinkError.
Notes The nargs argument values are not one-to-one with the first nargs local variables.
Argument values of types long and double must be stored in two consecutive local variables, thus more than nargs local variables may be required to pass nargs argument values to the invoked method.
If the resolved method is not signature polymorphic (§2.9), then the invokevirtual instruction proceeds as follows.
The actual method to be invoked is selected by the following lookup procedure: • If C contains a declaration for an instance method m that.
Otherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C; the.
The objectref must be followed on the operand stack by nargs argument values, where the number, type, and order of the values must be consistent with the descriptor of the selected instance method.
If the method is synchronized, the monitor associated with objectref is entered or reentered as if by execution of a monitorenter instruction (§monitorenter) in the current thread.
If the method is not native, the nargs argument values and objectref are popped from the operand stack.
A new frame is created on the Java Virtual Machine stack for the method being invoked.
Any argument value that is of a floating-point type undergoes value set conversion (§2.8.3) prior to being stored in a local variable.
The new frame is then made current, and the Java Virtual Machine pc is set to the opcode of the first instruction of the method to be invoked.
If the method is native and the platform-dependent code that implements it has not yet been bound (§5.6) into the Java Virtual Machine, that is done.
The nargs argument values and objectref are popped from the operand stack and are passed as parameters to the code that implements the method.
Any argument value that is of a floating-point type undergoes value set conversion (§2.8.3) prior to being passed as a parameter.
The parameters are passed and the code is invoked in an implementation-dependent manner.
When the platform-dependent code returns, the following take place: • If the native method is synchronized, the monitor associated.
If the native method returns a value, the return value of the platform-dependent code is converted in an implementationTHE JAVA VIRTUAL MACHINE INSTRUCTION SET Instructions 6.5
If the resolved method is signature polymorphic (§2.9), then the invokevirtual instruction proceeds as follows.
First, a reference to an instance of java.lang.invoke.MethodType is obtained as if by resolution of a symbolic reference to a method type (§5.4.3.5) with the same parameter and return types as the descriptor of the method referenced by the invokevirtual instruction.
If the named method is invokeExact, the instance of java.lang.invoke.MethodType must be semantically equal to the type descriptor of the receiving method handle objectref.
If the named method is invoke, and the instance of java.lang.invoke.MethodType is semantically equal to the type descriptor of the receiving method handle objectref, then the method handle to be invoked is objectref.
If the named method is invoke, and the instance of java.lang.invoke.MethodType is not semantically equal to the type descriptor of the receiving method handle objectref, then the Java Virtual Machine attempts to adjust the type descriptor of the receiving method handle, as if by a call to java.lang.invoke.MethodHandle.asType, to obtain an exactly invokable method handle m.
The objectref must be followed on the operand stack by nargs argument values, where the number, type, and order of the values must be consistent with the type descriptor of the method handle to be invoked.
This type descriptor will correspond to the method descriptor appropriate for the kind of the method handle to be invoked, as specified in §5.4.3.5.) Then, if the method handle to be invoked has bytecode behavior, the Java Virtual Machine invokes the method handle as if by execution of the bytecode behavior associated with the method handle's kind.
REF_invokeInterface), then a frame will be created and made current in the course of executing the bytecode behavior; when the method invoked by the bytecode behavior completes (normally or abruptly), the frame of its invoker is considered to be the frame for the method containing this invokevirtual instruction.
The frame in which the bytecode behavior itself executes is not visible.
Otherwise, if the method handle to be invoked has no bytecode behavior, the Java Virtual Machine invokes it in an implementation-dependent manner.
During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution (§5.4.3.3) can be thrown.
Otherwise, if the resolved method is a class (static) method, the invokevirtual instruction throws an IncompatibleClassChangeError.
Otherwise, if the resolved method is signature polymorphic, then during resolution of the method type derived from the descriptor in the symbolic reference to the method, any of the exceptions pertaining to method type resolution (§5.4.3.5) can be thrown.
Otherwise, if objectref is null, the invokevirtual instruction throws a NullPointerException.
Otherwise, if the resolved method is not signature polymorphic: • If no method matching the resolved name and descriptor is.
Otherwise, if the selected method is native and the code that implements the method cannot be bound, invokevirtual throws an UnsatisfiedLinkError.
Otherwise, if the resolved method is signature polymorphic, then: • If the method name is invokeExact, and the.
If the method name is invoke, and the obtained instance of java.lang.invoke.MethodType is not a valid argument to the java.lang.invoke.MethodHandle.asType method invoked on the receiving method handle, the invokevirtual instruction throws a java.lang.invoke.WrongMethodTypeException.
Notes The nargs argument values and objectref are not one-to-one with the first nargs+1 local variables.
Argument values of types long and double must be stored in two consecutive local variables, thus more than nargs local variables may be required to pass nargs argument values to the invoked method.
It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative and can be positive only if the dividend is positive.
Moreover, the magnitude of the result is always less than the magnitude of the divisor.
If the value of the divisor for an int remainder operator is 0, irem throws an ArithmeticException.
Description The current method must have return type boolean, byte, short, char, or int.
If the current method is a synchronized method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a monitorexit instruction (§monitorexit) in the current thread.
If no exception is thrown, value is popped from the operand stack of the current frame (§2.6) and pushed onto the operand stack of the frame of the invoker.
Any other values on the operand stack of the current method are discarded.
The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.
If the Java Virtual Machine implementation does not enforce the rules on structured locking described in §2.11.10, then if the current method is a synchronized method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, ireturn throws an IllegalMonitorStateException.
This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.
Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in §2.11.10 and if the first of those rules is violated during invocation of the current method, then ireturn throws an IllegalMonitorStateException.
Notes This is equivalent (even if overflow occurs) to multiplication by 2 to the power s.
Description The index is an unsigned byte that must be an index into the local variable array of the current frame (§2.6)
The value on the top of the operand stack must be of type int.
It is popped from the operand stack, and the value of the local variable at index is set to value.
Notes The istore opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index.
The value on the top of the operand stack must be of type int.
It is popped from the operand stack, and the value of the local variable at <n> is set to value.
For int subtraction, a-b produces the same result as a+(-b)
For int values, subtraction from zero is the same as negation.
The result is the 32 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type int.
If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical difference of the two values.
Despite the fact that overflow may occur, execution of an isub instruction never throws a run-time exception.
Description The address of the opcode of the instruction immediately following this jsr instruction is pushed onto the operand stack as a value of type returnAddress.
Execution proceeds at that offset from the address of this jsr instruction.
The target address must be that of an opcode of an instruction within the method that contains this jsr instruction.
Notes Note that jsr pushes the address onto the operand stack and ret (§ret) gets it out of a local variable.
Description The address of the opcode of the instruction immediately following this jsr_w instruction is pushed onto the operand stack as a value of type returnAddress.
Execution proceeds at that offset from the address of this jsr_w instruction.
The target address must be that of an opcode of an instruction within the method that contains this jsr_w instruction.
This limit may be raised in a future release of the Java Virtual Machine.
Description The value on the top of the operand stack must be of type long.
It is popped from the operand stack and converted to a double result using IEEE 754 round to nearest mode.
Description The value on the top of the operand stack must be of type long.
It is popped from the operand stack and converted to a float result using IEEE 754 round to nearest mode.
Description The value on the top of the operand stack must be of type long.
It may lose information about the overall magnitude of value.
The result may also not have the same sign as value.
The result is the 64 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type long.
If overflow occurs, the sign of the result may not be the same as the sign of the mathematical sum of the two values.
Despite the fact that overflow may occur, execution of an ladd instruction never throws a run-time exception.
Description The arrayref must be of type reference and must refer to an array whose components are of type long.
Both arrayref and index are popped from the operand stack.
The long value in the component of the array at index is retrieved and pushed onto the operand stack.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the laload instruction throws an ArrayIndexOutOfBoundsException.
Description The arrayref must be of type reference and must refer to an array whose components are of type long.
The index must be of type int, and value must be of type long.
The arrayref, index, and value are popped from the operand stack.
The long value is stored as the component of the array indexed by index.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the lastore instruction throws an ArrayIndexOutOfBoundsException.
They are both popped from the operand stack, and a signed integer comparison is performed.
Description The index is an unsigned byte that must be a valid index into the run-time constant pool of the current class (§2.6)
The run-time constant pool entry at index either must be a run-time constant of type int or float, or a reference to a string literal, or a symbolic reference to a class, method type, or method handle (§5.1)
If the run-time constant pool entry is a run-time constant of type int or float, the numeric value of that run-time constant is pushed onto the operand stack as an int or float, respectively.
Otherwise, if the run-time constant pool entry is a reference to an instance of class String representing a string literal (§5.1), then a reference to that instance, value, is pushed onto the operand stack.
Otherwise, the run-time constant pool entry must be a symbolic reference to a method type or a method handle (§5.1)
The method type or method handle is resolved (§5.4.3.5) and a reference to the resulting instance of java.lang.invoke.MethodType or java.lang.invoke.MethodHandle, value, is pushed onto the operand stack.
During resolution of a symbolic reference to a class, any of the exceptions pertaining to class resolution (§5.4.3.1) can be thrown.
During resolution of a symbolic reference to a method type or method handle, any of the exception pertaining to method type or method handle resolution (§5.4.3.5) can be thrown.
The index must be a valid index into the run-time constant pool of the current class.
The run-time constant pool entry at the index either must be a run-time constant of type int or float, or a reference to a string literal, or a symbolic reference to a class, method type, or method handle (§5.1)
If the run-time constant pool entry is a run-time constant of type int or float, the numeric value of that run-time constant is pushed onto the operand stack as an int or float, respectively.
Otherwise, if the run-time constant pool entry is a reference to an instance of class String representing a string literal (§5.1), then a reference to that instance, value, is pushed onto the operand stack.
Otherwise, if the run-time constant pool entry is a symbolic reference to a class (§4.4.1)
The named class is resolved (§5.4.3.1) and a reference to the Class object representing that class, value, is pushed onto the operand stack.
Otherwise, the run-time constant pool entry must be a symbolic reference to a method type or a method handle (§5.1)
The method type or method handle is resolved (§5.4.3.5) and a reference.
During resolution of the symbolic reference to a class, any of the exceptions pertaining to class resolution (§5.4.3.1) can be thrown.
During resolution of a symbolic reference to a method type or method handle, any of the exception pertaining to method type or method handle resolution (§5.4.3.5) can be thrown.
Operation Push long or double from run-time constant pool (wide index)
The index must be a valid index into the run-time constant pool of the current class.
The run-time constant pool entry at the index must be a run-time constant of type long or double (§5.1)
The numeric value of that run-time constant is pushed onto the operand stack as a long or double, respectively.
There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for the long type and the divisor is -1, then overflow occurs and the result is equal to the dividend; despite the overflow, no exception is thrown in this case.
If the value of the divisor in a long division is 0, ldiv throws an ArithmeticException.
The value of the local variable at index is pushed onto the operand stack.
Notes The lload opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index.
The value of the local variable at <n> is pushed onto the operand stack.
The result is the 64 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type long.
If overflow occurs, the sign of the result may not be the same as the sign of the mathematical sum of the two values.
Despite the fact that overflow may occur, execution of an lmul instruction never throws a run-time exception.
The long result is the arithmetic negation of value, -value.
For long values, negation is the same as subtraction from zero.
Because the Java Virtual Machine uses two's-complement representation for integers and the range of two's-complement values is not symmetric, the negation of the maximum negative long results in that same maximum negative number.
Despite the fact that overflow has occurred, no exception is thrown.
Immediately after the lookupswitch opcode, between zero and three bytes must act as padding, such that defaultbyte1 begins at an address that is a multiple of four bytes from the start of the current method (the opcode of its first instruction)
The npairs must be greater than or equal to 0
Each of the npairs pairs consists of an int match and a signed 32-bit offset.
The table match-offset pairs of the lookupswitch instruction must be sorted in increasing numerical order by match.
The key must be of type int and is popped from the operand stack.
If it is equal to one of them, then a target address is calculated by adding the corresponding offset to the address of the opcode of this lookupswitch instruction.
If the key does not match any of the match values, the target address is calculated by adding default to the address of the opcode of this lookupswitch instruction.
The target address that can be calculated from the offset of each match-offset pair, as well as the one calculated from default, must be the address of an opcode of an instruction within the method that contains this lookupswitch instruction.
The match-offset pairs are sorted to support lookup routines that are quicker than linear search.
It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative and can be positive only if the dividend is positive; moreover, the magnitude of the result is always less than the magnitude of the divisor.
If the value of the divisor for a long remainder operator is 0, lrem throws an ArithmeticException.
If the current method is a synchronized method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a monitorexit instruction (§monitorexit) in the current thread.
If no exception is thrown, value is popped from the operand stack of the current frame (§2.6) and pushed onto the operand stack of the frame of the invoker.
Any other values on the operand stack of the current method are discarded.
The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.
If the Java Virtual Machine implementation does not enforce the rules on structured locking described in §2.11.10, then if the current method is a synchronized method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, lreturn throws an IllegalMonitorStateException.
This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.
Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in §2.11.10 and if the first of those rules is violated during invocation of the current method, then lreturn throws an IllegalMonitorStateException.
Notes This is equivalent (even if overflow occurs) to multiplication by 2 to the power s.
The value on the top of the operand stack must be of type long.
It is popped from the operand stack, and the local variables at index and index+1 are set to value.
Notes The lstore opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index.
The value on the top of the operand stack must be of type long.
For long subtraction, a-b produces the same result as a+(-b)
For long values, subtraction from zero is the same as negation.
The result is the 64 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type long.
If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.
Despite the fact that overflow may occur, execution of an lsub instruction never throws a run-time exception.
A monitor is locked if and only if it has an owner.
The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows: • If the entry count of the monitor associated with objectref is.
If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.
If another thread already owns the monitor associated with objectref, the thread blocks until the monitor's entry count is zero, then tries again to gain ownership.
The monitorenter and monitorexit instructions are not used in the implementation of synchronized methods, although they can be used to provide equivalent locking semantics.
Monitor entry on invocation of a synchronized method, and monitor exit.
The association of a monitor with an object may be managed in various ways that are beyond the scope of this specification.
For instance, the monitor may be allocated and deallocated at the same time as the object.
Alternatively, it may be dynamically allocated at the time when a thread attempts to gain exclusive access to the object and freed at some later time when no thread remains in the monitor for the object.
The synchronization constructs of the Java programming language require support for operations on monitors besides entry and exit.
These include waiting on a monitor (Object.wait) and notifying other threads waiting on a monitor (Object.notifyAll and Object.notify)
These operations are supported in the standard explicit support for these operations appears in the instruction set of the Java Virtual Machine.
The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.
The thread decrements the entry count of the monitor associated with objectref.
If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner.
Other threads that are blocking to enter the monitor are allowed to attempt to do so.
Otherwise, if the thread that executes monitorexit is not the owner of the monitor associated with the instance referenced by objectref, monitorexit throws an IllegalMonitorStateException.
Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in §2.11.10 and if the second of those rules is violated by the execution of this monitorexit instruction, then monitorexit throws an IllegalMonitorStateException.
The monitorenter and monitorexit instructions are not used in the implementation of synchronized methods, although they can be used to provide equivalent locking semantics.
The Java Virtual Machine supports exceptions thrown within synchronized methods and synchronized statements differently: • Monitor exit on normal synchronized method completion.
Monitor exit on abrupt synchronized method completion is handled implicitly by the Java Virtual Machine's athrow instruction.
When an exception is thrown from within a synchronized statement, exit from the monitor entered prior to the execution of the synchronized statement is achieved using the Java Virtual Machine's exception handling mechanism (§3.14)
Description The dimensions operand is an unsigned byte that must be greater than or equal to 1
It represents the number of dimensions of the array to be created.
Each such value represents the number of components in a dimension of the array to be created, must be of type int, and must be non-negative.
All of the count values are popped off the operand stack.
The runtime constant pool item at the index must be a symbolic reference to a class, array, or interface type.
The named class, array, or interface type is resolved (§5.4.3.1)
The resulting entry must be an array class type of dimensionality greater than or equal to dimensions.
A new multidimensional array of the array type is allocated from the garbage-collected heap.
If any count value is zero, no subsequent dimensions are allocated.
The components of the array in the first dimension are initialized to subarrays of the type of the second dimension, and so on.
The components of the last allocated dimension of the array are initialized to the default initial value.
A reference arrayref to the new array is pushed onto the operand stack.
During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in §5.4.3.1 can be thrown.
Otherwise, if the current class does not have permission to access the element type of the resolved array class, multianewarray throws an IllegalAccessError.
Otherwise, if any of the dimensions values on the operand stack are less than zero, the multianewarray instruction throws a NegativeArraySizeException.
The array class referenced via the run-time constant pool may have more dimensions than the dimensions operand of the multianewarray instruction.
In that case, only the first dimensions of the dimensions of the array are created.
The run-time constant pool item at the index must be a symbolic reference to a class or interface type.
The named class or interface type is resolved (§5.4.3.1) and should result in a class type.
The objectref, a reference to the instance, is pushed onto the operand stack.
On successful resolution of the class, it is initialized (§5.5) if it has not already been initialized.
During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in §5.4.3.1 can be thrown.
Otherwise, if the symbolic reference to the class, array, or interface type resolves to an interface or is an abstract class, new throws an InstantiationError.
Otherwise, if execution of this new instruction causes initialization of the referenced class, new may throw an Error as detailed in JLS §15.9.4
Notes The new instruction does not completely create a new instance; instance creation is not completed until an instance initialization method (§2.9) has been invoked on the uninitialized instance.
The count represents the number of elements in the array to be created.
The atype is a code that indicates the type of array to create.
A new array whose components are of type atype and of length count is allocated from the garbage-collected heap.
A reference arrayref to this new array object is pushed into the operand stack.
If count is less than zero, newarray throws a NegativeArraySizeException.
Other implementations may implement packed boolean arrays; the baload and bastore instructions must still be used to access those arrays.
Operation Pop the top one or two operand stack values.
Description Pop the top one or two values from the operand stack.
The run-time constant pool item at that index must be a symbolic reference to a field (§5.1), which gives the name and descriptor of the field as well as a symbolic reference to the class in which the field is to be found.
The type of a value stored by a putfield instruction must be compatible with the descriptor of the referenced field (§4.3.2)
If the field descriptor type is boolean, byte, char, short, or int, then the value must be an int.
If the field descriptor type is float, long, or double, then the value must be a float, long, or double, respectively.
If the field descriptor type is a reference type, then the value must be of a type that is assignment compatible (JLS §5.2) with the field descriptor type.
The value and objectref are popped from the operand stack.
During resolution of the symbolic reference to the field, any of the exceptions pertaining to field resolution (§5.4.3.2) can be thrown.
Otherwise, if the resolved field is a static field, putfield throws an IncompatibleClassChangeError.
Otherwise, if the field is final, it must be declared in the current class, and the instruction must occur in an instance initialization method (<init>) of the current class.
Otherwise, if objectref is null, the putfield instruction throws a NullPointerException.
The run-time constant pool item at that index must be a symbolic reference to a field (§5.1), which gives the name and descriptor of the field as well as a symbolic reference to the class or interface in which the field is to be found.
On successful resolution of the field, the class or interface that declared the resolved field is initialized (§5.5) if that class or interface has not already been initialized.
The type of a value stored by a putstatic instruction must be compatible with the descriptor of the referenced field (§4.3.2)
If the field descriptor type is boolean, byte, char, short, or int, then the value must be an int.
If the field descriptor type is float, long, or double, then the value must be a float, long, or double, respectively.
If the field descriptor type is a reference type, then the value must be of a type that is assignment compatible (JLS §5.2) with the field descriptor type.
If the field is final, it must be declared in the current class, and the instruction must occur in the.
The value is popped from the operand stack and undergoes value set conversion (§2.8.3), resulting in value'
During resolution of the symbolic reference to the class or interface field, any of the exceptions pertaining to field resolution (§5.4.3.2) can be thrown.
Otherwise, if the resolved field is not a static (class) field or an interface field, putstatic throws an IncompatibleClassChangeError.
Otherwise, if the field is final, it must be declared in the current class, and the instruction must occur in the <clinit> method of the current class.
Otherwise, if execution of this putstatic instruction causes initialization of the referenced class or interface, putstatic may throw an Error as detailed in §5.5
Notes A putstatic instruction may be used only to set the value of an interface field on the initialization of that field.
The local variable at index in the current frame (§2.6) must contain a value of type returnAddress.
The contents of the local variable are written into the Java Virtual Machine's pc register, and execution continues there.
Notes Note that jsr (§jsr) pushes the address onto the operand stack and ret gets it out of a local variable.
The ret instruction should not be confused with the return instruction (§return)
A return instruction returns control from a method to its invoker, without passing any value back to the invoker.
The ret opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index.
If the current method is a synchronized method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a monitorexit instruction (§monitorexit) in the current thread.
If no exception is thrown, any values on the operand stack of the current frame (§2.6) are discarded.
The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.
If the Java Virtual Machine implementation does not enforce the rules on structured locking described in §2.11.10, then if the current method is a synchronized method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, return throws an IllegalMonitorStateException.
This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.
Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in §2.11.10 and if the first of those rules is violated during invocation of the current method, then return throws an IllegalMonitorStateException.
Description The arrayref must be of type reference and must refer to an array whose components are of type short.
Both arrayref and index are popped from the operand stack.
The component of the array at index is retrieved and sign-extended to an int value.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the saload instruction throws an ArrayIndexOutOfBoundsException.
Description The arrayref must be of type reference and must refer to an array whose components are of type short.
The arrayref, index, and value are popped from the operand stack.
The int value is truncated to a short and stored as the component of the array indexed by index.
Otherwise, if index is not within the bounds of the array referenced by arrayref, the sastore instruction throws an ArrayIndexOutOfBoundsException.
The intermediate value is then sign-extended to an int value.
Description Swap the top two values on the operand stack.
Notes The Java Virtual Machine does not provide an instruction implementing a swap on operands of category 2 computational types.
Immediately after the tableswitch opcode, between zero and three bytes must act as padding, such that defaultbyte1 begins at an address that is a multiple of four bytes from the start of the current method (the opcode of its first instruction)
Immediately after the padding are bytes constituting three signed 32-bit values: default, low, and high.
The value low must be less than or equal to high.
The index must be of type int and is popped from the operand stack.
If index is less than low or index is greater than high, then a target address is calculated by adding default to the address of the opcode of this tableswitch instruction.
Otherwise, the offset at position index - low of the jump table is extracted.
The target address is calculated by adding that offset to the address of the opcode of this tableswitch instruction.
The target address that can be calculated from each jump table offset, as well as the one that can be calculated from default, must be the address of an opcode of an instruction within the method that contains this tableswitch instruction.
Description The wide instruction modifies the behavior of another instruction.
It takes one of two formats, depending on the instruction being modified.
The second form applies only to the iinc instruction (§iinc)
In either case, the wide opcode itself is followed in the compiled code by the opcode of the instruction wide modifies.
The calculated index must be an index into the local variable array of the current frame.
The widened bytecode operates as normal, except for the use of the wider index and, in the case of the second form, the larger increment range.
Notes Although we say that wide "modifies the behavior of another instruction," the wide instruction effectively treats the bytes constituting the modified instruction as operands, denaturing the embedded instruction in the process.
In the case of a modified iinc instruction, one of the logical operands of the iinc is not even at the normal offset from the opcode.
The embedded instruction must never be executed directly; its opcode must never be the target of any control transfer instruction.
Oracle hereby grants you a fully-paid, non-exclusive, non-transferable, worldwide, limited license (without the right to sublicense), under Oracle's applicable intellectual property rights to view, download, use and reproduce the Specification only for the purpose of internal evaluation.
This includes (i) developing applications intended to run on an implementation of the Specification, provided that such applications do not themselves implement any portion(s) of the Specification, and (ii) discussing the Specification with any third party; and (iii) excerpting brief portions of the Specification in oral or written communications which discuss the Specification provided that such excerpts do not in the aggregate constitute a significant portion of the Specification.
Oracle also grants you a perpetual, non-exclusive, non-transferable, worldwide, fully paid-up, royalty free, limited license (without the right to sublicense) under any applicable copyrights or, subject to the provisions of subsection 4 below, patent rights it may have covering the Specification to create and/or distribute an Independent Implementation of the Specification that: (a) fully implements the Specification including all its required interfaces and functionality; (b) does not modify, subset, superset or otherwise extend the Licensor Name Space, or include any public or protected packages, classes, Java interfaces, fields or methods within the Licensor Name Space other than those required/authorized by the Specification or Specifications being implemented; and (c) passes the Technology Compatibility Kit (including satisfying the requirements of the applicable TCK Users Guide) for such Specification ("Compliant Implementation")
In addition, the foregoing license is expressly conditioned on your not acting outside its scope.
Also, no right, title, or interest in or to any trademarks, service marks, or trade names of Oracle or Oracle's licensors is granted hereunder.
Java, and Java-related logos, marks and names are trademarks or registered trademarks of Oracle in the U.S.
You need not include limitations (a)-(c) from the previous paragraph or any other particular "pass through" requirements in any license You grant concerning the use of your Independent Implementation or products derived from it.
However, except with respect to Independent Implementations (and products derived from them) that satisfy limitations (a)-(c) from the previous paragraph, You may neither: (a) grant or otherwise pass through to your licensees any licenses under Oracle's applicable intellectual property rights; nor (b) authorize your licensees to make any claims concerning their implementation's compliance with the Specification in question.
With respect to any patent claims covered by the license granted under subparagraph 2 above that would be infringed by all technically feasible implementations of the Specification, such license is conditioned upon your offering on fair, reasonable and non-discriminatory terms, to any party seeking it from You, a perpetual, non-exclusive, non-transferable, worldwide license under Your patent rights which are or would be infringed by all technically feasible implementations of the Specification to develop, distribute and use a Compliant Implementation.
With respect to any patent claims owned by Oracle and covered by the license granted under subparagraph 2, whether or not their infringement can be avoided in a technically feasible manner when implementing the Specification, such license shall terminate with respect to such claims if You initiate a claim against Oracle that it has, in the course of performing its responsibilities as the Specification Lead, induced any other entity to infringe Your patent rights.
Also with respect to any patent claims owned by Oracle and covered by the license granted under subparagraph 2 above, where the infringement of such claims can be avoided in a technically feasible manner when implementing the Specification such license, with respect to such claims, shall terminate if You initiate a claim against Oracle that its making, having made, using, offering to sell, selling or importing a Compliant Implementation infringes Your patent rights.
For the purposes of this Agreement: "Independent Implementation" shall mean an implementation of the Specification that neither derives from any.
This Agreement will terminate immediately without notice from Oracle if you breach the Agreement or act outside the scope of the licenses granted above.
This document does not represent any commitment to release or implement any portion of the Specification in any product.
In addition, the Specification could include technical inaccuracies or typographical errors.
You will indemnify, hold harmless, and defend Oracle and its licensors from any claims arising or resulting from: (i) your use of the Specification; (ii) the use or distribution of your Java application, applet and/or implementation; and/or (iii)
Government: If this Specification is being acquired by or on behalf of the U.S.
Government prime contractor or subcontractor (at any tier), then the Government's rights in the Software and accompanying documentation shall be only as set forth in this license; this is in accordance with 48 C.F.R.
If you provide Oracle with any comments or suggestions concerning the Specification ("Feedback"), you hereby: (i) agree that such Feedback is provided on a non-proprietary and non-confidential basis, and (ii) grant Oracle a perpetual, non-exclusive, worldwide, fully paid-up, irrevocable license, with the right to sublicense through multiple levels of sublicensees, to incorporate, disclose, and use without limitation the Feedback for any purpose.
Any action related to this Agreement will be governed by California law and controlling U.S.
Convention for the International Sale of Goods and the choice of law rules of any jurisdiction will not apply.
Licensee agrees to comply strictly with all such laws and regulations and acknowledges that it has the responsibility to obtain such licenses to export, re-export or import as may be required after delivery to Licensee.
This Agreement is the parties' entire agreement relating to its subject matter.
It supersedes all prior or contemporaneous oral or written communications, proposals, conditions, representations and warranties and prevails over any conflicting or additional terms of any quote, order, acknowledgment, or other communication between the parties relating to its subject matter during the term of this Agreement.
No modification to this Agreement will be binding, unless in writing and signed by an authorized representative of each party.
