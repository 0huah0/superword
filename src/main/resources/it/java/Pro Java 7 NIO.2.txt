It covers the three primary elements that offer new input/output (I/O) APIs in Java 7, showing you how to:
Each chapter contains extensive code examples that show the power and elegance of NIO.2, giving you the knowledge to apply the latest and greatest techniques in your own code.
For your convenience Apress has placed some of the front matter material after the index.
This class is a milestone of NIO.2, and every application that involves I/O operations will exploit the powerful facilities of this class.
Practically, it is the most commonly used class of NIO.2, since many I/O operations are based on a Path resource.
The Path class supports two types of operations: syntactic operations (almost any operation that involves manipulating paths without accessing the file system; these are logical manipulations done in memory) and operations over files referenced by paths.
This chapter covers the first type of operations and introduces you to the Path API.
In Chapter 4, I focus on  exploring the second type of operations.
The concepts presented in this chapter will be very useful in the rest of the book.
Introducing the Path Class A path resides in a file system, which “stores and organizes files on some form of media, generally one or more hard drives, in such a way that they can be easily retrieved.”1 The file system can be accessed through the java.nio.file.FileSystems final class, which is used to get an instance of the java.nio.file.FileSystem we want to work on.
The Path class manipulates a file in any file system (FileSystem) that can use any storage place (java.nio.file.FileStore; this class represents the underlying storage)
NIO.2 provides us with all file system functionalities that we may need to perform over a file, a directory, or a link.
The Path class is an upgraded version of the well-known java.io.File class, but the File class has kept a few specific operations, so it is not deprecated and cannot be considered obsolete.
Moreover, starting with Java 7, both classes are available, which means programmers can mix their powers to obtain the best of I/O APIs.
Java 7 provides a simple API for conversion between them.
Remember the days when you had to do the following?
Well, those days are gone, because with Java 7 you can do this:
At a closer look, a Path is a programmatic representation of a path in the file system.
Because Path is basically a string, the referenced resource might not exist.
Defining a Path Once you identify the file system and the location of a file or directory, you can create a Path object for it.
The following subsections present several different ways to define a path to the same file (on Windows)—C:\rafaelnadal\tournaments\2009\BNP.txt.
Define an Absolute Path An absolute path (also known as a full path or file path) is a path that contains the root directory and all other subdirectories that contain a file or folder.
Note that if you define a chunk for each component of the path, you can omit the file separator delimiter.
Define a Path Relative to the File Store Root A relative path (also known as a nonabsolute path or partial path) is only a portion of the full path.
A relative path is often used in creating a web page.
Relative paths are used much more frequently than absolute paths.
Defining a path relative to the current file store root should start with the file delimiter.
In the following examples, if the current file store root is C:, then the absolute path is C:\rafaelnadal\tournaments\2009\BNP.txt:
Define a Path Relative to the Working Folder When you define a path relative to the current working folder, the path should not start with the file delimiter.
If the current folder is /ATP under C: root, then the absolute path returned by the following snippet of code is C:\ATP\rafaelnadal\tournaments\2009\BNP.txt:
Define a Path from a URI In some cases, you may need to create a Path from a Uniform Resource Identifier (URI)
You can do so by that takes a URI object as an argument.
This is useful if you need to encapsulate a path string that can be entered into the address bar of a web browser:
Another common solution for creating a Path is to use the FileSystems class.
Get the Path of the Home Directory When you need a path that points to the home directory, you can proceed as shown in the following.
Getting Information About a Path After you have defined a Path object, you have access to a set of methods that provide useful information about the path elements.
This section presents examples that apply these information-obtaining methods to the path C:\rafaelnadal\tournaments\2009\BNP.txt:
Get the Path File/Directory Name element from the root in the directory hierarchy:
Get the Path Parent does not have a parent, it returns null):
Get a Path Subpath and the end index, representing the subsequence of elements:
Converting a Path In this section, you will see how to convert a Path object into a string, a URI, an absolute path, a real path, and a File object.
The Path class contains a dedicated method for each of these conversions, as shown in the following subsections.
The following is the path we are going to work with:
The result is a URI object that encapsulates a path string that can be entered into the address bar of a web browser.
Convert a Relative Path to an Absolute Path Obtaining an absolute path from a relative one is a very common task.
NIO.2 can do that with the same path is returned):
Convert a Path to a Real Path and the file system supports symbolic links, this method resolves any symbolic links in the path.
If you want to ignore symbolic links, then pass to the method the LinkOption.NOFOLLOW_LINKS enum constant.
Moreover, if the Path is relative, it returns an absolute path, and if the Path contains any redundant elements, it returns a path with those elements removed.
This method throws an IOException if the file does not exist or cannot be accessed.
The following snippet of code returns the real path of a file by not following symbolic links:
Combining Two Paths Combining two paths is a technique that allows you to define a fixed root path and append to it a partial path.
This is very useful for defining paths based on a common part.
Practically, this method replaces the file name of the current path with the file name of the given path.
Constructing a Path Between Two Locations which constructs a relative path between this path and a given path.
This method constructs a path originating from the original path and ending at the location specified by the passed-in path.
For a better understanding of this powerful facility, consider a simple example.
In this case, it is assumed that BNP.txt and AEGON.txt are siblings, which means that you can navigate from one to the other by going up one level and then down one level.
Another typical situation involves two paths that contain a root element.
In this case, both paths contain the same root element, /tournaments.
Note If only one of the paths includes a root element, then a relative path cannot be constructed.
Even then, the construction of the relative path is system dependent.
Comparing Two Paths The equality of two Paths can be tested in different ways for different purposes.
It does not access the file system, so the compared paths are not required to exist, and it does not check if the paths are the same file.
In some OS implementations, the paths are compared by ignoring the case, while in other implementations, the comparison is case sensitive—the implementation will specify whether case is considered.
Here I show a path relative to the current file store and an absolute path, both representing the same file, but not equals:
Sometimes you’ll want to check if two paths are the same file/folder.
You can easily accomplish this method requires that the compared files exist on the file system; otherwise, it throws an IOException.
Since the Path class implements the Comparable interface, you can compare paths by using the sorting.
The method returns zero if the argument is equal to this path, a value less than zero if this path is lexicographically less than the argument, or a value greater than zero if this path is lexicographically.
Using these methods, you can test if the current path starts or ends, respectively, with the given path.
Iterate over the Name Elements of a Path Since the Path class implements the Iterable interface, you can obtain an object that enables you to iterate over the elements in the path.
You can iterate either by using an explicit iterator or with a foreach loop that returns a Path object for each iteration.
This outputs the elements starting with the closest to the root, as follows:
Summary In this chapter you have taken your first step into the NIO.2 API.
Knowing how to obtain the default file system and how to define and manipulate file paths is important because the Path class will sustain the examples throughout the book and will usually be the entry point of applications.
If you have questions about a file or a directory, such as whether it is hidden, whether it is a directory, what its size is, and who owns it, you can get answers to those questions (and many others) from the metadata, which is data about other data.
NIO.2 associates the notion of metadata with attributes and provides access to them through the java.nio.file.attribute package.
Since different file systems have different notions about which attributes should be tracked, NIO.2 groups the attributes into views, each of which maps to a particular file system implementation.
Generally, views provide the attributes in bulk through a common method, on the view, other methods are available for additional tasks.
In this chapter you will learn how to use the views provided by NIO.2
You will see how to determine whether a file is read-only or hidden, when it was last accessed or modified, who owns it, and how to take ownership of it.
You will also discover how to view the access control list (ACL) of a file and how to set Unix permissions on a file.
Moreover, you will explore file store attributes and learn how to define your own attributes.
BasicFileAttributeView: This is a view of basic attributes that must be supported by all file system implementations.
DosFileAttributeView: This view provides the standard four supported attributes on file systems that support the DOS attributes.
PosixFileAttributeView: This view extends the basic attribute view with attributes supported on file systems that support the POSIX (Portable Operating System Interface for Unix) family of standards, such as Unix.
FileOwnerAttributeView: This view is supported by any file system implementation that supports the concept of a file owner.
AclFileAttributeView: This view supports reading or updating a file’s ACL.
UserDefinedFileAttributeView: This view enables support of metadata that is user defined.
Determining Views Supported by a Particular File System Before you attempt to access a view's attributes, make sure that your file system supports the corresponding view.
For example, for Windows 7, the preceding code returned the following results:
Note All file systems support the basic view, so you should get at least the basic name in your output.
You can pass the desired view as a String or as a class name.
The following code checks whether the basic view is supported by all the available file stores:
Moreover, you can check if a file store in which a particular file resides supports a single view, as shown in this example:
Now that you can determine which views are supported on your file system, it is time to dig deeper and explore each view’s attributes, starting with the basic view.
Basic View Most file system implementations support a set of common attributes (size, creation time, last accessed time, last modified time, etc.)
These attributes are grouped into a view named BasicFileAttributeView and can be extracted and set as described in the following subsections.
You need to pass the file path and the attribute name and specify whether or not you need to follow symbolic links.
The following code snippet shows how to extract the size attribute value.
The generally accepted form for retrieving a single attribute is [view-name:]attribute-name.
Update a Basic Attribute Updating any or all of the file’s last modified time, last access time, and create time attributes can be time, last access time, and create time as instances of FileTime, which is a new class in Java 7 representing the value of a file’s timestamp attribute.
If any one of lastModifiedTime, lastAccessTime, or creationTime has the value null, then the corresponding timestamp is not changed.
Updating the file’s last modified time can also be accomplished with the.
Actually, this method may be used to update the file’s last modified time, last access time, or create time.
Obviously, now you have to extract the three attributes’ values to see the changes.
There are four attributes, which are mapped by the following methods:
The following listing extracts in bulk the preceding four attributes for a given path:
Setting an attribute’s value and extracting a single attribute by name can be accomplished by the attribute):
File Owner View Most file systems accept the concept of file owner as an identity used to determine access rights to objects in a file system.
NIO.2 maps this concept in an interface named UserPrincipal and allows you to get or set the owner of a file through the file owner view, which is represented by the FileOwnerAttributeView interface.
Actually, as you will see in the following code examples, NIO.2 has multiple ways for setting and getting the file owner.
Note A principal named “apress" is used in the examples in this section, but this principal will not be available on your machine.
To test the code without getting a java.nio.file.attribute.UserPrincipalNotFoundException, you need to add your principal name (an admin user of your machine or a user with the proper OS privileges)
UserPrincipal instance that maps a string representing the file owner.
Here is a simple example of setting a file owner:
The FileOwnerAttributeView maps a file attribute view that supports reading or updating the owner of a file.
The owner attribute is identified by the name owner, and the value of the attribute is a UserPrincipal object.
The following code snippet shows you how to set the owner using this interface:
Reading the owner of a file is a common task when determining access rights to objects in a file system.
Caution If the user principal lookup service for the default file system can’t be obtained or an invalid username is specified, then a java.nio.file.attribute.UserPrincipalNotFoundException will be thrown.
The file owner attribute can be required with the following name:
Based on the PosixFileAttributes class, you can extract the POSIX attributes as follows:
Note A group principal named “apressteam” is used in the preceding example, but this group will not be available on your machine.
To test the preceding code without getting a java.nio.file.attribute.UserPrincipalNotFoundException, you need to add your group principal name (an admin group of your machine or a group with the proper OS privileges)
In ACL controls the owners, permissions, and different kinds of flags for each object.
NIO.2 provides control over the ACL through the ACL view represented by the AclFileAttributeView interface, a file attribute view that supports reading or updating a file’s ACL or file owner attributes.
If you’ve never seen the content of an ACL, then try out the following code, which uses.
Read ACL Entries The previous two examples showed you how to extract the ACL for a specified path.
The result was a list of AclEntry—a class that maps an entry from an ACL.
Principal: The identity to which the entry grants or denies access.
Flags: A set of flags to indicate how entries are inherited and propagated.
You can iterate over the list and extract each entry’s components as follows—this is the list extracted in the previous sections:
The following is example output of this code (tested on Windows 7):
Grant a New Access in an ACL example, if you want to grant a new access to a principal, then you must follow this process:
Following these steps, you can write a code snippet for granting read data access and append data access to a principal named apress:
Note The principal named “apress" used in the preceding example will not be available on your machine.
To test the code without getting a java.nio.file.attribute.UserPrincipalNotFoundException, add your principal name (an admin user of your machine or a user with the proper OS privileges)
The preceding code adds a new entry in an ACL of an existing file.
In common cases, you will probably do that when you create a new file.
File Store Attributes If you think of a computer as a file storage container, then you can easily identify more types of stores, such as partitions, devices, volumes, and so on.
NIO.2 can obtain information about each type of store through the FileStore abstract class.
For a particular store, you can obtain its name, its type, total space,
In the following subsections you will see how to obtain that information for all the stores in the default file system and for the store that contains a specified file.
Get Attributes of All File Stores each instance (name, type, total space, used space, and available free space) is a FileStore object, you following code snippet prints information about your stores:
Note As you can see in the preceding example, if a store does not have a name, a blank string is returned.
In addition, the values returned for the amount of disk space are expressed in bytes, so you will probably want to convert those numbers to kilobytes, megabytes, or gigabytes to make them easier for humans to read.
Get Attributes of the File Store in Which a File Resides Based on the FileStore class, you can get attributes of a file store in which a particular file resides.
NIO.2 determines the file store for you and provides access to the information.
A file store may support one or more FileStoreAttributeView classes that provide a read-only or updatable view of a set of file store attributes, as follows:
User-Defined File Attributes View If you find that there are not enough built-in attributes for your needs or if you have some unique metadata (meaningful to the file system) that you want to associate with a file, you can define your own attributes.
This facility allows you to associate to a file any attribute that you consider to be useful for your use cases.
For example, this may be useful if you develop a distributed file system.
For instance, you could add a boolean attribute that verifies whether or not the file is replicated or distributed to other locations.
Check User-Defined Attributes Supportability Before you attempt to create your own attributes, check whether your file system supports this facility.
Since this is checked over a file store, not over a file itself, first you need to obtain the desired file store.
It returns a boolean value, as you can see here:
Note You can do this check over all file stores, or a set of file stores, by getting them directly from the default file system.
It is not required to get the file store from where a file resides.
Operations on User-Defined Attributes If your file system supports user-defined attributes, then you are all set to create your own.
Next, you will see how to define an attribute, how to list the user-defined attributes, and how to delete a user-defined attribute.
Your focus in this section should be on the life cycle of user-defined attributes.
Define a User Attribute To start, you will define an attribute named file.description that has the value "This file contains this user-defined attribute as follows:
If an attribute of the given name already exists, then its value is replaced.
As you can see, the method returns an int, which represents the number of bytes written, possibly zero.
List User-Defined Attribute Names and Value Sizes At any moment, you can see the list of user-defined attribute names and value sizes by calling the result in the sizes of the attribute values.
Get the Value of a User-Defined Attribute Reading the value of a user-defined attribute is accomplished by using the buffer, and it returns the value in the specified buffer.
The following code snippet shows you how to do it:
Delete a File’s User-Defined Attribute When a user-defined attribute is no longer useful, you can easily delete it by calling the method and it will do the rest of the work for you.
The following shows how to delete the attribute defined earlier:
Summary In this chapter you have explored the views provided by NIO.2
You saw how to manipulate all kinds of attributes, how to query a file or a file store for different purposes, and how to define your own metadata.
After an introduction to the NIO.2 views and a description of how to determine which views are supported by a particular file system, the chapter introduced the basic and DOS attributes, which should be available for every file.
These attributes provide the main metadata, such as size, creation time, last modified time, read-only, and so forth.
The chapter next presented the file owner attributes, which provide support for setting and getting a file owner, followed by the POSIX attributes for Unix users and the ACL attributes, which provide access to the collection of permissions that control access to a file system’s objects.
The chapter wrapped up by discussing file store attributes and user-defined attributes.
Linux and Unix users (especially administrators) should be familiar with the concept of links.
There is two types of links: symbolic links and hard links.
Links commonly reach a file through several names, instead of navigating through a series of directories and subdirectories from the root – think of a link as an entity mapping a file/directory path and identified through a set of names.
If you are a dedicated Windows user, you might not be familiar with links, although Windows itself is perfectly aware of them, especially symbolic links, which most resemble Windows shortcuts.
NIO.2 provides support for both hard links and symbolic links.
Each method of the Path class knows how to detect a link and will behave in the default manner if no configuration of behavior is specified.
In this chapter, you will learn how to manipulate links through the java.nio.file API, including how to create a link and how to find the target of a link.
Introducing Links When you reach a file through a set of names (from command-line, an application, or other ways), you are dealing with a link.
A link can be set up either as a hard link (sometimes spelled hardlink) or as a symbolic link (also called symlink or softlink)
When a file has two names of equal weight and the inode table (Linux files don’t actually live in directories; they are assigned an inode number, which Linux uses to locate them) points directly to the blocks on the disk that contain the data, the link is a hard link.
Think of a hard link as a directory reference or pointer to a file.
When a file has one main name and an extra entry in the file name table that refers any accesses back to the main name, the link is a symbolic link.
Symbolic links are more flexible and used much more often than hard links.
The following are the main differences/similarities between the two types of links:
Hard links can be created only for files, not for directories.
Symbolic links can link to a file or a directory.
Removing the original file that your hard link points to does not remove the hard link itself, and the hard link still provides the content of the underlying file.
Removing the original file that your symbolic link points to does not remove the attached symbolic link, but without the original file, the symbolic link is useless.
If you remove the hard link or the symbolic link itself, the original file stays intact.
A hard link is the same entity as the original file.
A hard link looks, and behaves, like a regular file, so hard links can be hard to find.
A symbolic link’s target may not even exist, therefore it is much flexible.
Creating Links from the Command Line Windows users can create symbolic and hard links from the command line by using the mklink command.
This command gets a set of options, depending on which kind of link you need to create.
Target  specifies the path (relative or absolute) that the new link refers to.
Unix (Linux) users can use the command named ln to achieve the same effect achieved in the preceding Windows example (notice that the target file is listed first and the link name is listed second in this case):
In addition, in Unix (Linux) you can delete a link using the rm command:
Creating a Symbolic Link Creating a symbolic link is very easy to accomplish in NIO.2
You simply call the symbolic link, and an array of attributes to set atomically when creating the symbolic link.
If your file system does not support symbolic links, then an UnsupportedOperationException exception will be thrown.
In addition, keep in mind that the target of the symbolic link can be absolute or relative (as described in Chapter 1) and might or might not exist.
The following code snippet creates a simple symbolic link with the default attributes.
When you want to modify the default attributes of the link, you can use the third argument of the that encapsulates the value of a file attribute that can be set atomically when creating a new file, directory, or link.
The following code snippet reads the attributes of the target file and creates a link, assigning the attributes from the target to the link.
Note If the symbolic link already exists, then a FileAlreadyExistsException exception will be thrown.
It returns the path to the link, which represents the new directory entry.
You then can access the file using the link as the path.
If your file system does not support hard links, then an UnsupportedOperationException exception will be thrown.
In addition, keep in mind that a hard link can be created only for existing files.
Note If the hard link already exists, then a FileAlreadyExistsException exception will be thrown.
Checking a Symbolic Link Different instances of Path can point to files or links, so you can detect if a Path instance points to a the Path to be tested, and returns a boolean value.
The following code snippet is a simple example of testing a Path for a symbolic link.
As you read in Chapter 2, you can test Path for a symbolic link by using the attribute views.
The basic view provides an attribute named isSymbolicLink, which returns true if the specified Path locates a file (not recommended in this case since it returns a bulk list of attributes) or, much more easily, through the.
This method receives from the user the link, as a Path, and returns a Path object representing.
If the passed path is not a link, then a NotLinkException exception will be thrown.
Checking If a Link and a Target Point to the Same File Sometimes you may need to check if a link and a target point to the same file (location)
You can get this method receives (from the user) the two Paths to be compared and returns a boolean value.
The following code snippet creates a target and a symbolic link for the target and then applies the C:\rafaelnadal\photos\rafa_winner.jpg (the file must exist and the file system must have permission to create symbolic links)
Summary In this chapter you saw how NIO.2 deals with symbolic and hard links.
After a short overview of these two concepts and some brief examples of how to create them in Windows and Unix (Linux), you saw the NIO.2 approach.
You learned how to create symbolic and hard links directly from Java, how to check if a path is a link, how to detect the target of a link, and how to check if a link and a target point to the same file.
Now that you know how to point to a file or directory using the Path class, you are ready to learn how to accomplish the most common tasks for managing files and directories, such as create, read, write, move, delete, and so on.
NIO.2 comes with a set of brand new methods to accomplish these tasks, most of which are found in the java.nio.file.Files class.
The chapter starts by exploring some methods dedicated to checking if a Path is readable, writable, executable, regular, or hidden.
These checks enable you to determine what kind of file or directory you are dealing with before you apply operations such as write or read.
The chapter then focuses on directory operations, showing you how to list, create, and read directories.
You will see how to list the file are familiar with directory operations, you will explore file operations, such as reading, writing, creating, and opening files.
As you will see, there is a wide array of file I/O methods to choose from.
In this chapter, you will see at work methods for buffered and unbuffered streams, leaving coverage of the methods for channels for the next chapters, in which you will see the real power of NIO.
The chapter ends with the well-known delete, copy, and move operations.
Checking Methods for Files and Directories The Files class provides a set of isSomething methods that you can use to perform various kinds of checks before you actually manipulate a file or a directory.
Some of these methods were presented in the previous chapters, while the rest are presented here.
Taking advantage of these methods is recommended because they can be very useful in helping you to avoid exceptions or other strange behavior in your applications.
For example, it is a good idea to check if a file exists before you try to move it to another location.
Similarly, it is a good idea to check if a file is accessible to read before you try to read from it.
Some of these checks can also be performed through the metadata attributes, as you have seen in Chapter 2
Checking for the Existence of a File or Directory As you know from previous chapters, a Path instance is perfectly valid even if the mapped file or directory does not physically exist.
Moreover, the syntactic Path methods can be applied with success in such cases because they do not operate on the file or directory itself.
Both methods receive two arguments, representing the path to the file to test and options indicating (the file does not exist or the checking cannot be performed)
The following code snippet checks if the file AEGON.txt exists in the C:\rafaelnadal\tournaments\2009 directory (in our hypothetical directory structure, this file exists):
Note If both methods are applied to the same Path and both return false, then the checking cannot be performed.
For example, if the application does not have access to the file, then the status is unknown and both methods return false.
From here, it is easy to draw the conclusion that a file/directory’s existence status can be: exist, not exist, or unknown.
Immedately after checking this status, the result is outdated, since a file that exists can be deleted just after check, therefore the result must "expire" immediately.
If this method indicates the file exists then there is no guarantee that a subsequence access will succeed.
In addition, a SecurityException may be thrown if one of these methods does not have permissions to read the file.
Regular files are files that have no special characteristics (they are not symbolic links, directories, etc.) regular, or false if either the file does not exist, read, write, execute, and regular access would be denied because the JVM has insufficient permissions, or access cannot be determined.
Putting these methods into a code snippet that checks the accessibility of the AEGON.txt file in the C:\rafaelnadal\tournaments\2009 directory (the file must exist) looks like the following:
Note The preceding examples check the accessibility by applying all four methods to a Path, but you can combine these four methods in different ways depending on what level of accessibility you need to get.
For example, you may not care whether or not the Path is writable, in which case you can exclude this check.
Caution Even if these methods confirm the accessibility, there is no guarantee that the file can be accessed.
Unix fans are probably familiar with this concept, but it is applicable to any other system as well.
Checking If Two Paths Point to the Same File In the previous chapter, you saw how to check if a symbolic link and a target point to the same file.
For example, a relative Path and an absolute Path may point following code snippet, which expresses the path to the MutuaMadridOpen.txt file in three different ways (the file must exist in the C:\rafaelnadal\tournaments\2009 directory):
Checking the File Visibility that the notion of “hidden” is platform/provider dependent, you just need to pass the Path to be checked and get a true or false response.
The following code snippet checks if the MutuaMadridOpen.txt file is a hidden file (the file must exist in the C:\rafaelnadal\tournaments\2009 directory):
Creating and Reading Directories When it comes to creating and reading directories, NIO.2 provides a set of dedicated methods in the Files class.
In this section, you will discover how to list the file system roots, create directories (including temporary directories), list a directory’s content, and write and use filters for directories.
Listing File System Root Directories In Java 6, the file system root directories were extracted as an array of File objects.
You can easily get from Iterable into an array as follows:
If you need to extract the file system root directories as an array of File, use the Java 6 solution:
Creating a New Directory Creating a new directory is a common task that you can accomplish by calling the file attributes (FileAttribute<?>) to set atomically at creation time.
You can add a set of attributes at creation time as shown in the following example code snippet, which creates a new directory on a POSIX file system that has specific permissions:
Sometimes you need to create more than just a single directory.
For example, you may need to create a sequence of hierarchical directories, like \statistics\win\prizes.
The sequence of directories is passed as a Path instance with or without a list of file attributes to set atomically when creating the directory.
The following code snippet shows how to create a sequence of hierarchical directories under the C:\rafaelnadal directory:
This method may fail after creation of some directories, but not all of them.
Listing a Directory’s Content Working with directories and files usually involves looping a directory’s content for different purposes.
NIO.2 provides this facility through an iterable stream named DirectoryStream, which is an interface that implements Iterable.
The access to the directory stream is straightforward through the directory stream.
Listing the Entire Content The following code snippet will return the entire contents of a directory as links, files, subdirectories, and hidden files (the listed directory is C:\rafaelnadal\tournaments\2009):
A possible output follows (this is the entire content of the C:\rafaelnadal\tournaments\2009 directory):
Listing the Content by Applying a Glob Pattern Sometimes, you may need to list only the content that meets certain criteria, which requires applying a filter to the directory’s content.
Commonly, you need to extract only files and subdirectories whose names match a particular pattern.
NIO.2 defines this particular pattern as a built-in glob filter.
Since this is a pattern, it must respect some rules, as follows:
Convey a set of single characters or a range of characters if the hyphen character is present.
The following example will extract all files of type PNG, JPG, and BMP (regardless of their names) from the C:\rafaelnadal\tournaments\2009 directory:
Listing the Content by Applying a User-Defined Filter If a glob pattern does not satisfy your needs, then is time to write your own filter.
This is a simple task that requires implementing the DirectoryStream.Filter<T> interface, which has a single method, following code snippet accepts only directories in the final result:
The following list presents a set of commonly used filters:
Filter that accepts only files modified in the current day:
Creating, Reading, and Writing Files Probably the most common operations with files involve creating, reading, and/or writing actions.
NIO.2 comes with numerous dedicated methods for performing these actions at various levels of complexity and performance, from methods for commonly used small files (cases where it is convenient to read all bytes into a byte array) to methods for advanced features such as file locking and memory-mapped I/O.
This section starts with methods for small files and finishes with methods for buffered and unbuffered streams.
A stream represents an input source or an output destination (it can be anything from disk files to memory arrays)
Streams support different kinds of data, as strings, bytes, primitive data types, localized characters, and objects.
In an unbuffered stream, each read or write request is handled directly by the underlying operating system, while in a buffered stream, the data is read from a memory area known as a buffer; and the native input API is called only when the buffer is empty.
Similarly, buffered output streams write data to a buffer, and the native output API is called only when the buffer is full.
When a buffer is written out without waiting for it to fill, we say that the buffer is flushed.
Using Standard Open Options Starting with NIO.2, the methods dedicated to creating, reading and writing actions (or any other action that involves opening a file) support an optional parameter, OpenOption, which configures how to open or create a file.
Actually, the OpenOption is an interface from the java.nio.file package and it has two implementations: the LinkOption class (remember the well-known NOFOLLOW_LINKS enum constant) and the StandardOpenOption class, which defines the following enums:
CREATE_NEW Creates a new file, failing with an exception if the file already exists.
DELETE_ON_CLOSE Deletes the file when the stream is closed (used for deleting temporary files)
Some of these constants will be shown at work in the upcoming sections, after you take a look at.
This method gets the file to create (Path) and an optional list of file attributes (FileAttribute<?>) to set atomically at creation time.
The following code snippet creates a new file named SonyEricssonOpen.txt in the C:\rafaelnadal\tournaments\2010 directory (the directory must exist) with the default attributes (initially, the file must not exist; otherwise a FileAlreadyExistsException exception will be thrown):
You can add a set of attributes at creation time as shown in the following code snippet.
This code creates a new file on a POSIX file system that has specific permissions.
As you will see soon, this is not the only way to create a new file.
Writing a Small File NIO.2 comes with an elegant solution for writing small binary/text files.
This facility is provided through the file, if it doesn’t exist) or initially truncate an existing regular file to a size of 0 bytes.
After all bytes or lines are written, the method closes the file (it closes the file even when an I/O error or exception.
The following code snippet writes a byte array (representing a small tennis ball picture) with the default opening options (the file name is ball.png and it will be written in the C:\rafaelnadal\photos directory):
Now, if you check the corresponding path, you will find a small picture representing a tennis ball.
Moreover, if you need to write text (String) and you want to use this method, then convert the text.
After each line, this method appends the platform’s line separator (line.separator system property)
This method gets the path to the file, an iterable object over the char sequence, a charset to use for encoding, and options specifying how the file is opened.
The following code snippet writes some lines into a file (actually, it appends some lines to the end of the file wiki.txt created in the preceding section):
Reading a Small File NIO.2 provides a quick method to read small byte/text files in a single shot.
This facility is provided file’s bytes or lines, respectively, into a single read and take care of opening and closing the stream for you after the file has been read or an I/O error or exception has occurred.
Focusing on the (the file must exist) into a byte array (the file path is passed as an argument):
If you want to make sure that the returned byte array contains the picture, you can run (as a test) the following code snippet, which writes the bytes into a file named bytes_to_ball.png in the same directory:
String, as in the following example (you can use any charset that is proper for your text files):
Caution If the file is too large (bigger than 2GB), then the size of the array cannot be allocated and a OutOfMemory error will be thrown.
Conforming to official documentation, this method recognizes the following as line terminators:
Working with Buffered Streams In most operating systems, a system call to read or write data is an expensive operation.
Buffers can fix this issue by providing a memory space between the buffered methods and the operating system.
Before calling the native API, these methods get or put the data from/into a buffer between the operating system and the application, which increases the application’s efficiency because it reduces the number of system calls—the disk is accessed only when the buffer is full or empty, depending on whether it is a write operation or a read operation.
It returns a new default buffered writer (this is a java.io-specific BufferedWriter)
The method opens the file for writing (this can involve creating the file, if it doesn’t exist) or initially truncates an existing regular file to a size of 0 bytes.
In short, this method acts as if the CREATE, TRUNCATE_EXISTING, and WRITE options are present (which is applicable by default when no other options are specified)
The following code snippet uses a buffer to append data into the previously created wiki.txt file (the file exists; you should find it in the C:\rafaelnadal\wiki directory):
It returns a new default buffered reader (this is a java.io-specific BufferedReader)
The following code snippet reads the wiki.txt file using the UTF-8 charset:
If you followed along with the examples in the previous sections and created the entire wiki.txt file, then the preceding code will output the following content:
He is widely regarded as one of the greatest players of all time; his success on clay has earned him the nickname "The King of Clay", and has prompted many experts to regard him as the greatest clay court player of all time.
Working with Unbuffered Streams The unbuffered streams can be obtained through the new NIO.2 methods and either can be used verbatim or can be converted to buffered streams using the wrapping idiom provided by the java.io.
The method opens the file for writing (this can involve creating the file, if it doesn’t exist) or initially truncates an existing regular file to a size of 0 bytes.
In short, this method acts as if the CREATE, TRUNCATE_EXISTING, and WRITE options are present (which is applicable by default when no other options are specified)
It returns a new default thread-safe unbuffered stream that may be used to read bytes from the file (this is a java.io-specific InputStream)
The method opens the file for read; if no options are present, then it is equivalent to opening the file with the READ option.
The following code snippet reads the content of the file racquet.txt (the file must exist):
Therefore, you can modify the preceding code as follows (keep in mind that you are still dealing with an unbuffered stream):
Moreover, you can convert the unbuffered stream to a buffered stream by interoperating with the java.io API.
The following example has the same effect as the preceding example, but it is more efficient:
Creating Temporary Directories and Files A temporary directory is a directory that stores temporary files.
The location of the temporary directory depends on the operating system.
In Linux/Unix the global temporary directories are /tmp and /var/tmp.
Creating a Temporary Directory temporary directory in the default operating system location can be accomplished by calling the directory’s name (it can be null) and an optional list of file attributes to set atomically when creating the directory.
The following code snippet creates two temporary directories, one with a prefix and one without a prefix:
Note If you don’t know what the default location for temporary directories is, you can use the following code:
Going further, you can specify the default directory in which a temporary directory is created by of attributes, this method also gets a Path representing the default directory for temporary directories.
The following example creates a temporary directory in the C:\rafaelnadal\tmp directory:
Deleting a Temporary Directory with Shutdown-Hook Most operating systems will automatically delete the temporary directories (if not, you can use one of several kinds of cleaner software)
But, sometimes you may need to programmatically control the delete responsibility.
For this you can attach a shutdown-hook mechanism, a runtime mechanism used to perform any resource cleanup or save that must take place before the JVM shuts down.
This hook can be executed by the JVM at shutdown.
A nice and simple flow design of a shutdown-hook is shown in Figure 4-1
Putting the diagram shown in Figure 4-1 into code lines provide the following skeleton code:
Note Notice that adding a shutdown-hook as a Thread to the Runtime can be done as an anonymous inner class, as in the preceding code, or as a separate class that implements the Runnable or extends Thread.
A shutdown-hook is a nice solution to delete a temporary directory when the JVM shuts down, but, as you probably know, a directory cannot be deleted if it is not empty; therefore, you need to loop through the temporary directory content and delete each entry before deleting the temporary directory itself.
At this point, you know how to loop through a directory’s content only one level down, so suppose for now that your temporary directory contains only temporary files (as is true in many real-life cases) and other empty temporary directories.
Later in this book you will see how to implement recursive operations for navigating through all levels of a hierarchy structure.
The following example combines code from the preceding section for listing directory content with a shutdown-hook:
Obviously, in place of that, you will provide the business logic that uses the temporary directory for the job for which it was created.
Because this method must be called for each temporary file or directory, it is considered the least attractive choice because it will consume memory for each temporary entity.
Caution If your system is active for a long period of time or creates many temporary files or directories consider that it can use a lot of memory that will not be released until the JVM terminates.
Creating Temporary Files This section takes a closer look at temporary files and the NIO.2 approach to them.
In real-world applications, temporary files often provide very useful help.
They work very well when you need files that are not indented to be used outside of the application or the application execution.
The following code snippet creates two temporary files, one without a prefix and suffix and one with a specified prefix and suffix:
The output will be two empty temporary files in the operating system default location:
Note If you don’t know what the default location for temporary files is, you can use the following code:
Going further, you can specify the default directory in which a temporary file is created by calling attributes, this method also gets a Path representing the default directory for temporary files.
The following is an example that creates a temporary file in the C:\rafaelnadal\tmp directory:
The output will be one empty temporary file in the C:\rafaelnadal\tmp directory:
Deleting a Temporary File with Shutdown-Hook A temporary file is just a simple file until you make sure that it is truly temporary, which means that an automatic mechanism must delete temporary files periodically or at a specified time.
Obviously, in place of that, you will provide the business logic that uses the temporary file for the job for which it was created.
As its name suggests, this option deletes the file when the stream is closed.
For example, the following code snippet opens a stream for it with DELETE_ON_CLOSE explicitly specified, so when the stream is closed, the file should be deleted:
Simply define a file name, and use the DELETE_ON_CLOSE option in conjunction with the CREATE option, as shown in the following snippet (the effect is the same as in the preceding example):
Deleting, Copying, and Moving Directories and Files Delete, copy, and move are three of the most common operations used on files and directories.
NIO.2 provides dedicated methods to sustain different approaches to these operations.
Most of them come from the Files class, as you will see in this section.
Deleting Files and Directories following exceptions: NoSuchFileException (if the passed Path does not exist), DirectoryNotEmptyException (if the passed Path is a directory that it is not empty), IOException (if an I/O error occurs), or SecurityException (if the access for deletion is denied)
This is useful when you have multiple threads deleting files and you don’t want to throw an exception just because one thread did so first.
Keeping in mind that the preceding code just deleted the rafa_1.jpg file, the following code will return false:
Caution If the deleted resource is a directory, then it must be empty.
Deleting the entire directory content (which may contain other directories, files, and so on) is a task usually implemented as a recursive operation.
Note If the file is a symbolic link, then the symbolic link itself, not the final target of the link, is deleted.
Copying Files and Directories accomplish this task and provides a set of options for controlling the copy process—the methods take a varargs argument represented by these options.
These options are provided under the StandardCopyOption and LinkOption enums and are listed here:
REPLACE_EXISTING: If the copied file already exists, then it is replaced (in the case of a nonempty directory, a FileAlreadyExistsException is thrown)
When dealing with a symbolic link, the target of the link it is not copied; only the link is copied.
COPY_ATTRIBUTES: Copy a file with its associated attributes (at least, the lastModifiedTime attribute is supported and copied)
If you are not familiar with enum types, then you should know that they can be imported into applications as follows.
These are called static imports and can import any static fields or methods, not just fields from enum types (e.g., methods from java.lang.Math)
Note By default, when copying a symbolic link, the target of that link is copied.
Caution Trying to copy a nonempty directory will result in an empty directory.
This is a task usually implemented as a recursive operation, as you will see in Chapter 5
Moreover, copying a file is not an atomic operation, which means that an IOException exception can be thrown and the copy aborted even if the target file is incomplete or the attributes were not totally copied.
Usually, when you copy a file, you need a source path (copy from) and a target path (copy to)
Based on to the target file, and a set of options for controlling the copy process.
If no options are specified, then the copy ends successfully only if the target file does not exist and it is not a symbolic link.
Otherwise, an exception will be thrown unless the source and the target are not the.
It replaces an existing file, copies attributes of the source to the target, and does not follow links.
By default, the copy fails if the target file already exists or is a symbolic link.
For example, the following code snippet will get the input stream from an Internet URL (it will copy the picture indicated by the URL to the C:\rafaelnadal\photos directory only if the file does not exist):
Caution It is strongly recommended that you close the input stream immediately after an I/O error occurs.
It will return the number of bytes read or written.
The target file is represented as an output stream (the target will be replaced if exists)
Caution It is strongly recommended that you close the output stream immediately after an I/O error occurs.
Moving Files and Directories method gets the path to the file to move, the path to the target file, and a set of options that controls the moving process.
These options are provided under the StandardCopyOption enum and are listed here:
REPLACE_EXISTING: If the target file already exists, then the move is still performed and the target is replaced.
When dealing with a symbolic link, the symbolic link is replaced but what it points to is not affected.
ATOMIC_MOVE: The file move will be performed as an atomic operation, which guarantees that any process that monitors the file’s directory will access a complete file.
Again, these enum types can be imported into an application like this:
Note By default, when moving a symbolic link, the symbolic link itself is moved, not the target of that link.
Nevertheless, it is possible to move a directory that it is not empty if it does not require moving the entries in the directory.
In some cases a directory has entries for special files (such as links) that are created when the directory is created, and if the directory contains only those entries, it is considered empty.
If the target already exists, then it is replaced because the REPLACE_EXISITING option is specified.
If you have tested the preceding code, then rafa_2.jpg should be present in this directory.
Summary This chapter started by exploring some methods dedicated to checking if a Path is readable, writable, regular, or hidden.
It then focused on directory operations and how to list, create, and read directories.
You saw how to list the file system roots, how to create directories with methods such as such as reading, writing, creating, and opening files.
As you saw, there is a wide array of file I/O methods to choose from (for buffered and unbuffered streams)
The chapter ended with the well-known delete, copy, and move operations.
As you probably know, recursive programming is a debated technique because it usually needs a lot of memory but it simplifies some programming tasks.
Basically, a recursive programming is a situation in which a procedure calls itself, passing in a modified value of the parameter or parameters that were passed in to the current iteration of the procedure.
Programming tasks such as calculating factorial, Fibonacci numbers, anagrams, and Sierpinski carpet are just a few of the well-known tasks that can be accomplished through the recursive programming technique.
If you are already familiar with this programming technique, then proceed reading this chapter to see how NIO.2 takes advantage of it.
Many programming tasks that involve working with files require visiting all files in a file tree, which is a good opportunity for using the recursive programming mechanism because every file should be “touched” individually.
This is a very common approach when performing tasks such as deleting, copying, or moving a file tree.
Based on this mechanism, NIO.2 encapsulates the traversal process of a file tree in an interface, named FileVisitor, in the java.nio.file package.
This chapter starts by presenting the FileVisitor’s scope and methods.
Once you are familiar with FileVisitor, the chapter will help you to develop a set of applications you can use to perform tasks that involve traversing a file tree, such as finding, copying, deleting, and moving files.
The FileVisitor Interface As previously mentioned, the FileVisitor interface provides the support for recursively traversing a file tree.
The methods of this interface represent key points in the traversal process, enabling you to take control when a file is visited, before a directory is accessed, after a directory is accessed, and when a failure occurs; in other words, this interface has hooks for before, during, and after a file is visited, as well as for when failure occurs.
Once you have control (at any of these key points), you can choose how to process the visited file and decide what should happen to it next by indicating a visit result through the FileVisitResult enum, which contains four enum constants:
FileVisitResult.CONTINUE: This visit result indicates that the traversal process should continue.
It can be translated into different actions depending on which FileVisitor method is returned.
For example, the traversal process may continue by visiting the next file, visiting a directory’s entries, or skipping a failure.
FileVisitResult.SKIP_SIBLINGS:  This visit result indicates that the traversal process should continue without visiting the siblings of this file or directory.
FileVisitResult.SKIP_SUBTREE: This visit result indicates that the traversal process should continue without visiting the rest of the entries in this directory.
FileVisitResult.TERMINATE: This visit result indicates that the traversal process should terminate.
The constants of this enum type can be iterated as follows:
The following subsections discuss how you can control the traversal process by implementing the various FileVisitor methods.
For example, when searching for a file, this method should return CONTINUE until the file is found (or the tree is completely traversed) and TERMINATE after the file is found.
When this method is invoked, it receives a reference to the file and the file’s basic attributes.
If an I/O error occurs, then it throws an IOException exception.
Also, you can skip visiting the siblings of this file or directory (and any descendants) by returning the SKIP_SIBLINGS result.
When this method is invoked, it gets a reference to the directory and the directory’s basic attributes.
If an I/O error occurs, then it throws an IOException exception.
When this method is invoked, it gets a reference to the directory and IOException object—it will be null if no error occurred during the visit or it will return the corresponding error if one occurred.
If an I/O error occurs, then it throws an IOException exception.
When this method is invoked, it gets a reference to the file and the exception that occurred while trying to visit that file.
If an I/O error occurs, then it throws an IOException exception.
The SimpleFileVisitor Class Implementing the FileVisitor interface requires implementing all of its methods, which may be undesirable if you need to implement only one or a few of those methods.
In that case, it is much simpler to extend the SimpleFileVisitor class, which implements the FileVisitor interface.
For example, you may want to traverse a file tree and list the names of all directories.
To accomplish the following code snippet (the starting file tree is presented in the next section):
Starting the Recursive Process Once you have created the recursive mechanism (by implementing the FileVisitor interface or extending the SimpleFileVisitor class), you can start the process by calling one of the two usually the file tree root) and the file visitor to invoke for each file (this is an instance of the recursive mechanism class)
For example, you can start the code example in the preceding section by calling the.
The accepted options are the constants of the FileVisitOption enum.
Actually, this enum contains a single constant, named FOLLOW_LINKS, indicating that the symbolic links are followed in the walk (by default, they are not followed)
Calling this method for the preceding walk may look like the following:
Note Calling walkFileTree(start, visitor) has the same effect as calling walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)
The following lines are the output of the preceding example:
Common Walks There is a set of common walks that you can easily implement through the FileVisitor interface.
This section shows you how to write and implement applications to perform a file search, a recursive copy, a recursive move, and a recursive delete.
Writing a File Search Application Most operating systems provide a dedicated tool for searching files (for example, Linux has the find command, while Windows has the File Search tool)
From simple searches to advanced searches, all of the tools generally work in the same way: you specify the search criteria and then wait for the tool to find the matching file(s)
But, if you need to accomplish the search programmatically, then FileVisitor can help you with the traversal process.
Whether you are looking for a file by name, by extension, or by a glob pattern or are looking inside files for some text or code, the approach is always to visit each file in the file store and perform some checks to determine whether the file conforms to your search criteria.
When you write your file search tool based on FileVisitor, you need to keep in mind the following:
At this point you can extract each file name, its extension, or its attributes or open the file for reading.
You can use the file name, extension, and so on for determining whether the visited file is the searched one.
Sometimes you will mix these information into complex search criteria.
If you want to find directories, then the comparison must take place in the.
FileVisitResult.CONTINUE because this issue does not require the entire search process to be stopped.
If you search for a file by name and you know that there is a single file with that name in the file tree, then you can return FileVisitResult.TERMINATE once the returned.
The search process can follow symbolic links, which can be a good idea, since following symbolic links may locate the searched file before traversing the symbolic link’s target sub-tree.
Following symbolic links is not always a good idea; for example, for deleting files it is not advisable.
Searching for Files by Name The preceding list can be incorporated into the following single code snippet to produce an application that searches for a file by name.
This application will search for the file rafa_1.jpg in the entire default file system and will stop the search when it finds it.
A fragment of the output may look something like this:
Searching for Files by Glob Pattern Sometimes you may have only partial information about the file you want to search for, such as only its name or extension or perhaps even just a chuck of its name or extension.
The process will stop only after the entire tree has been traversed.
If you have additional information about the file you are looking for, then you can create a more complex search.
For example, besides the small piece of information about the file name and type, perhaps you know that the file size is smaller than a certain number of kilobytes, or perhaps you know a detail such as when the file was created, when the file was last modified, whether the file is hidden or read-only, or who owns it.
The following is a fragment of the found files output:
Searching for Files by Content One of the advanced file searches involves finding files by their content.
You pass a sequence of words or sentences and the search returns only files that contain that text.
This is the most time-consuming file search task because it requires searching for text inside each visited file, which means opening the file, reading it, and finally closing it.
Moreover, there are many file formats that support text, such as PDF, Microsoft Word, Excel, and PowerPoint, simple text files, XML, HTML, XHTML, and so forth.
Each of these formats is read differently, which requires dedicated code that is capable of extracting text files from them.
In this section we will develop an application that searches for files by content.
Using the StringTokenizer class, and commas as separators, the following example extracts each word and sentence into an ArrayList:
The following code loops this ArrayList and compares each word and sentence with the text parameter.
The following subsections focus on isolating a set of methods for extracting text from some of the most common file formats and performing the comparison.
We’ll then combine each of the methods we develop into a full search program.
For reading PDF files, we will use two of the most popular third-party open source libraries, iText and Apache PDFBox.
You can download the iText library from http://itextpdf.com/ and the PDFBox library from http://pdfbox.apache.org/
For purposes of this chapter, I used version 5.1.2 of iText and version PDF.
The first step consists of creating a PdfReader over the visited file.
If one of the tokens is found in the extracted text, then the search in the current file is stopped, the file is considered a valid search result, and its path and name are stored so we can print it out later when the entire search is over.
If you are more familiar with PDFBox than iText, then try the following method.
Start by creating a PDFParser over the PDF file, continue by extracting the number of pages, and finish by extracting the text.
The Microsoft Office suite’s files can be manipulated through the Apache POI library, which is the most commonly used Java API for Microsoft documents.
Based on the developer guide, I wrote the following method for extracting text from a Word document.
Apache POI extracts an array of String containing all the paragraphs of a Word document.
We can extract text from Excel files as shown in the following example.
After creating an HSSFWorkbook for the Excel document, the basic idea is to iterate over the sheets, then over the rows, and finally over the cells.
The cell should contain the specific text that we are looking for.
Finally, we can extract text from PowerPoint files as shown in the following example; each slide may contain text and notes:
Note I arbitrarily chose the third-party libraries used in the preceding examples.
There are many other open source and commercial libraries available for dealing with different kinds of documents.
Feel free to use anything that is convenient for your needs.
Our search example is not the most efficient way to do the searching.
In a worstcase scenario, we would have to walk through an entire array (half of an array in a typical scenario)
Perhaps using an indexing search such as the one that Apache Lucene (http://lucene.apache.org/java/docs/index.html) provides would be a better way to do it.
This as an exercise you can attempt on your own.
Text files (.txt, .html, .xml, etc.) do not require a third-party library.
They can be read using pure NIO.2 code as follows:
Put everything in the traversal process and the application is ready:
Note that sometimes this is a pretty slow process that may take from several seconds to dozens of minutes—the running time will vary based on the file tree size, number of checked files, and the size of those files.
In the preceding example, the file tree contains all file stores in the default file system, so each file in any of the supported formats will be opened, read, and explored for our set of search words.
Depending on how large and numerous the matching files are, the process may appear to be jammed for a few seconds as the results are returned.
You can improve this application by adding more file formats, a progress bar or flag indicating process status, and multiple threads to speed up the process.
Moreover, displaying the name of the files as they are found may be a better idea than storing their names and path.
Before you see an example, here are a few things you need to keep in mind:
Before you delete a directory, you must delete all files from it.
Since you can delete a directory only if it is empty, it is recommended to delete.
The delete process can follow symbolic links, which may be not advisable, since symbolic links may point files outside the deletetion domain.
But if you are sure that this case can never happen, or a supplementary condition prevents undesirable deletions, then follow symbolic links.
Our aim in this section is to create an application that deletes an entire file tree.
The following code deletes the C:\rafaelnadal directory (for further use, make a backup of this directory before you run the following code):
Note Sending the deleted files to the recycle bin can be accomplished by using JNI to invoke Windows API for more details.
Before you copy any files from a directory, you must copy the directory itself.
Copying a source directory (empty or not) will result in an empty target directory.
If you want to preserve the attributes of the source directory, you need to do that.
If you choose to follow links (FOLLOW_LINKS) and your file tree has a circular link to method with the FileSystemLoopException exception.
The copy process can follow symbolic links if you specify the FOLLOW_LINKS option.
Writing a Move Files Application Moving a file tree is a task that combines into a single application the steps of copying and deleting the file tree.
Before you see an example, here are some items you need to keep in mind:
Before you move any files from a directory, you must move the directory itself.
Since nonempty directories cannot be moved (only empty directories can be method.
After all files from a source directory are moved into the target directory, you need method.
Moreover, when you move a file or directory, you need to decide if ATOMIC_MOVE is needed.
If you want to preserve the attributes of the source directory, you need to do that attributes, such as lastModifiedTime, should be extracted in the directory, the directory content has changed and the initial last modified time is overwritten by the new date.
The move process can follow symbolic links if you specify the FOLLOW_LINKS option.
Keep in mind that moving a symbolic link moves the link itself, not the target of that link.
Summary This chapter focused on developing recursive operations over files and directories.
After a short intro to the recursive programming technique, you learned about the FileVisitor interface and SimpleFileVisitor implementation.
You then saw how to develop a set of applications that that you can use to perform tasks that involve traversing a file tree, such as finding, copying, deleting, and moving files.
The most common use is to monitor a directory for changes to its content through actions such as create, delete, and modify.
You’ve probably seen the effect of such a service many times.
For example, when you open a text file in an editor (such as GridinSoft Notepad, jEdit, etc.) and the file content is modified outside the editor, you will see a message that asks whether you want to reload the file because it was modified.
This means the editor has detected a file change through a watch service and is reporting it accordingly.
This is known as the file change notification mechanism, and starting with NIO.2, it is available through the Watch Service API.
The Watch Service API is a low-level API that can be used as is or can be customized.
You can even write a high-level API on top of it.
By default, this API uses the underlying file system functionalities to watch the file system for changes.
It allows you to register a directory (or directories) to be monitored for different kinds of notification events that you specify during registration.
When one or more of the registered notification events are detected by the watch service, the watch service passes the notification events to the process that is registered to handles them through a separate thread or pool of threads.
Note Starting with NIO.2, you no longer need to poll the file system for changes or use other in-house solutions to monitor the file system changes.
In previous Java versions, you have to implement an agent running in a separate thread that keeps track of all the contents of the watched directories, constantly polling the file system to see if anything important has happened.
Now, regardless of whether you are running Mac OS X, Linux, Unix, Windows, or some other OS, you have the guarantee that the underlying operating system and file system provide the required functionalities to allow Java to register to receive notification of file system changes.
In this chapter you will see how to develop applications based on the provided Watch Service API.
Implementing a functional application isn’t easy, so we will start with the simplest case in which the application monitors a single directory for changes.
Afterward, you will see how to recursively monitor a directory tree that you have registered to be watched.
In addition, we will develop two more applications that are less generic and that encapsulate real-life cases.
To get you started, the chapter provides an overview of the main classes involved in writing a Watch Service API–based application.
It has multiple implementations for different file systems and operating systems.
You use this interface together with three classes to develop a system that has file system watch capability.
Watchable object: An object is “watchable” if it represents an instance of a class that implements the java.nio.file.Watchable interface.
In our case, this is the most important class of NIO 2, the well-known Path class.
Event types: This is the list of events we are interested in monitoring.
Events trigger a notification only if they are specified in the register call.
The standard supported events are represented by the java.nio.file.StandardWatchEventKinds class and include create, delete, and modify.
Event modifier: This qualifies how a Watchable is registered with a WatchService.
As of the time of this writing, NIO.2 does not define any standard modifiers.
Watcher: The watcher watches watchables! In our examples, the watcher is WatchService and it monitors the file system changes (the file system is a FileSystem instance)
As you will see, the WatchService will be created through the FileSystem class.
It will work away silently in the background watching the registered Path.
Implementing a Watch Service Implementing a watch service is a task that requires accomplishing a set of steps.
In this section, you will see the main steps for developing a watch service that monitors a given directory for three notification events: delete, create, and modify.
Each step is supported by a chunk of code that demonstrates how to practically accomplish the step.
At the end, we will glue the chunks together into a complete functional example of a watch service.
Creating a WatchService We begin our journey by creating a WatchService for monitoring the file system.
Registering Objects with the Watch Service Every object that should be watched must be explicitly registered with the watch service.
We can register any object that implements the Watchable interface.
For our example, we will register directories that are instances of the Path class.
The supported types of events are mapped under the StandardWatchEventKinds class as constants of type Kind<Path>:
An ENTRY_CREATE event is also triggered when a file is renamed or moved into this directory.
An ENTRY_DELETE event is also triggered when a file is renamed or moved out of this directory.
Which events constitute a modification is somewhat platform-specific, but actually modifying the contents of a file always triggers a modify event.
On some platforms, changing attributes of files can also trigger this event.
StandardWatchEventKinds.OVERFLOW: Indicates that events might have been lost or discarded.
You do not have to register for the OVERFLOW event to receive it.
There are two such methods dedicated for registering objects with the watch service.
One of them receives two arguments representing the watch service to which this object is to be registered and the events for which this object should be registered.
The second register method receives these two arguments also, and a third argument that specifies modifiers that qualify how the directory is registered.
At the time of this writing, NIO.2 does not provide any standard modifiers.
The following code snippet registers the Path C:\rafaelnadal with the watch service (the monitored events will be create, delete, and modify):
You receive a WatchKey instance for each directory that you register; this is a token representing the registration of a watchable object with a WatchService.
It is your choice whether or not to hang onto this reference, because the WatchService returns the relevant WatchKey to you when an event is triggered.
More details about watch keys are provided in the following section.
Waiting for the Incoming Events Waiting for the incoming events requires an infinite loop.
When an event occurs, the watch service is responsible for signaling the corresponding watch key and placing it into the watcher’s queue, from where we can retrieve it—we say that the watch key was queued.
Therefore, our infinite loop may be of the following type:
Getting a Watch Key Retrieving a queued key can be accomplished by calling one of the following three methods of the WatchService class.
All three methods retrieve the next key and remove it from the queue.
They differ in how they respond if no key is available, as described here:
If still no key is available, then it returns null.
The time period is indicated as a long number, while the TimeUnit argument determines whether the specified time is minutes, seconds, milliseconds, or some other unit of time.
The following three code snippets show you each of these methods called inside the infinite loop:
Keep in mind that a key always has a state, which can be either ready, signaled, or invalid:
Ready: When it is first created, a key is in the ready state, which means that it is ready to accept events.
Signaled: When a key is in the signaled state, it means that at least one event has the fish.
When you have a fish on the hook, the float (key) signals you to pull the method is invoked to return the key to the ready state.
If other events occur while the key is signaled, they are queued without requeuing the key itself (this never happens when fishing)
Invalid: When a key is in the invalid state, it means that it is no longer active.
A key the directory becomes inaccessible, or the watch service is closed.
Note Watch keys are safe for use by multiple concurrent threads.
Retrieving Pending Events for a Key When the key is signaled, we have one or more pending events waiting for us to take action.
It gets no arguments and returns a List containing the retrieved pending events.
We can iterate this List to extract and process each pending event individually.
The List type is WatchEvent<T>, which represents an event (or repeated event) for an object that is registered with a WatchService:
The following code snippet iterates the pending events for our key:
Retrieving the Event Type and Count The WatchEvent<T> interface maps event properties, such as type and count.
Note If you ignore the registered event types, it is possible to receive an OVERFLOW event.
This kind of event can be ignored or handled, the choice of which is up to you.
Besides the event type, we can also get the number of times that the event has been observed.
Retrieving the File Name Associated with an Event When a delete, create, or modify event occurs on a file, we can find out its name by getting the event context (the file name is stored as the context of the event)
Putting the Key Back in Ready State and has been reset, and returns false if the watch key could not be reset because it is no longer valid.
In some cases, the infinite loop should be broken if the key is no longer valid; for example, if we have a single key, there is no reason to stay in the infinite loop.
Following is the code that is used to break the loop if the key in no longer valid:
Closing the Watch Service The watch service exits either when the thread exits or when the service is closed.
When the watch service is closed, any current operations are canceled and invalidated.
After a watch service is closed, any further attempt to invoke operations upon it will throw ClosedWatchServiceException.
If this watch service is already closed, then invoking this method has no effect.
Gluing It All Together In this section, we glue together all the preceding chunks of code, with imports and spaghetti-code, into a single application that watches for create, delete, and modify events for the path C:\rafaelnadal and reports the type of event and the file where it occurred.
For purposes of testing, try manually to add, delete, or modify a file or directory under this path.
Since this application contains an infinite loop, be careful to manually stop the application, or implement a stop mechanism.
The application is provided as a NetBeans project, so you can easily stop it, with no supplementary code, from the Output window.
Other Examples of Using a Watch Service In this section, we will “play” with the preceding application for coding some scenarios meant to explore the possibilities of the watch service.
We will build new applications based on this one for accomplish more complicated tasks that involves a watch service.
As in the previous section, following the description of each step, a chunk of code supporting the step is provided.
After the steps are described in full, we will pull everything together into the complete application.
Note For purposes of keeping the code as clean as possible, we will skip the declaration of variables (their names are the same as in the previous application) and code that should just be repeated.
Watching a Directory Tree To get started, we’ll develop an application that extends the preceding example to watch the entire C:\rafaelnadal directory tree.
Moreover, if a CREATE event creates a new directory somewhere in this tree, it will get registered immediately as if it were there from the beginning.
Next, we need to register the directory tree for create, delete, and modify events.
This is trickier than it was in the original application because we need to register each subdirectory of C:\rafaelnadal, not only this directory.
Therefore, we need a walk (see Chapter 5) to traverse each subdirectory and register it individually in the watch service.
This case is perfect for implementing a walk by extending the SimpleFileVisitor class, since we only need to get involved when a directory is previsited (additionally,
At this point, the initial C:\rafaelnadal directory and all subdirectories are registered for create, delete, and modify events.
Next, we will focus on the infinite loop that will “capture” these events.
When an event occurs, we are especially interested whether it is a CREATE event, since it may signal that a new subdirectory has been created, in which case it is our responsibility to add this subdirectory into the watch service process that we do not know which key has been queued, so we do not know which path should be passed for registration.
The solution may be to keep the keys and corresponding paths in a HashMap that is updated can just extract the associated key from the hash map:
Now, in the infinite loop, we can register any new subdirectory as follows:
The HashMap can also be used to stop the infinite loop when no more valid keys are available.
To accomplish this, when a key is invalid, it is removed from the HashMap, and when the HashMap is empty, the loop is broken:
That’s it! At this point, let’s put everything together into a single shot:
For testing purposes, try to create new subdirectories and files, modify them, and then delete them.
At the same time, keep an eye on the console output to see how events are reported.
Watching a Video Camera For this scenario, suppose that we have a surveillance video camera that captures at least one image every 10 seconds and sends it in JPG format to a computer directory.
Behind the scenes, a controller is responsible for checking if the camera sends the image captures on time and in the correct, JPG format.
It displays an alert message if the camera does not work properly.
This scenario can be easily reproduced in code lines thanks to the Watch Service API.
We are especially interested in writing the controller that watches the video camera.
Since the video camera sends the captures to a directory, our controller can watch that directory for the CREATE event.
The directory in this example is C:\security (which you should manually create) and it is mapped as a Path by the path variable:
Next, we know that the video camera sends images every 10 seconds, which means that the poll(long, TimeUnit) method should be perfect for monitoring this (remember that if an event occurs during the specified time period, this method exits, returning the relevant WatchKey)
We set it to wait exactly 11 seconds, and if in this time no new capture is created, then we report this through a message and stop the system:
Finally, if we have a new capture available, then all we need to do is check whether it is in the JPG which probes the content type of a file.
We pass the file, and it returns null or the content type as a MIME.
We have accomplished the main tasks in writing the controller, so now all we need to do is fill in the missing code (imports, declarations, main function, etc.) to give us the complete application, as follows:
System.out.println("The video camera is jammed - security watch system is break;
For testing purposes, you may need to write a tester class or, much easier, play the role of the video camera.
Just start the application and copy and paste JPG images in C:\security before the critical time passes.
Try different cases, such as using a wrong file format, waiting more than 11 seconds before copying another image, and so on.
Watching a Printer Tray System In this section, we will develop an application that monitors a large-scale printer tray.
Suppose that we have a multithreading base class that receives documents to be printed and dispatches them to a suite of.
Note Java 7 recommends using the new ThreadLocalRandom class for generating random numbers in multithreading cases.
But I prefer the old Random class because the new class seems to have a bug; it generates the same numbers over multiple threads.
If the bug has been resolved by the time you read this book, then you.
Our job is to implement a watch service to manage this tray.
When a new document arrives into the tray, we have to pass it to the Print class, and after a document has been printed, we have to delete it from the tray.
We start by obtaining a watch service via the classical approach and registering the C:\printertray directory for CREATE and DELETE events:
Next, when a new document arrives into the tray, we have to create a new Print thread and store the thread and the document path for further tracking the thread state.
This will help us to know when a document has been printed and thus should be deleted from the tray and removed for storage (we use a HashMap for this task)
The following code snippet contains the block of code executed when a new document arrives into the tray (a CREATE event was queued):
After a document is deleted from the tray (a DELETE event is queued), we just print a message:
But when is the document deleted? To solve this task, we use a little trick.
Instead of using the us control in the infinite loop at the specified time interval—when we have control (no matter whether or not any key was queued), we can loop the HashMap of threads to see if any printing job has terminated (the associated thread state is TERMINATED)
Every TERMINATED state will be followed by deletion of the associated path and removal of the HashMap entry.
When the path is deleted, a DELETE event will be queued.
For testing purposes, start the application and copy a set of files into the C:\printertray directory.
For example, the following is output from testing with a set of files:
Summary In this chapter you have explored a great facility of NIO.2, the Watch Service API.
You learned how to watch a directory or directory tree for events such as create, delete, and modify.
After an overview of this API and an introductory application, you saw how to combine this API with NIO.2 walks, how to simulate video camera surveillance, and how to watch a large-scale printer tray.
These examples were simply meant to stimulate your curiosity to explore further the exciting world of this API.
Since it is very versatile, it can be applied in many other scenarios.
For example, you might use it to update a file listing in a GUI display or to detect the modification of configuration files that could then be reloaded.
Files that can be explored sequentially are known as sequential files.
In this chapter you will see the advantages of using nonsequential (random) access to a file’s contents.
Files that permit random access to their contents are known as random access files (RAFs)
Sequential files are used more often because they are easy to create, but RAFs are more flexible and their data can be located faster.
With a RAF, you can open the file, seek a particular location, and read from or write to that file.
After you open a RAF, you can read from it or write to it in a random manner just by using a record number, or you can add to the beginning or end of the file since you know how many records are in the file.
A RAF allows you to read a single character, read a chunk of bytes or a line, replace a portion of the file, append lines, delete lines, and so forth, and allows you to perform all of these actions in a random manner.
Its name is SeekableByteChannel and it is available in the java.nio.channels package.
It extends the older ByteChannel interface and represents a byte channel that maintains a current position and allows that position to be modified.
Moreover, Java 7 improves the well-known FileChannel class by implementing this interface and providing RAF and FileChannel power in a single shot.
With a simple cast we can transform a SeekableByteChannel into a FileChannel.
This chapter uses the java.nio.ByteBuffer class extensively, so we will start with a short overview of it.
We will continue by detailing the SeekableByteChannel interface with applications that will read and write files randomly to accomplish different types of common tasks.
You will then see how to get a FileChannel with RAF capabilities and explore the main facilities provided by FileChannel, such as mapping a region of the file directly into memory for faster access, locking a region of the file, and reading and writing bytes from an absolute location without affecting the channel’s current position.
The chapter ends with a benchmarking application that will help you to determine the fastest way to streams, and so on.
Brief Overview of ByteBuffer A buffer is essentially an array (usually of bytes, but other kinds of arrays can be used—the Buffer interface offers ByteBuffer, CharBuffer, IntBuffer, ShortBuffer, LongBuffer, FloatBuffer, and DoubleBuffer) that holds some data to be written or that was just read.
The two most important components of buffers in NIO are properties and ancestor methods, as discussed next in turn.
ByteBuffer Properties The following are the essential properties of a buffer:
Limit: When writing from a buffer, the limit specifies how much data remains to get.
When you are reading into a buffer, the limit specifies how much room remains to put data into.
Position: The position keeps track of how much data you have read or written.
It specifies into which or from which array element the next byte will go or come.
A buffer’s position is never negative and is never greater than its limit.
Capacity: The capacity specifies the maximum amount of data that can be stored in a buffer.
Note In some cases, the initial limit may be 0, or it may be some other value, depending on the type of the buffer and the manner in which it is constructed.
Next, suppose that we read 2 bytes of data into our buffer.
Continuing with a second read, another 3 bytes go into the buffer.
At this point, suppose that we are not reading into the buffer anymore and want to write from the to the current position, and set the position to 0
After the flip, the buffer appears as shown in Figure 7-6
There are two additional operations we may want to accomplish.
Continuing with Figure 7-8 as a reference, we may want to rewind the buffer or clear the buffer.
Rewinding the buffer (calling the reset the buffer for receiving more bytes (the data is not deleted)—the limit is set to the capacity and the.
This is the index to which its position will be reset when the than the position.
If the mark is defined, then it is discarded when the position or the limit is adjusted to InvalidMarkException to be thrown.
At this point you have sufficient information about ByteBuffer to understand the following applications.
To get deeper into the bowels of ByteBuffer, access dedicated tutorials on the Web.) Therefore, we leave behind ByteBuffer for the moment and proceed to the main topic of this chapter, the SeekableByteChannel interface.
The next section will introduce you to channels and relate them with buffers.
By contrast, in a block-oriented I/O system, the input/output stream produces or consumes a block of data in one step.
Channels are analogous to streams, but with a few differences:
While streams are typically one-way (read or write), channels support read and write.
All data that is sent to a channel must first be placed in a buffer.
Any data that is read from a channel is read into a buffer.
Using the SeekableByteChannel Interface for Random Access to Files The new SeekableByteChannel interface provides support for RAF by implementing the notion of position over channels.
We can read or write a ByteBuffer from or to a channel, get or set the current position, and truncate an entity connected to a channel to a specified dimension.
The following methods are associated with these features (more details are available in the official documentation at http://download.oracle.com/javase/7/docs/api/index.html):
Setting the position to a value that is greater than the current size is legal but does not change the size of the entity.
Getting an instance of SeekableByteChannel can be accomplished through two methods of the Files file to open or create and a set of options specifying how the file is opened.
CREATE_NEW Creates a new file, failing with an exception if the file already exists.
DELETE_ON_CLOSE Deletes the file when the stream is closed (used for deleting temporary files)
Both of these methods open or create a file, returning a SeekableByteChannel to access the file.
Reading a File with SeekableByteChannel C:\rafaelnadal\grandslam\RolandGarros\story.txt (the file must exist):
As an example, the following application will read and display the content of story.txt using a ByteBuffer (the file must exist)
I chose a buffer of 12 bytes, but feel free to use any other size.
Rafa Nadal produced another masterclass of clay-court tennis to win his fifth French Open title ...
Writing a File with SeekableByteChannel Writing a file with SeekableByteChannel involves using the WRITE option.
In addition, if we want to clean up the existing content before writing, we can add the TRUNCATE_EXISTING option as follows.
Here we truncate story.txt and prepare it for writing (the story.txt file must exist)
When you write a file, there a few common cases that involve combining the open options:
To write into a file that exists, at the beginning, use WRITE.
To write into a file that exists, at the end, use WRITE and APPEND.
To write into a file that exists and clean up its content before writing, use WRITE and TRUNCATE_EXISTING.
To write into a file that does not exist, use CREATE (or CREATE_NEW) and WRITE.
SeekableByteChannel and File Attributes The following code snippet (written for Unix and other POSIX file systems) creates a file with a specific set of file permissions.
This code creates the file email.txt in the home\rafaelnadal\email directory or appends to it if it already exists.
The email.txt file is created with read and write permissions for the owner and read-only permissions for the group.
Reading a File with the Old ReadableByteChannel Interface The new SeekableByteChannel interface is based on the old interfaces ReadableByteChannel (represents a channel that reads bytes; only one thread can read at a time) and WritableByteChannel (represents a channel that writes bytes; only one thread can write at a time) that have been available in NIO since JDK 1.4
Thanks to this relationship method as follows, in which we read the content of the existing story.txt file:
As you can see, there is no need to specify the READ option.
Writing a File with the Old WritableByteChannel Interface method as follows, in which we append some text into story.txt:
Even if we use a WritableByteChannel, we still need to explicitly specify the WRITE option.
The APPEND option is optional, and is specific to the preceding example.
Playing with SeekableByteChannel Position Now that you know how to read and write an entire file with SeekableByteChannel, you are ready to discover how you can do the same operations but at a specified channel (entity) position.
For this, we current channel (entity) position, while the position(long) method sets the current position in the channel (entity) by counting the number of bytes from the beginning of it.
The first position is 0 and the last valid position is the channel (entity) size.
Example 1: Read One Character from Different Positions We start with a simple example that reads exactly one character from a text file from the first, middle, and last positions.
The file is MovistarOpen.txt and it is located in the C:\rafaelnadal\tournaments\2009 directory.
Example 2: Write Characters at Different Positions Next, we will try to write to a specific position.
Suppose that the MovistarOpen.txt file has the following default content:
It is the first clay-court tournament of the ATP World Tour season and also the opening leg of the four-tournament swing through Latin America, aptly coined the "Golden Swing" in honour of top Chileans and Olympic Gold medalists Fernando Gonsales and Nicolas Massu.
If everything worked fine, the new MovistarOpen.txt content should be as follows:
It is the first clay-court tournament of the ATP World Tour season and also the opening leg of the four-tournament swing through Latin America, aptly coined the "Golden Swing" in honour of top Chileans and Olympic Gold medalists Fernando Gonzalez and Nicolas Massu.
Example 3: Copy a Portion of a File from the Beginning to the End Moving on to a new application, we next want to copy a portion of text from the beginning of a file to the end of the same file.
As an example, we’ll use the HeinekenOpen.txt file (located in the C:\rafaelnadal\tournaments\2009 directory), which has the following content:
Example 4: Replace a File Portion with Truncate Capability In this example we will truncate a file and append new text in place of the truncated text.
We will use the BrasilOpen.txt file (found in the C:\rafaelnadal\tournaments\2009 directory), which has the following content:
Brasil Open At Forefront Of Green Movement The Brasil Open, the second stop of the four-tournament Latin American swing, is held in an area renowned for its lush natural beauty and stunning beaches.
The effect of this application is the following modification of the BrasilOpen.txt file:
Brasil Open At Forefront Of Green Movement The Brasil Open, the second stop of the four-tournament Latin American swing, is held in an area renowned for its lush natural beauty and stunning beaches.
The tournament has taken a lead in environmental conservation efforts, with highlights including the planting of 500 trees to neutralise carbon emissions and providing recyclable materials to local children for use in craft work.
This suite of examples should help you to understand how to randomly access file content.
Next, we are going to cast the SeekableByteChannel interface to FileChannel to give us access to more advanced features.
Working with FileChannel FileChannel was introduced in Java 4, but recently it was updated to implement the new SeekableByteChannel interface, combining their forces to achieve more power.
SeekableByteChannel provides the random access file feature, while FileChannel offers great advanced features such as mapping a region of the file directly into memory for faster access and locking a region of the file.
Both methods are able to open or create a file for the given Path and return a new channel.
The first (simplest) method receives the path of the file to open or create and a set of options specifying how the file is opened.
The second method receives the path of the file to open or create, a set of options specifying how the file is opened, and, optionally, a list of file attributes to set atomically when the file is created.
For example, the following code gets for the specified path a file channel with read/write capabilities:
Explicitly casting a SeekableByteChannel to a FileChannel can be an alternative to the preceding code:
Now, the fileChannel instance has access to the methods provided by SeekableByteChannel and FileChannel.
Mapping a Channel’s File Region Directly into Memory One of the great FileChannel facilities is the capability to map a region of a channel’s file directly into arguments:
Note Only channels opened for reading can be mapped as read-only, and only channels opened for reading and writing can be mapped as read/write or private.
To test if the operation completes successfully, the following is a printout of the byte buffer content:
If everything worked fine, you should see the BrasilOpen.txt content output to the console.
Locking a Channel’s File File locking is a mechanism that restricts access to a file or other piece of data to ensure that two or more users can’t modify the same file simultaneously.
Usually the file is locked when the first user accesses it and stays locked (can be read, but not modified) until that user is finished with the file.
On some platforms, file locking is advisory (any application can access the file if the application does not check for a file lock), while on others it is mandatory (file locking prevents any application from accessing a file)
We can take advantage of file locking in Java applications through the NIO API.
However, there is no guarantee that the file locking mechanism will always work as you expect.
Underlying OS support or, sometimes, a faulty implementation may affect the expected behavior.
File locks are held on behalf of the entire Java virtual machine.
Windows takes care of locking directories and other structures for you, so a delete, rename, or write operation will fail if another process has the file open.
Therefore, creating a Java lock over a system lock will fail.
The Linux kernel manages a set of functions known as advisory locking mechanisms.
In addition, you can enforce locking at the kernel level with mandatory locks.
Therefore, when using Java locks, keep in mind this aspect.
The second application will attempt to write to the same file during this time.
If the file was successfully locked for 2 minutes, then the second application will throw a java.io.IO.Exception and output a message like the following:
The process cannot access the file because another process has locked a portion of the file.
Use the file channel to create a lock on the file.
This method returns // null or throws an exception if the file is already locked.
File is already locked in this thread or virtual machine //}
Run the preceding application and, within a maximum of 2 minutes, start the following application in parallel:
You should find that the second application can write into vamos.txt only after the lock is released, after 2 minutes.
Copying Files with FileChannel FileChannel provides a few ways to copy a file.
Copying Files with FileChannel and a Direct or Non-direct ByteBuffer To copy files with FileChannel and a direct or non-direct ByteBuffer, we need one channel for the source file, one channel for the target file, and a direct or non-direct ByteBuffer.
Read data from file into ByteBuffer int bytesCount; //flip the buffer which set the limit to current position, and position to 0 //write data from ByteBuffer to file //for the next read.
To do so, modify the preceding code by replacing the line.
Earlier in the chapter you saw how to map a region of the channel’s files into memory using a MappedByteBuffer.
In this section, we extrapolate that example to copy the Rafa Best Shots.mp4 content:
Benchmarking FileChannel Copy Capabilities In the previous three sections you saw different ways to copy a file using FileChannel capabilities.
Which one should you choose? This is a hard question, and its answer depends on many factors.
This section focuses on one factor, speed, because completing a copy task quickly increases productivity and, in some situations, is critical to success.
Thus, this section implements an application that compares how much time each of the following solutions takes for each copy:
Time was captured only after three ignored consecutive runs; the first three runs are ignored to achieve a trend.
The first-time run is always slower than the subsequent runs.
The application is listed next and is available in the Source Code Download section of this book’s page on Apress.com:
Read data from file into ByteBuffer int bytesCount; //flip the buffer which set the limit to current position, and position to 0 //write data from ByteBuffer to file //for the next read.
Read data from file into ByteBuffer int bytesCount; //flip the buffer which set the limit to current position, and position to 0 //write data from ByteBuffer to file //for the next read.
The output of this application is pretty hard to sort through since there are so many numbers involved, so I’ve plotted some of the data instead to give you a clearer image of the results of several.
The Y axis in these figures is the estimated time expressed in seconds, and the X axis is the size of the used buffer (or run number, after skipping the first three runs)
Summary This chapter started with a short overview of the ByteBuffer class, which is commonly used with SeekableByteChannel and FileChannel.
It continued by detailing the SeekableByteChannel interface with applications that will read and write files randomly to accomplish different types of common tasks.
You then saw how to get a FileChannel with RAF capabilities and discovered the main facilities provided by FileChannel, including mapping a region of the file directly into memory for faster access, locking a region of the file, and reading and writing bytes from an absolute location without affecting the channel’s current position.
The chapter ended with a benchmarking application that tries to determine the fastest way to copy a file by comparing FileChannel capabilities against other common approaches, array.
Finally, programmers can now create network applications without years of study about network communications.
Java developers can write a simple network application just by scratching the surface of a few subjects, such as IP, IP addresses, ports, and Java networks.
On top of IP, we have other common protocols, such as TCP (Transmission Control Protocol) and UDP (User Datagram Protocol) (this chapter’s applications exploit these protocols), and on top of these we have even more, including HTTP, TELNET, DNS, and so on.
Sockets make use of IP for communication between machines, so Java network applications can “talk” to existing servers using their predefined protocol.
On the Internet, each machine can be identified by a numerical label, known as an IP address.
Moreover, it is important to know that IP addresses are organized into classes A, B, C, D, and E.
In addition, remember that the address 127.0.0.1 is reserved for the localhost address.
Certain types of servers are typically found on certain ports: for example if you connect to port Telnet server, on 119 an NNTP server, and so on.
Therefore, be careful when choosing ports; make sure you don’t interfere with other processes and that you keep in range.
Each of these notions has entire books dedicated to it, but this is enough information for the purposes of creating Java client/server applications.
In a client/server model, a server runs on a host and listens to a port for connection requests from clients across the network, or even from the same machine.
Clients use the IP address (hostname) and port to locate the server, while the server serves each client according to its request.
On the connection process, the client identifies itself to the server through a local port number that can be explicitly set or assigned by the kernel—a socket is bound to this local port number to be used during this connection (we say that the client binds to a local port number)
Upon acceptance, the server gets a new socket bound to a new local port number and also has its remote endpoint set to the address and port of the client—it needs a new port number so that it can continue to listen for connection requests on the original port.
We can conclude that, for Java, a socket is a bidirectional software endpoint between a server program and its client programs, or more generally, between two programs running on the network that are involved in a two-way communication.
An endpoint is a combination of an IP address and a port number.
Java introduced support for sockets in JDK 1.0, but things have of course changed over time from version to version.
The main classes dedicated to synchronous socket channels, ServerSocketChannel, SocketChannel, and DatagramChannel, implement this interface, which comes with methods for binding to and returning local addresses, and methods for setting and getting socket options through the new SocketOption<T> interface and StandardSocketOptions class.
This interface’s methods and the ones added directly into classes (for checking connection state, getting remote addresses, and shutdown) will prevent you from.
NIO.2 also introduces the MulticastChannel interface as a subinterface of NetworkChannel.
As its name suggests, the MulticastChannel interface maps a network channel that supports IP multicasting.
Keep in mind that MulticastChannel is implemented only by the datagram channel (the DatagramChannel class)
When joining a multicast group you get a membership key, which is a token that represents the membership of a multicast group.
Through the membership key, you can block/unblock datagrams from different addresses, drop membership, get the channel and/or multicast group for which this membership key was created, and more.
NetworkChannel Overview In this section we will have a short overview of the NetworkChannel methods.
This interface represents a channel to a network socket and comes with a set of five common methods for all sockets.
We present them here since they will be very useful in the next sections.
The local address can also be channels, socket channels, and datagram socket channels with the local machine.
Socket Options The remaining three methods of NetworkChannel deal with socket options supported by the current channel.
A socket option associated with a socket is represented by the SocketOption<T> interface.
Currently, NIO.2 implements this interface with a set of standard options in the StandardSocketOptions class.
IP_MULTICAST_IF: This option is used to specify the network interface (NetworkInterface) used for multicast datagrams sent by the datagram-oriented socket; if it is null, then the OS will choose the outgoing interface (if one is available)
By default, it is null, but the option’s value can be set after the socket is bound.
When we talk about sending datagrams, you will see how to find out what multicast interfaces are available on your machine.
IP_MULTICAST_LOOP: This option’s value is a boolean that controls the loopback of multicast datagrams (this is OS dependent)
You have to decide, as the application writer, whether you want the data you send to be looped back to your host or not.
By default, this is TRUE, but the option’s value can be set after the socket is bound.
If not otherwise specified, multicast datagrams are sent with a default value of 1, to prevent them to be forwarded beyond the local network.
With this option we can control the scope of the multicast datagrams.
By default this is set to 1, but the option’s value can be set after the socket is bound.
The option’s value can be set any time after the socket is bound.
By default, it is FALSE, but the option’s value can be set any time.
SO_KEEPALIVE: This option’s value it is a boolean indicating if the connection should be kept alive or not.
By default, it is set to FALSE, but the option’s value can be set any time.
SO_LINGER: This option’s value is an integer that represents a timeout in seconds (the linger interval)
When attempting to close a blocking-mode socket via the transmitting the unsent data (not defined for non-blocking mode)
By default, it is a negative value, which means that this option is disabled.
The option’s value can be set any time and the maximum value is OS dependent.
By default, the value is OS dependent, but it can be set before the socket is bound or connected.
Depending on the OS, the value can be changed after the socket is bound.
By default, the value is OS dependent, but it can be set before the socket is bound or connected.
Depending on the OS, the value can be changed after the socket is bound.
SO_REUSEADDR: This option’s value is an integer that represents if an address can be reused or not.
This is very useful in datagram multicasting when we want multiple programs to be bound to the same address.
By default, the option’s value is OS dependent, but it can be set before the socket is bound or connected.
By default it is FALSE, but it can be set at any time.
Retrieving the supported options for a specific channel (for a network socket) can be accomplished.
Writing TCP Server/Client Applications It is far from our aim to write a TCP tutorial, since this is a very well-documented and large subject, and involves many technical notions and aspects, but we’ll give a quick overview.
The primary function of TCP is to provide a point-to-point communication mechanism.
One process on one machine communicates with another process on another machine or within the same machine.
A unique TCP connection is identified by five elements: the IP address and port of the server, the IP address and port of the client, and the protocol (TCP/IP, UDP, etc.)
The server listens to one single port and can talk to many clients at the same time.
Moreover, TCP supports sending data as byte arrays or using streams, which are very popular in Java.
Non-Blocking Mechanisms When you decide to write a Java TCP server/client application, you must consider whether you need to write a blocking or non-blocking application.
This decision is important because the implementations are different and the complexity may also be critical.
The main characteristic of a blocking mechanism presumes that a given thread cannot do anything more until the I/O is fully received, which may take a while in some cases—the application’s flow is blocked because the methods do not return right away.
Non-blocking mechanisms, on the other hand, immediately queue an I/O request and return the control to application flow (methods return right away)
From a Java developer perspective, you also must take into account the degree of complexity involved by these mechanisms.
Non-blocking mechanisms are much more complex to implement than blocking mechanisms, but they allow you more performance and scalability.
Note Non-blocking mechanisms are not the same as asynchronous mechanisms (although this is often debated depending on who you ask)
For example, in a non-blocking environment, if an answer can’t be returned rapidly, the API returns immediately with an error and does nothing else, while in an asynchronous environment, the API always returns immediately, having started a behind-the-scenes effort to serve your request.
In other words, with a non-blocking mechanism, a function won’t wait while on the stack, and with an asynchronous mechanism, work may continue on behalf of the function call after that call has left the stack.
Asynchronous is more familiar with parallel (as threading), while non-blocking often refers to polling.
Both blocking and non-blocking modes have been implemented since NIO, but we will try to spice up the code with the new NIO.2 features.
In the next sections, we will develop both types of application.
Let’s start with the easy one that uses the blocking mechanism.
Writing a Blocking TCP Server The easiest approach for a better understanding of how to accomplish this task is to follow a straightforward set of steps accompanied by chunks of codes that will be glued together at the end of the discussion.
We want to develop a single-thread blocking TCP server that will echo to the client everything that it gets from it.
Many of the steps to accomplish this are transferable to other blocking TCP servers as well.
Creating a New Server Socket Channel The first step involves creating a selectable channel for stream-oriented listening socket, which is possible thanks to the java.nio.channels.ServerSocketChannel class, which is safe for use by multiple method, as show here:
Keep in mind that a newly created server socket channel is not bound or connected.
Binding and connecting will be accomplished in the next steps.
You can check if a server socket is already open or has been successfully opened by calling the.
Configuring Blocking Mechanisms If the server socket channel has been successfully opened, it is time to specify the blocking mechanism.
Notice that this method returns a SelectableChannel object, which represents a channel that can be multiplexed via a Selector.
This is useful when we are in non-blocking mode; therefore we will ignore it for the moment.
There is no required option (you can use the default values), but we’ll explicitly set a few options to show you how this can be done.
You can find out the supported options for a server socket channel by calling the inherited method.
Another common approach consists of creating an InetSocketAddress object without specifying the IP address, only the port (there is a constructor for that)
The wildcard address is a special local IP address that can be used only for bind operations, and usually means “any”:
Caution    When you are using an IP wildcard address, take care to avoid any undesirable complications that may occur if you have multiple network interfaces with separate IP addresses.
In this case, if you are not sure how to accomplish this without issues, is it recommended to bind the socket to a specific network address, rather than use a wildcard.
This returns null if the server socket channel has not been bound yet.
Accepting Connections After opening and binding, we finally reach the accepting milestone.
Since we are in blocking mode, accepting a connection will block the application until a new connection is available or an I/O error occurs.
We signal our impatience to accept new connections by calling the client socket channel (or simply, socket channel) for the new connection.
This is an instance of the SocketChannel class, which represents a selectable channel for stream-oriented connecting sockets.
Once we have accepted a new connection, we can find out the remote address by calling the remote address to which this channel’s socket is connected:
Transmitting Data over a Connection At this point the server and client can transmit data over a connection.
They can send and receive different kinds of data packets mapped as byte arrays or using streams along with the standard Java file I/O mechanism.
Implementing the transmission (send/receive) is a flexible and implementationspecific process since it involves many aspects.
For example, for our server we chose to use ByteBuffers and we kept in mind that this is an echo server—what it reads from the client is what it writes back.
Read a sequence of bytes from this channel into the given buffer.
These methods return the number of bytes read (it can be zero) or –1 if the channel has reached end-of-stream:
Write a sequence of bytes to this channel from the given buffer.
These methods return the number of bytes written; it can be zero:
As you know, channels are very good friends with buffers, but if you decide to use streams instead (InputStream and OutputStream), then you need to use the following code; once you have obtained an I/O stream you can further explore the standard Java file I/O mechanism.
Shutting down the connection for output (or writing) will reject any writing attempts by throwing a ClosedChannelException exception.
These methods are very useful if you want to reject read/write attempts without closing the channel.
Checking if a connection is currently shut down for I/O can be accomplished with the following code:
Closing the Channel method (this will not close the server for listening for incoming connections, it will just close a channel incoming connections; further clients won’t be able to locate the server anymore)
Using this feature will ensure that the resources are closed automatically.
If you are not familiar with try-with-resources feature, check out http://download.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html.
Putting it All Together into the Echo Server Now we have everything we need for creating our echo server.
Putting together the preceding chunks, adding the necessary imports and spaghetti code, and so on will provide us the following echo sever:
Writing a Blocking TCP Client What good is a server without a client? We do not want to find out the answer to this question, so let’s develop a client for our echo server.
When the number 50 is generated, the client stops sending and closes the channel.
The server will echo (write back) everything it reads from the client.
Now that we have a scenario, let’s see the steps for implementing it.
Creating a New Socket Channel The first step is to create a selectable channel for a stream-oriented connecting socket.
This is accomplished with the java.nio.channels.SocketChannel class, which is safe for use by multiple follows:
Keep in mind that a newly created socket channel is not connected.
Creating and connecting a socket channel in a single shot involves calling the SocketChannel.open(SocketAddress) method.
It is also possible to do this in two steps, as we will discuss.
You can check if a server socket is already open or has been successfully opened by calling the.
Configuring Blocking Mechanisms If the socket channel has been successfully opened, it is time to specify the blocking mechanism.
We will pass the true value, since we want to activate the blocking mechanism:
You can find the supported options for a server socket channel by calling the inherited method.
Connecting the Channel’s Socket After opening a socket channel (and optionally binding it), you should connect to the remote address (the server-side address)
Since we are in blocking mode, connecting to a remote address will block the application until a new connection is available or an I/O error occurs.
The method returns a boolean value representing a successful connection attempt.
You can use this boolean value to check the connection availability, until sending/receiving packets through this connection.
In addition, the same check can be accomplished by calling the.
Note Obviously, in real-world cases it’s considered bad practice to hard-code IP addresses within the application.
In this case the client will only be able to run on the same machine with the server, which sort of defeats the purpose of remote communication.
In your case, the client may likely use the hostname of the server instead of the IP address (likely configured through DNS)
Transmitting Data over a Connection The connection has been established, so we can start transmitting data packets.
We used methods previously when we developed the server-side code, so you should be familiar with them already):
Closing the Channel the client will be disconnected from the server:
Again, the Java 7 try-with-resources feature may be used for automatic closing.
Putting It All Together into the Client Now we have everything we need for creating our client.
Putting together all the required elements will provide us the following client:
Continue by starting the client and check out the output.
Writing a Non-Blocking TCP Client/Server Application Before we start developing, let’s have a short overview of the non-blocking API, which has been available since NIO, so it shouldn’t look totally new to you.
Keeping this in mind, we won’t go into too much detail about the things you likely already know.
Non-blocking socket mode is all about allowing I/O operation on a channel without blocking the processes using it.
The story begins exactly as in a blocking application: the server side is opened, is bound to a local address, and receives requests from the client side, which, obviously, is open, connected to the remote address, and sending requests to the server.
A Selector is created through a no-argument when one or more channels are available for data transfer and serializes the requests for helping the server to satisfy its clients (it monitors each recorded socket channel)
Moreover, the Selector processes multiple sockets’ I/O read/write operations in a single thread, thanks to a concept known as multiplexing—this solves the problem of dedicating one thread to each socket connection.
In API terms, the Selector is a multiplexor for (available in the ServerSocketChannel and SocketChannel classes, which are indirect subclasses of SelectableChannel) and deregistered by deallocating the resources that were allocated to the channel by the Selector.
Using the SelectionKey Class If you are still on track, then let’s go deeper! Each time a channel is registered with a Selector, it is.
Think of keys as the helpers used by the selector to sort the client requests—each helper (key) represents a single client subrequest and contains information for identifying the client and the type of the request (connect, read,write, etc.).When registering, we indicate the selector and, usually, the interest set for the resulting key (the interest set identifies the operations for which the key’s channel is monitored by the Selector)
SelectionKey.OP_ACCEPT (acceptable): The associated client requests a connection (usually created on the server side for indicating that a client requires a connection)
SelectionKey.OP_CONNECT (connectable): The server accepts the connection (usually created on the client side)
A selector is responsible for maintaining three sets of selection keys:
Note All three sets are empty in a newly created selector.
Selectors are themselves safe for use by multiple concurrent threads, but their key sets however are not.
When something happens on the battlefield, the selector wakes up and creates the corresponding keys (instances of the SelectionKey class)
Each key holds information about the application making the request and the type of the request (attempting/accepting connection and read/write operations)
The selector waits for incoming connections into an infinite loop (waits for events recorded on the.
The Selector waits for a client to attempt a connection, and when that happens, the server application gets the keys created by the selector.
For each key, it checks the type (each processed key is prevent the same key from coming up again)
At this point, the client socket channel is registered to the selector for reading/writing operations.
In keeping with this trend, when the client writes data on the socket channel, the selector will tell the server client attempts to read data from server, the process is similar, but the server instead writes data and the.
Note In non-blocking mode, an I/O operation may transfer fewer bytes than were requested (partial read or write), or possibly no bytes at all.
Using the Selector’s Methods Next, we’ll go over the methods invoked in this section, as well as a few more, are overviewed next (most of the following descriptions were taken from the official Java 7 Javadoc)
Selector.select(t): Same as select, but the blocking is performed only for the specified milliseconds.
If time expires and there is nothing to select, it returns 0
SelectionKey.interestOps(t): Sets this key’s interest set to the given value.
It gets the selector, the interest set for the resulting key, and the attachment for the resulting key (may be null)
Writing the Server Based on these methods and the preceding discussion, we have written the following non-blocking echo server (every step is commented to help give you a good understanding):
Writing the Client Focusing on the client side, the structure is almost the same, with a few differences:
First, the client socket channel is registered with the SelectionKey.OP_CONNECT option, since the client wants to be informed by the selector when the server accepts the connection.
Third, the client must check if the key is connectable (i.e., if the a conditional statement for closing the pending connections.
When you need to tell whether or not a connection operation is in progress on this channel, call the Also, finishing the process of connecting a socket channel can be accomplished by.
When 50 is generated, the client stops sending and closes the channel.
The server will echo (write back) everything it reads from the client.
Figure 8-2 shows an example of running the server and three client instances.
Keep in mind that even if it looks like a multithreading application, this is a single-thread application based on the multiplexing technique.
Writing UDP Server/Client Applications Since TCP has had its moment of glory, it is time for UDP to get our attention.
Additionally, each packet is an individual, and is handled separately (no packet is aware of other packets)
Moreover, the packets can arrive in any order, and some of them can be lost without the sender being informed, or they can arrive.
Since the sender can’t track the packets’ routes, each packet encapsulates the remote IP address and the port.
If TCP is like a telephone, UDP is like a letter.
The sender writes the receiver address (remote IP and port) and sender address (local IP and port) on the envelope (UDP packet), puts the letter (data to be sent) into the envelope, and sends the letter.
He doesn’t know if the letter will arrive to the receiver or not.
Moreover, a more recent letter can arrive faster than and old one, and a letter might never arrive at all—the letters are not aware of one another.
Keep in mind that TCP is for high-reliability data transmissions while UDP is for low-overhead transmissions.
Typically, use UDP in applications in which reliability is not critical but speed is.
In the next sections, we will write a single-thread blocking client/server application based on UDP.
Writing a UDP Server To aid your understanding, we will split the developing process into discrete steps and bring to the front the features of NIO.2 meant to increase performance and ease of development.
Again, we will write an echo server and a client that sends some text to it and receives it back.
Creating a Server Datagram–Oriented Socket Channel The entire process of writing a client/server UDP application involves the java.nio.channels.DatagramChannel class, which represents a thread-safe selectable channel for datagram-oriented sockets.
Therefore, we’ll start our server by creating a new DatagramChannel, which parameter known as a protocol family parameter, which is actually a java.net.ProtocolFamily object.
But in this case, the ProtocolFamily of the channel’s socket is platform (configuration) dependent and therefore unspecified.
You can check if a datagram-oriented socket channel is already open or has been successfully value:
A client datagram–oriented socket channel can be created and checked in the same manner.
As an example, we can set the input and output buffers used by the networking implementation as follows:
Notice that you can find out the supported options for a datagram-oriented socket channel by.
This returns null if the datagram-oriented socket channel has not been bound yet.
Transmitting Data Packets At this point our server is ready to receive and send packets.
Since UDP is a connectionless network protocol, you cannot just by default read and write to a DatagramChannel like you do from other channels—later, you will see how to set up a connection over UDP.
Here’s how this works according to the official documentation (see http://download.oracle.com/javase/7/docs/api/):
If this channel is in non-blocking mode and there is sufficient room in the underlying output buffer, or if this channel is in blocking mode and sufficient room becomes available, then the remaining bytes in the given buffer are transmitted as a single.
If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete.
If this channel’s socket is not bound then this method will first cause the socket to be method with a parameter of null.
Again, here’s how it works according to the documentation (see http://download.oracle.com/javase/7/docs/api/):
If a datagram is immediately available, or if this channel is in blocking mode and one eventually becomes available, then the datagram is copied into the given byte buffer and its source address is returned.
If this channel is in non-blocking mode and a datagram is not immediately available then this method immediately returns null.
If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete.
If this channel’s socket is not bound then this method will first cause the socket to be bound to an address that is assigned.
The method will return the datagram’s source address, or null if this channel is in non-blocking mode and no datagram is immediately available.
The remote address can be used to find out where to send an answer packet.
In addition, you can find out the remote address by calling the remote address to which this channel’s socket is connected—keep in mind that for a UDP connectionless case, this method returns null:
Our datagram echo server will listen for incoming packets in an infinite loop, in blocking mode (by default), and when a packet arrives, it will extract from it the remote address and data.
The data is sent back based on the remote address:
Closing the Datagram Channel When a datagram channel becomes useless, it must be closed.
Again, the Java 7 try-with-resources features can be used for automatic closing.
Putting All Together into the Server Now we have everything we need for creating our server.
Putting all of the previous information together will provide us the following server:
After creating a new DatagramChannel in the same manner as shown previously, and setting whatever options you need, you can start sending and receiving data packets.
Moreover, if this channel’s socket is not bound, keep in mind that if the server side is automatically bound (not explicitly), then the client should be aware of the chosen address (or more precisely, of the chosen IP address and port)
The opposite is also true if the server sends the first data packet.
First, start the server and wait until you see the following message:
Caution    Don’t forget to manually stop the UDP server after finishing tests!
Writing a Connected UDP Client connected-client scenario, the channel’s socket is configured so that it only receives/sends datagrams from/to the given remote peer address.
After the connection is established, data packets may not be received/sent from/to any other address.
A datagram-oriented socket remains connected until it is explicitly disconnected or until it is closed.
There is no need here for a will not affect read/write operations that are already in progress at the moment that it is invoked.
If this channel’s socket is not bound, then this method will first cause the socket to be bound to an address that.
The following application is a UDP connected client for our UDP echo server.
Reading sequence of bytes from this channel into the given buffer.
These methods return the number of bytes read (it can be zero) or –1 if the channel has reached the end of the stream:
Writing a sequence of bytes to this channel from the given buffer.
These methods return the number of bytes written; it can be zero:
First, start the server and wait until you see this message:
Multicasting You are probably already familiar with the term multicasting.
But, if you are not, let’s have a short overview of this concept.
Without academic descriptions and definitions, think of multicasting as the Internet’s version of broadcasting.
For example, a television station broadcasts its signal from one source, but the signal can reach everyone that lives in the signal area—only the ones that do not have the right equipment or refuse to catch the signal will fail to receive the transmission.
In the computer world, the TV station can be translated to a main node, or machine, that spreads datagrams to a group of destination hosts.
This is possible thanks to the multicast transport service, which sends datagrams from a source to multiple receivers in a single call—this opposed to the unicast transport service, which is specific to high-level network protocols that are based on point-to-point connections and requires a replicated unicast for sending the same data to multiple points (actually, it sends a copy of the data to each point)
Multicasting introduces the notion of a group for representing the receivers of the datagrams.
When a new receiver (client) wants to join a multicast group, it needs to connect to the group through the corresponding IP address and listen for the incoming datagrams.
Many real-life cases can be programmed based on multicasting, such as online conferencing, news distribution, advertising, e-mail groups, and data-sharing management.
MulticastChannel Overview NIO.2 comes with a new interface for mapping a network channel that supports IP multicasting.
At the API level, this is a subinterface of the NetworkChannel interface presented earlier in this chapter, and it is implemented by a single class: the DatagramChannel class.
We need to pass the IP address of the group and the network interface on which to join the group (you will see shortly how to check if your machine has a network interface capable of multicasting)
If the indicated group is successfully joined, this method returns a MembershipKey instance.
This is new in NIO.2, and it is a token representing the membership of an IP multicast group (see the next section)
Membership is cumulative, which means that this method may be invoked again with the same group and interface for receiving datagrams sent by other source addresses to the group.
Note A multicast channel may join several multicast groups, including the same group on more than one interface.
MembershipKey Overview When you join a multicast group, you get a membership key that can be used to perform different kinds of actions inside that group.
Block/unblock: You can block the sent datagrams from a specific source by calling.
Get group: You can get the source address of the multicast group for which this method returns an InetAddress object.
Get channel: You can get the channel for which this membership key was created MulticastChannel object.
Get source address: If the membership key is source specific (receives only datagrams from a specific source address), you can get the source address by InetAddress object.
Get network interface: You can get the network interface for which this method.
Drop: You can drop membership (the channel will no longer receive any.
A membership key is valid when you create it and remains valid until the membership is dropped by.
NetworkInterface Overview The NetworkInterface class represents a network interface, which is made up of a name and a list of IP addresses assigned to this interface.
It is used to identify the local interface to which a multicast group is joined.
For example, the following code will return information about all the network interfaces found on your machine:
This application will return all the network interfaces found on your machine, and for each one will render its display name (a human-readable String describing the network device) and name (the real name used to identify a network interface)
Moreover, each network interface is checked to see if it supports multicast, if it is virtual (a subinterface), and if it is up and running.
Figure 8-4 shows a fragment of output on my machine.
Writing a UDP Multicast Server In this section, we will write a UDP multicast server that sends to the group datagrams containing the current date and time on the server.
Now that we have some experience with writing UDP client/server applications, there is no need to repeat the entire process step by step.
We’ll just point out the main differences that transform a usual UDP client/server application into a UDP multicast client/server application.
The first one will indicate the network interface for IP multicast datagrams used in this case, and the second one should be enabled prior to binding the socket—this is required to allow multiple members of the group to bind to the same address:
Writing a UDP Multicast Client The code for a UDP multicast client is almost the same as for a server, with a few differences.
First, you may want to check if the remote address is actually a multicast address—this is possible by calling the adapted only for receiving datagrams from the UDP multicast server.
Blocking and Unblocking Datagrams Sometimes joining multicast groups can bring to you undesired datagrams (the reasons are not relevant and passing to it the InetAddress of that sender.
In addition, you can unblock the same sender, and start same InetAddress.
Usually, you’ll be in one of the following two scenarios:
You have a list of senders’ addresses that you’d like to join.
Supposing that the addresses are stored in a List, you can loop it and join each address separately, as shown here:
You have a list of senders’ addresses that you don’t want to join.
Supposing that the addresses are stored in a List, then you can loop it and block each address separately, as shown here:
First, start the multicast server and wait until you see this message:
Here is some example output for the UDP multicast server:
Here is the UDP client output (the client is started after a few minutes):
Performing some tests on this example will reveal some issues.
When the server is started, it sends datagrams without being aware of whether any client is listening for those datagrams.
Also, it is not aware of when clients join or leave the group.
On the opposite side, the client starts receiving datagrams when it joins the group, but is not aware of whether the server stops sending because of any causes.
If the server goes offline, the client is still waiting, and it will receive again when the server is online again and begins sending.
It can be an interesting exercise to try solving these issues if your case requires more control.
Also, you may want to experiment with threads, blocking /non-blocking modes, and connectionless/connected features to add more flexibly and performance to your multicasting applications.
Summary This chapter covered the NIO.2 features for creating TCP/UDP client/server applications.
As discussed, NIO.2 has improved this support by updating existing classes with new methods and adding new interfaces/classes for writing such applications.
The chapter began with the NetworkChannel interface, which provides methods commons to all network channel classes.
It also covered the main classes dedicated to synchronous socket channels: ServerSocketChannel, SocketChannel, and DatagramChannel.
It also discussed the MulticastChannel interface—a subinterface of NetworkChannel that maps a network channel that supports IP multicasting.
Finally, you saw how to write a single-thread blocking/non-blocking TCP client/server application, a single-thread blocking UDP client/server application, and a single-thread multicast UDP client/server application.
We’ve finally reached the most powerful feature introduced in NIO.2, the asynchronous channel API.
As you’ll see in this chapter, the asynchronous I/O (AIO) Java 7 journey starts in the java.nio.channels.AsynchronousChannel interface, which extends a channel with asynchronous I/O operations support.
This interface is implemented by three classes: AsynchronousFileChannel, AsynchronousSocketChannel, and AsynchronousServerSocketChannel.
These classes are similar in style to the NIO.2 channel APIs.
In addition, there is an asynchronous channel named AsynchronousByteChannel that can read and write bytes and stands up as a subinterface of AsynchronousChannel (this subinterface is implemented by the AsynchronousSocketChannel class)
Moreover, the new API introduces a class named AsynchronousChannelGroup, which presents the concept of an asynchronous channel group, in which each asynchronous channel belongs to a channel group (the default one or a specified one) that shares a pool of Java threads.
These threads receive instructions to perform I/O events and they dispatch the results to the completion handlers.
All the effort is for the purpose of handling the completion of initiated asynchronous I/O operations.
In this chapter, you will see the asynchronous mechanism from the Java perspective.
You will see the big picture of how Java implements asynchronous I/O, after which you will develop related applications for files and sockets.
We will start with asynchronous I/O for files by exploring the AsynchronousFileChannel class and continue with asynchronous I/O for TCP sockets and UDP sockets.
But, before we jump into the features of the API, a short overview of the difference between synchronous I/O and asynchronous I/O is in order.
Asynchronous I/O The difference between synchronous and asynchronous execution may seem a bit confusing at first, so let’s clear it up.
Basically, there are two types of input/output (I/O) synchronization: synchronous I/O and asynchronous I/O (also referred to as overlapped I/O)
In a synchronous I/O operation, a thread enters into action and waits until the I/O request is completed (the program is “stuck” waiting for the process to end, with no way out)
When the same action occurs in an asynchronous environment, a thread performs the I/O operation with more kernel help.
Actually, it immediately passes the request to the kernel and continues on to process another job.
The kernel signals to the thread when the operation has completed, and the thread “respects” the signal by interrupting its current job and processing the data from the I/O operation as necessary.
In the Java spirit of platform independence, asynchronous I/O can be tied to multiple threads—basically, allowing something to be processed on a separate thread.
You can use synchronous I/O if you simply want to make a request and receive a response.
Synchronous I/O limits performance and scalability since it is one thread per I/O connection, and running thousands of threads significantly increases overhead on the operating system.
Asynchronous I/O is a different programming model, because you don’t necessarily wait for a response, but rather submit your work for execution and then come back for a response either almost immediately or sometime later.
Therefore, asynchronous I/O seems to be better than synchronous I/O, since performance and scalability are keywords of the I/O system.
Various important operating systems, such as Windows and Linux, support fast, scalable I/O based on the use of asynchronous notifications of I/O operations taking place in the OS layers.
In summary, I/O processing that is expected to take a large amount of time can be optimized by using asynchronous I/O.
For relatively fast I/O operations, synchronous I/O would be better because the overhead of processing kernel I/O requests and kernel signals may make asynchronous I/O less beneficial.
Asynchronous I/O Big Picture When talking about asynchronous I/O in Java, we are talking about the asynchronous channels.
An asynchronous channel is a connection that supports multiple I/O operations in parallel through separate threads (connecting, reading, and writing, for example) and provides mechanisms for controlling the operations after they’ve been initiated.
This section discusses a few important aspects that are common to all asynchronous channels.
Foremost, note that all asynchronous channels initiate I/O operations (does not block the application to perform other tasks) and provide notifications when I/O completes.
This rule is the foundation of asynchronous channels, and from it derives the entire asynchronous channel API.
To begin our discussion of the asynchronous I/O big picture, we’ll look at forms.
Pending Result and the Future Class The first form returns a java.util.concurrent.Future<V> object and represents the pending result of an asynchronous I/O operation.
Through Future’s methods we can check if the operation is complete, wait for its completion (if it’s not already complete), and retrieve the result of the operation.
This attempt will fail if the task has already completed, has already been canceled, or could not be canceled for some other reason.
Caution    When canceling an asynchronous I/O operation, all threads waiting on the result will throw CancellationException.
Also, keep in the channel—all threads waiting on the result of the I/O operation will throw CancellationException, and any other I/O operations outstanding on the channel complete with the exception AsynchronousCloseException.
Tip Make sure that the I/O buffers involved in a canceled read/write operation are not further accessed while the channel remains open.
Future.get(long timeout, TimeUnit unit) after the operation has completed, waiting if necessary until it is ready or the specified timeout has expired.
Complete Result and the CompletionHandler Interface The second form, complete result, is reminiscent of the well-known callback mechanism (such as AJAX callbacks)
We register a callback to the asynchronous I/O operation (read or write, for example), and when the operation completes or fails, a handler (CompletionHandler) is invoked to consume the result of the operation.
A completion handler is of the form CompletionHandler<V,A>, where V is the type of the result value and A is the type of object attached to the I/O operation.
A handler should override two methods: the method, which is invoked if the I/O operation fails.
If the operation completes successfully, then the parameter representing an object that is passed in to the asynchronous operation.
It can be used to track which operation finished first if the same CompletionHandler object is used for multiple operations, but, of course, you may find it useful in other situations.
Types of Asynchronous Channels As of this writing, Java 7 comes with the following three types of asynchronous channels.
AsynchronousFileChannel As its name suggests, the AsynchronousFileChannel class represents an asynchronous channel for reading, writing, and manipulating a file.
This class provides methods for reading and writing a file based on ByteBuffers.
In addition, it provides methods for locking files, truncating files, and getting file sizes, but keep in mind that, unlike a synchronous FileChannel channel, this type of channel does not maintain a global file position (current position) or offset.
Even if no global position or offset is available, each read or write operation should specify the position in the file from which to read or write.
This allows accessing of different parts of the file concurrently.
When you work with an AsynchronousFileChannel channel, you must be careful to take into account the following aspects:
After a channel is closed, further attempts to initiate asynchronous I/O operations complete immediately with cause ClosedChannelException.
A reading attempt may cause a NonReadableChannelException exception if the channel has not been opened for reading.
A writing attempt may cause a NonWritableChannelException exception if this channel has not been opened for writing.
A locking attempt when a lock is already held by this Java virtual machine, or there is already a pending attempt to lock a region, will cause an OverlappingFileLockException exception.
AsynchronousServerSocketChannel The AsynchronousServerSocketChannel class represents an asynchronous channel for stream-oriented listening sockets.
Opening such a channel type allows us to bind it to a group that has an associated thread pool to which tasks are submitted to handle I/O operations (there is also a default group when none is specified)
After opening, the channel has the capability to accept incoming connections in an asynchronous manner, which means that we can choose between a Future and a CompletionHandler for tracking the connection status.
Important tasks such as binding and setting channel options are provided through the implemented NetworkChannel interface.
When you work with an AsynchronousServerSocketChannel channel, be careful to take into account the following:
Closing an asynchronous server socket channel by explicitly calling the inherited asynchronous operations on the channel to complete with an AsynchronousCloseException exception.
After a channel is closed, further attempts to initiate asynchronous I/O operations complete immediately with cause ClosedChannelException.
An opening attempt will cause a ShutdownChannelGroupException exception if the channel group is shut down.
If a thread initiates an accept operation before a previous accept operation has completed, then an AcceptPendingException exception will be thrown.
AsynchronousSocketChannel The AsynchronousSocketChannel class represents an asynchronous channel for stream-oriented connecting sockets.
Opening such a channel type allows us to bind it to a group that has an associated thread pool to which tasks are submitted to handle I/O operations (there is also a default group when none is specified)
After opening, the channel has the capability to connect to the remote addresses in an asynchronous manner, which means that we can choose between a Future and a CompletionHandler for tracking the connection status.
For a successful connection, this channel can read and write buffers of again, we can choose between a Future and a CompletionHandler for tracking the reading or writing status.
Important tasks such as binding and setting channel options are provided through the implemented NetworkChannel interface.
When you work with an AsynchronousSocketChannel channel, be careful to take into account the following:
Further attempts to initiate asynchronous I/O operations over a closed channel will finish immediately with a ClosedChannelException exception.
An attempt to invoke an I/O operation upon an unconnected channel will cause a NotYetConnectedException exception to be thrown.
If a thread initiates a read operation before a previous read operation has completed, then a ReadPendingException exception will be thrown.
If a thread initiates a write operation before a previous write operation has completed, then a WritePendingException exception will be thrown.
An attempt to connect to a channel may cause an AlreadyConnectedException exception if this channel is already connected.
An attempt to connect to a channel may cause a ConnectionPendingException exception if a connection operation is already in progress on this channel.
If the timeout elapses before an operation completes, then an InterruptedByTimeoutException exception will complete the operation.
A timeout may leave the channel, or the underlying connection, in an inconsistent state.
If the implementation cannot guarantee that bytes have not been read from or written to the channel, then it puts the channel into an implementation-specific error state.
A subsequent attempt to initiate a read or write operation causes an unspecified runtime exception to be thrown.
Groups As mentioned in the introduction to the chapter, the asynchronous API introduces a class named AsynchronousChannelGroup, which presents the concept of an asynchronous channel group, in which each asynchronous channel belongs to a channel group (the default one or a specified one) that shares a pool of Java threads.
These threads receive instructions to perform I/O events and they dispatch the results to the completion handlers.
The asynchronous channel group encapsulates thread pool and the resources shared by all the threads working for the channels.
Also, the channel is in effect owned by the group, so if the group is closed, the channel is closed too.
Asynchronous channels are safe for use by multiple concurrent threads.
Some channel implementations may support concurrent reading and writing but may not allow more than one read and one write operation to be outstanding at any given time.
Default Group Besides the developer’s created groups, JVM maintains a system-wide default group that is constructed automatically, useful for simple applications.
When a group is not specified, or a null is passed instead, the asynchronous channels are bound, at construction time, to the default group.
The default group may be configured by means of two system properties, the first of which follows:
Following is the description of this property from the official Java Platform SE 7 documentation for the AsynchronousChannelGroup class:
The value of this property is taken to be the fully-qualified name of a concrete ThreadFactory class.
The class is loaded using the system class loader and instantiated.
The factory’s newThread method is invoked to create each thread for the default group’s thread pool.
If the process to load and instantiate the value of the property fails then an unspecified error is thrown during the construction of the default group.
To paraphrase, this system property defines a java.util.concurrent.ThreadFactory to use instead of the default one.
The value of the initialSize parameter for the default group.
The value of the property is taken to be the String representation of an Integer that is the initial size parameter.
If the value cannot be parsed as an Integer it causes an unspecified error to be thrown during the construction of the default group.
In short, this system property specifies the thread pool’s initial size.
Custom Groups If the default group does not satisfy your needs, the AsynchronousChannelGroup class provides three methods for creating your own channel groups.
For AsynchronousServerSocketChannel, AsynchronousSocketChannel, and AsynchronousDatagramChannel (unavailable as of this writing), the ExecutorService instead of an AsynchronousChannelGroup.
Now, let’s see what the advantages and disadvantages of each supported thread pool are; these characteristics will help you to decide which one is proper in your case.
You can request a fixed thread pool by calling the following AsynchronousChannelGroup method:
This method creates a channel group with a fixed thread pool.
You must specify the factory to use when creating new threads and the number of threads.
Caution    The life cycle in a fixed thread pool follows a simple scenario: a thread waits for an I/O event, completes I/O for the event, invokes a completion handler, and goes back to wait for more I/O events (the kernel dispatches events directly to these threads)
When the completion handler terminates normally, the thread returns to the thread pool and waits for the next event.
But if the completion handler does not complete in a timely manner, then it is possible to enter into an indefinitely blocking.
If all threads “deadlock” inside a completion handler, then the application is blocked until a thread is available to execute again, and any new event will be queued until a thread is available.
In the worst-case scenario, no thread can get free and the kernel can no longer execute anything.
This issue may be avoided if you don’t use blocking or long operations inside a completion handler.
Also, you may use a cached thread pool or timeouts for avoiding this issue.
You can request a cached thread pool by calling the following AsynchronousChannelGroup method:
This method creates an asynchronous channel group with a given thread pool that creates new threads as needed.
You just need to specify the initial number of threads and an ExecutorService that creates new threads as needed.
It may reuse previously constructed threads when they are available.
In this case the asynchronous channel group will submit events to the thread pool that simply invoke completion handlers.
But if the thread pool simply invokes the completion handlers, then who does the hard work and performs the I/O operations? The answer is the hidden thread pool.
This is a set of separate threads that waits for incoming I/O events.
More precisely, the kernel I/O operations are handled by one or more invisible internal threads that dispatch events to a cached pool, which in turn invokes completion handlers.
The hidden thread pool is important because it greatly reduces the probability that the application will be blocked (it solves the fixed thread pool issue) and guarantees that the kernel will be able to complete its I/O operations.
But we still have an issue, because the cached thread pool needs unbounded queuing, which can make the queue grow infinitely and cause OutOfMemoryError—so monitor the queue (avoid locking all the threads and avoid feeding the queue forever)
Avoiding the use of blocking or long operations inside completion handlers is still a good idea.
You can also request a thread pool by calling the following AsynchronousChannelGroup method:
This method creates an asynchronous channel group with a designated thread pool.
The ExecutorService executes tasks submitted to dispatch completion results for operations initiated on asynchronous channels in the group.
Using this approach requires extra care when configuring ExecutorService—do at least two things here: provide support for direct handoff or.
Further attempts to construct a channel that binds to the group will throw ShutdownChannelGroupException.
Once it is marked for shutdown, the group begins the termination process, which involves waiting for all the bound asynchronous channels to be closed (i.e., the completion handlers have run and the resources have been released)
You can check if a group has terminated by calling the completion handlers.
Keep in mind that calling this method will complete with the exception AsynchronousCloseException any outstanding asynchronous operations upon this channel.
After a channel is closed, further attempts to initiate asynchronous I/O operations complete immediately with cause ClosedChannelException.
When a ServiceExecutor is specified, it is intended to be used exclusively by the resulting asynchronous channel group.
Termination of the group results in the orderly shutdown of the executor service; if the executor service shuts down for some other reason, an unspecified behavior will occur.
Note In the case of an asynchronous channel for stream-oriented connecting sockets, there is also the further read attempts by returning the end-of-stream indicator, -1) and for writing by calling the exception)
Therefore, you must make sure that you do not access a byte buffer that is currently involved in an I/O operation.
A nice solution for avoiding this issue is to use a ByteBuffer pool.
When an I/O operation is oncoming, you get a byte buffer from the pool, perform the I/O operation, and then return the byte buffer to the pool.
Fixing this issue also fixes another issue regarding the out of memory errors.
Memory requirements for buffers depend on the number of outstanding I/O operations, but using a pool will help you to reuse a set of buffers and avoid out of memory issues.
If you are not familiar with this API, you should consult the official documentation, available at.
This API is an important component of the Java concept of concurrency and multithreading, and it is beyond our aim to present it here since it is a large and complex API.
To give you a brief introduction, the Executor Framework provides a convenient way to create custom thread pools through the java.util.concurrent.Executors class (which contains factory and utility methods for different kinds of interfaces involved in the multithreading API, such as java.util.concurrent.Executor and java.util.concurrent.ExecutorService)
Each of these methods creates a number (specified by developer or deduced by default implementation) of worker threads.
The ExecutorService interface adds life cycle methods to the do not return results, but when you expect your threads to return a computed result, you can use the java.util.concurrent.Callable interface, which makes use of generics to define the type of object accordingly—this throws an Exception if the result cannot be computed.
Developing Asynchronous Applications There are so many examples to develop and so many tests to perform to accomplish best scalability with the asynchronous channel API that an entire dedicated book would be required to cover all the details.
Since we are covering the topic in a single chapter, we will cut straight to the stub applications, which should provide you with a source of inspiration to develop others.
We start this developing spree with the asynchronous file channel for reading, writing, and manipulating a file.
You will see how to perform these I/O operations over a file based on both Future and CompletionHander forms.
We’ll then move on to the asynchronous channel for stream-oriented listening sockets and the asynchronous channel for stream-oriented connecting sockets.
Asynchronous File Channel Examples The first step of any application that involves an asynchronous file channel is to create a new will receive the path of the file to open or create and, optionally, a set of options specifying how the file is thread pool that may be shared with other channels (the default group)
File Read and Future The following code snippet creates a new asynchronous file channel for reading the file story.txt located in the C:\rafaelnadal\grandslam\RolandGaross directory (the file must exist):
Since we are interested in using the Future mode, we will use the.
This method reads a sequence of bytes from this channel into the given buffer, starting at the given file position, and returns an object representing the pending result.
Since we are in an asynchronous environment, this method just initiates the read and does not block the application.
The following code shows you how to use it to read the first 100 bytes:
Placing this call in a loop allows us to complete other tasks until the read completes:
When the read operation completes, the application flow exits the loop and the result can be is an integer representing the number of read bytes, while the bytes are in the destination buffer:
Rafa Nadal produced another masterclass of clay-court tennis to win his fifth French Open title ...
File Write and Future The following code snippet creates a new asynchronous file channel for writing more bytes into the file story.txt located in C:\rafaelnadal\grandslam\RolandGaross (the file must exist):
Since we are interesting in using the Future mode, we will use the.
This method writes a sequence of bytes to this channel from the given buffer, starting at the given file position, and returns an object representing the pending result.
Since we are in an asynchronous environment, this method just initiates the write and does not block the application.
The following code shows you how to use it to write some bytes starting from position 100:
The world No2, Novak Djokovic, dumped out here in the semi-finals by a resurgent Federer, will come hard at them again at Wimbledon but there is much to come from two rivals who, for seven years, have held all pretenders at.
As an exercise, try combining both applications into a single one for reading and writing asynchronously.
This method also has a timeout version, in which we can specify precisely how long this method throws a TimeoutException and we can interrupt the thread to finish this task by calling the very short timeout:
First, if the time expires and the I/O operation does not complete, the output will be as follows:
If the I/O operation completes before the time expires, the output will be as follows:
File Read and CompletionHandler Now that you’ve seen a few examples of how the Future form works, it’s time to see how a CompletionHandler can be written to read the story.txt content.
This method reads a sequence of bytes from this channel into the given buffer, starting at the given file position.
Besides the destination buffer and the file position, this method gets the object to attach to the I/O operation (can be null) and the completion handler for consuming the result.
Since we are in an asynchronous environment, this method just initiates the read and does not block the application.
The current thread was used just to discover when we should stop the application; in some cases, the flow may end the application before the completion handler consumes the result.
In other cases, you may see the waiting message after the CompletionHandler output, depending on how fast it consumes the result of the I/O operation.
The destination ByteBuffer may “arrive” into the CompletionHandler as the object attached to the I/O operation (when you do not have any attachments, just pass null)
Rafa Nadal produced another masterclass of clay-court tennis to win his fifth French Open title ...
File Lock Sometimes you need to acquire an exclusive lock on a channel’s file before performing another I/O more details of which you can find in the official documentation at http://download.oracle.com/javase/7/docs/api/):
The file used is CopaClaro.txt, located in C:\rafaelnadal\tournaments\2009 (the file must exist)
Copa Claro is the third stop of the four-tournament Latin American swing, and is contested on clay at the Buenos Aires Lawn Tennis Club, known as the Cathedral of Argentinean tennis.
AsynchronousFileChannel and ExecutorService custom thread pool through an ExecutorService object.
In our scenario, we want to develop an application that asynchronously fills up 50 ByteBuffers with bytes from random positions of the story.txt file.
Moreover, we want to use a custom group with a fixed thread pool of five threads.
We start by creating the thread pool through an ExecutorService:
We submit each “worker” to the executor and store its Future into buffer.
Since we passed to the executor all the necessary tasks, we can shut it down so that it doesn’t accept new tasks.
It finishes all existing threads in the queue and terminates—in the meantime, we can count some sheep:
Done! Gluing everything together and adding boilerplate code and imports produces the following:
Developing an asynchronous client/server application is an interesting project for any Java developer who is focused on the networking applications field.
The easiest approach for a better understanding of how to accomplish this task is to follow a straightforward set of steps accompanied by chunks of codes that will be glued together at the end of the discussion.
We’ll start with an asynchronous server based on the Future form.
Writing an Asynchronous Server (Based on Future) We want to develop an asynchronous server that will echo to the client everything that it gets from it.
During execution, the Future mode will be responsible for tracking the status of tasks such as accepting connections, reading bytes from the client, and writing bytes to the client.
The first step involves creating an asynchronous channel for a stream-oriented listening socket, which is accomplished with java.nio.channels.AsynchronousServerSocketChannel.
More precisely, this task is asynchronous server socket channel is bound to the default group:
Keep in mind that a newly created asynchronous server socket channel is not bound to the local address.
You can check if an asynchronous server socket is already open or has been successfully opened by Boolean value:
There is no required option (you can use the default values), but we’ll explicitly set a few options to show you how this can be done.
You can find out which options are supported for an asynchronous server socket channel by calling.
Another common approach is to create an InetSocketAddress object without specifying the IP address, only the port (there is a constructor for that)
In this case, the IP address is the wildcard address, and the port number is a specified value.
The wildcard address is a special local IP address that can be used only for bind operations.
This returns null if the asynchronous server socket channel has not been bound yet.
After opening and binding, we finally reach the accepting milestone.
We signal our impatience to accept asynchronous operation to accept a connection made to this channel’s socket and returns a Future the operation completion status.
AsynchronousSocketChannel class, which represents an asynchronous channel for stream-oriented connecting sockets.
Once we have accepted a new connection, we can find out the remote address by calling the.
At this point the server and client can transmit data over a connection.
They can send and receive different kinds of data packets mapped as byte arrays.
Implementing the transmission (send/receive) is a flexible and specific process since it involves many options.
For example, for our server we’ll use ByteBuffers, keeping in mind that this is an echo server—what it reads from the client is what it writes back.
First, we wait for incoming bytes to be read (this is what the server echoes)
Second, we wait until the write operation ends, to avoid the case in which more bytes should be echoed and a thread initiates a new write operation before a previous write operation has completed, which ends with a WritePendingException exception.
Since the application is “captured” inside read/write operations with the first client, it is unprepared to accept other connections until it has completely served the current client, which means that only one client can be served at a time.
To accomplish this, you can call the connections, it will just close a channel for a client) and/or the connections; subsequent clients won’t be able to locate the server any more)
Alternatively, we can close these resources by placing the code into the Java 7 try-with-resources feature.
This is possible because the AsynchronousServerSocketChannel and AsynchronousSocketChannel classes implement the AutoCloseable interface.
Using this feature will ensure that the resources are closed automatically.
Now we have everything we need to create our echo server.
Putting together the preceding chunks of code and adding the necessary imports, spaghetti code, and so forth produces the following echo sever:
You’re likely still wondering about how to accept multiple clients.
Afterward, the worker is submitted to the executor and a new connection is prepared to be accepted.
If an unexpected error occurs, then we shut down the executor and wait to.
The following application modifies the preceding one so that it accepts multiple clients at the same time:
Writing an Asynchronous Client (Based on Future) Now let’s develop a client for our echo server.
When the number 50 is generated, the client stops sending and closes the channel.
The server will echo (write back) everything it reads from the client.
The steps for implementing the client for this scenario are discussed next.
The first step is to create an asynchronous channel for stream-oriented connecting sockets bound to the default group.
Keep in mind that a newly created asynchronous socket channel is not connected.
You can check if an asynchronous server socket is already open or has been successfully opened by calling the.
You can discover the supported options for an asynchronous server socket channel by calling the.
After opening an asynchronous socket channel (and optionally binding it), you should connect to the remote address (the server-side address)
This method initiates an operation to connect to this channel.
The connection has been established, so we can start transmitting data packets.
The operation, and return a Future<Integer> object for tracking the read/write operation status.
Calling the written and a thread initiates a new write operation before a previous write operation has completed, which ends with a WritePendingException exception.
Again, the Java 7 try-with-resources feature may be used for automatically closing.
Now we have everything we need to create our client.
Putting together the preceding code chunks and adding the necessary imports, spaghetti code, and so on will provide us the following client:
Testing the Echo Application (Based on Future) Testing the application is a simple task.
Continue by starting the client and check out the output.
Writing an Asynchronous Server (Based on CompletionHandler) Next, we want to develop the same echo asynchronous server using the CompletionHandler mode instead of the Future mode.
Actually, we will mix them together, by letting the CompletionHandler mode deal with the connection’s acceptance operation and letting the Future mode deal with read/write operations.
We open the asynchronous server socket channel, set its options, and bind it in the exact same manner as we did earlier.
Next we focus on signaling the desire to accept connections.
This method gets the object to attach to the I/O operation (which can be null) and the completion handler that is invoked when a connection is accepted (or the operation fails)
The result passed to the completion handler is the AsynchronousSocketChannel to the new connection.
We implement the CompletionHandler as an anonymous inner class and override its methods.
Now, only if the operation of accepting connections fails—we just throw an exception and get ready to accept another connection.
Finally, there is one more aspect to take care off.
Since this is an asynchronous application, the flow will “traverse” the entire application and exit so fast that not even a single connection can be established or served, which is not good, because we want the server to wait and serve clients for a long time.
Writing an Asynchronous Client (Based on CompletionHandler) The client for our server can also be implemented with a CompletionHandler for dealing with the.
This method gets the remote address to which this channel is to be connected, the object to attach to the I/O operation (can be null), and the completion handler that is invoked when the connection is successfully established or not.
We implement the CompletionHandler as an anonymous inner class and override its methods.
Now, operation of connecting fails—in this case, the channel is closed.
Testing the Echo Application (Based on CompletionHandler) Testing the application is a simple task.
Using Read/Write Operations and CompletionHandler In the previous examples, we have managed the read/write operations through the Future mode.
If you want to associate a CompletionHandler with a read/write operation, then you can use the next.
This method initiates an operation that reads a sequence of bytes from this channel into the given buffer:
This method initiates an operation that reads a sequence of bytes from this channel into the given buffer.
Analogue to these methods, but for writing operations, we have one method for asynchronous gathering write:
And we have two more methods for writing a sequence of bytes to this channel from the given buffer:
Writing an Asynchronous Client/Server Based on Custom Group The previous client/server applications were developed by using the default group.
We can specify a custom group as an AsynchronousChannelGroup object passed to the First, we create a custom group.
This example creates a cached thread pool with the initial size of one thread:
The following example creates a fixed thread pool with exactly five threads:
And, the threadGroup can be passed to the asynchronous channel for stream-oriented listening sockets—if the group is shut down and a connection is accepted, then the connection is closed, and the operation completes with an IOException exception and causes ShutdownChannelGroupException:
When a new connection is accepted, the resulting AsynchronousSocketChannel will be bound to the same AsynchronousChannelGroup as this channel.
Or the ThreadGroup can be passed to the asynchronous channel for stream-oriented connecting sockets—if the group is shut down and a connection is active, then the connection is closed, and the operation completes with an IOException exception and causes ShutdownChannelGroupException:
Now you can modify the preceding applications for using custom groups.
Tips The applications presented in this chapter are fine for educational purposes but not for a production environment.
If you need to write applications for a production environment, then it is a good idea to keep in mind the following tips.
The method is able to read from a large number of slow clients for a while, but eventually it is overwhelmed by the huge number of clients arriving.
You can avoid this by applying a trick: use a byte buffer pool and throttle read operations.
In addition, there may be a danger here of running out of memory if your byte buffer grows too large, so you must be mindful of memory consumption (perhaps adjust Java heap parameters such as Xms and Xmx)
In this scenario, you must make sure you do not lock your thread pool, especially if you are using a fixed thread pool.
You can avoid this scenario by using blocking only for short reading operations.
Focusing now on write operations, consider the scenario in which an write operation and moves on to other tasks.
But, moving on to other tasks may cause the thread to write call.
You can fix this issue by making For this, use a first-in first out queue (FIFO-Q) for the byte buffers and write only when the previous.
All read/write operations will be asynchronous and will provide support for Future and CompletionHandler modes.
This class was introduced in and then removed from earlier, unstable versions of Java 7
There is a chance it will show up in later releases, so some guidelines for its main features are presented here.
The AsynchronousDatagramChannel class represents an asynchronous channel for datagram-oriented sockets.
This channel supports asynchronous opening and read/write operations (through channels)
That means that these operations can be tracked by Future and CompletionHandler mechanisms.
On the other hand, this channel implements NetworkChannel for binding and setting/getting socket options and implements MulticastChannel for joining multicast groups.
If you work with an asynchronous datagram channel in the future, you must be careful to take into account the following aspects:
An attempt to connect a channel may cause a ClosedChannelException exception if this channel is closed.
An attempt to invoke an I/O operation upon an unconnected channel will cause a NotYetConnectedException exception to be thrown.
Closing an asynchronous datagram socket channel by explicitly calling the outstanding asynchronous operations on the channel to complete with the AsynchronousCloseException exception.
After a channel is closed, further attempts to initiate asynchronous I/O operations complete immediately with cause method is available for closing the channel.
Summary In this chapter, you learned how to work with the NIO.2 asynchronous channel API.
After a brief introduction to the differences between synchronous I/O and asynchronous I/O, you received a detailed overview of this API structure.
After that, you saw theory put into practice, starting with the java.nio.channels.AsynchronousChannel interface, which extends a channel with asynchronous I/O operations support.
The three classes that implement this interface for asynchronous operations over files and sockets were then presented: AsynchronousFileChannel, AsynchronousSocketChannel, and AsynchronousServerSocketChannel.
The currently unavailable AsynchronousDatagramChannel class was also described in this chapter, just in case it reappears in the future.
The chapter also introduced the AsynchronousChannelGroup, including the notion of the asynchronous channel group.
The chapter wrapped up with a few tips regarding developing asynchronous-based applications.
The first parts of this chapter offer some information that is good to know, or at least hear about.
This information didn’t fit neatly into any of the previous chapters, and you probably won’t use it very soon, but it may be helpful someday.
We finish this chapter (and the book also) with a set of NIO.2 milestone methods that were presented and used in the book.
Every time you need a quick reminder or overview of these methods, you can easily leaf through the last pages of the book for them.
Refactoring java.io.File Code If you have developed a few applications based on java.io.File, then you should be familiar with the most common methods of this class.
But, if you’ve developed more than a few applications based on java.io.File, then you should be familiar with not only its methods, but also its methods’ drawbacks.
For example, many of these methods don’t throw exceptions when they fail, there is no real support for symbolic links, metadata access is inefficient, file-renaming across platforms is inconsistent, some methods don’t scale, and so on—all of which should sound pretty familiar to many senior Java developers, and pretty scary for juniors.
The first milestone of refactoring java.io.File code may be considered the conversion of File.
However, while this is the easiest solution, it may not always satisfy your needs.
Tests this abstract pathname for equality with the given object.
Tests whether the file denoted by this abstract pathname is a normal file.
Tests whether the file denoted by this abstract pathname is a directory.
Tests whether the file named by this abstract pathname is a hidden file.
Tests whether the application can read the file denoted by this abstract pathname.
Tests whether the application can modify the file denoted by this abstract pathname.
Tests whether the application can execute the file denoted by this abstract pathname.
Creates the directory named by this abstract pathname, including any necessary but nonexistent parent directories.
Atomically creates a new, empty file named by this abstract pathname if and only if a file with this name does not yet exist.
Returns an array of strings naming the files and directories in the directory denoted by this abstract pathname.
Returns an array of strings naming the files and directories in the directory denoted by this abstract pathname that satisfy the specified filter.
The length of the file denoted by this abstract pathname.
Deletes the file or directory denoted by this abstract pathname.
Sets the owner or everybody’s execute permission for this abstract pathname.
Sets the owner or everybody’s read permission for this abstract pathname.
Marks the file or directory named by this abstract pathname so that only read operations are allowed.
Sets the owner or everybody’s write permission for this abstract pathname.
Returns the time that the file denoted by this abstract pathname was last modified.
Sets the last-modified time of the file or directory named by this abstract pathname.
Creates an empty file in the default temporary-file directory, using the given prefix and suffix to generate its name.
Creates a new empty file in the specified directory, using the given prefix and suffix strings to generate its name.
Returns the size of the partition named by this abstract pathname.
Returns the number of unallocated bytes in the partition named by this abstract path name.
Returns the number of bytes available to this virtual machine on the partition named by this abstract pathname.
Requests that the file or directory denoted by this abstract pathname be deleted when the virtual machine terminates.
Working with the ZIP File System Provider Conforming to NIO.2, a file system concerns the generic notion of a container that’s capable of managing and accessing the file system objects.
A file system object is typically a file store (e.g., on Windows we usually have C:, D:, and E: file stores, and we refer to them as partitions), but it can be a directory or a file as well.
The ZFSP treats a ZIP/JAR file as a file system and provides the ability to manipulate the contents of the file.
The ZFSP creates one file system for each ZIP/JAR file.
First, we create a simple HashMap that contains the configurable properties of a ZIP file system created by the ZFSP.
If the value is true, the ZFSP creates a new ZIP file if it does not exist.
Therefore, we can indicate that the ZIP file exists and the needed encoding is ISO-8859-1 like so:
For creating a new ZIP file system or obtaining a reference to an existing one, we use the factory methods of the java.nio.file.FileSystems class.
Create a ZIP file system by specifying the path of the ZIP/JAR file.
This can be accomplished by using the JAR URL syntax defined in the java.net.JarURLConnection class:
Now that we have an instance of a ZIP file system, we can invoke the methods of the java.nio.file.FileSystem and java.nio.file.Path classes to perform operations such as copying, moving, and renaming files, as well as modifying file attributes.
We want to copy the AEGONTickets.png entry out of the archive.
If everything worked fine, then you will see the following message, and the file AEGONTicketsCopy.png should exist in C:\rafaelnadal\tournaments\2009 directory.
Considerations on Developing a Custom File System Provider In the preceding section, you saw how to use a custom file system provider.
If you decide to try to write your own custom file system provider, then it is a good idea to take into account the considerations listed in this section.
For one, you must know that the main class that supports this kind of attempt is java.nio.file.spi.FileSystemProvider.
A custom file system provider will implement this class as a factory for java.nio.file.FileSystem instances.
A file system provider is identified by a URI scheme such as file, jar, memory, or cd, and a file system’s URI has a URI scheme that matches the file system provider’s URI scheme.
Therefore, implementing a custom file system provider requires writing at least two classes and keeping in mind a set of mandatory steps.
Create an internal cache for managing the provider’s created file systems.
Implement the methods of the file system according to your needs (you may need to define the number of roots, read/write access, file stores, etc.)
For more details, you may want to take a closer look at official documentation, at http://download.oracle.com/javase/7/docs/technotes/guides/io/fsp/filesystemprovider.html.
This last section covers some useful methods that are ready to help you in any NIO.2 application.
Default File System You’ve seen how to get the default file system many times in this book, but we’re putting this so you can easily access this information if you forget.
File Stores Getting the file system file stores is another well-covered subject in the book, but for a quick reminder, come here.
Path of a File Here’s how to get the path of a file:
Path String Separator As you know, a path string separator is OS dependent.
To retrieve the Path string separator for the default file system, you can use one of the following approaches:
Summary In this chapter you learned how to convert code based on the java.io.File class into code based on.
Also, you learned how to use the ZIP file system provider and some information on creating a custom file system provider.
The chapter (and the book) ends with the most used snippets of codes from the book.
All rights are reserved by the Publisher, whether the whole or part of the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microfilms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed.
Exempted from this legal reservation are brief excerpts in connection with reviews or scholarly analysis or material supplied specifically for the purpose of being entered and executed on a computer system, for exclusive use by the purchaser of the work.
Duplication of this publication or parts thereof is permitted only under the provisions of the Copyright Law of the Publisher's location, in its current version, and permission for use must always be obtained from Springer.
Permissions for use may be obtained through RightsLink at the Copyright Clearance Center.
Violations are liable to prosecution under the respective Copyright Law.
Trademarked names, logos, and images may appear in this book.
Rather than use a trademark symbol with every occurrence of a trademarked name, logo, or image we use the names, logos, and images only in an editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the trademark.
The use in this publication of trade names, trademarks, service marks, and similar terms, even if they are not identified as such, is not to be taken as an expression of opinion as to whether or not they are subject to proprietary rights.
While the advice and information in this book are believed to be true and accurate at the date of publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or omissions that may be made.
The publisher makes no warranty, express or implied, with respect to the material contained herein.
For information on translations, please e-mail rights@apress.com, or visit www.apress.com.
Apress and friends of ED books may be purchased in bulk for academic, corporate, or promotional use.
For more information, reference our Special Bulk Sales–eBook Licensing web page at www.apress.com/bulk-sales.
Any source code or other supplementary materials referenced by the author in this text is available to readers at www.apress.com.
For detailed information about how to locate your book’s source code, go to www.apress.com/sourcecode/
Deal with files and directories through the new java.nio.fileFiles API.
Use the FileVisitor API to develop recursive file operations ..........................................
Use the new SeekableByteChannel API for working with random access file .............
Work with the Zip File System and write a custom file system provider ........................
Checking for the Existence of a File or Directory .............................................................
Anghel Leonard is a senior Java developer with more than 12 years of experience in Java SE, Java EE, and related frameworks.
Currently, he is developing web applications using the latest Java technologies on the market (EJB 3.0, CDI, Spring, JSF, Struts,
In the past two years, he has focused on developing rich Internet applications for geographic information systems.
He has more than 20 years of experience working in various areas of information technology and financial services.
His professional interests are in Internet technology, service-oriented architecture, enterprise application architecture, multiplatform distributed applications, cloud, distributed caching, Java, grid, and high performance computing.
Thank you to the Apress team for trust in me to write this book and for the hard work you put in this project.
And thank you, Octavia, my dear wife, for your love, patience, and for being next to me all the time.
This book covers all the important aspects involved in developing NIO.2-based applications.
You will learn to develop NIO.2 applications, beginning with simple but essential stuff and gradually moving on to complex features such as sockets and asynchronous channels.
For the opening chapters (Chapters 1-5), it is enough to be familiar with Java syntax and to know how to open and run NetBeans projects.
For Chapters 6-10), having some knowledge about a few fundamental programming concepts such as recursion, multi-threading and concurrency, Internet protocols, and network applications is essential.
What This Book Covers This section contains a brief summary of what is covered in each chapter.
Carry out Path class operations Chapter 1: Here you meet the new API for manipulating file paths; you now use the java.nio.file.Path class to manipulate a file in any file system.
In this chapter I cover such important topics as declaring Path instances and syntactic operations.
Attributes are divided into categories, and now they cover POSIX systems as well.
This chapter shows you how to create, follow, and manipulate symbolic and hard links.
Deal with files and directories through the new java.nio.file.Files API Chapter 4: Here you learn the most common tasks that involve files/directories, such as create, read, write, update, and more.
You learn how to check file status and loop file stores, how to work with temporary files, and how to delete, copy, and move files and directories.
Chapter 5 shows you how to do all that through the brand new FileVisitor API.
You also find out how to develop a Search File tool.
I also cover watching a print tray and surveying a video camera in this chapter.
This is where you discover how flexible and versatile the new Watch Service API is.
Use the new SeekableByteChannel API for working with random access file Chapter 7: Random access file (RAF) is a powerful tool in the right hands.
This chapter introduces the new SeekableByteChannel API and provides plenty of examples that exploit its methods.
Practice, practice, practice, and go beyond being a RAF apprentice!
Develop blocking/non-blocking socket-based applications Chapter 8: Learn how to develop Java network-based applications in blocking and non-blocking styles.
I cover both TCP and UDP in detail and sprinkle important aspects of sockets programming throughout the chapter.
It was a pleasure to write, and I hope you find it as useful as I found it fun.
With the Asynchronous Channel API, you can develop asynchronous networkbased Java applications with a suite of classes and options.
Work with the Zip File System Provider and write a custom file system provider Chapter 10: This last chapter finishes the book with an example of using the new Zip File System Provider.
I address a few considerations about writing a custom file system provider as well.
Chapter 10 also contains a table with detailed conversions between java.io.File and java.nio.file.Path APIs.
