Oracle and Java are registered trademarks of Oracle and/or its affiliates.
The Specification provided herein is provided to you only under the Limited License Grant included herein as Appendix A.
It also integrates changes made to the Java programming language under maintenance since the Third Edition in 2005
Readers may send feedback about errors and ambiguities in The Java Language Specification to jls-comments_ww@oracle.com.
The origins of these features lie in Project Coin, an OpenJDK project started in 2009 with the goal of "Making things programmers do every day easier"
The project solicited proposals from the Java community for broadly useful language features that were, in comparison with "large" features like generics, relatively "small" in their specification, implementation, and testing.
Thousands of emails and six dozen proposals later, proposals were accepted from Joshua Bloch (the try-with-resources statement), Derek Foster/Bruce Chapman (improvements to literals), Neal Gafter (multi-catch and precise rethrow), Bob Lee (simplified variable arity method invocation), and Jeremy Manson (improved type inference for instance creation, a.k.a.
Over the course of the project, there were essential contributions from Mandy Chung, Jon Gibbons, Brian Goetz, David Holmes, and Dan Smith in areas ranging from library support to language specification.
Stuart Marks led a "coinification" effort to apply the features to the Oracle JDK codebase, both to validate their utility and to develop conventions for wider use.
The "diamond" syntax and precise rethrow give type inference a new visibility in the Java programming language.
To a great extent, inference is worthwhile only if it produces types no less specific than those in a manifestly-typed program prior to Java SE 7
Otherwise, new code may find inference insufficient, and migration from manifest to inferred types in existing code will be risky.
Such "quantitative language design" greatly improves confidence in the suitability and safety of the final feature.
The challenge of growing a mature language with millions of developers is partially offset by the ability of language designers to learn from developers' actual code.
The Java SE 7 platform adds features that cater for non-Java languages, effectively expanding the computational model of the platform.
Without changes, the Java programming language would be unable to access or even express some of these features.
Its static type system comes under particular stress when invoking code written in dynamically typed languages.
Consequently, method invocation in the Java programming language has been modified to support method handle invocation as defined by JSR 292, Dynamically Typed Languages on the Java Platform.
The following individuals have all provided many valuable comments which improved this specification: J.
This edition is the first to be written in the DocBook XML format.
Metadata in the XML markup forms a kind of static type system, classifying each paragraph by its role, such as a definition or an error.
Many thanks go to Robert Stayton for sharing his considerable DocBook expertise and for helping to render DocBook in the traditional look and feel of The Java Language Specification.
Generics, annotations, autoboxing and unboxing, enum types, foreach loops, variable arity methods, and static imports are all new to the language as of Autumn 2004
The Java programming language has grown a great deal in these past four years.
Unfortunately, it is unrealistic to shrink a commercially successful programming language - only to grow it more and more.
The challenge of managing this growth under the constraints of compatibility and the conflicting demands of a wide variety of uses and users is non-trivial.
I can only hope that we have met this challenge successfully with this specification; time will tell.
This specification builds on the efforts of many people, both at Sun Microsystems and outside it.
The most crucial contribution is that of the people who actually turn the specification into real software.
Chief among these are the maintainers of javac, the reference compiler for the Java programming language.
Neal's dedication and productivity can honestly be described as heroic.
We literally could not have completed the task without him.
In addition, his insight and skill made a huge contribution to the design of the new language features across the board.
No one deserves more credit for this version of the Java programming language than he - but any blame for its deficiencies should be directed at myself and the members of the many JSR Expert Groups!
Neal has gone on in search of new challenges, and has been succeeded by Peter von der Ah√©, who continues to improve and stengthen the implementation.
Before Neal's involvement, Bill Maddox was in charge of javac when the previous edition was completed, and he nursed features such as generics and asserts through their early days.
Another individual who deserves to be singled out is Joshua Bloch.
Josh participated in endless language design discussions, chaired several Expert Groups and was a key contributor to the Java platform.
It is fair to say that Josh and Neal care more about this book than I do myself! Many parts of the specification were developed by various Expert Groups in the framework of the Java Community Process.
The most pervasive set of language changes is the result of JSR 14, Adding Generics to the Java Programming Language.
In the early stages, Sven-Eric Panitz and Steve Marx were members as well.
A prolonged and arduous process of design and implementation led us to the current language extension.
Long before the JSR for generics was initiated, Martin Odersky and Philip Wadler had created an experimental language called Pizza to explore the ideas involved.
In the spring of 1998, David Stoutamire and myself began a collaboration with Martin and Philip based on those ideas, that resulted in GJ.
When the JSR 14 Expert Group was convened, GJ was chosen as the basis for extending the Java programming language.
The theoretical basis for the core of the generic type system owes a great debt to the expertise of Martin Odersky and Philip Wadler.
These were based on the work of Atsushi Igarashi and Mirko Viroli, which itself built on earlier work by Kresten Thorup and Mads Torgersen.
Wildcards were initially designed and implemented as part of a collaboration between Sun and Aarhus University.
Thanks to Ole Lehrmann-Madsen for enabling and supporting that work.
Joe Darcy and Ken Russell implemented much of the specific support for reflection of generics.
Honorable mention must go to individuals whose comments on the generics design made a significant difference.
Alan Jeffrey made crucial contributions to JSR 14 by pointing out subtle flaws in the original type system.
Bob Deen suggested the "? super T" syntax for lower bounded wildcards.
Enums and the foreach loop were primarily designed by Josh Bloch and Neal Gafter.
Variable arity methods would never have made it into the Java programming language without Neal's special efforts designing them (not to mention the small matter of implementing them)
Josh Bloch bravely took upon himself the responsibility for JSR 175, which added annotations to the Java programming language.
Neal Gafter, as usual, was a major contributor on this front as well.
Another change in this edition is a complete revision of the Java memory model, undertaken by JSR 133
The Java memory model chapter in this book is in fact almost entirely their work, with only editorial revisions.
Key sections dealing with finalization in Chapter 12 owe much to this work as well, and especially to Doug Lea.
I'd like to express my gratitude to Archibald Putt, who provided insight and encouragement.
Thanks once again to Joe Darcy for introducing us, as well as for many useful comments, and his specific contributions on numerical issues and the design of hexadecimal literals.
Special thanks to Laurie Tolson, my manager, for her support throughout the long process of deriving these specifications.
The following individuals all provided many valuable comments that have contributed to this specification: Scott Annanian, Martin Bravenboer, Bruce.
Ann Sellers, Greg Doench, and John Fuller at Addison-Wesley were exceedingly patient and ensured that the book materialized, despite the many missed deadlines for this text.
As always, I thank my wife Weihong and my son Teva for their support and cooperation.
This success has brought a challenge: along with explosive growth in popularity, there has been explosive growth in the demands made on the language and its libraries.
To meet this challenge, the language has grown as well (fortunately, not explosively) and so have the libraries.
It integrates all the changes made to the Java programming language since the publication of the First Edition in 1996
In addition, this edition incorporates important clarifications and amendments involving method lookup and binary compatibility.
The Java programming language is likely to continue to evolve.
At this writing, there are ongoing initiatives through the Java Community Process to extend the language with generic types and assertions, refine the memory model, etc.
However, it would be inappropriate to delay the publication of the Second Edition until these efforts are concluded.
The specifications of the libraries are now far too large to fit into this volume, and they continue to evolve.
The library specifications can be found on the Web; this specification now concentrates solely on the Java programming language proper.
Tim Lindholm brought extraordinary dedication to his role as technical editor of the Java Series.
He also made invaluable technical contributions, especially on floating-point issues.
The book would likely not see the light of day without him.
Lisa Friendly, the Series editor, provided encouragement and advice for which I am very thankful.
David Bowen first suggested that I get involved in the specifications of the Java platform.
I am grateful to him for introducing me to this uncommonly rich area.
John Rose, the father of nested types in the Java programming language, has been unfailingly gracious and supportive of my attempts to specify them accurately.
Special thanks go to Roly Perera at Ergnosis and to Leonid Arbouzov and his colleagues on.
Their thorough reading of earlier drafts has greatly improved the accuracy of this specification.
They all worked hard to make sure the reference implementation conformed to the specification.
Tricia Jordan, my manager, has been a model of patience, consideration and understanding.
Thanks are also due to Larry Abrahams, director of Java 2 Standard Edition, for supporting this work.
Suzette Pelouch provided invaluable assistance with the index and, together with Doug Kramer and Atul Dambalkar, assisted with FrameMaker expertise; Mike Hendrickson and Julie Dinicola at Addison-Wesley were gracious, helpful and ultimately made this book a reality.
On a personal note, I thank my wife Weihong for her love and support.
Finally, I'd like to thank my coauthors, James Gosling, Bill Joy, and Guy Steele for inviting me to participate in this work.
After several years of experience with the language, and significant contributions by Ed Frank, Patrick Naughton, Jonathan Payne, and Chris Warth it was retargeted to the Internet, renamed, and substantially revised to be the language specified here.
The Java programming language is a general-purpose concurrent class-based object-oriented programming language, specifically designed to have as few implementation dependencies as possible.
It allows application developers to write a program once and then be able to run it everywhere on the Internet.
This book attempts a complete specification of the syntax and semantics of the language.
We intend that the behavior of every language construct is specified here, so that all implementations will accept the same programs.
Except for timing dependencies or other non-determinisms and given sufficient time and sufficient memory space, a program written in the Java programming language should compute the same result on all machines and in all implementations.
We believe that the Java programming language is a mature language, ready for widespread use.
Nevertheless, we expect some evolution of the language in the years to come.
We intend to manage this evolution in a way that is completely compatible with existing applications.
To do this, we intend to make relatively few new versions of the language.
Compilers and systems will be able to support the several versions simultaneously, with complete compatibility.
Much research and experimentation with the Java platform is already underway.
We encourage this work, and will continue to cooperate with external groups to explore improvements to the language and platform.
For example, we have already received several interesting proposals for parameterized types.
In technically difficult areas, near the state of the art, this kind of research collaboration is essential.
We acknowledge and thank the many people who have contributed to this book through their excellent feedback, assistance and encouragement:
We apologize if we have omitted anyone.) The feedback from all these reviewers was invaluable to us in improving the definition of the language as well as the form of the presentation in this book.
Any remaining errors in this book - we hope they are few - are our responsibility and not theirs.
We thank Francesca Freedman and Doug Kramer for assistance with matters of typography and layout.
We thank Dan Mills of Adobe Systems Incorporated for assistance in exploring possible choices of typefaces.
Many of our colleagues at Sun Microsystems have helped us in one way or another.
Lisa Friendly, our series editor, managed our relationship with Addison-Wesley.
Susan Stambaugh managed the distribution of many hundreds of copies of drafts to reviewers.
We are thankful for the tools and services we had at our disposal in writing this book: telephones, overnight delivery, desktop workstations, laser printers, photocopiers, text formatting and page layout software, fonts, electronic mail, the World Wide Web, and, of course, the Internet.
Kudos to the thousands of people who have worked over the years to make these excellent tools and services work quickly and reliably.
Mike Hendrickson, Katie Duffy, Simone Payment, and Rosa Aim√©e Gonz√°lez of Addison-Wesley were very helpful, encouraging, and patient during the long process of bringing this book to print.
Rosemary Simpson worked hard, on a very tight schedule, to create the index.
We got into the act at the last minute, however; blame us and not her for any jokes you may find hidden therein.
Finally, we are grateful to our families and friends for their love and support during this last, crazy, year.
In their book The C Programming Language, Brian Kernighan and Dennis Ritchie said that they felt that the C language "wears well as one's experience with it grows." If you like C, we think you will like the Java programming language.
It is designed to be simple enough that many programmers can achieve fluency in the language.
It is intended to be a production language, not a research language, and so, as C.
Hoare suggested in his classic paper on language design, the design has avoided including new and untested features.
This specification clearly distinguishes between the compile-time errors that can and must be detected at compile time, and those that occur at run time.
Compile time normally consists of translating programs into a machine-independent byte code representation.
Run-time activities include loading and linking of the classes needed to execute a program, optional machine code generation and dynamic optimization of the program, and actual program execution.
The Java programming language is a relatively high-level language, in that details of the machine representation are not available through the language.
It includes automatic storage management, typically using a garbage collector, to avoid the safety problems of explicit deallocation (as in C's free or C++'s delete)
High-performance garbage-collected implementations can have bounded pauses to support systems programming and real-time applications.
The language does not include any unsafe constructs, such as array accesses without index checking, since such unsafe constructs would cause a program to behave in an unspecified way.
The Java programming language is normally compiled to the bytecoded instruction set and binary format defined in The Java Virtual Machine Specification, Java SE 7 Edition.
Chapter 2 describes grammars and the notation used to present the lexical and syntactic grammars for the language.
It supports the writing of Unicode characters on systems that support only ASCII.
The primitive types are defined to be the same on all machines and in all implementations, and are various sizes of two's-complement integers, single- and double-precision IEEE 754 standard floating-point numbers, a boolean type, and a Unicode character char type.
Reference types are the class types, the interface types, and the array types.
The reference types are implemented by dynamically created objects that are either instances of classes or arrays.
All objects (including arrays) support the methods of the class Object, which is the (single) root of the class hierarchy.
In many cases, wrapping and unwrapping is performed automatically by the compiler (in which case, wrapping is called boxing, and unwrapping is called unboxing)
Class and interface declarations may be generic, that is, they may be parameterized by other reference types.
Such declarations may then be invoked with specific type arguments.
A variable of a primitive type holds a value of that exact primitive type.
A variable of a class type can hold a null reference or a reference to an object whose type is that class type or any subclass of that class type.
A variable of an interface type can hold a null reference or a reference to an instance of any class that implements the interface.
A variable of an array type can hold a null reference or a reference to an array.
A variable of class type Object can hold a null reference or a reference to any object, whether class instance or array.
Conversions change the compile-time type and, sometimes, the value of an expression.
These conversions include the boxing and unboxing conversions between primitive types and reference types.
Numeric promotions are used to convert the operands of a numeric operator to a common type where an operation can be performed.
Chapter 6 describes declarations and names, and how to determine what names mean (denote)
The language does not require types or their members to be declared before they are used.
Declaration order is significant only for local variables, local classes, and the order of initializers of fields in a class or interface.
The Java programming language provides control over the scope of names and supports limitations on external access to members of packages, classes, and interfaces.
This helps in writing large programs by distinguishing the implementation of a type from its users and those who extend it.
Recommended naming conventions that make for more readable programs are described here.
Chapter 7 describes the structure of a program, which is organized into packages similar to the modules of Modula.
The members of a package are classes, interfaces, and subpackages.
Compilation units contain type declarations and can import types from other packages to give them short names.
Packages have names in a hierarchical name space, and the Internet domain name system can usually be used to form unique package names.
The members of classes are classes, interfaces, fields (variables) and methods.
Instance variables are dynamically created in objects that are instances of classes.
Instance methods are invoked on instances of classes; such instances become the current object this during their execution, supporting the object-oriented programming style.
Classes support single implementation inheritance, in which the implementation of each class is derived from that of a single superclass, and ultimately from the class Object.
Variables of a class type can reference an instance of that class or of any subclass of that class, allowing new types to be used with existing methods, polymorphically.
Methods declare the checked exceptions that can arise from their execution, which allows compile-time checking to ensure that exceptional conditions are handled.
Objects can declare a finalize method that will be invoked before the objects are discarded by the garbage collector, allowing the objects to clean up their state.
For simplicity, the language has neither declaration "headers" separate from the implementation of a class nor separate type and class hierarchies.
A special form of classes, enums, support the definition of small sets of values and their manipulation in a type safe manner.
Unlike enumerations in other languages, enums are objects and may have their own methods.
Chapter 9 describes interface types, which declare a set of abstract methods, member types, and constants.
Classes that are otherwise unrelated can implement the same interface type.
A variable of an interface type can contain a reference to any object that implements the interface.
Such annotations are not permitted to affect the semantics of programs in the Java programming language in any way.
Arrays are dynamically created objects and may be assigned to variables of type Object.
The language supports arrays of arrays, rather than multidimensional arrays.
Chapter 11 describes exceptions, which are nonresuming and fully integrated with the language semantics and concurrency mechanisms.
There are three kinds of exceptions: checked exceptions, run-time exceptions, and errors.
The compiler ensures that checked exceptions are properly handled by requiring that a method or constructor can result in a checked exception only if the method or constructor declares it.
This provides compile-time checking that exception handlers exist, and aids programming in the large.
Invalid operations in the program detected by the Java Virtual Machine result in run-time exceptions, such as NullPointerException.
Errors result from failures detected by the Java Virtual Machine, such as OutOfMemoryError.
Chapter 12 describes activities that occur during execution of a program.
A program is normally stored as binary files representing compiled classes and interfaces.
These binary files can be loaded into a Java Virtual Machine, linked to other classes and interfaces, and initialized.
After initialization, class methods and class variables may be used.
Some classes may be instantiated to create new objects of the class type.
Objects that are class instances also contain an instance of each superclass of the class, and object creation involves recursive creation of these superclass instances.
When an object is no longer referenced, it may be reclaimed by the garbage collector.
If an object declares a finalizer, the finalizer is executed before the object.
When a class is no longer needed, it may be unloaded.
Chapter 13 describes binary compatibility, specifying the impact of changes to types on other types that use the changed types but have not been recompiled.
These considerations are of interest to developers of types that are to be widely distributed, in a continuing series of versions, often through the Internet.
Good program development environments automatically recompile dependent code whenever a type is changed, so most programmers need not be concerned about these details.
The language has no goto statement, but includes labeled break and continue statements.
Unlike C, the Java programming language requires boolean (or Boolean) expressions in control-flow statements, and does not convert types to boolean implicitly (except through unboxing), in the hope of catching more errors at compile time.
A try statement can include catch and finally clauses to protect against non-local control transfers.
This document fully specifies the (apparent) order of evaluation of expressions, for increased determinism and portability.
Overloaded methods and constructors are resolved at compile time by picking the most specific method or constructor from those which are applicable.
Chapter 16 describes the precise way in which the language ensures that local variables are definitely set before use.
While all other variables are automatically initialized to a default value, the Java programming language does not automatically initialize local variables in order to avoid masking programming errors.
Chapter 17 describes the semantics of threads and locks, which are based on the monitor-based concurrency originally introduced with the Mesa programming language.
The Java programming language specifies a memory model for sharedmemory multiprocessors that supports high-performance implementations.
Most of the example programs given in the text are ready to be executed and are similar in form to:
On a machine with the Oracle JDK installed, this class, stored in the file Test.java, can be compiled and executed by giving the commands:
Throughout this specification we refer to classes and interfaces drawn from the Java SE platform API.
Whenever we refer to a class or interface (other than those declared in an example) using a single identifier N, the intended reference is to the class or interface named N in the package java.lang.
We use the canonical name (¬ß6.7) for classes or interfaces from packages other than java.lang.
Non-normative information, designed to clarify the specification, is given in smaller, indented text.
As noted above, this specification often refers to classes of the Java SE platform API.
In particular, some classes have a special relationship with the Java programming language.
Examples include classes such as Object, Class, ClassLoader, String, Thread, and the classes and interfaces in package java.lang.reflect, among others.
This specification constrains the behavior of such classes and interfaces, but does not provide a complete specification for them.
The reader is referred to the Java SE platform API documentation.
Consequently, this specification does not describe reflection in any detail.
Many linguistic constructs have analogs in the reflection API, but these are generally.
For example, when we list the ways in which an object can be created, we generally do not include the ways in which the reflection API can accomplish this.
Readers should be aware of these additional mechanisms even though they are not mentioned in the text.
Each production has an abstract symbol called a nonterminal as its left-hand side, and a sequence of one or more nonterminal and terminal symbols as its right-hand side.
For each grammar, the terminal symbols are drawn from a specified alphabet.
Starting from a sentence consisting of a single distinguished nonterminal, called the goal symbol, a given context-free grammar specifies a language, namely, the set of possible sequences of terminal symbols that can result from repeatedly replacing any nonterminal in the sequence with a right-hand side of a production for which the nonterminal is the left-hand side.
A lexical grammar for the Java programming language is given in ¬ß3
This grammar has as its terminal symbols the characters of the Unicode character set.
This grammar has tokens defined by the lexical grammar as its terminal symbols.
It defines a set of productions, starting from the goal symbol CompilationUnit (¬ß7.3), that describe how sequences of tokens can form syntactically correct programs.
Chapter 18 also gives a syntactic grammar for the Java programming language, better suited to implementation than exposition.
Terminal symbols are shown in fixed width font in the productions of the lexical and syntactic grammars, and throughout this specification whenever the text is directly referring to such a terminal symbol.
These are to appear in a program exactly as written.
The definition of a nonterminal is introduced by the name of the nonterminal being defined followed by a colon.
One or more alternative right-hand sides for the nonterminal then follow on succeeding lines.
This definition of ArgumentList is recursive, that is to say, it is defined in terms of itself.
The result is that an ArgumentList may contain any positive number of arguments.
The subscripted suffix "opt", which may appear after a terminal or nonterminal, indicates an optional symbol.
The alternative containing the optional symbol actually specifies two right-hand sides, one that omits the optional element and one that includes it.
BasicForStatement: for ( ; ; ForUpdateopt ) Statement for ( ; Expression ; ForUpdateopt ) Statement for ( ForInit ; ; ForUpdateopt ) Statement for ( ForInit ; Expression ; ForUpdateopt ) Statement.
BasicForStatement: for ( ; ; ) Statement for ( ; ; ForUpdate ) Statement for ( ; Expression ; ) Statement for ( ; Expression ; ForUpdate ) Statement for ( ForInit ; ; ) Statement for ( ForInit ; ; ForUpdate ) Statement for ( ForInit ; Expression ; ) Statement for ( ForInit ; Expression ; ForUpdate ) Statement.
A very long right-hand side may be continued on a second line by substantially indenting this second line.
When the words "one of" follow the colon in a grammar definition, they signify that each of the terminal symbols on the following line or lines is an alternative definition.
When an alternative in a lexical production appears to be a token, it represents the sequence of characters that would make up such a token.
The right-hand side of a lexical production may specify that certain expansions are not permitted by using the phrase "but not" and then indicating the expansions to be excluded.
Finally, a few nonterminal symbols are described by a descriptive phrase in roman type in cases where it would be impractical to list all the alternatives.
Line terminators are defined (¬ß3.4) to support the different conventions of existing host systems while maintaining consistent line numbers.
Information about this character set and its associated character encodings may be found at http:// www.unicode.org/
The Java SE platform tracks the Unicode specification as it evolves.
The precise version of Unicode used by a given release is specified in the documentation of the class Character.
The Unicode standard was originally designed as a fixed-width 16-bit character encoding.
It has since been changed to allow for characters whose representation requires more than 16 bits.
Some APIs of the Java SE platform, primarily in the Character class, use 32-bit integers to represent code points as individual entities.
This specification uses the terms code point and UTF-16 code unit where the representation is relevant, and the generic term character where the representation is irrelevant to the discussion.
A raw Unicode character stream is translated into a sequence of tokens, using the following three lexical translation steps, which are applied in turn:
This translation step allows any program to be expressed using only ASCII characters.
The longest possible translation is used at each step, even if the result does not ultimately make a correct program while another lexical translation would.
Thus, the input characters a--b are tokenized (¬ß3.5) as a, --, b, which is not part of any grammatically correct program, even though the tokenization a, -, -, b could be part of a grammatically correct program.
This translation step results in a sequence of Unicode input characters.
The \, u, and hexadecimal digits here are all ASCII characters.
If an eligible \ is not followed by u, then it is treated as a RawInputCharacter and remains part of the escaped Unicode stream.
If an eligible \ is followed by u, or more than one u, and the last u is not followed by four hexadecimal digits, then a compile-time error occurs.
The character produced by a Unicode escape does not participate in further Unicode escapes.
The Java programming language specifies a standard way of transforming a program written in Unicode into ASCII that changes a program into a form that can be processed by ASCII-based tools.
This transformed version is equally acceptable to a Java compiler and represents the exact same program.
The exact Unicode source can later be restored from this ASCII form by converting each escape sequence where multiple u's are present to a sequence of Unicode characters with one fewer u, while simultaneously converting each escape sequence with a single u to the corresponding single Unicode character.
A Java compiler should use the \uxxxx notation as an output format to display Unicode characters when a suitable font is not available.
A Java compiler next divides the sequence of Unicode input characters into lines by recognizing line terminators.
LineTerminator: the ASCII LF character, also known as "newline" the ASCII CR character, also known as "return" the ASCII CR character followed by the ASCII LF character.
The two characters CR immediately followed by LF are counted as one line terminator, not two.
A line terminator specifies the termination of the // form of a comment (¬ß3.7)
The lines defined by line terminators may determine the line numbers produced by a Java compiler.
The result is a sequence of line terminators and input characters, which are the terminal symbols for the third step in the tokenization process.
The tokens are the terminal symbols of the syntactic grammar (¬ß2.3)
For example, the ASCII characters intervening white space or comment.
As a special concession for compatibility with certain operating systems, the ASCII SUB character (\u001a, or control-Z) is ignored if it is the last character in the escaped input stream.
Consider two tokens x and y in the resulting input stream.
If x precedes y, then we say that x is to the left of y and that y is to the right of x.
White space is defined as the ASCII space character, horizontal tab character, form feed character, and line terminator characters (¬ß3.4)
WhiteSpace: the ASCII SP character, also known as "space" the ASCII HT character, also known as "horizontal tab" the ASCII FF character, also known as "form feed" LineTerminator.
An end-of-line comment: all the text from the ASCII characters // to the end of the line is ignored (as in C++)
These productions imply all of the following properties: ‚Ä¢ Comments do not nest.
An identifier is an unlimited-length sequence of Java letters and Java digits, the first of which must be a Java letter.
JavaLetter: any Unicode character that is a Java letter (see below)
JavaLetterOrDigit: any Unicode character that is a Java letter-or-digit (see below)
A "Java letter" is a character for which the method Character.isJavaIdentifierStart(int) returns true.
A "Java letter-or-digit" is a character for which the method Character.isJavaIdentifierPart(int) returns true.
The $ character should be used only in mechanically generated source code or, rarely, to access pre-existing names on legacy systems.
Letters and digits may be drawn from the entire Unicode character set, which supports most writing scripts in use in the world today, including the large sets for Chinese, Japanese, and Korean.
This allows programmers to use identifiers in their programs that are written in their native languages.
Two identifiers are the same only if they are identical, that is, have the same Unicode character for each letter or digit.
Identifiers that have the same external appearance may yet be different.
Unicode composite characters are different from their canonical equivalent decomposed characters.
Keyword: one of abstract   continue   for          new         switch assert     default    if           package     synchronized boolean    do         goto         private     this break      double     implements   protected   throw byte       else       import       public      throws case       enum       instanceof   return      transient catch      extends    int          short       try char       final      interface    static      void class      finally    long         strictfp    volatile const      float      native       super       while.
The keywords const and goto are reserved, even though they are not currently used.
This may allow a Java compiler to produce better error messages if these C++ keywords incorrectly appear in programs.
While true and false might appear to be keywords, they are technically Boolean literals (¬ß3.10.3)
Similarly, while null might appear to be a keyword, it is technically the null literal (¬ß3.10.7)
The suffix L is preferred, because the letter l (ell) is often hard to distinguish from the digit 1 (one)
Underscores are allowed as separators between digits that denote the integer.
In a decimal or octal literal, the integer is denoted by all the digits in the literal before any type suffix.
Therefore, underscores may not appear before the first digit or after the last digit in the numeral.
The following hexadecimal, octal, and binary literals represent the decimal value -1:
It is a compile-time error if a hexadecimal, octal, or binary int literal does not fit in 32 bits.
The following hexadecimal, octal, and binary literals represent the decimal value -1L:
It is a compile-time error if a hexadecimal, octal, or binary long literal does not fit in 64 bits.
A floating-point literal has the following parts: a whole-number part, a decimal or hexadecimal point (represented by an ASCII period character), a fraction part, an exponent, and a type suffix.
For decimal floating-point literals, at least one digit (in either the whole number or the fraction part) and either a decimal point, an exponent, or a float type suffix are required.
The exponent, if present, is indicated by the ASCII letter e or E followed by an optionally signed integer.
For hexadecimal floating-point literals, at least one digit is required (in either the whole number or the fraction part), and the exponent is mandatory, and the float type suffix is optional.
The exponent is indicated by the ASCII letter p or P followed by an optionally signed integer.
Underscores are allowed as separators between digits that denote the whole-number part, and between digits that denote the fraction part, and between digits that denote the exponent.
Sign: one of + FloatTypeSuffix: one of f F d D.
A floating-point literal is of type float if it is suffixed with an ASCII letter F or f; otherwise its type is double and it can optionally be suffixed with an ASCII letter D or d (¬ß4.2.3)
The details of proper input conversion from a Unicode string representation of a floatingpoint number to the internal IEEE 754 binary floating-point representation are described for the methods valueOf of class Float and class Double of the package java.lang.
The largest positive finite literal of type float is 3.4028235e38f.
The smallest positive finite non-zero literal of type float is 1.40e-45f.
The largest positive finite literal of type double is 1.7976931348623157e308
The smallest positive finite non-zero literal of type double is 4.9e-324
It is a compile-time error if a non-zero floating-point literal is too large, so that on rounded conversion to its internal representation, it becomes an IEEE 754 infinity.
It is a compile-time error if a non-zero floating-point literal is too small, so that, on rounded conversion to its internal representation, it becomes a zero.
A compile-time error does not occur if a non-zero floating-point literal has a small value that, on rounded conversion to its internal representation, becomes a nonzero denormalized number.
Predefined constants representing Not-a-Number values are defined in the classes Float and Double as Float.NaN and Double.NaN.
The boolean type has two values, represented by the boolean literals true and false, formed from ASCII letters.
A character literal is expressed as a character or an escape sequence (¬ß3.10.6), enclosed in ASCII single quotes.
It is a compile-time error for the character following the SingleCharacter or EscapeSequence to be other than a '
It is a compile-time error for a line terminator (¬ß3.4) to appear after the opening ' and before the closing '
As specified in ¬ß3.4, the characters CR and LF are never an InputCharacter; each is recognized as constituting a LineTerminator.
Similarly, it is not correct to write '\u000d' for a character literal whose value is carriage return (CR)
In C and C++, a character literal may contain representations of more than one character, but the value of such a character literal is implementation-defined.
In the Java programming language, a character literal always represents exactly one character.
A string literal consists of zero or more characters enclosed in double quotes.
It is a compile-time error for a line terminator to appear after the opening " and before the closing matching "
As specified in ¬ß3.4, the characters CR and LF are never an InputCharacter; each is recognized as constituting a LineTerminator.
Similarly, it is not correct to write "\u000d" for a string literal containing a single carriage return (CR)
Finally, it is not possible to write "\u0022" for a string literal containing a double quotation mark (")
Moreover, a string literal always refers to the same instance of class String.
This is because string literals - or, more generally, strings that are the values of constant expressions (¬ß15.28) - are "interned" so as to share unique instances, using the method String.intern.
Literal strings within different classes in the same package represent references to the same String object.
Literal strings within different classes in different packages likewise represent references to the same String object.
Strings computed by constant expressions (¬ß15.28) are computed at compile time and then treated as if they were literals.
Strings computed by concatenation at run time are newly created and therefore distinct.
The result of explicitly interning a computed string is the same string as any pre-existing literal string with the same contents.
The null type has one value, the null reference, represented by the null literal null, which is formed from ASCII characters.
A null literal is always of the null type (¬ß4.1)
The Java programming language is also a strongly typed language, because types limit the values that a variable (¬ß4.12) can hold or that an expression can produce, limit the operations supported on those values, and determine the meaning of the operations.
The types of the Java programming language are divided into two categories: primitive types and reference types.
The primitive types (¬ß4.2) are the boolean type and the numeric types.
The numeric types are the integral types byte, short, int, long, and char, and the floating-point types float and double.
The reference types (¬ß4.3) are class types, interface types, and array types.
An object (¬ß4.3.1) is a dynamically created instance of a class type or a dynamically created array.
The values of a reference type are references to objects.
All objects, including arrays, support the methods of class Object (¬ß4.3.2)
Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type.
The null reference is the only possible value of an expression of null type.
The null reference can always undergo a widening reference conversion to any reference type.
In practice, the programmer can ignore the null type and just pretend that null is merely a special literal that can be of any reference type.
A primitive type is predefined by the Java programming language and named by its reserved keyword (¬ß3.9):
Primitive values do not share state with other primitive values.
The numeric types are the integral types and the floating-point types.
The boolean type has exactly two values: true and false.
The values of the integral types are integers in the following ranges:
The Java programming language provides a number of operators that act on integral values:
The comparison operators, which result in a value of type boolean:
The cast operator (¬ß15.16), which can convert from an integral value to a value of any specified numeric type.
Other useful constructors, methods, and constants are predefined in the classes Byte, Short, Integer, Long, and Character.
If an integer operator other than a shift operator has at least one operand of type long, then the operation is carried out using 64-bit precision, and the result of the numerical operator is of type long.
Otherwise, the operation is carried out using 32-bit precision, and the result of the numerical operator is of type int.
If either operand is not an int, it is first widened to type int by numeric promotion.
Any value of any integral type may be cast to or from any numeric type.
There are no casts between integral types and the type boolean.
See ¬ß4.2.5 for an idiom to convert integer expressions to boolean.
The integer operators do not indicate overflow or underflow in any way.
The first multiplication is performed in 32-bit precision, whereas the second multiplication is a long multiplication.
The IEEE 754 standard includes not only positive and negative numbers that consist of a sign and magnitude, but also positive and negative zeros, positive and negative infinities, and special Not-a-Number values (hereafter abbreviated NaN)
A NaN value is used to represent the result of certain invalid operations such as dividing zero by zero.
NaN constants of both float and double type are predefined as Float.NaN and Double.NaN.
Every implementation of the Java programming language is required to support two standard sets of floating-point values, called the float value set and the double value set.
In addition, an implementation of the Java programming language may support either or both of two extended-exponent floating-point value sets, called the floatextended-exponent value set and the double-extended-exponent value set.
Some values can be represented in this form in more than one way; for example, supposing that a value v in a value set might be represented in this form using certain values for s, m, and e, then if it happened that m were even and e were less than 2K-1, one could halve m and increase e by 1 to produce a second representation for the same.
The constraints on the parameters N and K (and on the derived parameters Emin and Emax) for the two required and two optional floating-point value sets are summarized in Table 4.1
Where one or both extended-exponent value sets are supported by an implementation, then for each supported extended-exponent value set there is a specific implementation-dependent constant K, whose value is constrained by Table 4.1; this value K in turn dictates the values for Emin and Emax.
Each of the four value sets includes not only the finite nonzero values that are ascribed to it above, but also NaN values and the four values positive zero, negative zero, positive infinity, and negative infinity.
Note that the constraints in Table 4.1 are designed so that every element of the float value set is necessarily also an element of the float-extended-exponent value set, the double value set, and the double-extended-exponent value set.
Likewise, each element of the double value set is necessarily also an element of the doubleextended-exponent value set.
Each extended-exponent value set has a larger range of exponent values than the corresponding standard value set, but does not have more precision.
The elements of the float value set are exactly the values that can be represented using the single floating-point format defined in the IEEE 754 standard.
The elements of the double value set are exactly the values that can be represented using the double floating-point format defined in the IEEE 754 standard.
Note, however, that the elements of the float-extended-exponent and double-extended-exponent value sets defined here do not correspond to the values that can be represented using IEEE 754 single extended and double extended formats, respectively.
The float, float-extended-exponent, double, and double-extended-exponent value sets are not types.
It is always correct for an implementation of the Java programming language to use an element of the float value set to represent a value of type float; however, it may be permissible in certain regions of code for an implementation to use an element of the float-extended-exponent value set instead.
Similarly, it is always correct for an implementation to use an element of the double value set to represent a value of type double; however, it may be permissible in certain regions of code for an implementation to use an element of the doubleextended-exponent value set instead.
Except for NaN, floating-point values are ordered; arranged from smallest to largest, they are negative infinity, negative finite nonzero values, positive and negative zero, positive finite nonzero values, and positive infinity.
While each hardware architecture returns a particular bit pattern for NaN when a new NaN is generated, a programmer can also create NaNs with different bit patterns to encode, for example, retrospective diagnostic information.
For the most part, the Java SE platform treats NaN values of a given type as though collapsed into a single canonical value, and hence this specification normally refers to an arbitrary NaN as though to a canonical value.
However, version 1.3 of the Java SE platform introduced methods enabling the programmer to distinguish between NaN values: the Float.floatToRawIntBits and Double.doubleToRawLongBits methods.
The interested reader is referred to the specifications for the Float and Double classes for more information.
The Java programming language provides a number of operators that act on floating-point values:
The comparison operators, which result in a value of type boolean:
Other useful constructors, methods, and constants are predefined in the classes Float, Double, and Math.
If at least one of the operands to a binary operator is of floating-point type, then the operation is a floating-point operation, even if the other is integral.
If at least one of the operands to a numerical operator is of type double, then the operation is carried out using 64-bit floating-point arithmetic, and the result of the numerical operator is a value of type double.
Otherwise, the operation is carried out using 32-bit floating-point arithmetic, and the result of the numerical operator is a value of type float.
If the other operand is not a float, it is first widened to type float by numeric promotion.) Any value of a floating-point type may be cast to or from any numeric type.
There are no casts between floating-point types and the type boolean.
See ¬ß4.2.5 for an idiom to convert floating-point expressions to boolean.
In particular, the Java programming language requires support of IEEE 754 denormalized floating-point numbers and gradual underflow, which make it easier to prove desirable properties of particular numerical algorithms.
Floating-point operations do not "flush to zero" if the calculated result is a denormalized number.
The Java programming language requires that floating-point arithmetic behave as if every floating-point operator rounded its floating-point result to the result precision.
Inexact results must be rounded to the representable value nearest to the infinitely precise result; if the two nearest representable values are equally near, the one with its least significant bit zero is chosen.
This is the IEEE 754 standard's default rounding mode known as round to nearest.
The Java programming language uses round toward zero when converting a floating value to an integer (¬ß5.1.3), which acts, in this case, as though the number were truncated, discarding the mantissa bits.
Rounding toward zero chooses at its result the format's value closest to and no greater in magnitude than the infinitely precise result.
A floating-point operation that underflows produces a denormalized value or a signed zero.
A floating-point operation that has no mathematically definite result produces NaN.
All numeric operations with NaN as an operand produce NaN as a result.
An example of gradual underflow: // An example of NaN: // An example of inexact results and rounding: // Another example of inexact results and rounding: // An example of cast to integer rounding:
This example demonstrates, among other things, that gradual underflow can result in a gradual loss of precision.
The boolean type represents a logical quantity with two possible values, indicated by the literals true and false (¬ß3.10.3)
Only boolean and Boolean expressions can be used in control flow statements and as the first operand of the conditional operator ? :
An integer or floating-point expression x can be converted to a boolean, following An object reference obj can be converted to a boolean, following the C language convention that any reference other than null is true, by the expression obj!
A boolean can be converted to a String by string conversion (¬ß5.4)
A class or interface type consists of a type declaration specifier, optionally followed by type arguments (¬ß4.5.1)
If type arguments appear anywhere in a class or interface type, it is a parameterized type (¬ß4.5)
A type declaration specifier may be either a type name (¬ß6.5.5), or a class or interface type followed by "." and an identifier.
There are contexts in the Java programming language where a generic class or interface name is used without providing type arguments.
Such contexts do not involve the use of raw types (¬ß4.8)
Rather, they are contexts where type arguments are unnecessary for, or irrelevant to, the meaning of the generic class or interface.
For example, a single-type-import declaration import java.util.List; puts the simple type name List in scope within a compilation unit so that parameterized types of the form List<...> may be used.
As another example, invocation of a static method of a generic class needs only to give the (possibly qualified) name of the generic class without any type arguments, because such type arguments are irrelevant to a static method.
The method itself may be generic, and take its own type arguments, but the type parameters of a static method are necessarily unrelated to the type parameters of its enclosing generic class (¬ß6.5.5).)
Because of the occasional need to use a generic class or interface name without type arguments, type names are distinct from type declaration specifiers.
A type name is always qualified by means of another type name.
In some cases, this is necessary to access an inner class that is a member of a parameterized type.
Here is an example of where a type declaration specifier is distinct from a type name:
If we accessed Inner by qualifying it with a type name, as in:
The reference values (often just references) are pointers to these objects, and a special null reference, which refers to no object.
A class instance is explicitly created by a class instance creation expression (¬ß15.9)
An array is explicitly created by an array creation expression (¬ß15.10)
A Point instance is explicitly created at class initialization time: */
An array is implicitly created by an array constructor: */
An array is explicitly created by an array creation expression: */
Most objects have state, stored in the fields of objects that are instances of classes or in the variables that are the components of an array object.
If two variables contain references to the same object, the state of the object can be modified using one variable's reference to the.
The class Object is a superclass (¬ß8.1.4) of all other classes.
The method equals defines a notion of object equality, which is based on value,
The method finalize is run just before an object is destroyed (¬ß12.6)
The method getClass returns the Class object that represents the class of the object.
It can be used, for example, to discover the fully qualified name of a class, its members, its immediate superclass, and any interfaces that it implements.
A class method that is declared synchronized (¬ß8.4.3.6) synchronizes on the monitor associated with the Class object of the class.
The method hashCode is very useful, together with the method equals, in hashtables such as java.util.Hashmap.
The methods wait, notify, and notifyAll are used in concurrent programming using threads (¬ß17.2)
The method toString returns a String representation of the object.
Instances of class String represent sequences of Unicode code points.
String literals (¬ß3.10.5) are references to instances of class String.
Two reference types are the same compile-time type if they have the same binary name (¬ß13.1) and their type arguments, if any, are the same, applying this definition recursively.
When two reference types are the same, they are sometimes said to be the same class or the same interface.
At run time, several reference types with the same binary name may be loaded simultaneously by different class loaders.
These types may or may not represent the same type declaration.
Even if two such types do represent the same type declaration, they are considered distinct.
They are both class or both interface types, are defined by the same class loader, and have the same binary name (¬ß13.1), in which case they are sometimes said to be the same run-time class or the same run-time interface.
They are both array types, and their component types are the same run-time type (¬ß10)
A type variable is an unqualified identifier used as a type in class, interface, method, and constructor bodies.
The scope of a type variable declared as a type parameter is specified in ¬ß6.3
Every type variable declared as a type parameter has a bound.
If no bound is declared for a type variable, Object is assumed.
It is a compile-time error if any of the types I1 ...
The erasures (¬ß4.6) of all constituent types of a bound must be pairwise different, or a compile-time error occurs.
A type variable must not at the same time be a subtype of two interface types which are different parameterizations of the same generic interface, or a compile-time error occurs.
The order of types in a bound is only significant in that the erasure of a type variable is determined by the first type in its bound, and that a class type or type variable may only appear in the first position.
In appearing at the point where the type variable is declared.
The type variable T has the same members as the intersection type C & I, which in turn has the same members as the empty class CT, defined in the same scope with equivalent supertypes.
The members of an interface are always public, and therefore always inherited (unless overridden)
Hence mI is a member of CT and of T.
Among the members of C, all but mCPrivate are inherited by CT, and are therefore members of both CT and T.
If C had been declared in a different package than T, then the call to mCDefault would give rise to a compile-time error, as that member would not be accessible at the point where T is declared.
Each parameterized type in the set is of the form C<T1,...,Tn> where each type argument Ti ranges over all types that are subtypes of all types listed in the corresponding bound.
That is, for each bound type Si in Bi, Ti is a subtype of.
A parameterized type is written as a ClassType or InterfaceType that contains at least one type declaration specifier immediately followed by a type argument list <T1,...,Tn>
The type argument list denotes a particular invocation of the type parameters of the generic type indicated by the type declaration specifier.
Given a type declaration specifier immediately followed by a type argument list, let C be the final Identifier in the specifier.
It is a compile-time error if C is not the name of a generic class or interface, or if the number of type arguments in the type argument list differs from the number of type parameters of C.
In this specification, whenever we speak of a class or interface type, we include the generic version as well, unless explicitly excluded.
Vector<int> is illegal, as primitive types cannot be type arguments.
Pair<String> is illegal, as there are not enough type arguments.
Pair<String,String,String> is illegal, as there are too many type arguments.
A parameterized type may be an invocation of a generic class or interface which is nested.
Two parameterized types are provably distinct if either of the following conditions hold: ‚Ä¢ They are invocations of distinct generic type declarations.
Wildcards are useful in situations where only partial knowledge about the type parameter is required.
In contrast, the use of an unbounded wildcard allows any kind of collection to be used as a parameter.
Here is an example where the element type of an array is parameterized by a wildcard:
Wildcards may be given explicit bounds, just like regular type variable declarations.
An upper bound is signified by the following syntax, where B is the bound:
Unlike ordinary type variables declared in a method signature, no type inference is required when using a wildcard.
Consequently, it is permissible to declare lower bounds on a wildcard, using the following syntax, where B is a lower bound:
Here, the method is declared within the interface Collection<E>, and is designed to add all the elements of its incoming argument to the collection upon which it is invoked.
A natural tendency would be to use Collection<E> as the type of c, but this is unnecessarily restrictive.
An alternative would be to declare the method itself to be generic:
This version is sufficiently flexible, but note that the type parameter is used only once in the signature.
This reflects the fact that the type parameter is not being used to express any kind of interdependency between the type(s) of the argument(s), the return type and/or throws type.
In the absence of such interdependency, generic methods are considered bad style, and wildcards are preferred.
Here, the referent can be inserted into any queue whose element type is a supertype of the type T of the referent; T is the lower bound for the wildcard.
Two type arguments are provably distinct if one of the following is true: ‚Ä¢ Neither argument is a type variable or wildcard, and the two arguments are not.
The relationship of wildcards to established type theory is an interesting one, which we briefly allude to here.
Historically, wildcards are a direct descendant of the work by Atsushi Igarashi and Mirko Viroli.
Wildcards differ in certain details from the constructs described in the aforementioned paper, in particular in the use of capture conversion (¬ß5.1.10) rather than the close operation described by Igarashi and Viroli.
Let m be a member or constructor declaration in D, where D is a class extended by C or an interface implemented by C.
If any of the type arguments in the invocation of C are wildcards, then:
Let D be a (possibly generic) class or interface declaration in C.
Then the type of D in C<T1,...,Tn> is D where, if D is generic, all type arguments are unbounded wildcards.
This is of no consequence, as it is impossible to access a member of a parameterized type without performing capture conversion (¬ß5.1.10), and it is impossible to use a wildcard type after the keyword new in a class instance creation expression.
The sole exception to the previous paragraph is when a nested parameterized type is used as the expression in an instanceof operator (¬ß15.20.2), where capture conversion is not applied.
Type erasure is a mapping from types (possibly including parameterized types and type variables) to types (that are never parameterized types or type variables)
The erasure of a type variable (¬ß4.4) is the erasure of its leftmost bound.
The erasure of every other type is the type itself.
Type erasure also maps the signature (¬ß8.4.2) of a constructor or method to a signature that has no parameterized types or type variables.
The erasure of a constructor or method signature s is a signature consisting of the same name as s and the erasures of all the formal parameter types given in s.
The erasure of the signature of a generic method has no type parameters.
Because some type information is erased during compilation, not all types are available at run time.
Types that are completely available at run time are known as reifiable types.
A type is reifiable if and only if one of the following holds: ‚Ä¢ It refers to a non-generic class or interface type declaration.
It is a parameterized type in which all type arguments are unbounded wildcards.
It is an array type (¬ß10.1) whose element type is reifiable.
It is a nested type where, for each type T separated by a ".", T itself is reifiable.
The decision not to make all generic types reifiable is one of the most crucial, and controversial design decisions involving the type system of the Java programming language.
Ultimately, the most important motivation for this decision is compatibility with existing code.
In a naive sense, the addition of new constructs such as generics has no implications for pre-existing code.
The Java programming language, per se, is compatible with earlier versions as long as every program written in the previous versions retains its meaning in the new version.
However, this notion, which may be termed language compatibility, is of purely theoretical interest.
Real programs (even trivial ones, such as "Hello World") are composed of several compilation units, some of which are provided by the Java SE platform (such as elements of java.lang or java.util)
In practice, then, the minimum requirement is platform compatibility - that any program written for the prior version of the Java SE platform continues to function unchanged in the new version.
One way to provide platform compatibility is to leave existing platform functionality unchanged, only adding new functionality.
For example, rather than modify the existing Collections hierarchy in java.util, one might introduce a new library utilizing generics.
The disadvantages of such a scheme is that it is extremely difficult for pre-existing clients of the Collection library to migrate to the new library.
Collections are used to exchange data between independently developed modules; if a vendor decides to switch to the new, generic, library, that vendor must also distribute two versions of their code, to be compatible.
Libraries that are dependent on other vendors code cannot be modified to use generics until the supplier's library is updated.
If two modules are mutually dependent, the changes must be made simultaneously.
Clearly, platform compatibility, as outlined above, does not provide a realistic path for adoption of a pervasive new feature such as generics.
Therefore, the design of the generic type system seeks to support migration compatibility.
Migration compatibiliy allows the evolution of existing code to take advantage of generics without imposing dependencies between independently developed software modules.
The price of migration compatibility is that a full and sound reification of the generic type system is not possible, at least while the migration is taking place.
More precisely, a raw type is defined to be one of: ‚Ä¢ The reference type that is formed by taking the name of a generic type declaration.
An array type whose element type is a raw type.
A non-static member type of a raw type R that is not inherited from a superclass or superinterface of R.
A non-generic class or interface type is not a raw type.
To see why a non-static type member of a raw type is considered raw, consider the following example:
The type of the member(s) of Inner depends on the type parameter of Outer.
If Outer is raw, Inner must be treated as raw as well, as there is no valid binding for T.
This rule applies only to type members that are not inherited.
Inherited type members that depend on type variables will be inherited as raw types as a consequence of the rule that the supertypes of a raw type are erased, described later in this section.
Another implication of the rules above is that a generic inner class of a raw type can itself only be used as a raw type:
It is not possible to access Inner as a partially raw type (a "rare" type):
The superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of its parameterized invocations.
The type of a static method or static field of a raw type C is the same as its type in the generic declaration corresponding to C.
It is a compile-time error to pass type arguments to a non-static type member of a raw type that is not inherited from its superclasses or superinterfaces.
It is a compile-time error to attempt to use a type member of a parameterized type as a raw type.
This means that the ban on "rare" types extends to the case where the qualifying type is parameterized, but we attempt to use the inner class as a raw type:
In non-legacy code, we should use the generic types correctly and pass all the required type arguments.
The supertype of a class may be a raw type.
Member accesses for the class are treated as normal, and member accesses for the supertype are treated as for raw types.
In the constructor of the class, calls to super are treated as method calls on a raw type.
The use of raw types is allowed only as a concession to compatibility of legacy code.
The use of raw types in code written after the introduction of generics into the Java programming language is strongly discouraged.
It is possible that future versions of the Java programming language will disallow the use of raw types.
To make sure that potential violations of the typing rules are always flagged, some accesses to members of a raw type will result in compile-time unchecked warnings.
The rules for compile-time unchecked warnings when accessing members or constructors of raw types are as follows:
At an assignment to a field: if the type of the left-hand operand is a raw type, then a compile-time unchecked warning occurs if erasure changes the field's type.
At an invocation of a method or constructor: if the type of the class or interface to search (¬ß15.12.1) is a raw type, then a compile-time unchecked warning occurs if erasure changes any of the formal parameter types of the method or constructor.
No compile-time unchecked warning occurs for a method call when the formal parameter types do not change under erasure (even if the result type and/or throws clause changes), for reading from a field, or for a class instance creation of a raw type.
The warnings here cover the case where a legacy consumer uses a generified library.
The legacy consumer receives a warning because it may have caused heap pollution (¬ß4.12.2) for generified consumers of the generified library.
Note that the legacy consumer can assign a Vector<String> from the library to its own Vector variable without receiving a warning.
That is, the subtyping rules (¬ß4.10.2) of the Java programming language make it possible for a variable of a raw type to be assigned a value of any of the type's parameterized instances.)
The warnings from unchecked conversion cover the dual case, where a generified consumer uses a legacy library.
For example, a method of the library has the raw return type Vector, but the consumer assigns the result of the method invocation to a variable of type Vector<String>
This is unsafe, since the raw vector might have had a different element type than String, but is still permitted using unchecked conversion in order to enable interfacing with legacy code.
In contrast, the static member cng retains its full parameterized type even when accessed through a object of raw type.
Note that access to a static member through an instance is considered bad style and is to be discouraged.) The member myNumbers is inherited from the NonGeneric class (whose erasure is also NonGeneric) and so retains its full parameterized type.
Raw types can be thought of as wildcards whose type rules are deliberately unsound, to accommodate interaction with legacy code.
It is not possible to write an intersection type directly as part of a program; no syntax supports this.
It is worth dwelling upon the distinction between intersection types and the bounds of type variables.
This intersection type is often trivial (i.e., consists of a single type)
However, capture conversion can lead to the creation of type variables whose bounds are more general (e.g., array types)
The subtype and supertype relations are binary relations on types.
The supertypes of a type are obtained by reflexive and transitive closure over the direct supertype relation, written S >1 T, which is defined by rules given later in this section.
We write S :> T to indicate that the supertype relation holds between S and T.
The subtypes of a type T are all types U such that T is a supertype of U, and the null type.
We write T <: S to indicate that that the subtype relation holds between types T and S.
The type Object, if C is an interface type with no direct superinterfaces.
The direct supertypes of a type variable are the types listed in its bound.
A type variable is a direct supertype of its lower bound.
The direct supertypes of the null type are all reference types other than the null type itself.
Types are used when they appear in declarations or in certain expressions.
In this example, types are used in declarations of the following:
Fields, which are the class variables and instance variables of classes (¬ß8.3), and to be of type int.
Compatibility of the value of a variable with its type is guaranteed by the design of the Java programming language, as long as a program does not give rise to compiletime unchecked warnings (¬ß4.12.2)
A variable of a primitive type always holds a primitive value of that exact primitive type.
A variable of a class type T can hold a null reference or a reference to an instance of class T or of any class that is a subclass of T.
A variable of an interface type can hold a null reference or a reference to any instance of any class that implements the interface.
Note that a variable is not guaranteed to always refer to a subtype of its declared type, but only to subclasses or subinterfaces of the declared type.
This is due to the possibility of heap pollution discussed below.
If T is a primitive type, then a variable of type "array of T" can hold a null reference or a reference to any array of type "array of T"
If T is a reference type, then a variable of type "array of T" can hold a null reference or a reference to any array of type "array of S" such that type S is a subclass or subinterface of type T.
A variable of type Object[] can hold a reference to an array of any reference type.
A variable of type Object can hold a null reference or a reference to any object, whether it is an instance of a class or an array.
It is possible that a variable of a parameterized type will refer to an object that is not of that parameterized type.
The problem cannot be identified at run time because type variables are not reified, and thus instances do not carry any information at run time regarding the type arguments used to create them.
In a simple example as given above, it may appear that it should be straightforward to identify the situation at compile time and give an error.
However, in the general (and typical) case, the value of the variable l may be the result of an invocation of a separately compiled method, or its value may depend upon arbitrary control flow.
The code above is therefore very atypical, and indeed very bad style.
Furthermore, the fact that Object[] is a supertype of all array types means that unsafe aliasing can occur which leads to heap pollution.
For example, the following code compiles because it is statically type-correct:
If and only if the body of the method was type-safe with respect to the variable arity parameter, then the programmer could use the SafeVarargs annotation to silence warnings at invocations (¬ß9.6.3.7)
Since the body of the method as written above causes heap pollution, it would be completely inappropriate to use the annotation to disable warnings for callers.
Finally, note that the stringLists array could be aliased through variables of types other than Object[], and heap pollution could still occur.
For example, the type of the array variable could be java.util.Collection[] - a raw element type - and the body of the method above would compile without warnings or errors and still cause heap pollution.
And if the Java SE platform defined, say, Sequence as a non-generic supertype of List<T>, then using Sequence as the type of array would also cause heap pollution.
The variable will always refer to an object that is an instance of a class that represents the parameterized type.
The value of ls in the example above is always an instance of a class that provides a representation of a List.
Assignment from an expression of a raw type to a variable of a parameterized type should only be used when combining legacy code which does not make use of parameterized types with more modern code that does.
If no operation that requires a compile-time unchecked warning to be issued takes place, and no unsafe aliasing occurs of array variables with non-reifiable element types, then heap pollution cannot occur.
Note that this does not imply that heap pollution only occurs if a compile-time unchecked warning actually occurred.
It is possible to run a program where some of the binaries were produced by a compiler for an older version of the Java programming language, or from sources that explicitly suppressed unchecked warnings.
Conversely, it is possible that despite executing code that could (and perhaps did) give rise to a compile-time unchecked warning, no heap pollution takes place.
Indeed, good programming practice requires that the programmer satisfy herself that despite any unchecked warning, the code is correct and heap pollution will not occur.
The class variable effectively ceases to exist when its class or interface is unloaded (¬ß12.7)
An instance variable is a field declared within a class declaration without using the keyword static (¬ß8.3.1.1)
The instance variable effectively ceases to exist when the object of which it is a field is no longer referenced, after any necessary finalization of the object (¬ß12.6) has been completed.
The array components effectively cease to exist when the array is no longer referenced.
Method parameters (¬ß8.4.1) name argument values passed to a method.
For every parameter declared in a method declaration, a new parameter variable is created each time that method is invoked (¬ß15.12)
The new variable is initialized with the corresponding argument value from the method invocation.
The method parameter effectively ceases to exist when the execution of the body of the method is complete.
Constructor parameters (¬ß8.8.1) name argument values passed to a constructor.
The new variable is initialized with the corresponding argument value from the creation expression or constructor invocation.
The constructor parameter effectively ceases to exist when the execution of the body of the constructor is complete.
An exception parameter is created each time an exception is caught by a catch clause of a try statement (¬ß14.20)
The exception parameter effectively ceases to exist when execution of the block associated with the catch clause is complete.
Local variables are declared by local variable declaration statements (¬ß14.4)
A local variable declaration statement may contain an expression which initializes the variable.
The local variable with an initializing expression is not initialized, however, until the local variable declaration statement that declares it is executed.
The rules of definite assignment (¬ß16) prevent the value of a local variable from being used before it has been initialized or otherwise assigned a value.) The local variable effectively ceases to exist when the execution of the block or for statement is complete.
Were it not for one exceptional situation, a local variable could always be regarded as being created when its local variable declaration statement is executed.
The exceptional situation involves the switch statement (¬ß14.11), where it is possible for.
Declaring a variable final can serve as useful documentation that its value will not change and can help avoid programming errors.
It is a compile-time error if a final variable is assigned to unless it is definitely unassigned (¬ß16) immediately prior to the assignment.
A blank final is a final variable whose declaration lacks an initializer.
Once a final variable has been assigned, it always contains the same value.
If a final variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object.
This applies also to arrays, because arrays are objects; if a final variable holds a reference to an array, then the components of the array may be changed by operations on the array, but the variable will always refer to the same array.
In this program, the class Point declares a final class variable origin.
The origin variable holds a reference to an object that is an instance of class Point whose coordinates.
The value of the variable Point.origin can never change, so it always refers to the same Point object, the one created by its initializer.
However, an operation on this Point object might change its state - for example, modifying its useCount or even, misleadingly, its x or y coordinate.
A variable of primitive type or type String, that is final and initialized with a compile-time constant expression (¬ß15.28), is called a constant variable.
An exception parameter of a uni-catch clause (¬ß14.20) may be effectively final instead of being explicitly declared final.
Every variable in a program must have a value before its value is used: ‚Ä¢ Each class variable, instance variable, or array component is initialized with a.
For type short, the default value is zero, that is, the value of (short)0
For type int, the default value is zero, that is, 0
For type long, the default value is zero, that is, 0L.
For type float, the default value is positive zero, that is, 0.0f.
For type double, the default value is positive zero, that is, 0.0d.
For type char, the default value is the null character, that is, '\u0000'
For all reference types (¬ß4.3), the default value is null.
See ¬ß12 for a full description of all aspects of loading, linking, and initialization of classes and interfaces, plus a description of the instantiation of classes to make new class instances.
In the Java programming language, every variable and every expression has a type that can be determined at compile time.
The type may be a primitive type or a reference type.
We often use the term type to refer to either a class or an interface.
In the Java Virtual Machine, every object belongs to some particular class: the class that was mentioned in the creation expression that produced the object (¬ß15.9), or the class whose Class object was used to invoke a reflective method to produce the.
An object is said to be an instance of its class and of all superclasses of its class.
The method getClass, when invoked for an array object, will return a class object (of class Class) that represents the class of the array (¬ß10.8)
The compile-time type of a variable is always declared, and the compile-time type of an expression can be deduced at compile time.
The compile-time type limits the possible values that the variable can hold at run time or the expression can produce at run time.
If a run-time value is a reference that is not null, it refers to an object or array that has a class, and that class will necessarily be compatible with the compile-time type.
Even though a variable or expression may have a compile-time type that is an interface type, there are no instances of interfaces.
A variable or expression whose type is an interface type can reference any object whose class implements (¬ß8.1.5) that interface.
Sometimes a variable or expression is said to have a "run-time type"
This refers to the class of the object referred to by the value of the variable or expression at run time, assuming that the value is not null.
The correspondence between compile-time types and run-time types is incomplete for two reasons:
At run time, classes and interfaces are loaded by the Java Virtual Machine using class loaders.
Each class loader defines its own set of classes and interfaces.
As a result, it is possible for two loaders to load an identical class or interface definition but produce distinct classes or interfaces at run time.
Consequently, code that compiled correctly may fail at link time if the class loaders that load it are inconsistent.
As a result, the same class or interface at run time represents multiple parameterized types (¬ß4.5) from compile-time.
Under certain conditions, it is possible that a variable of a parameterized type refers to an object that is not of that parameterized type.
The variable will always refer to an object that is an instance of a class that represents the parameterized type.
The local variable p of the method main of class Test has type Point and is initially assigned a reference to a new instance of class Point.
The local variable cp similarly has as its type ColoredPoint, and is initially assigned a reference to a new instance of class ColoredPoint.
The assignment of the value of cp to the variable p causes p to hold a reference to a ColoredPoint object.
This is permitted because ColoredPoint is a subclass of Point, so the class ColoredPoint is assignment-compatible (¬ß5.2) with the type Point.
A ColoredPoint object includes support for all the methods of a Point.
In addition to its particular fields r, g, and b, it has the fields of class Point, namely x and y.
The local variable c has as its type the interface type Colorable, so it can hold a reference to any object whose class implements Colorable; specifically, it can hold a reference to a ColoredPoint.
However, the expression new anonymous class (¬ß15.9.5) that implements the Colorable interface.
It is possible, however, to write an expression in a context where the type of the expression is not appropriate.
In some cases, this leads to an error at compile time.
In other cases, the context may be able to accept a type that is related to the type of the expression; as a convenience, rather than requiring the programmer to indicate a type conversion explicitly, the Java programming language performs an implicit conversion from the type of the expression to a type acceptable for its surrounding context.
A specific conversion from type S to type T allows an expression of type S to be treated at compile time as if it had type T instead.
In some cases this will require a corresponding action at run time to check the validity of the conversion or to translate the run-time value of the expression into a form appropriate for the new type T.
A conversion from type Object to type Thread requires a run-time check to make sure that the run-time value is actually an instance of class Thread or one of its subclasses; if it is not, an exception is thrown.
A conversion from type Thread to type Object requires no run-time action; Thread is a subclass of Object, so any reference produced by an expression of type Thread is a valid reference value of type Object.
Depending on the actual run-time value, information may be lost.
In every conversion context, only certain specific conversions are permitted.
There are five conversion contexts in which conversion of expressions may occur.
Each context allows conversions in some of the categories named above but not others.
The term "conversion" is also used to describe the process of choosing a specific conversion for such a context.
For example, we say that an expression that is an actual argument in a method invocation is subject to "method invocation conversion," meaning that a specific conversion will be implicitly chosen for that expression according to the rules for the method invocation argument context.
The conversion process for such operands is called numeric promotion.
Promotion is special in that, in the case of binary operators, the conversion chosen for one operand may depend in part on the type of the other operand expression.
Assignment conversion may cause an OutOfMemoryError (as a result of boxing conversion (¬ß5.1.7)), a NullPointerException (as a result of unboxing.
It is more inclusive than assignment or method invocation conversion, allowing any specific conversion other than a string conversion, but certain casts to a reference type may cause an exception at run time.
String conversion may cause an OutOfMemoryError (as a result of class instance creation (¬ß12.5)) to be thrown at run time.
Numeric promotion (¬ß5.6) brings the operands of a numeric operator to a common type so that an operation can be performed.
Casting conversion (5.4) of a float literal to // type int.
After promotion, the operation is float*float: // Two string conversions of i and f:
Method invocation conversion (5.3) of f's value // to type double, needed because the method Math.sin // accepts only a double argument: // Two string conversions of f and d:
Specific type conversions in the Java programming language are divided into 13 categories.
A conversion from a type to that same type is permitted for any type.
This may seem trivial, but it has two practical consequences.
First, it is always permitted for an expression to have the desired type to begin with, thus allowing the simply stated rule that every expression is subject to conversion, if only a trivial identity conversion.
Second, it implies that it is permitted for a program to include redundant cast operators for the sake of clarity.
A widening primitive conversion does not lose information about the overall magnitude of a numeric value.
A widening primitive conversion from an integral type to another integral type, or from float to double in a strictfp expression (¬ß15.4), does not lose any information at all; the numeric value is preserved exactly.
A widening primitive conversion from float to double that is not strictfp may lose information about the overall magnitude of the converted value.
A widening conversion of an int or a long value to float, or of a long value to double, may result in loss of precision - that is, the result may lose some of the least significant bits of the value.
A widening conversion of a signed integer value to an integral type T simply signextends the two's-complement representation of the integer value to fill the wider format.
A widening conversion of a char to an integral type T zero-extends the representation of the char value to fill the wider format.
Despite the fact that loss of precision may occur, a widening primitive conversion never results in a run-time exception (¬ß11.1.1)
A narrowing primitive conversion may lose information about the overall magnitude of a numeric value and may also lose precision and range.
This conversion can lose precision, but also lose range, resulting in a float zero from a nonzero double and a float infinity from a finite double.
A double NaN is converted to a float NaN and a double infinity is converted to the same-signed float infinity.
A narrowing conversion of a signed integer to an integral type T simply discards all but the n lowest order bits, where n is the number of bits used to represent type T.
In addition to a possible loss of information about the magnitude of the numeric value, this may cause the sign of the resulting value to differ from the sign of the input value.
A narrowing conversion of a char to an integral type T likewise simply discards all but the n lowest order bits, where n is the number of bits used to represent type T.
In addition to a possible loss of information about the magnitude of the numeric value, this may cause the resulting value to be a negative number, even though chars represent 16-bit unsigned integer values.
A narrowing conversion of a floating-point number to an integral type T takes two steps:
In the first step, the floating-point number is converted either to a long, if T is long, or to an int, if T is byte, short, char, or int, as follows:
If T is long, and this integer value can be represented as a long, then the.
Otherwise, if this integer value can be represented as an int, then the result of the first step is the int value V.
Otherwise, one of the following two cases must be true: a.
The value must be too small (a negative value of large magnitude.
The value must be too large (a positive value of large magnitude or positive infinity), and the result of the first step is the largest representable value of type int or long.
In the second step: ‚Ä¢ If T is int or long, the result of the conversion is the result of the first step.
If T is byte, char, or short, the result of the conversion is the result of a narrowing conversion to type T (¬ß5.1.3) of the result of the first step.
The results for char, int, and long are unsurprising, producing the minimum and maximum representable values of the type.
The results for byte and short lose information about the sign and magnitude of the numeric values and also lose precision.
The results can be understood by examining the low order bits of the minimum and maximum int.
Despite the fact that overflow, underflow, or other loss of information may occur, a narrowing primitive conversion never results in a run-time exception (¬ß11.1.1)
A narrowing of int to short loses high bits: // An int value too big for byte changes sign and magnitude: // A float value too big to fit gives largest int value: // A NaN converted to int yields zero: // A double value too large for float yields infinity: // A double value too small for float underflows to zero:
The following conversion combines both widening and narrowing primitive conversions:
A widening reference conversion exists from any reference type S to any reference type T, provided S is a subtype (¬ß4.10) of T.
Widening reference conversions never require a special action at run time and therefore never throw an exception at run time.
They consist simply in regarding a reference as having some other type in a manner that can be proved correct at compile time.
Six kinds of conversions are called the narrowing reference conversions: ‚Ä¢ From any reference type S to any reference type T, provided that S is a proper.
An important special case is that there is a narrowing reference conversion from the class type Object to any other reference type (¬ß4.12.4)
From any class type C to any non-parameterized interface type K, provided that C is not final and does not implement K.
From any interface type J to any non-parameterized class type C that is not final.
From any interface type J to any non-parameterized interface type K, provided.
From the interface types Cloneable and java.io.Serializable to any array.
Such conversions require a test at run time to find out whether the actual reference value is a legitimate value of the new type.
Boxing conversion converts expressions of primitive type to corresponding expressions of reference type.
Specifically, the following nine conversions are called the boxing conversions: ‚Ä¢ From type boolean to type Boolean.
This rule is necessary because the conditional operator (¬ß15.25) applies boxing conversion to the types of its operands, and uses the result in further calculations.
At run time, boxing conversion proceeds as follows: ‚Ä¢ If p is a value of type boolean, then boxing conversion converts p into a reference.
If p is a value of type byte, then boxing conversion converts p into a reference.
If p is a value of type char, then boxing conversion converts p into a reference.
If p is a value of type short, then boxing conversion converts p into a reference.
If p is a value of type int, then boxing conversion converts p into a reference r.
If p is a value of type long, then boxing conversion converts p into a reference.
If p is a value of type float then: ‚óÜ If p is not NaN, then boxing conversion converts p into a reference r of class.
Otherwise, boxing conversion converts p into a reference r of class and type.
If p is a value of type double, then: ‚óÜ If p is not NaN, boxing conversion converts p into a reference r of class and.
Otherwise, boxing conversion converts p into a reference r of class and type.
If p is a value of any other type, boxing conversion is equivalent to an identity conversion (¬ß5.1.1)
Ideally, boxing a given primitive value p, would always yield an identical reference.
In practice, this may not be feasible using existing implementation techniques.
The final clause above requires that certain common values always be boxed into indistinguishable objects.
For other values, this formulation disallows any assumptions about the identity of the boxed values on the programmer's part.
This would allow (but not require) sharing of some or all of these references.
This ensures that in most common cases, the behavior will be the desired one, without imposing an undue performance penalty, especially on small devices.
A boxing conversion may result in an OutOfMemoryError if a new instance of one of the wrapper classes (Boolean, Byte, Character, Short, Integer, Long, Float, or Double) needs to be allocated and insufficient storage is available.
Unboxing conversion converts expressions of reference type to corresponding expressions of primitive type.
Specifically, the following eight conversions are called the unboxing conversions: ‚Ä¢ From type Boolean to type boolean.
At run time, unboxing conversion proceeds as follows: ‚Ä¢ If r is a reference of type Boolean, then unboxing conversion converts r into.
If r is a reference of type Byte, then unboxing conversion converts r into.
If r is a reference of type Character, then unboxing conversion converts r into.
If r is a reference of type Short, then unboxing conversion converts r into.
If r is a reference of type Integer, then unboxing conversion converts r into.
If r is a reference of type Long, then unboxing conversion converts r into.
If r is a reference of type Float, unboxing conversion converts r into.
If r is a reference of type Double, then unboxing conversion converts r into.
If r is null, unboxing conversion throws a NullPointerException A type is said to be convertible to a numeric type if it is a numeric type (¬ß4.2), or it is a reference type that may be converted to a numeric type by unboxing conversion.
A type is said to be convertible to an integral type if it is an integral type, or it is a reference type that may be converted to an integral type by unboxing conversion.
Let G name a generic type declaration with n type parameters.
Unchecked conversion is used to enable a smooth interoperation of legacy code, written before the introduction of generic types, with libraries that have undergone a conversion to use genericity (a process we call generification)
In such circumstances (most notably, clients of the Collections Framework in java.util), legacy code uses raw types (e.g.
Expressions of raw types are passed as arguments to library methods that use parameterized versions of those same types as the types of their corresponding formal parameters.
Such calls cannot be shown to be statically safe under the type system using generics.
Rejecting such calls would invalidate large bodies of existing code, and prevent them from using newer versions of the libraries.
This in turn, would discourage library vendors from taking advantage of genericity.
To prevent such an unwelcome turn of events, a raw type may be converted to an arbitrary invocation of the generic type declaration to which the raw type refers.
While the conversion is unsound, it is tolerated as a concession to practicality.
If Ti is a wildcard type argument of the form ? extends Bi, then Si is a fresh lower bound is the null type.
It is a compile-time error if, for any two classes (not interfaces) Vi and Vj, Vi is not a subclass of Vj or vice versa.
If Ti is a wildcard type argument of the form ? super Bi, then Si is a fresh type is Bi.
Capture conversion never requires a special action at run time and therefore never throws an exception at run time.
It works for any type of list, and so the use of the wildcard type List<?> as the type of the formal parameter is entirely appropriate.
The implementation needs to copy the list, extract elements from the copy, and insert them into the original.
To do this in a type-safe manner, we need to give a name, T, to the element List<?> is a list of unknown type.
It is not a subtype of List<T>, for any type T.
This is undesirable, as it exposes implementation information to the caller.
Worse, the designer of an API might reason that the signature using a wildcard is what the callers of the API require, and only later realize that a type safe implementation was precluded.
The call is harmless, because the incoming argument is doubtless a list of some type (albeit an unknown one)
If we can capture this unknown type in a type variable X, we can infer T to be X.
The specification of course must cope with complications, like non-trivial (and possibly recursively defined) upper or lower bounds, the presence of multiple arguments etc.
Mathematically sophisticated readers will want to relate capture conversion to established type theory.
Readers unfamiliar with type theory can skip this discussion - or else study a suitable text, such as Types and Programming Languages by Benjamin Pierce, and then revisit this section.
Here then is a brief summary of the relationship of capture conversion to established type theoretical notions.
Capture conversion corresponds loosely to an opening of a value of existential type.
A capture conversion of an expression e can be thought of as an open of e in a scope that comprises the top level expression that encloses e.
The classical open operation on existentials requires that the captured type variable must not escape the opened expression.
The open that corresponds to capture conversion is always on a scope sufficiently large that the captured type variable can never be visible outside that scope.
Any type may be converted to type String by string conversion.
If T is byte, short, or int, then use new Integer(x)
This reference value is then converted to type String by string conversion.
Now only reference values need to be considered: ‚Ä¢ If the reference is null, it is converted to the string "null" (four ASCII characters n, u, l, l)
Otherwise, the conversion is performed as if by an invocation of the toString method of the referenced object with no arguments; but if the result of invoking the toString method is null, then the string "null" is used instead.
The toString method is defined by the primordial class Object (¬ß4.3.2)
Value set conversion is the process of mapping a floating-point value from one value set to another without changing its type.
Within an expression that is not FP-strict (¬ß15.4), value set conversion provides choices to an implementation of the Java programming language:
If the value is an element of the float-extended-exponent value set, then the implementation may, at its option, map the value to the nearest element of the float value set.
This conversion may result in overflow (in which case the value is replaced by an infinity of the same sign) or underflow (in which case the value may lose precision because it is replaced by a denormalized number or zero of the same sign)
If the value is an element of the double-extended-exponent value set, then the implementation may, at its option, map the value to the nearest element of the double value set.
This conversion may result in overflow (in which case the value is replaced by an infinity of the same sign) or underflow (in which case the value may lose precision because it is replaced by a denormalized number or zero of the same sign)
If the value is of type double and is not an element of the double value set, then the implementation must map the value to the nearest element of the double value set.
Within an FP-strict expression, mapping values from the float-extended-exponent value set or double-extended-exponent value set is necessary only when a method is invoked whose declaration is not FP-strict and the implementation has chosen to represent the result of the method invocation as an element of an extended-exponent value set.
Whether in FP-strict code or code that is not FP-strict, value set conversion always leaves unchanged any value whose type is neither float nor double.
Assignment conversion occurs when the value of an expression is assigned (¬ß15.26) to a variable: the type of the expression must be converted to the type of the variable.
Assignment contexts allow the use of one of the following:
It is a compile-time error if the chain of conversions contains two parameterized types that are not in the subtype relation.
The first three elements of the chain are related by widening reference conversion, while the last entry is derived from its predecessor by unchecked conversion.
In addition, if the expression is a constant expression (¬ß15.28) of type byte, short, char, or int:
A narrowing primitive conversion may be used if the type of the variable is byte, short, or char, and the value of the constant expression is representable in the type of the variable.
A narrowing primitive conversion followed by a boxing conversion may be used if the type of the variable is: ‚óÜ Byte and the value of the constant expression is representable in the type byte.
Short and the value of the constant expression is representable in the type short.
Character and the value of the constant expression is representable in the type char.
The compile-time narrowing of constants means that code such as:
Without the narrowing, the fact that the integer literal 42 has type int would mean that a cast to byte would be required:
A value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type.
If the type of the expression cannot be converted to the type of the variable by a conversion permitted in an assignment context, then a compile-time error occurs.
If the type of an expression can be converted to the type of a variable by assignment conversion, we say the expression (or its value) is assignable to the variable or, equivalently, that the type of the expression is assignment compatible with the type of the variable.
If v is of type double and is an element of the double-extended-exponent value set, then the implementation must map v to the nearest element of the double value set.
The only exceptions that an assignment conversion may cause are:
A ClassCastException if, after the type conversions above have been applied, the resulting value is an object which is not an instance of a subclass or subinterface of the erasure (¬ß4.6) of the type of the variable.
This circumstance can only arise as a result of heap pollution (¬ß4.12.2)
In practice, implementations need only perform casts when accessing a field or method of an object of parametized type, when the erased type of the field, or the erased result type of the method differ from their unerased type.
A NullPointerException as a result of an unboxing conversion on a null.
The following test program illustrates assignment conversions on reference values, but fails to compile, as described in its comments.
Okay because ColoredPoint is a subclass of Point: // Okay because ColoredPoint implements Colorable: // The following cause compile-time errors because // we cannot be sure they will succeed, depending on // the run-time type of p; a run-time check will be // necessary for the needed narrowing conversion and // must be indicated by including a cast: // nor a subclass of ColoredPoint.
The value of veclong cannot be assigned to a Long variable, because Long is a class type other than Object.
An array can be assigned only to a variable of a compatible array type, or to a variable of type Object, Cloneable or java.io.Serializable.
The value of veclong cannot be assigned to vecshort, because they are arrays of primitive type, and short and long are not the same primitive type.
The value of cpvec can be assigned to pvec, because any reference that could be the value of an expression of type ColoredPoint can be the value of a variable of type Point.
The subsequent assignment of the new Point to a component of pvec then would throw an ArrayStoreException (if the program were otherwise corrected so that it could be compiled), because a ColoredPoint array cannot have an instance of Point as the value of a component.
The value of pvec cannot be assigned to cpvec, because not every reference that could be the value of an expression of type ColoredPoint can correctly be the value of a variable of type Point.
Thus to allow such an assignment would allow a violation of the type system.
It is a compile-time error if the chain of conversions contains two parameterized types that are not in the subtype relation.
A value of the null type (the null reference is the only such value) may be converted to any reference type.
If the type of the expression cannot be converted to the type of the parameter by a conversion permitted in a method invocation context, then a compile-time error occurs.
If an argument value of type double is an element of the double-extendedexponent value set, then the implementation must map the value to the nearest element of the double value set.
The only exceptions that an method invocation conversion may cause are: ‚Ä¢ A ClassCastException if, after the type conversions above have been applied,
This circumstance can only arise as a result of heap pollution (¬ß4.12.2)
A NullPointerException as a result of an unboxing conversion on a null.
Method invocation conversions specifically do not include the implicit narrowing of integer constants which is part of assignment conversion (¬ß5.2)
The designers of the Java programming language felt that including these implicit narrowing conversions would add additional complexity to the overloaded method matching resolution process (¬ß15.12.2)
A language that included implicit narrowing of integer constants would need additional rules to resolve cases like this example.
String conversion applies only to an operand of the binary + operator which is not a String when the other operand is a String.
Casting conversion is applied to the operand of a cast operator (¬ß15.16): the type of the operand expression must be converted to the type explicitly named by the cast operator.
Value set conversion (¬ß5.1.13) is applied after the type conversion.
The compile-time legality of a casting conversion is as follows:
An expression of a primitive type may undergo casting conversion to another primitive type, by an identity conversion (if the types are the same), or by a widening primitive conversion, or by a narrowing primitive conversion, or by a widening and narrowing primitive conversion.
An expression of a primitive type may undergo casting conversion to a reference type without error, by boxing conversion.
An expression of a reference type may undergo casting conversion to a primitive type without error, by unboxing conversion.
An expression of a reference type may undergo casting conversion to another reference type if no compile-time error occurs given the rules in ¬ß5.5.1
The following tables enumerate which conversions are used in certain casting conversions.
In the tables, a comma between symbols indicates that a casting conversion uses one conversion followed by another.
To ‚Üí byte short char int long float double boolean.
Given a compile-time reference type S (source) and a compile-time reference type T (target), a casting conversion exists from S to T if no compile-time errors occur due to the following rules.
Furthermore, if there exists a supertype X of T, and a supertype Y of S, such that both X and Y are provably distinct parameterized types (¬ß4.5), and that the erasures of X and Y are the same, a compile-time error occurs.
Otherwise, the cast is always legal at compile time (because even if S does not implement T, a subclass of S might)
If S is a final class (¬ß8.1.1), then S must implement T, or a compile-time error occurs.
If T is a type variable, then this algorithm is applied recursively, using the upper bound of T in place of T.
If T is an array type, then S must be the class Object, or a compile-time error occurs.
If T is an array type, then S must be the type java.io.Serializable or Cloneable (the only interfaces implemented by arrays), or a compile-time error occurs.
If T is a type that is not final (¬ß8.1.1), then if there exists a supertype X of T, and a supertype Y of S, such that both X and Y are provably distinct parameterized types, and that the erasures of X and Y are the same, a compile-time error occurs.
Otherwise, the cast is always legal at compile time (because even if T does not implement S, a subclass of T might)
If T is a type that is final, then: ‚óÜ If S is not a parameterized type or a raw type, then T must implement S, or a.
Otherwise, S is either a parameterized type that is an invocation of some.
Then there must exist a supertype X of T, such that X is an invocation of G, or a compile-time error occurs.
Furthermore, if S and X are provably distinct parameterized types then a compile-time error occurs.
If S is a type variable, then this algorithm is applied recursively, using the upper bound of S in place of S.
That is, the success of the cast is determined by the most restrictive component of the intersection type.
If S is an array type SC[], that is, an array of components of type SC:
If T is a class type, then if T is not Object, then a compile-time error occurs (because Object is the only class type to which arrays can be assigned)
If T is an interface type, then a compile-time error occurs unless T is the type java.io.Serializable or the type Cloneable (the only interfaces implemented by arrays)
If T is a type variable, then: ‚óÜ If the upper bound of T is Object or java.io.Serializable or Cloneable,
Colorable c; // The following may cause errors at run time because // we cannot be sure they will succeed; this possibility // is suggested by the casts: // object which is a ColoredPoint.
Here, the first compile-time error occurs because the class types Long and Point are unrelated (that is, they are not the same, and neither is a subclass of the other), so a cast between them will always fail.
The second compile-time error occurs because a variable of type EndPoint can never reference a value that implements the interface Colorable.
This is because EndPoint is a final type, and a variable of a final type always holds a value of the same run-time type as its compile-time type.
Therefore, the run-time type of variable e must be exactly the type EndPoint, and type EndPoint does not implement Colorable.
A cast from a type S to a type variable T is unchecked unless S <: T.
An unchecked cast causes a compile-time unchecked warning, unless suppressed by the SuppressWarnings annotation (¬ß9.6.3.5)
A cast is checked if it is not statically known to be correct and it is not unchecked.
If a cast to a reference type is not a compile-time error, there are several cases:
If the value at run time is null, then the cast is allowed.
Otherwise, let R be the class of the object referred to by the run-time reference value, and let T be the erasure (¬ß4.6) of the type named in.
A cast conversion must check, at run time, that the class R is assignment compatible with the type T, via the algorithm in ¬ß5.5.3
Note that R cannot be an interface when these rules are first applied for any given cast, but R may be an interface if the rules are applied recursively because the run-time reference value may refer to an array whose element type is an interface type.
Here is the algorithm to check whether the run-time type R of an object is assignment compatible with the type T which is the erasure (¬ß4.6) of the type named in the cast operator.
If a run-time exception is thrown, it is a ClassCastException.
If T is an interface type, then R must implement (¬ß8.1.5) interface T, or a runtime exception is thrown.
If T is an array type, then a run-time exception is thrown.
If T is a class type, then T must be Object (¬ß4.3.2), or a run-time exception is thrown.
If T is an interface type, then R must be either the same interface as T or a subinterface of T, or a run-time exception is thrown.
If T is an array type, then a run-time exception is thrown.
If R is a class representing an array type RC[], that is, an array of components of type RC:
If T is a class type, then T must be Object (¬ß4.3.2), or a run-time exception is thrown.
If T is an interface type, then a run-time exception is thrown unless T is the type java.io.Serializable or the type Cloneable (the only interfaces implemented by arrays)
This case could slip past the compile-time checking if, for example, a reference to an array were stored in a variable of type Object.
This program uses casts to compile, but it throws exceptions at run time, because the types are incompatible.
Numeric promotion is applied to the operands of an arithmetic operator.
Numeric promotions are used to convert the operands of a numeric operator to a common type so that an operation can be performed.
Some operators apply unary numeric promotion to a single operand, which must produce a value of a numeric type: ‚Ä¢ If the operand is of compile-time type Byte, Short, Character, or Integer, it.
Otherwise, if the operand is of compile-time type Long, Float, or Double, it is subjected to unboxing conversion (¬ß5.1.8)
Otherwise, if the operand is of compile-time type byte, short, or char, it is promoted to a value of type int by a widening primitive conversion (¬ß5.1.2)
Otherwise, a unary numeric operand remains as is and is not converted.
In any case, value set conversion (¬ß5.1.13) is then applied.
A long shift distance (right operand) does not promote the value being shifted (left operand) to long.
When an operator applies binary numeric promotion to a pair of operands, each of which must denote a value that is convertible to a numeric type, the following rules apply, in order:
Otherwise, if either operand is of type float, the other is converted to float.
Otherwise, if either operand is of type long, the other is converted to long.
After the type conversion, if any, value set conversion (¬ß5.1.13) is applied to each operand.
The example converts the ASCII character G to the ASCII control-G (BEL), by masking off all but the low 5 bits of the character.
The 7 is the numeric value of this control character.
A declared entity (¬ß6.1) is a package, class type (normal or enum), interface type (normal or annotation type), member (class, interface, field, or method) of a reference type, type parameter (of a class, interface, method or constructor), parameter (to a method, constructor, or exception handler), or local variable.
Names in programs are either simple, consisting of a single identifier, or qualified, consisting of a sequence of identifiers separated by "." tokens (¬ß6.2)
Every declaration that introduces a name has a scope (¬ß6.3), which is the part of the program text within which the declared entity can be referred to by a simple name.
A qualified name N.x may be used to refer to a member of a package or reference type, where N is a simple or qualified name and x is an identifier.
If N names a reference type or a variable of a reference type, then x names a member of that type, which is either a class, an interface, a field, or a method.
In determining the meaning of a name (¬ß6.5), the context of the occurrence is used to disambiguate among packages, types, variables, and methods with the same name.
Access control (¬ß6.6) can be specified in a class, interface, method, or field declaration to control when access to a member is allowed.
The default access is that a member can be accessed anywhere within the package that contains its declaration; other possibilities are.
Fully qualified and canonical names (¬ß6.7) are also discussed in this chapter.
A declaration introduces an entity into a program and includes an identifier (¬ß3.8) that can be used in a name to refer to this entity.
A parameter of an exception handler declared in a catch clause of a try statement (¬ß14.20)
Constructors (¬ß8.8) are also introduced by declarations, but use the name of the class in which they are declared rather than introducing a new name.
The class libraries of the Java SE platform attempt to use, whenever possible, names chosen according to the conventions presented below.
These conventions help to make code more readable and avoid certain kinds of name conflicts.
We recommend these conventions for use in all programs written in the Java programming language.
However, these conventions should not be followed slavishly if long-held conventional usage dictates otherwise.
So, for example, the sin and cos methods of the class java.lang.Math have mathematically conventional names, even though these method names flout the convention suggested here because they are short and are not verbs.
Developers should take steps to avoid the possibility of two published packages having the same name by choosing unique package names for packages that are widely distributed.
This allows packages to be easily and automatically installed and catalogued.
This section specifies a suggested convention for generating such unique package names.
Implementations of the Java SE platform are encouraged to provide automatic support for converting a set of packages from local and casual package names to the unique name format described here.
If unique package names are not used, then package name conflicts may arise far from the point of creation of either of the conflicting packages.
This may create a situation that is difficult or impossible for the user or programmer to resolve.
The class ClassLoader can be used to isolate packages with the same name from each other in those cases where the program.
You form a unique package name by first having (or belonging to an organization that has) an Internet domain name, such as oracle.com.
You then reverse this name, component by component, to obtain, in this example, com.oracle, and use this as a prefix for your package names, using a convention developed within your organization to further administer package names.
Such a convention might specify that certain package name components be division, department, project, machine, or login names.
The first component of a unique package name is always written in all-lowercase ASCII letters and should be one of the top level domain names, such as com, edu, gov, mil, net, or org, or one of the English two-letter codes identifying countries as specified in ISO Standard 3166
The name of a package is not meant to imply where the package is stored on the Internet.
The suggested convention for generating unique package names is merely a way to piggyback a package naming convention on top of an existing, widely known unique name registry instead of having to create a separate registry for package names.
For example, a package named edu.cmu.cs.bovik.cheese is not necessarily obtainable from Internet address cmu.edu or cs.cmu.edu or bovik.cs.cmu.edu.
In some cases, the Internet domain name may not be a valid package name.
Here are some suggested conventions for dealing with these situations:
If the domain name contains a hyphen, or any other special character not allowed in an identifier (¬ß3.8), convert it into an underscore.
If any of the resulting package name components are keywords (¬ß3.9), append an underscore to them.
If any of the resulting package name components start with a digit, or any other character that is not allowed as an initial character of an identifier, have an underscore prefixed to the component.
Names of packages intended only for local use should have a first identifier that begins with a lowercase letter, but that first identifier specifically should not be the identifier java; platform.
Names of class types should be descriptive nouns or noun phrases, not overly long, in mixed case with the first letter of each word capitalized.
Likewise, names of interface types should be short and descriptive, not overly long, in mixed case with the first letter of each word capitalized.
The name may be a descriptive noun or noun phrase, which is appropriate when an interface is used as if it were an abstract superclass, such as interfaces java.io.DataInput and java.io.DataOutput; or it may be an adjective describing a behavior, as for the interfaces Runnable and Cloneable.
Type variable names should be pithy (single character if possible) yet evocative, and should not include lower case letters.
This makes it easy to distinguish type parameters from ordinary classes and interfaces.
Container types should use the name E for their element type.
Maps should use K for the type of their keys and V for the type of their values.
The name X should be used for arbitrary exception types.
We use T for type, whenever there is not anything more specific about the type to distinguish it.
If there are multiple type parameters that denote arbitrary types, one should use letters that neighbor T in the alphabet, such as S.
In such cases, all the variables with the same prefix should be subscripted.
If a generic method appears inside a generic class, it is a good idea to avoid using the same names for the type parameters of the method and class, to avoid confusion.
When type parameters do not fall conveniently into one of the categories mentioned, names should be chosen to be as meaningful as possible within the confines of a single letter.
The names mentioned above (E, K, V, X, T) should not be used for type parameters that do not fall into the designated categories.
Method names should be verbs or verb phrases, in mixed case, with the first letter lowercase and the first letter of any subsequent words capitalized.
Methods to get and set an attribute that might be thought of as a variable V should be named getV and setV.
An example is the methods getPriority and setPriority of class Thread.
A method that returns the length of something should be named length, as in class String.
A method that tests a boolean condition V about an object should be named isV.
A method that converts its object to a particular format F should be named toF.
Examples are the method toString of class Object and the methods toLocaleString and toGMTString of class java.util.Date.
Whenever possible and appropriate, basing the names of methods in a new class on names in an existing class that is similar, especially a class from the Java SE platform API, will make it easier to use.
Names of fields that are not final should be in mixed case with a lowercase first letter and the first letters of subsequent words capitalized.
Note that well-designed classes have very few public or protected fields, except for fields that are constants (static final fields)
Fields should have names that are nouns, noun phrases, or abbreviations for nouns.
Examples of this convention are the fields buf, pos, and count of the class java.io.ByteArrayInputStream and the field bytesTransferred of the class java.io.InterruptedIOException.
The names of constants in interface types should be, and final variables of class types may conventionally be, a sequence of one or more words, acronyms, or abbreviations, all uppercase, with components separated by underscore "_" characters.
A group of constants that represent alternative values of a set, or, less frequently, masking bits in an integer value, are sometimes usefully specified with a common acronym as a name prefix.
Local variable and parameter names should be short, yet meaningful.
They are often short sequences of lowercase letters that are not words, such as:
Acronyms, that is the first letter of a series of words, as in cp for a variable holding a reference to a ColoredPoint.
Abbreviations, as in buf holding a pointer to a buffer of some kind.
Mnemonic terms, organized in some way to aid memory and understanding, typically by using a set of local variables with conventional names patterned after the names of parameters to widely used classes.
One-character local variable or parameter names should be avoided, except for temporary and looping variables, or where a variable holds an undistinguished value of a type.
Local variable or parameter names that consist of only two or three lowercase letters should not conflict with the initial country codes and domain names that are the first component of unique package names.
A name is used to refer to an entity declared in a program.
There are two forms of names: simple names and qualified names.
A qualified name consists of a name, a "." token, and an identifier.
In determining the meaning of a name (¬ß6.5), the context in which the name appears is taken into account.
Packages and reference types have members which may be accessed by qualified names.
Not all identifiers in a program are a part of a name.
In declarations (¬ß6.1), where an identifier may occur to specify the name by which the declared entity will be known.
In field access expressions (¬ß15.11), where an identifier occurs after a "." token to indicate a member of an object that is the value of an expression or the keyword super that appears before the "." token.
In some method invocation expressions (¬ß15.12), where an identifier may occur after a "." token and before a "(" token to indicate a method to be invoked for an object that is the value of an expression or the keyword super that appears before the "." token.
In qualified class instance creation expressions (¬ß15.9), where an identifier occurs immediately to the right of the leftmost new token to indicate a type that must be a member of the compile-time type of the primary expression preceding the "." preceding the leftmost new token.
Rather, they are used in declarations to specify the names of the declared entities.
A field access expression, like a method invocation expression, uses an identifier rather than a name to denote the member of interest.)
One might wonder why these kinds of expression use an identifier rather than a simple name, which is after all just an identifier.
The reason is that a simple expression name is defined in terms of the lexical environment; that is, a simple expression name must be in the scope of a variable declaration.
But field access, and method invocation qualified by a Primary, and qualified class instance creation all denote members whose names are not in the lexical environment.
By definition, such names are bound only in the context provided by the Primary of the field access expression, method invocation expression, or class instance creation expression.
Therefore, we denote such members with identifiers rather than simple names.
To complicate things further, a field access expression is not the only way to denote a field of an object.
For parsing reasons, a qualified name is used to denote a field of an inscope variable.
The variable itself is denoted with a simple name, alluded to above.) It is necessary for access control (¬ß6.6) to capture both mechanisms for denoting a field.
The following code was taken from a version of the class String and its method indexOf, where the label was originally called test.
Changing the label to have the same name as the local variable i does not obscure (¬ß6.4.2) the label in the scope of the declaration of i.
The identifier max could also have been used as the statement label; the label would not obscure the local variable max within the labeled statement.
The scope of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name, provided it is visible (¬ß6.4.1)
A declaration is said to be in scope at a particular point in a program if and only if the declaration's scope includes that point.
The declaration of a package that is not observable is never in scope.
The scope of a top level type (¬ß7.6) is all type declarations in the package in which the top level type is declared.
The scope of a declaration of a member m declared in or inherited by a class type C (¬ß8.1.6) is the entire body of C, including any nested type declarations.
The scope of a declaration of a member m declared in or inherited by an interface type I (¬ß9.1.4) is the entire body of I, including any nested type declarations.
The scope of an enum constant C declared in an enum type T is the body of T, and any case label of a switch statement whose expression is of enum type T.
The scope of a class's type parameter (¬ß8.1.2) is the type parameter section of the class declaration, the type parameter section of any superclass or superinterface of the class declaration, and the class body.
The scope of an interface's type parameter (¬ß9.1.2) is the type parameter section of the interface declaration, the type parameter section of any superinterface of the interface declaration, and the interface body.
The scope of a method's type parameter (¬ß8.4.4) is the entire declaration of the method, including the type parameter section, but excluding the method modifiers.
The scope of a constructor's type parameter (¬ß8.8.4) is the entire declaration of the constructor, including the type parameter section, but excluding the constructor modifiers.
The scope of a local class declaration immediately enclosed by a block (¬ß14.2) is the rest of the immediately enclosing block, including its own class declaration.
The scope of a local class declaration immediately enclosed by a switch block statement group (¬ß14.11) is the rest of the immediately enclosing switch block statement group, including its own class declaration.
The scope of a local variable declaration in a block (¬ß14.4) is the rest of the block in which the declaration appears, starting with its own initializer and including any further declarators to the right in the local variable declaration statement.
The scope of a parameter of an exception handler that is declared in a catch clause of a try statement (¬ß14.20) is the entire block associated with the catch.
The scope of a variable declared in the ResourceSpecification of a try-withresources statement (¬ß14.20.3) is from the declaration rightward over the remainder.
The translation of a try-with-resources statement implies the rule above.
These rules imply that declarations of class and interface types need not appear before uses of the types.
In the following program, the use of PointList in class Point is valid, because the scope of the class declaration PointList includes both class Point and class PointList, as well as any other type declarations in other compilation units of package points.
This program causes a compile-time error because the initialization of x is within the scope of the declaration of x as a local variable, and the local variable x does not yet have a value and cannot be used.
In the following program, the initializer for three can correctly refer to the variable two declared in an earlier declarator, and the method invocation in the next line can correctly refer to the variable three declared earlier in the block.
Some declarations are not permitted within the scope of a local variable, formal parameter, exception parameter, or local class declaration because it would be impossible to distinguish between the declared entities using only simple names.
For example, if the name of a formal parameter of a method could be redeclared as the name of a local variable in the method body, then the local variable would shadow the formal parameter and the formal parameter would no longer be visible - an undesirable outcome.
It is a compile-time error if the name of a formal parameter is redeclared as a local variable of the method or constructor; or as an exception parameter of a catch clause in a try statement in the body of the method or constructor; or as a resource in a try-with-resources statement in the body of the method or constructor.
It is a compile-time error if the name of a local variable v is redeclared as a local variable of the directly enclosing method, constructor, or initializer block within the scope of v; or as an exception parameter of a catch clause in a try statement of the directly enclosing method, constructor or initializer block within the scope of v; or as a resource in a try-with-resources statement of the directly enclosing method, constructor or initializer block within the scope of v.
It is a compile-time error if the name of a local class C is redeclared as a local class of the directly enclosing method, constructor, or initializer block within the scope of C.
It is a compile-time error if the name of an exception parameter is redeclared within the Block of the catch clause as a local variable of the directly enclosing method, constructor, or initializer block; or as an exception parameter of a catch clause in a try statement of the directly enclosing method, constructor or initializer block; or as a resource in a try-with-resources statement of the directly enclosing method, constructor or initializer block.
It is a compile-time error if the name of a variable declared in a ResourceSpecification of a try-with-resources statement (¬ß14.20.3) is redeclared within the try Block as a local variable of the directly enclosing method, constructor, or initializer block, or as an exception parameter of a catch clause in a try statement of the directly enclosing method or initializer block.
The translation of a try-with-resources statement implies the rule above.
Despite the above rules against redeclaration of variables, the rules of shadowing (¬ß6.4.1) allow redeclaration in certain nested class declarations (i.e.
A formal parameter of a method or constructor may be shadowed anywhere inside a class declaration nested within that method or constructor.
A local variable of a method, constructor, or initializer may be shadowed anywhere inside a class declaration nested within the scope of the local variable.
A local class declaration may be shadowed anywhere inside a class declaration nested within the local class declaration's scope.
An exception parameter may be shadowed anywhere inside a class declaration nested within the Block of the catch clause.
A variable declared in a ResourceSpecification may be shadowed anywhere inside a class declaration nested within the try Block.
Because a declaration of an identifier as a local variable of a method, constructor, or initializer block must not appear within the scope of a parameter or local variable of the same name, a compile-time error occurs for the following program:
This restriction helps to detect some otherwise very obscure bugs.
A similar restriction on shadowing of members by local variables was judged impractical, because the addition of a member in a superclass could cause subclasses to have to rename local variables.
Related considerations make restrictions on shadowing of local variables by members of nested classes, or on shadowing of local variables by local variables declared within nested classes unattractive as well.
On the other hand, local variables with the same name may be declared in two separate blocks or for statements, neither of which contains the other:
This program compiles without error and, when executed, produces the output:
Some declarations may be shadowed in part of their scope by another declaration of the same name, in which case a simple name cannot be used to refer to the declared entity.
A declaration d is said to be visible at point p in a program if the scope of d includes p, and d is not shadowed by any other declaration at p.
When the program point we are discussing is clear from context, we will often simply say that a declaration is visible.
A declaration d of a type named n shadows the declarations of any other types named n that are in scope at the point where d occurs throughout the scope of d.
A declaration d of a field or formal parameter named n shadows, throughout the scope of d, the declarations of any other variables named n that are in scope at the point where d occurs.
A declaration d of a local variable or exception parameter named n shadows, throughout the scope of d, (a) the declarations of any other fields named n that are in scope at the point where d occurs, and (b) the declarations of any other variables named n that are in scope at the point where d occurs but are not declared in the innermost class in which d is declared.
A declaration d of a method named n shadows the declarations of any other methods named n that are in an enclosing scope at the point where d occurs throughout the scope of d.
A type-import-on-demand declaration never causes any other declaration to be shadowed.
A static-import-on-demand declaration never causes any other declaration to be shadowed.
A single-static-import declaration d in a compilation unit c of package p that static method named n with signature s imported by a static-import-on-demand declaration in c, throughout c.
Since the scope of a class variable includes the entire body of the class (¬ß8.2), the class variable x would normally be available throughout the entire body of the method main.
In this example, however, the class variable x is shadowed within the body of the method main by the declaration of the local variable x.
The expression x in the invocation of print refers to (denotes) the value of the local variable x.
The invocation of println uses a qualified name (¬ß6.6) Test.x, which uses the class type name Test to access the class variable x, because the declaration of Test.x is shadowed at this point and cannot be referred to by its simple name.
The keyword this can also be used to access a shadowed field x, using the form this.x.
Here, the constructor takes parameters having the same names as the fields to be initialized.
This is simpler than having to invent different names for the parameters and is not too confusing in this stylized context.
In general, however, it is considered poor style to have local variables with the same names as fields.
A simple name may occur in contexts where it may potentially be interpreted as the name of a variable, a type, or a package.
Thus, it is may sometimes be impossible to refer to a visible type or package declaration via its simple name.
The naming conventions of ¬ß6.1 help reduce obscuring, but if it does occur, here are some notes about what you can do to avoid it.
If a package name is obscured by a field declaration, then import declarations (¬ß7.5) can usually be used to make available the type names declared in that package.
If a package name is obscured by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code.
The first component of a package name is normally not easily mistaken for a type name, as a type name normally begins with a single uppercase letter.
The Java programming language does not actually rely on case distinctions to determine whether a name is a package name or a type name.)
Names of fields, parameters, and local variables normally do not obscure type names because they conventionally begin with a lowercase letter whereas type names conventionally begin with an uppercase letter.
Method names cannot obscure or be obscured by other names (¬ß6.5.7)
If a field name obscures a package name, then an import declaration (¬ß7.5) can usually be used to make available the type names declared in that package.
If a field name obscures a type name, then a fully qualified name for the type can be used unless the type name denotes a local class (¬ß14.3)
If a field name is shadowed by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code.
Constant names normally have no lowercase letters, so they will not normally obscure names of packages or types, nor will they normally shadow fields, whose names typically contain at least one lowercase letter.
Constant names cannot obscure method names, because they are distinguished syntactically.
The meaning of a name depends on the context in which it is used.
The determination of the meaning of a name requires three steps: ‚Ä¢ First, context causes a name syntactically to fall into one of.
Second, a name that is initially classified by its context as an AmbiguousName or as a PackageOrTypeName is then reclassified to be a PackageName, TypeName, or ExpressionName.
Third, the resulting category then dictates the final determination of the meaning of the name (or a compile-time error if the name has no meaning)
Identifier The use of context helps to minimize name conflicts between entities of different kinds.
Such conflicts will be rare if the naming conventions described in ¬ß6.1 are followed.
Nevertheless, conflicts may arise unintentionally as types developed by different.
For example, types, methods, and fields may have the same name.
It is always possible to distinguish between a method and a field with the same name, since the context of a use always tells whether a method is intended.
As the class type which is to be instantiated in an unqualified class instance.
As the element type of an array to be created in an array creation expression (¬ß15.10)
A name is syntactically classified as an ExpressionName in these contexts: ‚Ä¢ As the qualifying expression in a qualified superclass constructor invocation.
The effect of syntactic classification is to restrict certain kinds of entities to certain parts of expressions:
The name of a field, parameter, or local variable may be used as an expression (¬ß15.14.1)
The name of a method may appear in an expression only as part of a method invocation.
The name of a class or interface type may appear in an expression only as part of a.
The name of a package may appear in an expression only as part of a qualified name for a class or interface type.
A later step determines whether or not a package of that name actually exists.
If the AmbiguousName is a qualified name, consisting of a name, a ".", and an Identifier, then the name to the left of the "." is first reclassified, for it is itself an AmbiguousName.
There is then a choice: ‚Ä¢ If the name to the left of the "." is reclassified as a PackageName, then:
If there is a package whose name is the name to the left of the "." and that package contains a declaration of a type whose name is the same as the Identifier, then this AmbiguousName is reclassified as a TypeName.
A later step determines whether or not a package of that name actually exists.
If the name to the left of the "." is reclassified as a TypeName, then: ‚óÜ If the Identifier is the name of a method or field of the type denoted by.
Otherwise, if the Identifier is the name of a member type of the type denoted.
If the name to the left of the "." is reclassified as an ExpressionName, then let T be the type of the expression denoted by ExpressionName.
If the Identifier is the name of a method or field of the type denoted by T, this.
First of all, the name org.rpgpoet.Music.wizards.length is classified as an ExpressionName because it functions as a PostfixExpression.
The simple name org is reclassified as a PackageName (since there is no variable or type named org in scope)
Next, assuming that there is no class or interface named rpgpoet in any compilation unit of package org (and we know that there is no such class or interface because package org has a subpackage named rpgpoet), the qualified name org.rpgpoet is reclassified as a PackageName.
Next, because package org.rpgpoet has an accessible (¬ß6.6) interface type named Music, the qualified name org.rpgpoet.Music is reclassified as a TypeName.
Finally, because the name org.rpgpoet.Music is a TypeName, the qualified name org.rpgpoet.Music.wizards is reclassified as an ExpressionName.
The meaning of a name classified as a PackageName is determined as follows.
If a package name consists of a single Identifier, then this identifier denotes a top level package named by that identifier.
If no top level package of that name is in scope (¬ß6.3), then a compile-time error occurs.
If a package name is of the form Q.Id, then Q must also be a package name.
The If Q does not name an observable package (¬ß7.4.3), or Id is not the simple name of an observable subpackage of that package, then a compile-time error occurs.
If the PackageOrTypeName, Q, occurs in the scope of a type named Q, then the PackageOrTypeName is reclassified as a TypeName.
The meaning of the PackageOrTypeName is the meaning of the reclassified name.
Given a qualified PackageOrTypeName of the form Q.Id, if the type or package denoted by Q has a member type named Id, then the qualified PackageOrTypeName name is reclassified as a TypeName.
The meaning of the qualified PackageOrTypeName is the meaning of the reclassified name.
The meaning of a name classified as a TypeName is determined as follows.
If a type name consists of a single Identifier, then the identifier must occur in the scope of exactly one visible declaration of a type with this name, or a compile-time error occurs.
If a type name is of the form Q.Id, then Q must be either a type name or a package name.
This program produced the following output the first time it was run:
In this example, the name java.util.Date must denote a type, so we first use the procedure recursively to determine if java.util is an accessible type or a package, which it is, and then look to see if the type Date is accessible in this package.
The meaning of a name classified as an ExpressionName is determined as follows.
If an expression name consists of a single Identifier, then there must be exactly one declaration denoting either a local variable, parameter, or field visible (¬ß6.4.1) at the point at which the Identifier occurs.
If the declaration declares a final variable which is definitely assigned before the simple expression, the meaning of the name is the value of that variable.
Otherwise, the meaning of the expression name is the variable declared by the declaration.
If the expression name appears in a context where it is subject to assignment conversion or method invocation conversion or casting conversion, then the type of the expression name is the declared type of the field, local variable, or parameter after capture conversion (¬ß5.1.10)
Otherwise, the type of the expression name is the declared type of the field, local variable or parameter.
That is, if the expression name appears "on the right hand side", its type is subject to capture conversion.
If the expression name is a variable that appears "on the left hand side", its type is not subject to capture conversion.
In this program, the names used as the left-hand-sides in the assignments to i, v, and f denote the local variable i, the field v, and the value of f (not the variable f, because f is a final variable)
The example therefore produces an error at compile time because the last assignment does not have a variable as its left-hand side.
If the erroneous assignment is removed, the modified code can be compiled and it will produce the output:
If an expression name is of the form Q.Id, then Q has already been classified as a.
If Q is a package name, then a compile-time error occurs.
Otherwise, if the single accessible member field is not a class variable (that is, it.
Otherwise, if the class variable is declared final, then Q.Id denotes the value of the class variable.
The type of the expression Q.Id is the declared type of the class variable after capture conversion (¬ß5.1.10)
If Q.Id appears in a context that requires a variable and not a value, then a compile-time error occurs.
The type of the expression Q.Id is the declared type of the class variable after capture conversion (¬ß5.1.10)
Note that this clause covers the use of enum constants (¬ß8.9), since these always have a corresponding final class variable.
The type of the expression Q.Id is the declared type of the field after capture conversion (¬ß5.1.10)
If Q.Id appears in a context that requires a variable and not a value, then a compile-time error occurs.
If Q is an expression name, let T be the type of the expression Q: ‚Ä¢ If T is not a reference type, a compile-time error occurs.
If there is not exactly one accessible (¬ß6.6) member of the type T that is a field named Id, then a compile-time error occurs.
The type of the expression Q.Id is the declared type of the field after capture conversion (¬ß5.1.10)
If Q.Id appears in a context that requires a variable and not a value, and the field denoted by Q.Id is definitely assigned, then a compile-time error occurs.
Otherwise, Q.Id denotes a variable, the field Id of class T, which may be either a class variable or an instance variable.
The type of the expression Q.Id is the type of the field member after capture conversion (¬ß5.1.10)
This program encounters two compile-time errors, because the int variable i has no members, and because nPoints is not a method of class Point.
Note that expression names may be qualified by type names, but not by types in general.
A consequence is that it is not possible to access a class variable through a parameterized type.
This does not restrict the Java programming language in any meaningful way.
Type parameters may not be used in the types of static variables, and so the type arguments of a parameterized type can never influence the type of a static variable.
Technically, the type name Foo above is a raw type, but this use of raw types is harmless, and does not give rise to warnings.
The meaning of a name classified as a MethodName is determined as follows.
A simple method name may appear as the element name in an element-value pair.
In that case, the Identifier in an ElementValuePair must be the simple name of one of the elements of the annotation type identified by TypeName in the containing annotation, or a compile-time error occurs.
In other words, the identifier in an element-value pair must also be a method name in the interface identified by TypeName.
Otherwise, a simple method name necessarily appears in the context of a method invocation expression.
In that case, if a method name consists of a single Identifier, then Identifier is the method name to be used for method invocation.
The following program demonstrates the role of method visibility when determining which method to invoke.
It is the method Test.f1(int), whose declaration is in scope throughout the body of Test including the anonymous class declaration.
First, the declaration of the method Super.f2(String) is in scope throughout the anonymous class declaration.
Second, the declaration of the method Test.f2(int) is in scope throughout the body of Test including the anonymous class declaration.
Third, the declaration of the method Test.f3(int) is in scope throughout the body of Test including the anonymous class declaration.
Choosing to search a nested class's superclass hierarchy before than the lexically enclosing scope is called the "comb rule" (¬ß15.12.1)
A qualified method name can only appear in the context of a method invocation expression.
If a method name is of the form Q.Id, then Q has already been classified as a package name, a type name, or an expression name:
If Q is a package name, then a compile-time error occurs.
Otherwise, Q is a type name or an expression name.
Id is the method name to be used for method invocation.
If Q is a type name, then Id must name at least one static method of the type Q, or a compile-time error occurs by the rules of ¬ß15.12
If Q is an expression name, then let T be the type of the expression Q.
Id must name at least one method of the type T, or a compile-time error occurs by the rules of ¬ß15.12
Like expression names, method names may be qualified by type names, but not by types in general.
The implications are similar to those for expression names as discussed in ¬ß6.5.6.2
The Java programming language provides mechanisms for access control, to prevent the users of a package or class from depending on unnecessary details of the implementation of that package or class.
If access is permitted, then the accessed entity is said to be accessible.
Note that accessibility is a static property that can be determined at compile time; it depends only on types and declaration modifiers.
Qualified names are a means of access to members of packages and reference types.
Each of these expressions uses identifiers, rather than names, for the reason given in ¬ß6.2
Consequently, access control to members (whether fields, methods, types) is applied explicitly by field access expressions, method invocation expressions, and qualified class instance creation expressions.
Note that access to a field may also be denoted by a qualified name occuring as a postfix expression.)
Note that qualified names, field access expressions, method invocation expressions, and qualified class instance creation expressions are syntactically similar in that a "." token appears, preceded by some indication of a package, type, or expression having a type, and followed by an Identifier that names a member of the package or type.
Many statements and expressions allow the use of types rather than type names.
For example, a class declaration may use a parameterized type (¬ß4.5) to denote a superclass.
Because a parameterized type is not a qualified type name, it is necessary for the class.
Consequently, most of the statements and expressions that provide contexts in ¬ß6.5.1 to classify a TypeName must also perform their own access control checks.
Beyond access to members of a package or reference type, there is the matter of access to constructors of a reference type.
Access control must be checked when a constructor is invoked explicitly or implicitly.
These "manual" checks are necessary because ¬ß6.5.1 ignores explicit constructor invocation statements (because they reference constructor names indirectly) and is unaware of the distinction between the class type denoted by an unqualified class instance creation expression and a constructor of that class type.
Also, constructors do not have qualified names, so we cannot rely on access control being checked during classification of qualified type names.
If a class or interface type is declared public, then it may be accessed by.
If a top level class or interface type is not declared public, then it may be accessed only from within the package in which it is declared.
An array type is accessible if and only if its element type is accessible.
A member (class, interface, field, or method) of a reference (class, interface,
Otherwise, if the member or constructor is declared protected, then access is.
Otherwise, if the member or constructor is declared private, then access is permitted if and only if it occurs within the body of the top level class (¬ß7.6) that encloses the declaration of the member or constructor.
Otherwise, we say there is default access, which is permitted only when the access occurs from within the package in which the type is declared.
The class type PointVec is not public and not part of the public interface of the.
The class type Point is declared public and is available to other packages.
It is part of the public interface of the package points.
The methods move, getX, and getY of the class Point are declared public and so are available to any code that uses an object of type Point.
The fields x and y are declared protected and are accessible outside the package points only in subclasses of class Point, and only when they are fields of objects that are being implemented by the code that is accessing them.
See ¬ß6.6.2 for an example of how the protected access modifier limits access.
A public class member or constructor is accessible throughout the package where it is declared and from any other package, provided the package in which it is declared is observable (¬ß7.4.3)
These public members are accessible to any other package that has access to package points.
The fields x and y are not public and therefore are accessible only from within the package points.
If a class lacks the public modifier, access to the class declaration is limited to the package in which it is declared (¬ß6.6)
The class Point is available outside the package points, while the class PointList is available for access only within the using its fully qualified name:
However, this compilation unit cannot use or import points.PointList, which is not declared public and is therefore inaccessible outside package points.
If none of the access modifiers public, protected, or private are specified, a class member or constructor is accessible throughout the package that contains the declaration of the class in which the class member is declared, but the class member or constructor is not accessible in any other package.
If a public class has a method or constructor with default access, then this method or constructor is not accessible to or inherited by a subclass declared outside this package.
Because move of Point is not overridden by move in PlusPoint, the method moveAlso in Point never calls the method move in PlusPoint.
Thus if you delete the super.move call from PlusPoint and execute the test program:
If move of Point were overridden by move in PlusPoint, then this program would recurse infinitely, until a StackOverflowError occurred.
A private class member or constructor is accessible only within the body of the top level class (¬ß7.6) that encloses the declaration of the member or constructor.
They may not be accessed by qualified names, field access expressions, or method invocation expressions outside the body of the declaration of Point.
See ¬ß8.8.8 for an example that uses a private constructor.
A protected member or constructor of an object may be accessed from outside the package in which it is declared only by code that is responsible for the implementation of that object.
Let C be the class in which a protected member is declared.
Access is permitted only within the body of a subclass S of C.
In addition, if Id denotes an instance field or instance method, then: ‚Ä¢ If the access is by a qualified name Q.Id, where Q is an ExpressionName, then.
If the access is by a field access expression E.Id, where E is a Primary expression, or by a method invocation expression E.Id(
Let C be the class in which a protected constructor is declared and let S be the innermost class in whose declaration the use of the protected constructor occurs.
If the access is by a superclass constructor invocation super(
If the access is by an anonymous class instance creation expression of the form new C(
Otherwise, if the access is by a simple class instance creation expression of the form new C(
A protected constructor can be accessed by a class instance creation expression (that does not declare an anonymous class) only from within the package in which it is defined.
A compile-time error occurs in the method delta here: it cannot access the protected members x and y of its parameter p, because while Point3d (the class in which the references to fields x and y occur) is a subclass of Point (the class in which x and y are declared), it is not involved in the implementation of a Point (the type of the parameter p)
A compile-time error also occurs in the method warp: it cannot access the protected member z of its parameter a, because while the class Point (the class in which the reference to field z occurs) is involved in the implementation of a Point3d (the type of the parameter a), it is not a subclass of Point3d (the class in which z is declared)
Every primitive type, named package, top level class, and top level interface has a fully qualified name: ‚Ä¢ The fully qualified name of a primitive type is the keyword for that primitive.
The fully qualified name of a named package that is not a subpackage of a named.
The fully qualified name of a named package that is a subpackage of another named package consists of the fully qualified name of the containing package, followed by ".", followed by the simple (member) name of the subpackage.
The fully qualified name of a top level class or top level interface that is declared in an unnamed package is the simple name of the class or interface.
The fully qualified name of a top level class or top level interface that is declared in a named package consists of the fully qualified name of the package, followed by ".", followed by the simple name of the class or interface.
Each member class, member interface, and array type may have a fully qualified name:
A member class or member interface M of another class or interface C has a fully qualified name if and only if C has a fully qualified name.
In that case, the fully qualified name of M consists of the fully qualified name of C, followed by ".", followed by the simple name of M.
An array type has a fully qualified name if and only if its element type has a fully qualified name.
In that case, the fully qualified name of an array type consists of the fully qualified name of the component type of the array type followed by "[]"
A local class does not have a fully qualified name.
The fully qualified name of the type long is "long"
The fully qualified name of the package java.lang is "java.lang" because it is subpackage lang of package java.
The fully qualified name of the class Object, which is defined in the package java.lang, is "java.lang.Object"
The fully qualified name of the interface Enumeration, which is defined in the package java.util, is "java.util.Enumeration"
The fully qualified name of the type "array of double" is "double[]"
The fully qualified name of the type "array of array of array of array of String" is "java.lang.String[][][][]"
Every primitive type, named package, top level class, and top level interface has a canonical name: ‚Ä¢ For every primitive type, named package, top level class, and top level interface,
Each member class, member interface, and array type may have a canonical name: ‚Ä¢ A member class or member interface M declared in another class C has a canonical.
In that case, the canonical name of M consists of the canonical name of C, followed by ".", followed by the simple name of M.
An array type has a canonical name if and only if its component type has a canonical name.
In that case, the canonical name of the array type consists of the canonical name of the component type of the array type followed by "[]"
The difference between a fully qualified name and a canonical name can be seen in code such as:
Each package has its own set of names for types, which helps to prevent name conflicts.
A top level type is accessible (¬ß6.6) outside the package that declares it only if the type is declared public.
The members of a package are class and interface types (¬ß7.6), which are declared in compilation units of the of their own.
A package can be stored in a file system or in a database (¬ß7.2)
Packages that are stored in a file system may have certain constraints on the organization of their compilation units to allow a simple implementation to find classes easily.
A package consists of a number of compilation units (¬ß7.3)
A compilation unit automatically has access to all types declared in its package and also automatically For small programs and casual development, a package can be unnamed (¬ß7.4.2) or have a simple name, but if code is to be widely distributed, unique package names should be chosen using qualified names.
This can prevent the conflicts that would otherwise occur if two development groups happened to pick the same package name and these packages were later to be used in a single program.
The package java has subpackages awt, applet, io, lang, net, and util, but no compilation units.
The package java.awt has a subpackage named image, as well as a number of compilation units containing declarations of class and interface types.
If the fully qualified name (¬ß6.7) of a package is P, and Q is a subpackage of P, then P.Q is the fully qualified name of the subpackage, and furthermore denotes a package.
A package may not contain two members of the same name, or a compile-time error results.
Because the package java.awt has a subpackage image, it cannot (and does not) contain a declaration of a class or interface type named image.
If there is a package named mouse and a member type Button in that package (which then might be referred to as mouse.Button), then there cannot be any package with the fully qualified name mouse.Button or mouse.Button.Click.
If com.nighthacks.java.jag is the fully qualified name of a type, then there cannot be any package whose fully qualified name is either com.nighthacks.java.jag or com.nighthacks.java.jag.scrabble.
It is however possible for members of different packages to have the same simple name.
These two class types are different, reflected by the fact that they have different fully qualified names (¬ß6.7)
The fully qualified name of this example Vector is vector.Vector, whereas java.util.Vector is the fully qualified name of the Vector class included in the Java SE platform.
Because the package vector contains a class named Vector, it cannot also have a subpackage named Vector.
The hierarchical naming structure for packages is intended to be convenient for organizing related packages in a conventional manner, but has no significance in itself other than the prohibition against a package having a subpackage with the same simple name as a top level type (¬ß7.6) declared in that package.
For example, there is no special access relationship between a package named oliver and another package named oliver.twist, or between packages named evelyn.wood and evelyn.waugh.
That is, the code in a package named oliver.twist has no better access to the types declared within package oliver than code in any other package.
Each host system determines how packages and compilation units are created and stored.
Each host system also determines which compilation units are observable (¬ß7.3) in a particular compilation.
The observability of compilation units in turn determines which packages are observable, and which packages are in scope.
In simple implementations of the Java SE platform, packages and compilation units may be stored in a local file system.
Other implementations may store them using a distributed file system or some form of database.
If a host system stores packages and compilation units in a database, then the database must not impose the optional restrictions (¬ß7.6) on compilation units permissible in file-based implementations.
For example, a system that uses a database to store packages may not enforce a maximum of one public class or interface per compilation unit.
Systems that use a database must, however, provide an option to convert a program to a form that obeys the restrictions, for purposes of export to file-based implementations.
As an extremely simple example of storing packages in a file system, all the packages and source and binary code in a project might be stored in a single directory and its subdirectories.
Each immediate subdirectory of this directory would represent a top level further level of subdirectory would represent a subpackage of the package represented by the containing directory, and so on.
Continuing the example, the directory java would contain, among others, the following subdirectories:
Still continuing the example, if we were to look inside the directory util, we might see the following files:
Under this simple organization of packages, an implementation of the Java SE platform would transform a package name into a pathname by concatenating the components of the package name, placing a file name separator (directory indicator) between adjacent components.
For example, if this simple organization were used on an operating system where the file name separator is /, the package name:
A package name component or class name might contain a character that cannot correctly appear in a host file system's ordinary directory name, such as a Unicode character on a system that allows only ASCII characters in file names.
If the @ character is not a valid character in a file name for some given host file system, then some other character that is not valid in a identifier could be used instead.
A compilation unit that has no package declaration is part of an unnamed.
Top level type declarations (¬ß7.6) of class and interface types.
Every compilation unit implicitly imports every public type name declared in the predefined package java.lang, as if the declaration import java.lang.*; appeared at the beginning of each compilation unit immediately after any package statement.
As a result, the names of all those types are available as simple names in every compilation unit.
All the compilation units of the predefined package java and its subpackages lang and io are always observable.
For all other packages, the host system determines which compilation units are observable.
The observability of a compilation unit influences the observability of its package (¬ß7.4.3)
Types declared in different compilation units can depend on each other, circularly.
A Java compiler must arrange to compile all such types at the same time.
A package declaration appears within a compilation unit to indicate the package to which the compilation unit belongs.
A package declaration in a compilation unit specifies the name (¬ß6.2) of the.
The package name mentioned in a package declaration must be the fully qualified name (¬ß6.7) of the package.
The PackageName in a package declaration ensures there is an observable package with the supplied canonical name, and that it is not subject to the rules in ¬ß6.5.3 for determining the meaning of a package name.
The keyword package may optionally be preceded by annotation modifiers.
At most one annotated package declaration is permitted for a given package.
The manner in which this restriction is enforced must, of necessity, vary from implementation to implementation.
The following scheme is strongly recommended for file-system-based implementations: The sole annotated package declaration, if it exists, is placed in a source file called package-info.java in the directory containing the source files for the package.
This file does not contain the source for a class called packagePACKAGES Package Declarations 7.4
Typically package-info.java contains only a package declaration, preceded immediately by the annotations on the package.
While the file could technically contain the source code for one or more package-private (default-access) classes, it would be very bad form.
It is recommended that package-info.java, if it is present, take the place of this file is present, the documentation generation tool should look for the package documentation comment immediately preceding the (possibly annotated) package declaration in package-info.java.
In this way, package-info.java becomes the sole repository for package-level annotations and documentation.
If, in future, it becomes desirable to add any other package-level information, this file should prove a convenient home for this information.
A compilation unit that has no package declaration is part of an unnamed package.
Unnamed packages are provided by the Java SE platform principally for convenience when developing small or temporary applications or when just beginning development.
Note that an unnamed package cannot have subpackages, since the syntax of a.
An implementation of the Java SE platform must support at least one unnamed so.
Which compilation units are in each unnamed package is determined by the host system.
In implementations of the Java SE platform that use a hierarchical file system for storing one unnamed package is observable at a time, namely the one that is associated with the "current working directory"
The precise meaning of "current working directory" depends on the host system.
One can conclude this from the rule above and from the rules of observable compilation units, as follows.
The predefined package java.lang declares the class Object, so the compilation unit for Object is always observable (¬ß7.3)
Hence, the java.lang package is observable (¬ß7.4.3), and the java package also.
Furthermore, since Object is observable, the array type Object[] implicitly exists.
Its superinterface java.io.Serializable (¬ß10.1) also exists, hence the java.io package is observable.
An import declaration allows a named type or a static member to be referred to by a simple name (¬ß6.2) that consists of a single identifier.
Without the use of an appropriate import declaration, the only way to refer to a type declared in another package, or a static member of another type, is to use a fully qualified name (¬ß6.7)
A single-static-import declaration (¬ß7.5.3) imports all accessible static members with a given name from a type, by giving its canonical name.
A static-import-on-demand declaration (¬ß7.5.4) imports all accessible static members of a named type as needed, by mentioning the canonical name of a type.
An import declaration makes types or members available by their simple names only within the compilation unit that actually contains the import declaration.
The scope of the type(s) or member(s) introduced by an import declaration specifically does not include the PackageName of a package declaration, other import declarations in the current compilation unit, or other compilation units in the same package.
A type in an unnamed package (¬ß7.4.2) has no canonical name, so the requirement for a canonical name in every kind of import declaration implies that (a) types in an unnamed cannot be imported.
A single-type-import declaration imports a single type by giving its canonical name, making it available under a simple name in the class and interface declarations of the compilation unit in which the single-type-import declaration appears.
The TypeName must be the canonical name (¬ß6.7) of a class type, interface type, enum type, or annotation type.
It is a compile-time error if the named type is not accessible (¬ß6.6)
Note that java.util.Vector is declared as a generic type (¬ß8.1.2)
Once imported, the name Vector can be used without qualification in a parameterized type such as Vector<String>, or as the raw type Vector.
This highlights a limitation of the import declaration: a type nested inside a generic type declaration can be imported, but its outer type is always erased.
If two single-type-import declarations in the same compilation unit attempt to the two types are the same type, in which case the duplicate declaration is ignored.
If the type imported by the single-type-import declaration is declared in the compilation unit that contains the import declaration, the import declaration is ignored.
If a single-type-import declaration imports a type whose simple name is n, and the compilation unit also declares a top level type (¬ß7.6) whose simple name is n, a compile-time error occurs.
If a compilation unit contains both a single-type-import declaration that imports a type whose simple name is n, and a single-static-import declaration (¬ß7.5.3) that.
Note that an import statement cannot import a subpackage, only a type.
For example, it does not work to try to import java.util and then use the name util.Random to refer to the type java.util.Random:
Package names and type names are usually different under the naming conventions described in ¬ß6.1
Nevertheless, in a contrived example where there is an unconventionallynamed package Vector, which declares a public class whose name is Mosquito:
A type-import-on-demand declaration allows all accessible types of a named.
The PackageOrTypeName must be the canonical name (¬ß6.7) of a package, a class type, an interface type, an enum type, or an annotation type.
It is a compile-time error if the named package or type is not accessible (¬ß6.6)
It is not a compile-time error to name the current package or java.lang in a typeimport-on-demand declaration.
The declaration might be shadowed by a single-type-import declaration of a type whose simple name is Vector; by a type named Vector and declared in the package to which the compilation unit belongs; or any nested classes or interfaces.
The declaration might be obscured by a declaration of a field, parameter, or local variable named Vector.
It would be unusual for any of these conditions to occur.)
Two or more type-import-on-demand declarations in the same compilation unit may name the same type or package.
All but one of these declarations are considered redundant; the effect is as if that type was imported only once.
A single-static-import declaration imports all accessible static members with a given simple name from a type.
This makes these static members available under their simple name in the class and interface declarations of the compilation unit in which the single-static-import declaration appears.
The TypeName must be the canonical name (¬ß6.7) of a class type, interface type, enum type, or annotation type.
It is a compile-time error if the named type is not accessible (¬ß6.6)
The Identifier must name at least one static member of the named type.
It is a compile-time error if there is no static member of that name, or if all of the named members are not accessible.
It is permissible for one single-static-import declaration to import several fields or types with the same name, or several methods with the same name and signature.
If a single-static-import declaration imports a type whose simple name is n, and the compilation unit also declares a top level type (¬ß7.6) whose simple name is n, a compile-time error occurs.
If a compilation unit contains both a single-static-import declaration that imports a type whose simple name is n, and a single-type-import declaration (¬ß7.5.1) that.
A static-import-on-demand declaration allows all accessible static members of a named type to be imported as needed.
The TypeName must be the canonical name (¬ß6.7) of a class type, interface type, enum type, or annotation type.
It is a compile-time error if the named type is not accessible (¬ß6.6)
Two or more static-import-on-demand declarations in the same compilation unit may name the same type; the effect is as if there was exactly one such declaration.
Two or more static-import-on-demand declarations in the same compilation unit may name the same member; the effect is as if the member was imported exactly once.
It is permissible for one static-import-on-demand declaration to import several fields or types with the same name, or several methods with the same name and signature.
It is a compile-time error if a top level type declaration contains any one of the following access modifiers: protected, private, or static.
It is a compile-time error if the name of a top level type appears as the name of any other top level class or interface type declared in the same package.
It is a compile-time error if the name of a top level type is also declared as a type by a single-type-import declaration (¬ß7.5.1) in the compilation unit containing the type declaration.
Here, the first compile-time error is caused by the duplicate declaration of the name Point as both a class and an interface in the same package.
A second compile-time error is the attempt to declare the name Vector both by a class type declaration and by a single-typeimport declaration.
Within this compilation unit, the simple name Vector refers to the class test.Vector, not to java.util.Vector (which can still be referred to by code within the compilation unit, but only by its fully qualified name)
This program defines two classes that use each other in the declarations of their class members.
Because the class types Point and PointColor have all the type declarations in package points, including all those in the current compilation unit, as their scope, this program compiles correctly.
The fully qualified name of a top level type is specified in ¬ß6.7
In this code, the class Point is declared in a compilation unit with no package statement, and thus Point is its fully qualified name, whereas in the code:
The package name vista is suitable for local or personal use; if the package were intended to be widely distributed, it would be better to give it a unique package name (¬ß6.1).)
An implementation of the Java SE platform must keep track of types within expanded to binary names to make sure that such names are understood as referring to the same type.
For example, if a compilation unit contains the single-type-import declaration (¬ß7.5.1):
If and only if packages are stored in a file system (¬ß7.2), the host system may choose to enforce the restriction that it is a compile-time error if a type is not found in a file under a name composed of the type name plus an extension (such as .java or .jav) if either of the following is true: ‚Ä¢ The type is referred to by code in other compilation units of the package in which.
The type is declared public (and therefore is potentially accessible from code.
This restriction implies that there must be at most one such type per compilation unit.
This restriction makes it easy for a Java compiler to find a named class within a package.
In practice, many programmers choose to put each class or interface type in its own compilation unit, whether or not it is public or is referred to by code in other compilation units.
For example, the source code for a public type wet.sprocket.Toad would be found in a file Toad.java in the directory wet/sprocket, and the corresponding object code would be found in the file Toad.class in the same directory.
A top level class is a class that is not a nested class.
A nested class is any class whose declaration occurs within the body of another class or interface.
Details that are specific to particular kinds of classes are discussed in the sections dedicated to these constructs.
A named class may be declared abstract (¬ß8.1.1.1) and must be declared abstract if it is incompletely implemented; such a class cannot be instantiated, but can be extended by subclasses.
A class may be declared final (¬ß8.1.1.2), in which case it cannot have subclasses.
If a class is declared public, then it can be referred to from other packages.
Classes may be generic (¬ß8.1.2), that is, they may declare type variables whose bindings may differ among different instances of the class.
Classes may be decorated with annotations (¬ß9.7) just like any other kind of declaration.
The body of a class declares members (fields and methods and nested classes and interfaces), instance and static initializers, and constructors (¬ß8.1.6)
Field, method, member class, member interface, and constructor declarations may include the access modifiers (¬ß6.6) public, protected, or private.
The members of a class include both declared and inherited members (¬ß8.2)
Newly declared fields can hide fields declared in a superclass or superinterface.
Newly declared methods can hide, implement, or override methods declared in a superclass or superinterface.
Field declarations (¬ß8.3) describe class variables, which are incarnated once, and instance variables, which are freshly incarnated for each instance of the class.
A field may be declared final (¬ß8.3.1.2), in which case it can be assigned to only once.
Member class declarations (¬ß8.5) describe nested classes that are members of the surrounding class.
Member classes may be static, in which case they have no access to the instance variables of the surrounding class; or they may be inner classes (¬ß8.1.3)
Member interface declarations (¬ß8.5) describe nested interfaces that are members of the surrounding class.
A class method is invoked relative to the class type; an instance method is invoked with respect to some particular object that is an instance of a class type.
A method whose declaration does not indicate how it is implemented must be declared abstract.
A method may be declared final (¬ß8.4.3.3), in which case it cannot be hidden or overridden.
A method may be implemented by platform-dependent native code (¬ß8.4.3.4)
Static initializers (¬ß8.7) are blocks of executable code that may be used to help initialize a class.
Constructors (¬ß8.8) are similar to methods, but cannot be invoked directly by a method call; they are used to initialize new class instances.
There are two kinds of class declarations: normal class declarations and enum declarations.
The rules in this section apply to all class declarations unless this specification explicitly states otherwise.
In many cases, special restrictions apply to enum declarations (¬ß8.9)
The Identifier in a class declaration specifies the name of the class.
It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces.
ClassModifier: one of Annotation public protected private abstract static final strictfp.
The modifier static pertains only to member classes (¬ß8.5.1), not to top level or local or anonymous classes.
It is a compile-time error if the same modifier appears more than once in a class declaration.
If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier.
An abstract class is a class that is incomplete, or to be considered incomplete.
If a normal class that is not abstract contains an abstract method, then a compile-time error occurs.
An enum type (¬ß8.9) must not be declared abstract, or a compile-time error occurs.
It is a compile-time error for an enum type E to have an abstract method m as a member unless E has one or more enum constants, and all of E's enum constants have class bodies that provide concrete implementations of m.
It is a compile-time error for the class body of an enum constant to declare an abstract method.
Any of C's superclasses has an abstract method and C neither declares nor.
A direct superinterface (¬ß8.1.5) of C declares or inherits a method (which is.
It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression (¬ß15.9)
A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class.
It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods.
Here, a class Point is declared that must be declared abstract, because it contains a declaration of an abstract method named alert.
The subclass of Point named ColoredPoint inherits the abstract method alert, so it must also be declared abstract.
On the other hand, the subclass of Point named SimplePoint provides an implementation of alert, so it need not be abstract.
However, a Point variable could correctly be initialized with a reference to any subclass of Point, and the class SimplePoint is not abstract, so the statement:
Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed.
These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor, taking one argument of type int, that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int (¬ß8.4)
A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation.
If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor (¬ß8.8.10) of no arguments, make it private, never invoke it, and declare no other constructors.
A class of this form usually contains class methods and variables.
The class Math is an example of a class that cannot be instantiated; its declaration looks like this:
A class can be declared final if its definition is complete and no subclasses are desired or required.
It is a compile-time error if the name of a final class appears in the extends clause (¬ß8.1.4) of another class declaration; this implies that a final class cannot have any subclasses.
It is a compile-time error if a class is declared both final and abstract, because the implementation of such a class could never be completed (¬ß8.1.1.1)
Because a final class never has any subclasses, the methods of a final class are never overridden (¬ß8.4.8.1)
The effect of the strictfp modifier is to make all float or double expressions within the class declaration (including within variable initializers, instance initializers, static initializers, and constructors) be explicitly FP-strict (¬ß15.4)
This implies that all methods declared in the class, and all nested types declared in the class, are implicitly strictfp.
A class is generic if it declares one or more type variables (¬ß4.4)
These type variables are known as the type parameters of the class.
The type parameter section follows the class name and is delimited by angle brackets.
In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T, while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively)
It is a compile-time error if a type variable in a class's type parameter section depends on itself.
A generic class declaration defines a set of parameterized types (¬ß4.5), one for each possible invocation of the type parameter section by type arguments.
All of these parameterized types share the same class at run time.
It is a compile-time error if a generic class is a direct or indirect subclass of Throwable (¬ß11.1.1)
This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes.
It is a compile-time error to refer to a type parameter of a generic class C anywhere in:
An inner class is a nested class that is not explicitly or implicitly declared static.
Inner classes may not declare static initializers (¬ß8.7) or member interfaces, or a compile-time error occurs.
Inner classes may not declare static members, unless they are constant variables (¬ß4.12.4), or a compile-time error occurs.
Inner classes may inherit static members that are not constant variables even though they may not declare them.
Nested classes that are not inner classes may declare static members freely, in accordance with the usual rules of the Java programming language.
Member interfaces (¬ß8.5) are implicitly static so they are never considered to be inner classes.
A statement or expression occurs in a static context if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor invocation statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement (¬ß8.8.7)
An inner class C is a direct inner class of a class O if O is the immediately lexically enclosing class of C and the declaration of C does not occur in a static context.
A class C is an inner class of class O if it is either a direct inner class of O or an inner class of an inner class of O.
A class O is the zeroth lexically enclosing class of itself.
A class O is the n'th lexically enclosing class of a class C if it is the immediately enclosing class of the n-1'th lexically enclosing class of C.
An instance i of a direct inner class C of a class O is associated with an instance of O, known as the immediately enclosing instance of i.
The immediately enclosing instance of an object, if any, is determined when the object is created (¬ß15.9.2)
An object o is the zeroth lexically enclosing instance of itself.
An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1'th lexically enclosing instance of i.
An instance of an inner class I whose declaration occurs in a static context has no lexically enclosing instances.
However, if I is immediately declared within a static method or static initializer then I does have an enclosing block, which is the innermost block statement lexically enclosing the declaration of I.
For every superclass S of C which is itself a direct inner class of a class SO, there is an instance of SO associated with i, known as the immediately enclosing instance of i with respect to S.
The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement.
When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class, the variable of the corresponding lexically enclosing instance is used.
Any local variable, formal parameter, or exception parameter used but not declared in an inner class must be declared final.
Any local variable used but not declared in an inner class must be definitely assigned (¬ß16) before the body of the inner class.
A blank final (¬ß4.12.4) field of a lexically enclosing class may not be assigned within an inner class, or a compile-time error occurs.
The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod.
Instance variables of class Outer are not available within the body of a static method.
In particular, instance variables of Outer are not available inside the body of LocalInStaticContext.
However, local variables from the surrounding method may be referred to without error (provided they are marked final)
Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class.
An instance variable is always defined with respect to an instance.
In the case of instance variables of an enclosing class, the instance variable must be defined with respect to an enclosing instance of that class.
For example, the class Local above has an enclosing instance of class Outer.
Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance)
The optional extends clause in a normal class declaration specifies the direct superclass of the current class.
The following is repeated from ¬ß4.3 to make the presentation here clearer:
The extends clause must not appear in the definition of the class Object, or a compile-time error occurs, because it is the primordial class and has no direct superclass.
The ClassType must name an accessible (¬ß6.6) class type, or a compile-time error occurs.
If the specified ClassType names a class that is final (¬ß8.1.1.2), then a compiletime error occurs, as final classes are not allowed to have subclasses.
It is a compile-time error if the ClassType names the class Enum or any invocation of it.
If the TypeDeclSpecifier is followed by any type arguments, it must be a correct invocation of the type declaration denoted by TypeDeclSpecifier, and none of the type arguments may be wildcard type arguments, or a compile-time error occurs.
The direct superclass of an enum type E is Enum<E>
A class is said to be a direct subclass of its direct superclass.
The direct superclass is the class from whose implementation the implementation of the current class is derived.
The class Object is the direct superclass of the class Point.
The class ColoredPoint is a direct subclass of class Point.
The class Point is the direct superclass of class ColoredPoint.
The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint.
The subclass relationship is the transitive closure of the direct subclass relationship.
Class C is said to be a superclass of class A whenever A is a subclass of C.
A class C directly depends on a type T if T is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier of a superclass or superinterface name.
A class C depends on a reference type T if any of the following conditions hold: ‚Ä¢ C directly depends on T.
It is a compile-time error if a class depends on itself.
If circularly declared classes are detected at run time, as classes are loaded (¬ß12.2), then a ClassCircularityError is thrown.
The optional implements clause in a class declaration lists the names of interfaces that are direct superinterfaces of the class being declared.
InterfaceTypeList: InterfaceType InterfaceTypeList , InterfaceType The following is repeated from ¬ß4.3 to make the presentation here clearer:
Each InterfaceType must name an accessible (¬ß6.6) interface type, or a compiletime error occurs.
If the TypeName is followed by any type arguments, it must be a correct invocation of the type declaration denoted by TypeName, and none of the type arguments may be wildcard type arguments, or a compile-time error occurs.
It is a compile-time error if the same interface is mentioned as a direct superinterface two or more times in a single implements clause's names.
This is true even if the interface is named in different ways.
This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface.
An interface type I is a superinterface of class type C if any of the following is true:
I is a superinterface of the direct superclass of C.
A class can have a superinterface in more than one way.
The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint.
The interface Paintable is a subinterface of the interface Colorable, and Colorable is a superinterface of Paintable, as defined in ¬ß9.1.3
The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable.
Unless the class being declared is abstract, the declarations of all the method members of each direct superinterface must be implemented either by a declaration in this class or by an existing method declaration inherited from the direct superclass, because a class that is not abstract is not permitted to have abstract methods (¬ß8.1.1.1)
It is permitted for a single method declaration in a class to implement methods of more than one superinterface.
This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable.
You can tune a piano, but can you tuna fish?
On the other hand, in a situation such as this:
This declaration cannot be correct, // no matter what type is used.
Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass (¬ß8.4.8)
A class may not at the same time be a subtype of two interface types which are different invocations of the same generic interface (¬ß9.1.2), or a subtype of an invocation of a generic interface and a raw type naming that same generic interface, or a compile-time error occurs.
This requirement was introduced in order to support translation by type erasure (¬ß4.6)
If C itself is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes.
The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows (¬ß6.4.1) the other definitions of the same kind and name.
Members of a class that are declared private are not inherited by subclasses of that class.
Only members of a class that are declared protected or public are inherited by subclasses declared in a package other than the one in which the class is declared.
Constructors, static initializers, and instance initializers are not members and therefore are not inherited.
We use the phrase the type of a member to denote: ‚Ä¢ For a field, its type.
Fields, methods, and member types of a class type may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures (¬ß6.5)
One error occurs because ColoredPoint has no constructor declared with two int parameters, as requested by the use in main.
This illustrates the fact that ColoredPoint does not inherit the constructors of its superclass Point.
Another error occurs because ColoredPoint declares no constructors, and therefore a default constructor for it is automatically created (¬ß8.8.9), and this default constructor is equivalent to:
The error is that the constructor for Point that takes no arguments is constructor invocation (¬ß8.8.7)
Two more errors occur because the method reset of class Point is private, and therefore is not inherited by class ColoredPoint.
The method invocations in method clear of class ColoredPoint and in method main of class Test are therefore not correct.
Consider the example where the points package declares two compilation units:
The class Point3d inherits the fields x and y of class Point, because it is in the same package as Point.
A better way to write the third compilation unit would be:
If Point4d is written in this way, it will compile without errors.
Therefore, this test program, in another package, can be compiled successfully:
Here, the class variable totalMoves can be used only within the class Point; it is not inherited by the subclass Point3d.
A compile-time error occurs because method move of class Point3d tries to increment totalMoves.
Even though a class might not be declared public, instances of the class might be available at run time to code outside the package in which it is declared by means a public superclass or superinterface.
An instance of the class can be assigned to a variable of such a public type.
An invocation of a public method of the object referred to by such a variable may invoke a method of the class if it implements or overrides a method of the public superclass or superinterface.
In this situation, the method is necessarily declared public, even though it is declared in a class that is not public.)
The two-argument version of method move could then be invoked for that object, which is permissible because method move of Point3d is public (as it must be, for any method that overrides a public method must itself be public,
The fields x and y of that object could also be accessed from such a third package.
The declaration of the field z as public is not useless, however.
The variables of a class type are introduced by field declarations.
The Identifier in a FieldDeclarator may be used in a name to refer to the field.
More than one field may be declared in a single field declaration by using more than one declarator; the FieldModifiers and Type apply to all the declarators in the declaration.
The declared type of a field is denoted by the Type that appears in the field declaration, followed by any bracket pairs that follow the Identifier in the declarator.
It is a compile-time error for the body of a class declaration to declare two fields with the same name.
If the class declares a field with a certain name, then the declaration of that field is said to hide any and all accessible declarations of fields with the same name in superclasses, and superinterfaces of the class.
In this respect, hiding of fields differs from hiding of methods (¬ß8.4.8.3), for there is no distinction drawn between static and non-static fields in field hiding whereas a distinction is drawn between static and non-static methods in method hiding.
In this respect, hiding of fields is similar to hiding of methods.
If a field declaration hides the declaration of another field, the two fields need not have the same type.
A class inherits from its direct superclass and direct superinterfaces all the nonprivate fields of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.
A private field of a superclass might be accessible to a subclass - for example, if both classes are members of the same class.
Nevertheless, a private field is never inherited by a subclass.
It is possible for a class to inherit more than one field with the same name.
Such a situation does not in itself cause a compile-time error.
However, any attempt within the body of the class to refer to any such field by its simple name will result in a compile-time error, because such a reference is ambiguous.
There might be several paths by which the same field declaration might be inherited from an interface.
In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.
A value stored in a field of type float is always an element of the float value set of the double value set.
It is not permitted for a field of type float to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a field of type double to contain an element of the doubleextended-exponent value set that is not also an element of the double value set.
A class may inherit two or more fields with the same name, either from two interfaces or from its superclass and an interface.
A compile-time error occurs on any attempt to refer to any ambiguously inherited field by its simple name.
A qualified name or a field access expression that contains the keyword super (¬ß15.11.2) may be used to access such fields unambiguously.
This in itself is permitted, but a compile-time error occurs because of the use of the simple name v in method printV: it cannot be determined which v is intended.
The following variation uses the field access expression super.v to refer to the field named v declared in class SuperTest and uses the qualified name Frob.v to refer to the field named v declared in interface Frob:
Even if two distinct inherited fields have the same type, the same value, and are both final, any reference to either field by simple name is considered ambiguous and results in a compile-time error.
The point of this example is that the reference to RED is also considered ambiguous, because two distinct declarations are inherited.
The fact that the two fields named RED happen to have the same type and the same unchanging value does not affect this judgment.
If the same field declaration is inherited from an interface by multiple paths, the field is considered to be inherited only once.
It may be referred to by its simple name without ambiguity.
The simple names RED, GREEN, and BLUE may nevertheless be used without ambiguity within the class PaintedPoint to refer to the fields declared in interface Colorable.
FieldModifier: one of Annotation public protected private static final transient volatile.
The access modifiers public, protected, and private are discussed in ¬ß6.6
It is a compile-time error if the same modifier appears more than once in a field declaration, or if a field declaration has more than one of the access modifiers.
If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for FieldModifier.
If a field is declared static, there exists exactly one incarnation of the field, no matter how many instances (possibly zero) of the class may eventually be created.
A static field, sometimes called a class variable, is incarnated when the class is initialized (¬ß12.4)
A field that is not declared static (sometimes called a non-static field) is called an instance variable.
Whenever a new instance of a class is created (¬ß12.5), a new variable associated with that instance is created for every instance variable declared in that class or any of its superclasses.
In this example, the class variable origin of the class Point is referenced both using the class name as a qualifier, in Point.origin, and using variables of the class type in field access expressions (¬ß15.11), as in p.origin and q.origin.
These two ways of accessing the origin class variable access the same object, evidenced by the fact that the value of the reference equality expression (¬ß15.21.3):
Within the declaration of class Test, the simple name x refers to the field declared within class Test.
Code in class Test may refer to the field x of class Point as super.x (or, because x is static, as Point.x)
Code in class Test may still refer to that same field as super.x.
It must be noted, however, that while the field x of class Point is not inherited by class Test, it is nevertheless implemented by instances of class Test.
In other words, every instance of class Test contains two fields, one of type int and one of type double.
Both fields bear the name x, but within the declaration of class Test, the simple name x always refers to the field declared within class Test.
Code in instance methods of class Test may refer to the instance variable x of class Point as super.x.
Code that uses a field access expression to access field x will access the field named x in the class indicated by the type of reference expression.
Thus, the expression sample.x accesses a double value, the instance variable declared in class Test, because the type of the variable sample is Test, but the expression ((Point)sample).x accesses an int value, the instance variable declared in class Point, because of the cast to type Point.
If the declaration of x is deleted from class Test, as in the program:
Within instance methods in the declaration of class Test, the simple name x now refers to the field declared within class Point.
Code in class Test may still refer to that same field as super.x.
The expression sample.x still refers to the field x within type Test, but that field is now an.
Both class and instance variables (static and non-static fields) may be declared final.
Variables may be marked transient to indicate that they are not part of the persistent state of an object.
This specification does not specify details of such services; see the specification of java.io.Serializable for an example of such a service.
The Java programming language allows threads to access shared variables (¬ß17.1)
As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables.
The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes.
A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable (¬ß17.4)
It is a compile-time error if a final variable is also declared volatile.
If, in the following example, one thread repeatedly calls the method one (but no more than Integer.MAX_VALUE times in all), and another thread repeatedly calls the method two:
One way to prevent this out-or-order behavior would be to declare methods one and two to be synchronized (¬ß8.4.3.6):
This prevents method one and method two from being executed concurrently, and furthermore guarantees that the shared values of i and j are both updated before method one returns.
Therefore method two never observes a value for j greater than that for i; indeed, it always observes the same value for i and j.
Another approach would be to declare i and j to be volatile:
This allows method one and method two to be executed concurrently, but guarantees that accesses to the shared values for i and j occur exactly as many times, and in exactly the same order, as they appear to occur during execution of the program text by each thread.
Therefore, the shared value for j is never greater than that for i, because each update to i must be reflected in the shared value for i before the update to j occurs.
It is possible, however, that any given invocation of method two might observe a value for j that is much.
If the declarator is for an instance variable (that is, a field that is not static), then the variable initializer is evaluated and the assignment performed each time an instance of the class is created (¬ß12.5)
Exception checking for a variable initializer in a field declaration is specified in ¬ß11.2.3
Variable initializers are also used in local variable declaration statements (¬ß14.4), where the initializer is evaluated and the assignment performed each time the local variable declaration statement is executed.
If a reference by simple name to any instance variable occurs in an initialization expression for a class variable, then a compile-time error occurs.
Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope.
See ¬ß8.3.2.3 for the precise rules governing forward reference to class variables.
Initialization expressions for instance variables may use the simple name of any static variable declared in or inherited by the class, even one whose declaration occurs textually later.
This program compiles without error; it initializes j to 1 when class Test is initialized, and initializes f to the current value of j every time an instance of class Test is created.
Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope.
See ¬ß8.3.2.3 for the precise rules governing forward reference to instance variables.
The declaration of a member needs to appear textually before it is used only if the member is an instance (respectively static) field of a class or interface C and all of the following conditions hold: ‚Ä¢ The usage occurs in an instance (respectively static) variable initializer of C or.
The usage is not on the left hand side of an assignment.
It is a compile-time error if any of the four requirements above are not met.
The restrictions above are designed to catch, at compile time, circular or otherwise malformed initializations.
Accesses by methods are not checked in this way, so:
A method declares executable code that can be invoked, passing a fixed number of values as arguments.
The Identifier in a MethodDeclarator may be used in a name to refer to the method.
It is a compile-time error for the body of a class to declare as members two methods with override-equivalent signatures (¬ß8.4.2)
For compatibility with older versions of the Java SE platform, the declaration of a method that returns an array is allowed to place (some or all of) the empty bracket pairs that form the declaration of the array type after the formal parameter list.
This is supported by the following obsolescent production, but should not be used in new code.
The formal parameters of a method or constructor, if any, are specified by a list of comma-separated parameter specifiers.
Each parameter specifier consists of a type (optionally preceded by the final modifier and/or one or more annotations) and an identifier (optionally followed by brackets) that specifies the name of the parameter.
The last formal parameter of a method or constructor is special: it may be a variable arity parameter, indicated by an ellipsis following the type.
If the last formal parameter is a variable arity parameter, the method is a variable arity method.
If a method or constructor has no formal parameters, only an empty pair of parentheses appears in the declaration of the method or constructor.
The following is repeated from ¬ß8.3 to make the presentation here clearer:
It is a compile-time error for a method or constructor to declare two formal parameters with the same name.
That is, their declarations mention the same Identifier.) It is a compile-time error if a formal parameter that is declared final is assigned to within the body of the method or constructor.
It is a compile-time error to use mixed array notation (¬ß10.2) for a variable arity parameter.
The declared type of a formal parameter is denoted by the Type that appears in its parameter specifier, followed by any bracket pairs that follow the Identifier in the declarator, except for a variable arity parameter, whose declared type is an array type whose component type is the Type that appears in its parameter specifier.
When the method or constructor is invoked (¬ß15.12), the values of the actual argument expressions initialize newly created parameter variables, each of the declared type, before execution of the body of the method or constructor.
The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the formal parameter.
Invocations of a variable arity method may contain more actual argument expressions than formal parameters.
All the actual argument expressions that do not correspond to the formal parameters preceding the variable arity parameter will be evaluated and the results stored into an array that will be passed to the method invocation (¬ß15.12.4.2)
A method or constructor parameter of type float always contains an element of double always contains an element of the double value set.
It is not permitted for a method or constructor parameter of type float to contain an element of the floatextended-exponent value set that is not also an element of the float value set, nor for a method parameter of type double to contain an element of the double-extendedexponent value set that is not also an element of the double value set.
Where an actual argument expression corresponding to a parameter variable is not FP-strict (¬ß15.4), evaluation of that actual argument expression is permitted to use intermediate values drawn from the appropriate extended-exponent value sets.
Prior to being stored in the parameter variable, the result of such an expression is mapped to the nearest value in the corresponding standard value set by method invocation conversion (¬ß5.3)
Two methods have the same signature if they have the same name and argument types.
After renaming each occurrence of a Bi in N's type to Ai, the bounds of corresponding type variables are the same, and the formal parameter types of M and N are the same.
It is a compile-time error to declare two methods with override-equivalent signatures in a class.
This program causes a compile-time error because it declares two move methods with the same (and hence, override-equivalent) signature.
This is an error even though one of the declarations is abstract.
The notion of subsignature is designed to express a relationship between two methods whose signatures are not identical, but in which one may override the other.
Specifically, it allows a method whose signature does not use generic types to override any generified version of that method.
This is important so that library designers may freely generify methods independently of clients that define subclasses or subinterfaces of the library.
Now, assume this code was written before the introduction of generics, and now the author of class CollectionConverter decides to generify the code, thus:
This would significantly inhibit the use of generics, since library writers would hesitate to migrate existing code.
MethodModifier: one of Annotation public protected private abstract static final synchronized native strictfp.
It is a compile-time error if the same modifier appears more than once in a method declaration, or if a method declaration has more than one of the access modifiers It is a compile-time error if a method declaration that contains the keyword abstract also contains any one of the keywords private, static, final, native, strictfp, or synchronized.
It is a compile-time error if a method declaration that contains the keyword native also contains strictfp.
If two or more (distinct) method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for MethodModifier.
An abstract method declaration introduces the method as a member, providing its signature (¬ß8.4.2), return type, and throws clause (if any), but does not provide an implementation.
The declaration of an abstract method m must appear directly within an abstract error occurs.
Every subclass of A that is not abstract (¬ß8.1.1.1) must provide an implementation for m, or a compile-time error occurs.
It would be impossible for a subclass to implement a private abstract method, because be used.
An abstract class can override an abstract method by providing another abstract method declaration.
This can provide a place to put a documentation comment, to refine the return type, or to declare that the set of checked exceptions (¬ß11.2) that can be thrown by that method, when it is implemented by its subclasses, is to be more limited.
An instance method that is not abstract can be overridden by an abstract method.
The overriding declaration of method get in class InfiniteBuffer states that method get in any subclass of InfiniteBuffer never throws a BufferEmpty exception, putatively because it generates the data in the buffer, and thus can never run out of data.
We can declare an abstract class Point that requires its subclasses to implement toString if they are to be complete, instantiable classes:
This abstract declaration of toString overrides the non-abstract toString method of class Object.
Class Object is the implicit direct superclass of class Point.) Adding the code:
Method toString of class Object can be made available to class ColoredPoint only if class Point explicitly makes it available through some other method, as in:
A method that is declared static is called a class method.
It is a compile-time error to use the name of a type parameter of any surrounding declaration in the header or body of a class method.
A class method is always invoked without reference to a particular object.
A method that is not declared static is called an instance method, and sometimes called a non-static method.
An instance method is always invoked with respect to an object, which becomes the current object to which the keywords this and super refer during execution of the method body.
A method can be declared final to prevent subclasses from overriding or hiding it.
It is a compile-time error to attempt to override or hide a final method.
A private method and all methods declared immediately within a final class (¬ß8.1.1.2) behave as if they are final, since it is impossible to override them.
At run time, a machine-code generator or optimizer can "inline" the body of a final method, replacing an invocation of the method with the code in its body.
The inlining process must preserve the semantics of the method invocation.
In particular, if the target of an instance method invocation is null, then a NullPointerException must be thrown even if the method is inlined.
A Java compiler must ensure that the exception will be thrown at the correct point, so that the actual arguments to the method will be seen to have been evaluated in the correct order prior to the method invocation.
Inlining the method move of class Point in method main would transform the for loop to the form:
Such inlining cannot be done at compile time unless it can be guaranteed that Test and Point will always be recompiled together, so that whenever Point - and specifically its move method - changes, the code for Test.main will also be updated.
A method that is native is implemented in platform-dependent code, typically written in another programming language such as C.
The body of a native method is given as a semicolon only, indicating that the implementation is omitted, instead of a block.
For example, the class RandomAccessFile of the package java.io might declare the following native methods:
The effect of the strictfp modifier is to make all float or double expressions within the method body be explicitly FP-strict (¬ß15.4)
A synchronized method acquires a monitor (¬ß17.1) before it executes.
For a class (static) method, the monitor associated with the Class object for the method's class is used.
For an instance method, the monitor associated with this (the object for which the method was invoked) is used.
These are the same monitors that can be used by the synchronized statement (¬ß14.19)
This program defines a class which is designed for concurrent use.
Each instance of the class Box has an instance variable boxContents that can hold a reference to any object.
You can put an object in a Box by invoking put, which returns false if the box is already full.
You can get something out of a Box by invoking get, which returns a null reference if the box is empty.
If put and get were not synchronized, and two threads were executing methods for the same instance of Box at the same time, then the code could misbehave.
It might, for example, lose track of an object because two invocations to put occurred at the same time.
A method is generic if it declares one or more type variables (¬ß4.4)
These type variables are known as the type parameters of the method.
The form of the type parameter section of a generic method is identical to the type parameter section of a generic class (¬ß8.1.2)
A generic method declaration defines a set of methods, one for each possible invocation of the type parameter section by type arguments.
Type arguments may not need to be provided explicitly when a generic method is invoked, as they can often be inferred (¬ß15.12.2.7)
The scope and shadowing of a method's type parameter is specified in ¬ß6.3
The result of a method declaration either declares the type of value that the method returns (the return type), or uses the keyword void to indicate that the method does not return a value.
Return types may vary among methods that override each other if the return types are reference types.
The notion of return-type-substitutability supports covariant returns, that is, the specialization of the return type to a subtype.
An unchecked conversion is allowed in the definition, despite being unsound, as a special allowance to allow smooth migration from non-generic to generic code.
It is a compile-time error if any ExceptionType mentioned in a throws clause is not a subtype (¬ß4.10) of Throwable.
Type variables are allowed in a throws clause even though they are not allowed in a catch clause.
It is permitted but not required to mention unchecked exception classes (¬ß11.1.1) in a throws clause.
The relationship between a throws clause and the exception checking for a method or constructor body is specified in ¬ß11.2.3
Essentially, for each checked exception that can result from execution of the body of a method or constructor, a compile-time error occurs unless its exception type or a supertype of its exception type is mentioned in a throws clause in the declaration of the method or constructor.
The requirement to declare checked exceptions allows a Java compiler to ensure that code for handling such error conditions has been included.
Methods or constructors that fail to handle exceptional conditions thrown as checked exceptions in their bodies will normally cause compile-time errors if they lack proper exception types in their throws clauses.
The Java programming language thus encourages a programming style where rare and otherwise truly exceptional conditions are documented in this way.
The relationship between the throws clause of a method and the throws clauses of overridden or hidden methods is specified in ¬ß8.4.8.3
A method body is either a block of code that implements the method or simply a semicolon, indicating the lack of an implementation.
It is a compile-time error if a method declaration is either abstract or native and has a block for its body.
It is a compile-time error if a method declaration is neither abstract nor native and has a semicolon for its body.
If a method is declared void, then its body must not contain any return statement (¬ß14.17) that has an Expression, or a compile-time error occurs.
If a method is declared to have a return type, then every return statement (¬ß14.17) in its body must have an Expression, or a compile-time error occurs.
If a method is declared to have a return type, then a compile-time error occurs if the body of the method can complete normally (¬ß14.1)
In other words, a method with a return type must return only by using a return statement that provides a value return; it is not allowed to "drop off the end of its body"
Note that it is possible for a method to have a declared return type and yet contain no return statements.
If, for example, a class declares two public methods with the same name (¬ß8.4.9), and a subclass overrides one of them, the subclass still inherits the other method.
If the method not inherited is declared in a class, or the method not inherited is declared in an interface and the new declaration is abstract, then the new declaration is said to override it.
If the method not inherited is abstract and the new declaration is not abstract, then the new declaration is said to implement it.
The signature of an overriding method may differ from the overridden one if a formal parameter in one of the methods has a raw type, while the corresponding parameter in the other has a parameterized type.
The rules allow the signature of the overriding method to differ from the overridden one, to accommodate migration of pre-existing code to take advantage of generics.
It is a compile-time error if an instance method overrides a static method.
In this respect, overriding of methods differs from hiding of fields (¬ß8.3), for it is permissible for an instance variable to hide a static variable.
An overridden method can be accessed by using a method invocation expression (¬ß15.12) that contains the keyword super.
A qualified name or a cast to a superclass type is not effective in attempting to access an overridden method; in this respect, overriding of methods differs from hiding of fields (¬ß15.12.4.4)
The presence or absence of the strictfp modifier has absolutely no effect on the rules for overriding methods and implementing abstract methods.
For example, it is permitted for a method that is not FP-strict to override an FP-strict method and it is permitted for an FP-strict method to override a method that is not FP-strict.
Here, the class SlowPoint overrides the declarations of method move of class Point with its own move method, which limits the distance that the point can move on each invocation of the method.
When the move method is invoked for an instance of class SlowPoint, the overriding definition in class SlowPoint will always be called, even if the reference to the SlowPoint object is taken from a variable whose type is Point.
Overriding makes it easy for subclasses to extend the behavior of an existing class, as shown in this example:
The class BufferOutput implements a very simple buffered version of an OutputStream, flushing the output when the buffer is full or flush is invoked.
The subclass LineBufferOutput declares only a constructor and a single method putchar, which overrides the method putchar of BufferOutput.
It inherits the methods putstr and flush from class BufferOutput.
In the putchar method of a LineBufferOutput object, if the character argument is a newline, then it invokes the flush method.
The critical point about overriding in this example is that the method putstr, which is declared in class BufferOutput, invokes the putchar method defined by the current object this, which is not necessarily the putchar method declared in class BufferOutput.
Thus, when putstr is invoked in main using the LineBufferOutput object lbo, the invocation of putchar in the body of the putstr method is an invocation of the putchar of the object lbo, the overriding declaration of putchar that checks for a newline.
This allows a subclass of BufferOutput to change the behavior of the putstr method without redefining it.
Documentation for a class such as BufferOutput, which is designed to be extended, should clearly indicate what is the contract between the class and its subclasses, and should clearly indicate that subclasses may override the putchar method in this way.
The implementor of the BufferOutput class would not, therefore, want to change the implementation of putstr in a future implementation of BufferOutput not to use the method putchar, because this would break the pre-existing contract with subclasses.
It is a compile-time error if a static method hides an instance method.
In this respect, hiding of methods differs from hiding of fields (¬ß8.3), for it is permissible for a static variable to hide an instance variable.
A hidden method can be accessed by using a qualified name or by using a method invocation expression (¬ß15.12) that contains the keyword super or a cast to a superclass type.
In this respect, hiding of methods is similar to hiding of fields.
A class (static) method that is hidden can be invoked by using a reference whose type is the class that actually contains the declaration of the method.
In this respect, hiding of static methods is different from overriding of instance methods.
This rule allows for covariant return types - refining the return type of a method when overriding it.
A method that overrides or hides another method, including methods that implement abstract methods defined in interfaces, may not be declared to throw more checked exceptions than the overridden or hidden method.
In this respect, overriding of methods differs from hiding of fields (¬ß8.3), for it is permissible for a field to hide a field of another type.
More precisely, suppose that B is a class or interface, and A is a superclass or superinterface of B, and a method declaration n in B overrides or hides a method declaration m in A.
Then: ‚Ä¢ If n has a throws clause that mentions any checked exception types, then m must.
For every checked exception type listed in the throws clause of n, that same exception class or one of its supertypes must occur in the erasure (¬ß4.6) of the throws clause of m; otherwise, a compile-time error occurs.
If the unerased throws clause of m does not contain a supertype of each exception type in the throws clause of n, a compile-time unchecked warning occurs.
These restrictions are necessary because generics are implemented via erasure.
The rule above implies that methods declared in the same class with the same name must have different erasures.
It also implies that a type declaration cannot implement or extend two distinct invocations of the same generic interface.
If the overridden or hidden method is protected, then the overriding or hiding.
If the overridden or hidden method has default (package) access, then the overriding or hiding method must not be private; otherwise, a compile-time error occurs.
Note that a private method cannot be hidden or overridden in the technical sense of those terms.
This means that a subclass can declare a method with the same signature as a private method in one of its superclasses, and there is no requirement that the return type or throws clause of such a method bear any relationship to those of the private method in the superclass.
The following declarations are legal in the Java programming language from Java SE 5.0 onwards:
The relaxed rule for overriding also allows one to relax the conditions on abstract classes implementing interfaces.
Now, at some point the author of StringSorter decides to generify the code:
An unchecked warning would be given when compiling Overrider against the new definition of StringSorter because the return type of Overrider.toList is List, which is not a subtype of the return type of the overridden method, List<String>
This program uses the usual and conventional form for declaring a new exception type, in its declaration of the class BadPointException:
The program results in a compile-time error, because the override of method move in class CheckedPoint declares that it will throw a checked exception that the move in class Point has not declared.
If this were not considered an error, an invoker of the method move on a reference of type Point could find the contract between it and Point broken if this exception were thrown.
A different compile-time error now occurs, because the body of the method move cannot throw a checked exception, namely BadPointException, that does not appear in the throws clause for move.
A class cannot have two member methods with the same name and type erasure:
This is illegal since D.id(Object) is a member of D, C<String>.id(String) is declared in a supertype of D, and:
The signature of D.id(Object) is not a subsignature of that of C<String>.id(String)
Two different methods of a class may not override methods with the same erasure:
This is also illegal, since D.id(String) is a member of D, D.id(Integer) is declared in D, and:
I.id(Integer) yet the two overridden methods have the same erasure.
It is possible for a class to inherit multiple methods with override-equivalent signatures (¬ß8.4.2)
It is a compile-time error if a class C inherits a concrete method whose signature is a subsignature of another concrete method inherited by C.
Otherwise, there are two possible cases: ‚Ä¢ If one of the inherited methods is not abstract, then there are two subcases:
If the method that is not abstract is static, a compile-time error occurs.
Otherwise, the method that is not abstract is considered to override, and.
If the signature of the non-abstract method is not a subsignature of each of the other inherited methods, a compile-time unchecked warning occurs unless suppressed by the SuppressWarnings annotation (¬ß9.6.3.5)
If the return type of the non-abstract method is not a subtype of the return type of any of the other inherited methods, a compile-time unchecked warning occurs unless suppressed by the SuppressWarnings annotation (¬ß9.6.3.5)
A compile-time error occurs if the return type of the non-abstract method is not return-type-substitutable (¬ß8.4.5) for each of the other inherited methods.
A compile-time error occurs if the inherited method that is not abstract has a throws clause that conflicts (¬ß8.4.6) with that of any other of the inherited methods.
If all the inherited methods are abstract, then the class is necessarily an abstract class and is considered to inherit all the abstract methods.
One of the inherited methods must be return-type-substitutable for every other inherited method; otherwise, a compile-time error occurs.
The throws clauses do not cause errors in this case.)
There might be several paths by which the same method declaration might be inherited from an interface.
This fact causes no difficulty and never, of itself, results in a compile-time error.
If two methods of a class (whether both declared in the same class, or both inherited by a class, or one declared and one inherited) have the same name but signatures that are not override-equivalent, then the method name is said to be overloaded.
This fact causes no difficulty and never of itself results in a compile-time error.
There is no required relationship between the return types or between the throws.
If the method that is to be invoked is an instance method, the actual method to be invoked will be determined at run time, using dynamic method lookup (¬ß15.12.4)
Here, the class Point has two members that are methods with the same name, move.
The overloaded move method of class Point chosen for any particular method invocation is determined at compile time by the overloading resolution procedure given in ¬ß15.12
In total, the members of the class Point are the float instance variables x and y declared in Point, the two declared move methods, the declared toString method, and the members that Point inherits from its implicit direct superclass Object (¬ß4.3.2), such as the method hashCode.
Note that Point does not inherit the toString method of class Object because that method is overridden by the declaration of the toString method in class Point.
Here, the class RealPoint hides the declarations of the int instance variables x and y of class Point with its own float instance variables x and y, and overrides the method move of class Point with its own move method.
It also overloads the name move with another method with a different signature (¬ß8.4.2)
In this example, the members of the class RealPoint include the instance variable color inherited from the class Point, the float instance variables x and y declared in RealPoint, and the two move methods declared in RealPoint.
Which of these overloaded move methods of class RealPoint will be chosen for any particular method invocation will be determined at compile time by the overloading resolution procedure described in ¬ß15.12
This following program is an extended variation of the preceding program:
Here, the class Point provides methods getX and getY that return the values of its fields x and y; the class RealPoint then overrides these methods by declaring methods with the same signature.
The result is two errors at compile time, one for each method, because the return types do not match; the methods in class Point return values of type int, but the wanna-be overriding methods in class RealPoint return values of type float.
Here, the overriding methods getX and getY in class RealPoint have the same return types as the methods of class Point that they override, so this code can be successfully compiled.
The first line of output illustrates the fact that an instance of RealPoint actually contains the two integer fields declared in class Point; it is just that their names are hidden from code that occurs within the declaration of class RealPoint (and those of any subclasses it might have)
When a reference to an instance of class RealPoint in a variable of type Point is used to access the field x, the integer field x declared in class Point is accessed.
The second line of output shows that the field access rp.x refers to the field x declared in class RealPoint.
This field is of type float, and this second line of output accordingly displays floating-point values.
Incidentally, this also illustrates the fact that the method name show is overloaded; the types of the arguments in the method invocation dictate which of the two definitions will be invoked.
Indeed, there is no way to invoke the getX method of class Point for an instance of class RealPoint from outside the body of RealPoint, no matter what the type of the variable we may use to hold the reference to the object.
Thus, we see that fields and methods behave differently: hiding is different from overriding.
A member class is a class whose declaration is directly enclosed in another class or interface declaration.
A member interface is an interface whose declaration is directly enclosed in another class or interface declaration.
The accessibility of a member type in a class declaration is specified in ¬ß6.6
It is a compile-time error if a member type declaration has more than one of the access modifiers public, protected, and private.
Member type declarations may have annotation modifiers (¬ß9.7) like any other type or member declaration.
If a class declares a member type with a certain name, then the declaration of that type is said to hide any and all accessible declarations of member types with the same name in superclasses and superinterfaces of the class.
In this respect, hiding of member types is similar to hiding of fields (¬ß8.3)
A class inherits from its direct superclass and direct superinterfaces all the non-private member types of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.
A class may inherit two or more type declarations with the same name, either from two interfaces or from its superclass and an interface.
It is a compile-time error to attempt to refer to any ambiguously inherited class or interface by its simple name.
If the same type declaration is inherited from an interface by multiple paths, the class or interface is considered to be inherited only once.
It may be referred to by its simple name without ambiguity.
The static keyword may modify the declaration of a member type C within the body of a non-inner class or interface T.
Its effect is to declare that C is not an inner class.
Just as a static method of T has no current instance of T in its body, C also has no current instance of T, nor does it have any lexically enclosing instances.
It is a compile-time error if a static class contains a usage of a non-static member of an enclosing class.
It is permitted for the declaration of a member interface to redundantly specify the static modifier.
It is a compile-time error if an instance initializer cannot complete normally (¬ß14.21)
It is a compile-time error if a return statement (¬ß14.17) appears anywhere within an instance initializer.
Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope.
See ¬ß8.3.2.3 for the precise rules governing forward reference to instance variables.
Exception checking for an instance initializer is specified in ¬ß11.2.3
A static initializer declared in a class is executed when the class is initialized (¬ß12.4.2)
Together with any field initializers for class variables (¬ß8.3.2), static initializers may be used to initialize the class variables of the class.
It is a compile-time error if a static initializer cannot complete normally (¬ß14.21)
It is a compile-time error if a return statement (¬ß14.17) appears anywhere within a static initializer.
Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope.
See ¬ß8.3.2.3 for the precise rules governing forward reference to class variables.
Exception checking for a static initializer is specified in ¬ß11.2.3
The SimpleTypeName in the ConstructorDeclarator must be the simple name of the class that contains the constructor declaration; otherwise a compile-time error occurs.
In all other respects, the constructor declaration looks just like a method declaration that has no result (¬ß8.4.5)
They are never inherited and therefore are not subject to hiding or overriding.
This is useful, for example, in preventing instantiation by declaring an inaccessible constructor (¬ß8.8.10)
The formal parameters and type parameters of a constructor are identical in syntax and semantics to those of a method (¬ß8.4.1)
It is a compile-time error to declare two constructors with override-equivalent signatures (¬ß8.4.2) in a class.
It is a compile-time error to declare two constructors whose signatures have the same erasure (¬ß4.6) in a class.
The access modifiers public, protected, and private are discussed in ¬ß6.6
It is a compile-time error if the same modifier appears more than once in a constructor declaration, or if a constructor declaration has more than one of the access modifiers public, protected, and private.
It is a compile-time error if the constructor of an enum type (¬ß8.9) is declared.
If no access modifier is specified for the constructor of a normal class, the constructor has default access.
If no access modifier is specified for the constructor of an enum type, the constructor is private.
If two or more (distinct) method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for MethodModifier.
Unlike methods, a constructor cannot be abstract, static, final, native, strictfp, or synchronized:
A constructor is not inherited, so there is no need to declare it final.
A constructor is always invoked with respect to an object, so it makes no sense for a constructor to be static.
There is no practical need for a constructor to be synchronized, because it would lock the object under construction, which is normally not made available to other threads until all constructors for the object have completed their work.
The lack of native constructors is an arbitrary language design choice that makes it easy for an implementation of the Java Virtual Machine to verify that superclass constructors are always properly invoked during object creation.
It is possible for a constructor to be declared generic, independently of whether the class the constructor is declared in is itself generic.
A constructor is generic if it declares one or more type variables (¬ß4.4)
These type variables are known as the type parameters of the constructor.
The form of the type parameter section of a generic constructor is identical to the type parameter section of a generic class (¬ß8.1.2)
A generic constructor declaration defines a set of constructors, one for each possible invocation of the type parameter section by type arguments.
Type arguments may not need to be provided explicitly when a generic constructor is invoked, as they can often by inferred (¬ß15.12.2.7)
The throws clause for a constructor is identical in structure and behavior to the throws clause for a method (¬ß8.4.6)
The type of a constructor consists of its signature and the exception types given by its throws clause.
The first statement of a constructor body may be an explicit invocation of another constructor of the same class or of the direct superclass (¬ß8.8.7.1)
It is a compile-time error for a constructor to directly or indirectly invoke itself through a series of one or more explicit constructor invocations involving this.
If the constructor is a constructor for an enum type (¬ß8.9), it is a compile-time error for it to invoke the superclass constructor explicitly.
If a constructor body does not begin with an explicit constructor invocation and the constructor being declared is not part of the primordial class Object, then the constructor body implicitly begins with a superclass constructor invocation arguments.
Except for the possibility of explicit constructor invocations, the body of a constructor is like the body of a method (¬ß8.4.7)
A return statement (¬ß14.17) may be used in the body of a constructor if it does not include an expression.
Here, the first constructor of ColoredPoint invokes the second, providing an additional argument; the second constructor of ColoredPoint invokes the constructor of its superclass Point, passing along the coordinates.
Explicit constructor invocation statements can be divided into two kinds: ‚Ä¢ Alternate constructor invocations begin with the keyword this (possibly.
They are used to invoke an alternate constructor of the same class.
Superclass constructor invocations begin with either the keyword super (possibly prefaced with explicit type arguments) or a Primary expression.
They are used to invoke a constructor of the direct superclass.
Superclass constructor invocations may be subdivided: ‚óÜ Unqualified superclass constructor invocations begin with the keyword super.
They allow a subclass constructor to explicitly specify the newly created object's immediately enclosing instance with respect to the direct superclass (¬ß8.1.3)
This may be necessary when the superclass is an inner class.
An explicit constructor invocation statement in a constructor body may not refer to any instance variables or instance methods or inner classes declared in this class or any superclass, or use this or super in any expression; otherwise, a compiletime error occurs.
The exception types that an explicit constructor invocation statement can throw are specified in ¬ß11.2.2
If the first constructor of ColoredPoint in the example from ¬ß8.8.7 were changed as follows:
Let C be the class being instantiated, and let S be the direct superclass of C.
It is a compile-time error if S is not accessible (¬ß6.6)
If a superclass constructor invocation statement is qualified, then: ‚Ä¢ If S is not an inner class, or if the declaration of S occurs in a static context, then.
Otherwise, let p be the Primary expression immediately preceding ".super"
Let O be the innermost lexically enclosing class of S.
It is a compile-time error if the type of p is not O or a subclass of O, or if the type of p is not accessible (¬ß6.6)
If a superclass constructor invocation statement is unqualified, and if S is an inner member class, then it is a compile-time error if S is not a member of a lexically enclosing class of C by declaration or inheritance.
Evaluation of an alternate constructor invocation statement proceeds by first evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.
Evaluation of a superclass constructor invocation statement is more complicated, as follows:
Let C be the class being instantiated, let S be the direct superclass of C, and let i be the instance being created.
The immediately enclosing instance of i with respect to S (if any) must be determined: ‚Ä¢ If S is not an inner class, or if the declaration of S occurs in a static context,
If the superclass constructor invocation is qualified, then the Primary.
If p evaluates to null, a NullPointerException is raised, and the superclass constructor invocation completes abruptly.
Otherwise, the result of this evaluation is the immediately enclosing instance of i with respect to S.
Let n be an integer such that O is the n'th lexically enclosing class of C.
The immediately enclosing instance of i with respect to S is the n'th lexically enclosing instance of this.
Let O be the innermost lexically enclosing class of S, and let n be an integer such that O is the n'th lexically enclosing class of C.
The immediately enclosing instance of i with respect to S is the n'th lexically enclosing instance of this.
After determining the immediately enclosing instance of i with respect to S (if any), evaluation of the superclass constructor invocation statement proceeds by evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.
Finally, if the superclass constructor invocation statement completes normally, then all instance variable initializers of C and all instance initializers of C are executed.
If an instance initializer or instance variable initializer I textually precedes another instance initializer or instance variable initializer J, then I is executed before J.
Execution of instance variable initializers and instance initializers is performed regardless of whether the superclass constructor invocation actually appears as an explicit constructor invocation statement or is provided automatically.
An alternate constructor invocation does not perform this additional implicit execution.)
Overloading of constructors is identical in behavior to overloading of methods (¬ß8.4.9)
The overloading is resolved at compile time by each class instance creation expression (¬ß15.9)
If a class contains no constructor declarations, then a default constructor with no formal parameters and no throws clause is implicitly declared.
If the class being declared is the primordial class Object, then the default constructor has an empty body.
Otherwise, the default constructor simply invokes the superclass constructor with no arguments.
It is a compile-time error if a default constructor is implicitly declared but the superclass does not have an accessible constructor (¬ß6.6) that takes no arguments and has no throws clause.
In a class type, if the class is declared public, then the default constructor protected, then the default constructor is implicitly given the access modifier.
In an enum type, the default constructor is implicitly private (¬ß8.9.2)
The rule that the default constructor of a class has the same access modifier as the class itself is simple and intuitive.
Note, however, that this does not imply that the constructor is accessible whenever the class is accessible.
However, the constructor is protected relative to Inner, while Inner is protected relative to Outer.
So, Inner is accessible in SonOfOuter, since it is a subclass of Outer.
Inner's constructor is not accessible in SonOfOuter, because the class SonOfOuter is not a subclass of Inner! Hence, even though Inner is accessible, its default constructor is not.
A class can be designed to prevent code outside the class declaration from creating instances of the class by declaring at least one constructor, to prevent the creation of an implicit constructor, and by declaring all constructors to be private.
A public class can likewise prevent the creation of instances outside its package by declaring at least one constructor, to prevent creation of a default constructor with public access, and by declaring no constructor that is public.
Here, the class ClassOnly cannot be instantiated, while in the following code:
Enum types (¬ß8.9) must not be declared abstract; doing so will result in a compile-time error.
An enum type is implicitly final unless it contains at least one enum constant that has a class body.
It is a compile-time error to explicitly declare an enum type to be final.
It is permissible to explicitly declare a nested enum type to be static.
An enum type has no instances other than those defined by its enum constants.
It is a compile-time error to attempt to explicitly instantiate an enum type (¬ß15.9.1)
The final clone method in Enum ensures that enum constants can never be cloned, and the special treatment by the serialization mechanism ensures that duplicate instances are never created as a result of deserialization.
Together, these four things ensure that no instances of an enum type exist beyond those defined by the enum constants.
The body of an enum type may contain enum constants.
An enum constant defines an instance of the enum type.
An enum constant may optionally be preceded by annotation modifiers.
The Identifier in a EnumConstant may be used in a name to refer to the enum constant.
An enum constant may be followed by arguments, which are passed to the constructor of the enum type when the constant is created during class initialization as described later in this section.
The constructor to be invoked is chosen using the normal overloading rules (¬ß15.12.2)
If the arguments are omitted, an empty argument list is assumed.
The optional class body of an enum constant implicitly defines an anonymous class declaration (¬ß15.9.5) that extends the immediately enclosing enum type.
The class body is governed by the usual rules of anonymous classes; in particular it cannot contain any constructors.
Instance methods declared in these class bodies may be invoked outside the enclosing enum type only if they override accessible methods in the enclosing enum type.
It is a compile-time error for the class body of an enum constant to declare an abstract method.
Because there is only one instance of each enum constant, it is permissible to use the if it is known that at least one of them refers to an enum constant.
The equals method in Enum is a final method that merely invokes super.equals on its argument and returns the result, thus performing an identity comparison.
At first glance, it might appear wasteful to generate a java.util.EnumSet object for a single iteration, but they are so cheap that this is the recommended idiom for iteration over a subrange.
Internally, a java.util.EnumSet is represented with a single long assuming the enum type has 64 or fewer elements.
Any constructor or member declarations within an enum declaration apply to the enum type exactly as if they had been present in the class body of a normal class declaration, unless explicitly stated otherwise.
It is a compile-time error if a constructor declaration of an enum type is public or protected.
If an enum type has no constructor declarations, then a private constructor that takes no parameters (to match the implicit empty argument list) is automatically provided.
It is a compile-time error for an enum declaration to declare a finalizer.
An instance of an enum type may never be finalized.
It is a compile-time error for an enum type E to have an abstract method m as a member unless E has one or more enum constants, and all of E's enum constants have class bodies that provide concrete implementations of m.
In addition to the members that an enum type E inherits from Enum<E>, for each declared enum constant with the name n, the enum type has an implicitly declared declared in the same order as the corresponding enum constants, before any static fields explicitly declared in the enum type.
Each such field is initialized to the enum constant that corresponds to it.
The enum constant is said to be created when the corresponding field is initialized.
In addition, if E is the name of an enum type, then that type has the following implicitly declared static methods:
Returns an array containing the constants of this enum * type, in the order they're declared.
Returns the enum constant of this type with the specified * name.
The string must match exactly an identifier used to declare * an enum constant in this type.
It follows that enum type declarations cannot contain fields that conflict with the enum constants, and cannot contain methods that conflict with the automatically generated.
It is a compile-time error to reference a static field of an enum type that is not a constant variable (¬ß4.12.4) from constructors, instance initializer blocks, or instance variable initializer expressions of that type.
It is a compile-time error for the constructors, instance initializer blocks, or instance variable initializer expressions of an enum constant e to refer to e or to an enum constant of the same type that is declared to the right of e.
Without this rule, apparently reasonable code would fail at run time due to the initialization circularity inherent in enum types.
A circularity exists in any class with a "self-typed" static field.) Here is an example of the sort of code that would fail:
Static initialization of this enum type would throw a NullPointerException because the static variable colorMap is uninitialized when the constructors for the enum constants run.
Note that the example can easily be refactored to work properly:
The refactored version is clearly correct, as static initialization occurs top to bottom.
Each enum constant arranges for a different value in the field value, passed in via a constructor.
The field represents the value, in cents, of an American coin.
Note that there are no restrictions on the type or number of parameters that may be declared by an enum type's constructor.
A switch statement is useful for simulating the addition of a method to an enum type from outside the type.
This example "adds" a color method to the Coin type, and prints a table of coins, their values, and their colors.
In the following program, a playing card class is built atop two simple enum types.
Note that each enum type would be as long as the entire example in the absence of the enum facility:
Primary sort on suit, secondary sort on rank suitCompare :
It takes two integer parameters on the command line, representing the number of hands to deal and the number of cards in each hand:
Returns a new ArrayList consisting of the last n * elements of deck, which are removed from deck.
The returned list is sorted using the elements' * natural ordering.
The above pattern is much safer than using a switch statement in the base type (Operation), as the pattern precludes the possibility of forgetting to add a behavior for a new constant (since the enum declaration would cause a compile-time error)
This type has no implementation, but otherwise unrelated classes can implement it by providing implementations for its abstract methods.
A nested interface is any interface whose declaration occurs within the body of another class or interface.
A top level interface is an interface that is not a nested interface.
We distinguish between two kinds of interfaces - normal interfaces and annotation types.
Details that are specific to particular kinds of interfaces are discussed in the sections dedicated to these constructs.
Programs can use interfaces to make it unnecessary for related classes to share a common abstract superclass or to add methods to Object.
An interface may be declared to be a direct extension of one or more other interfaces, meaning that it implicitly specifies all the member types, abstract methods, and constants of the interfaces it extends, except for any member types and constants that it may hide.
A class may be declared to directly implement one or more interfaces, meaning that any instance of the class implements all the abstract methods specified by the interface or interfaces.
A class necessarily implements all the interfaces that its direct superclasses and direct superinterfaces do.
This (multiple) interface inheritance allows objects to support (multiple) common behaviors without sharing any implementation.
A variable whose declared type is an interface type may have as its value a reference to any instance of a class which implements the specified interface.
It is not sufficient that the class happen to implement all the abstract methods of the interface; the class or one of its superclasses must actually be declared to implement the interface, or else the class is not considered to implement the interface.
There are two kinds of interface declarations - normal interface declarations and annotation type declarations (¬ß9.6)
The Identifier in an interface declaration specifies the name of the interface.
It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces.
InterfaceModifier: one of Annotation public protected private abstract static strictfp.
The access modifier public (¬ß6.6) pertains to every kind of interface declaration.
The access modifiers protected and private pertain only to member interfaces within a directly enclosing class or enum declaration (¬ß8.5.1)
It is a compile-time error if the same modifier appears more than once in an interface declaration.
If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for InterfaceModifier.
This modifier is obsolete and should not be used in new programs.
The effect of the strictfp modifier is to make all float or double expressions within the interface declaration be explicitly FP-strict (¬ß15.4)
This implies that all nested types declared in the interface are implicitly strictfp.
An interface is generic if it declares one or more type variables (¬ß4.4)
These type variables are known as the type parameters of the interface.
The type parameter section follows the interface name and is delimited by angle brackets.
In an interface's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T, while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively)
It is a compile-time error if a type variable in a interface's type parameter section depends on itself.
The scope of an interface's type parameter is specified in ¬ß6.3
It is a compile-time error to refer to a type parameter of an interface I anywhere in the declaration of a field or type member of I.
A generic interface declaration defines a set of parameterized types (¬ß4.5), one for each possible invocation of the type parameter section by type arguments.
All of these parameterized types share the same interface at run time.
If an extends clause is provided, then the interface being declared extends each of the other named interfaces and therefore inherits the member types, methods, and constants of each of the other named interfaces.
These other named interfaces are the direct superinterfaces of the interface being declared.
Any class that implements the declared interface is also considered to implement all the interfaces that this interface extends.
The superinterface relationship is the transitive closure of the direct superinterface relationship.
An interface K is a superinterface of interface I if either of the following is true:
There exists an interface J such that K is a superinterface of J, and J is a.
Interface I is said to be a subinterface of interface K whenever K is a superinterface of I.
While every class is an extension of class Object, there is no single interface of which all interfaces are extensions.
An interface I directly depends on a type T if T is mentioned in the extends clause of I either as a superinterface or as a qualifier within a superinterface name.
An interface I depends on a reference type T if any of the following conditions hold: ‚Ä¢ I directly depends on T.
I directly depends on a class C that depends (¬ß8.1.5) on T.
I directly depends on an interface J that depends on T (using this definition.
It is a compile-time error if an interface depends on itself.
If circularly declared interfaces are detected at run time, as interfaces are loaded (¬ß12.2), then a ClassCircularityError is thrown.
The scope of a declaration of a member m declared in or inherited by an interface type I is specified in ¬ß6.3
The members of an interface are: ‚Ä¢ Those members declared in the interface.
If an interface has no direct superinterfaces, then the interface implicitly declares.
It is a compile-time error if the interface explicitly declares such a method m in the case where m is declared to be final in Object.
It follows that is a compile-time error if the interface declares a method with a signature that is override-equivalent (¬ß8.4.2) to a public method of Object, but has a different return type or incompatible throws clause.
The interface inherits, from the interfaces it extends, all members of those interfaces, except for (a) fields, classes, and interfaces that it hides and (b) methods that it overrides (¬ß9.4.1)
Fields, methods, and member types of an interface type may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures (¬ß6.5)
Every field declaration in the body of an interface is implicitly public, static, and final.
It is permitted to redundantly specify any or all of these modifiers for such fields.
If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for ConstantModifier.
It is a compile-time error if the same modifier appears more than once in a field declaration.
It is a compile-time error for the body of an interface declaration to declare two fields with the same name.
The declared type of a field is denoted by the Type that appears in the field declaration, followed by any bracket pairs that follow the Identifier in the declarator.
If the interface declares a field with a certain name, then the declaration of that field is said to hide any and all accessible declarations of fields with the same name in superinterfaces of the interface.
It is possible for an interface to inherit more than one field with the same name.
Such a situation does not in itself cause a compile-time error.
However, any attempt within the body of the interface to refer to any such field by its simple name will result in a compile-time error, because such a reference is ambiguous.
There might be several paths by which the same field declaration might be inherited from an interface.
In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.
If two fields with the same name are inherited by an interface because, for example, two of its direct superinterfaces declare fields with that name, then a single ambiguous member results.
Any use of this ambiguous member will result in a compile-time error.
This is all right as long as the interface does not contain any reference by simple name to the field YELLOW.
Such a reference could occur within a variable initializer for a field.)
If a single field is inherited multiple times from the same interface because, for example, both this interface and one of this interface's direct superinterfaces extend the interface that declares the field, then only a single member results.
This situation does not in itself cause a compile-time error.
In the previous example, the fields RED, GREEN, and BLUE are inherited by interface LotsOfColors in more than one way, through interface RainbowColors and also through interface PrintColors, but the reference to field RED in interface LotsOfColors is not considered ambiguous because only one actual declaration of the field RED is involved.
Every field in the body of an interface must have an initialization expression, which need not be a constant expression (¬ß15.28), or a compile-time error occurs.
It is a compile-time error if an initialization expression for an interface field contains a reference by simple name to the same field or to another field whose declaration occurs textually later in the same interface.
This program causes two compile-time errors, because j is referred to in the initialization of f before j is declared, and because the initialization of k refers to k itself.
The variable initializer is evaluated and the assignment performed exactly once, when the interface is initialized (¬ß12.4.2)
This also applies to static final fields in classes (¬ß8.3.2.1)
Every method declaration in the body of an interface is implicitly public (¬ß6.6)
Every method declaration in the body of an interface is implicitly abstract, so its body is always represented by a semicolon, not a block.
It is permitted, but discouraged as a matter of style, to redundantly specify the It is a compile-time error if the same modifier appears more than once on a method declared in an interface.
It is a compile-time error if a method declared in an interface is declared static, because static methods cannot be abstract.
It is a compile-time error if a method declared in an interface is strictfp or native or synchronized, because those keywords describe implementation properties rather than interface properties.
However, a method declared in an interface may be implemented by a method that is declared strictfp or native or synchronized in a class that implements the interface.
It is a compile-time error if a method declared in an interface is declared final.
However, a method declared in an interface may be implemented by a method that is declared final in a class that implements the interface.
It is a compile-time error for the body of an interface to declare, explicitly or implicitly, two methods with override-equivalent signatures (¬ß8.4.2)
However, an interface may inherit several methods with such signatures (¬ß9.4.1)
The rules for type parameters of a generic method in an interface are the same as for a generic method in a class (¬ß8.4.4)
An interface inherits from its direct superinterfaces all methods of the superinterfaces that are not overridden by a declaration in the interface.
If, for example, an interface declares two public methods with the same name (¬ß9.4.2), and a subinterface overrides one of them, the subinterface still inherits the other method.
Methods declared in interfaces are abstract and thus contain no implementation.
About all that can be accomplished by an overriding method declaration, other than to affirm a method signature, is to refine the return type or to restrict the exceptions that might be thrown by an implementation of the method.
Here is a variation of the example shown in (¬ß8.4.3.1):
The relationship between the return type of an interface method and the return types of any overridden interface methods is specified in ¬ß8.4.8.3
The relationship between the throws clause of an interface method and the throws clauses of any overridden interface methods are specified in ¬ß8.4.8.3
The relationship between the signature of an interface method and the signatures of overridden interface methods are specified in ¬ß8.4.8.3
It is possible for an interface to inherit several methods with override-equivalent signatures (¬ß8.4.2)
Such a situation does not in itself cause a compile-time error.
However, one of the inherited methods must be return-type-substitutable for every other inherited method; otherwise, a compile-time error occurs.
The throws clauses do not cause errors in this case.) There might be several paths by which the same method declaration is inherited from an interface.
This fact causes no difficulty and never, of itself, results in a compile-time error.
If two methods of an interface (whether both declared in the same interface, or both inherited by an interface, or one declared and one inherited) have the same name but different signatures that are not override-equivalent (¬ß8.4.2), then the method name is said to be overloaded.
This fact causes no difficulty and never of itself results in a compile-time error.
There is no required relationship between the return types or between the throws clauses of two methods with the same name but different signatures that are not override-equivalent.
Here, the method named move is overloaded in interface RealPointInterface with three different signatures, two of them declared and one inherited.
Any non-abstract class that implements interface RealPointInterface must provide implementations of all three method signatures.
A member type declaration in an interface is implicitly static and public.
It is permitted to redundantly specify either or both of these modifiers.
It is a compile-time error if the same modifier appears more than once in a member type declaration in an interface.
If an interface declares a member type with a certain name, then the declaration of that type is said to hide any and all accessible declarations of member types with the same name in superinterfaces of the interface.
An interface inherits from its direct superinterfaces all the non-private member types of the superinterfaces that are both accessible to code in the interface and not hidden by a declaration in the interface.
An interface may inherit two or more type declarations with the same name.
It is a compile-time error to attempt to refer to any ambiguously inherited class or interface by its simple name.
If the same type declaration is inherited from an interface by multiple paths, the class or interface is considered to be inherited only once; it may be referred to by its simple name without ambiguity.
An annotation type declaration is a special kind of interface declaration.
To distinguish an annotation type declaration from an ordinary interface declaration, the keyword interface is preceded by an at-sign (@)
Note that the at-sign (@) and the keyword interface are two distinct tokens.
Technically it is possible to separate them with whitespace, but this is discouraged as a matter of style.
The Identifier in an annotation type declaration specifies the name of the annotation type.
It is a compile-time error if an annotation type has the same simple name as any of its enclosing classes or interfaces.
The direct superinterface of an annotation type is always java.lang.annotation.Annotation.
By virtue of the AnnotationTypeDeclaration syntax, an annotation type declaration cannot be generic, and no extends clause is permitted.
A consequence of the fact that an annotation type cannot explicitly declare a superclass or superinterface is that a subclass or subinterface of an annotation type is never itself an annotation type.
An annotation type declaration inherits several members from java.lang.annotation.Annotation, including the implicitly declared methods corresponding to the instance methods in Object, yet these methods do not define elements (¬ß9.6.1) of the annotation type and it is illegal to use them in annotations.
Without this rule, we could not ensure that the elements were of the types representable in annotations, or that accessor methods for them would be available.
Unless explicitly modified herein, all of the rules that apply to ordinary interface declarations apply to annotation type declarations.
For example, annotation types share the same namespace as ordinary class and interface types; and annotation type declarations are legal wherever interface declarations are legal, and have the same scope and accessibility.
Each method declaration in an annotation type declaration defines an element of the annotation type.
An annotation type has no elements other than those defined by the methods it explicitly declares.
By virtue of the AnnotationTypeElementDeclaration syntax, a method declaration in an annotation type declaration cannot have any formal parameters or type parameters, or a throws clause.
By convention, no AbstractMethodModifiers should be present on an annotation type element except for annotations.
The following annotation type declaration defines an annotation type with several elements:
Describes the "request-for-enhancement" (RFE) * that led to the presence of the annotated API element.
The following annotation type declaration defines an annotation type with no elements, termed a marker annotation type:
It is a compile-time error if the return type of a method declared in an annotation type is not one of the following: a primitive type, String, Class, any parameterized.
It is a compile-time error if any method declared in an annotation type has a signature that is override-equivalent to that of any public or protected method declared in class Object or in the interface java.lang.annotation.Annotation.
It is a compile-time error if an annotation type declaration T contains an element of type T, either directly or indirectly.
By convention, the name of the sole element in a single-element annotation type is value.
Linguistic support for this convention is provided by the single element advantage of the construct.
The convention is illustrated in the following annotation type declaration:
The following annotation type declaration defines a single-element annotation type whose sole element has an array type:
The following annotation type declaration shows a Class annotation whose value is restricted by a bounded wildcard:
Note that the grammar for annotation type declarations permits other element declarations besides method declarations.
For example, one might choose to declare a nested enum for use in conjunction with an annotation type:
Here is an example of a complex annotation type, that is, an annotation type that contains one or more elements whose types are also annotation types.
An annotation type element may have a default value specified for it.
This is done by following its (empty) parameter list with the keyword default and the default value of the element.
Defaults are applied dynamically at the time annotations are read; default values are not compiled into annotations.
Thus, changing a default value affects annotations even in classes that were compiled before the change was made (presuming these annotations lack an explicit value for the defaulted element)
An ElementValue (¬ß9.7) is used to specify a default value.
It is a compile-time error if the type of the element is not commensurate (¬ß9.7) with the default value specified.
Several annotation types are predefined in the libraries of the Java SE platform.
This section does not provide a complete specification for the predefined annotations contained here in; that is the role of the appropriate API specifications.
Only those semantics that require special behavior on the part of a Java compiler or Java Virtual Machine implementation are specified here.
The annotation type java.lang.annotation.Target is intended to be used in meta-annotations that indicate the kind of program element that an annotation type is applicable to.
It is a compile-time error if a given enum constant appears more than once in an annotation whose corresponding type is java.lang.annotation.Target.
Annotations may be present only in source code, or they may be present in the binary form of a class or interface.
An annotation that is present in the binary form may or may not be available at run time via the reflection libraries of the Java SE platform.
The annotation type java.lang.annotation.Retention is used to choose among these possibilities.
If an annotation a corresponds to a type T, and T has a (meta-)annotation m that corresponds to java.lang.annotation.Retention, then: ‚Ä¢ If m has an element whose value is java.lang.annotation.RetentionPolicy.SOURCE, then a Java compiler must ensure that a is not present in the binary representation of the class or interface in which a appears.
If m has an element whose value is java.lang.annotation.RetentionPolicy.CLASS or java.lang.annotation.RetentionPolicy.RUNTIME, then a Java compiler must ensure that a is represented in the binary representation of the class or interface in which a appears, unless m annotates a local variable declaration.
An annotation on a local variable declaration is never retained in the binary representation.
In addition, if m has an element whose value is java.lang.annotation.RetentionPolicy.RUNTIME, the reflection libraries of the Java SE platform must make a available at run time.
If T does not have a (meta-)annotation m that corresponds to java.lang.annotation.Retention, then a Java compiler must treat T as if it does have such a meta-annotation m with an element whose value is java.lang.annotation.RetentionPolicy.CLASS.
The annotation type java.lang.annotation.Inherited is used to indicate that annotations on a class C corresponding to a given annotation type are inherited by subclasses of C.
Programmers occasionally overload a method declaration when they mean to override it, leading to subtle problems.
The annotation type Override supports early detection of such problems.
This is perfectly legal, but class Foo inherits the equals implementation from Object, which can cause some very subtle bugs.
If a method declaration is annotated with the annotation @Override, but the method does not override or implement a method declared in a supertype, or is not overrideequivalent to a public method of Object, a compile-time error occurs.
The clause about overriding a public method is motivated by use of @Override in an interface.
However, consider an interface that attempts to use @Override on a clone method: (finalize could also be used in this example)
Because Object.clone is not public, there is no member called clone implicitly declared in Quux.
Therefore, the explicit declaration of clone in Quux is not deemed.
In contrast, a class declaration that declares clone is simply overriding Object.clone, so is able to use @Override:
Java compilers are increasingly capable of issuing helpful "lint-like" warnings.
To encourage the use of such warnings, there should be some way to disable a warning in a part of the program when the programmer knows that the warning is inappropriate.
The annotation type SuppressWarnings supports programmer control over warnings otherwise issued by a Java compiler.
It contains a single element that is an array of String.
If a program declaration is annotated with the annotation report any warning identified by one of S1 ...
Sk if that warning would have been generated as a result of the annotated declaration or any of its parts.
Compiler vendors should document the warning names they support in conjunction with this annotation type.
Vendors are encouraged to cooperate to ensure that the same names work across multiple compilers.
A program element annotated @Deprecated is one that programmers are discouraged from using, typically because it is dangerous, or because a better alternative exists.
A Java compiler must produce a deprecation warning when a type, method, field, or constructor whose declaration is annotated with the annotation @Deprecated is used (i.e.
The use is within an entity that is annotated to suppress the warning with the.
The use and declaration are both within the same outermost class.
Use of the @Deprecated annotation on a local variable declaration or on a parameter declaration has no effect.
Such warnings are uninformative if the body of the variable arity method is wellbehaved with respect to the variable arity parameter.
The annotation type SafeVarargs, when used to annotate a method or constructor declaration, makes a programmer assertion that prevents a Java compiler from reporting unchecked warnings for the declaration or invocation of a variable arity method or constructor where the compiler would otherwise do so due to the variable arity parameter having a non-reifiable element type.
The SafeVarargs annotation has non-local effects because it suppresses unchecked warnings at method invocation expressions in addition to an unchecked warning pertaining to the declaration of the variable arity method itself (¬ß8.4.1)
In contrast, the @SuppressWarnings("unchecked") annotation has local effects because it only suppresses unchecked warnings pertaining to the declaration of a method.
The canonical target for a SafeVarargs annotation is a method like java.util.Collections.addAll, whose declaration starts with:
The variable arity parameter has declared type T[], which is non-reifiable.
However, the method fundamentally just reads from the input array and adds the elements to a collection, both of which are safe operations with respect to the array.
Therefore, any compile-time unchecked warnings at method invocation expressions for java.util.Collections.addAll are arguably spurious and uninformative.
Applying a SafeVarargs annotation to the method declaration prevents generation of these unchecked warnings at the method invocation expressions.
It is a compile-time error if a fixed arity method or constructor declaration is annotated with the SafeVarargs annotation.
It is a compile-time error if a variable arity method declaration that is neither static nor final is annotated with the SafeVarargs annotation.
Since a SafeVarargs annotation is only applicable to static methods, final instance methods, and constructors, the annotation is not usable where method overriding occurs.
Annotation inheritance only works on classes (not methods, interfaces, or constructors), so a SafeVarargs-style annotation cannot be passed through instance methods in classes or through interfaces.
An annotation is a modifier consisting of the name of an annotation type (¬ß9.6) and zero or more element-value pairs, each of which associates a value with a different element of the annotation type.
The purpose of an annotation is simply to associate information with the annotated program element.
Annotations must contain an element-value pair for every element of the corresponding annotation type, except for those elements with default values, or a compile-time error occurs.
Annotations may, but are not required to, contain element-value pairs for elements with default values.
Such annotations are placed immediately before the enum constant they annotate.
It is a compile-time error if a declaration is annotated with more than one annotation for a given annotation type.
Annotations are conventionally placed before all other modifiers, but this is not a requirement; they may be freely intermixed with other modifiers.
The others (marker annotation and single-element annotation) are merely shorthands.
A normal annotation is used to annotate a program element.
The TypeName names the annotation type corresponding to the annotation.
Note that the at-sign (@) is a token unto itself.
Technically it is possible to put whitespace between it and the TypeName, but this is discouraged as a matter of style.
It is a compile-time error if TypeName does not name an annotation type that is accessible (¬ß6.6) at the point where the annotation is used.
The Identifier in an ElementValuePair must be the simple name of one of the elements (i.e.
The return type of this method defines the element type of the element-value pair.
An ElementValueArrayInitializer is similar to a normal array initializer (¬ß10.6), except that annotations are permitted in place of expressions.
The type of V is assignment compatible (¬ß5.2) with T, and furthermore:
If T is a primitive type or String, and V is a constant expression (¬ß15.28)
If T is Class, or an invocation of Class, and V is a class literal (¬ß15.8.2)
If T is an enum type, and V is an enum constant.
Note that null is not a legal element value for any element type.
It is a compile-time error if the element type is not commensurate with the ElementValue.
If the element type is not an annotation type or an array type, ElementValue must be a ConditionalExpression (¬ß15.25)
A ConditionalExpression is simply an expression without assignments, and not necessarily an expression involving the conditional operator (? :)
ConditionalExpression is preferred over Expression in ElementValue because an element value has a simple structure (constant expression or class literal or enum constant) that may easily be represented in binary form.
If the element type is an array type and the corresponding ElementValue is not an ElementValueArrayInitializer, then an array value whose sole element is the value represented by the ElementValue is associated with the element.
Otherwise, if the corresponding ElementValue is an ElementValueArrayInitializer, then the array value represented by the ElementValueArrayInitializer is associated with the element.
In other words, it is permissible to omit the curly braces when a single-element array is to be associated with an array-valued annotation type element.
Note that the array's element type cannot be an array type.
That is, nested array types are not permitted as element types.
While the annotation syntax would permit this, the annotation type declaration syntax would not.)
An annotation on an annotation type declaration is known as a meta-annotation.
An annotation type may be used to annotate its own declaration.
More generally, circularities in the transitive closure of the "annotates" relation are permitted.
For example, it is legal to annotate an annotation type declaration with another annotation type, and to annotate the latter type's declaration with the former type.
Here is an example of a normal annotation that takes advantage of default values.
Note that the types of the annotations in the examples in this section are the annotation types defined in the examples in ¬ß9.6
Note also that the elements are in the above annotation are in the same order as in the corresponding annotation type declaration.
This is not required, but unless specific circumstances dictate otherwise, it is a reasonable convention to follow.
The second form of annotation, marker annotation, is a shorthand designed for use with marker annotation types.
It is legal to use the marker annotation form for annotation types with elements, so long as all the elements have default values.
Here is an example using the Preliminary marker annotation type from ¬ß9.6.1:
The third form of annotation, single-element annotation, is a shorthand designed for use with single-element annotation types.
It is legal to use single-element annotations for annotation types with multiple elements, so long as one element is named value, and all other elements have default values.
Here is an example of a single-element array-valued single-element annotation.
Here is an example with of a single-element annotation that contains a normal annotation.
Here is an example of a single-element annotation with a Class element whose value is restricted by the use of a bounded wildcard.
Here is an example of a single-element annotation using an enum type defined inside the annotation type.
All methods of class Object may be invoked on an array.
The number of variables may be zero, in which case the array is said to be empty.
The variables contained in an array have no names; instead they are referenced by array access expressions that use non-negative integer index values.
All the components of an array have the same type, called the component type of the array.
If the component type of an array is T, then the type of the array itself is written T[]
The value of an array component of type float is always an element of the float always an element of the double value set.
It is not permitted for the value of an array component of type float to be an element of the float-extended-exponent value set that is not also an element of the float value set, nor for the value of an array component of type double to be an element of the double-extended-exponent value set that is not also an element of the double value set.
The component type of an array may itself be an array type.
The components of such an array may contain references to subarrays.
If, starting from any array type, one considers its component type, and then (if that is also an array type) the component type of that type, and so on, eventually one must reach a component type that is not an array type; this is called the element type of the original array, and the components at this level of the data structure are called the elements of the original array.
There are some situations in which an element of an array can be an array: if the element type is Object or Cloneable or java.io.Serializable, then some or all of the elements may be arrays, because any array object can be assigned to any variable of these types.
Array types are used in declarations and in cast expressions (¬ß15.16)
An array type is written as the name of an element type followed by some number of empty pairs of square brackets []
The number of bracket pairs indicates the depth of array nesting.
The element type of an array may be any type, whether primitive or reference.
Arrays with an interface type as the element type are allowed.
An element of such an array may have as its value a null reference or an instance of any type that implements the interface.
Arrays with an abstract class type as the element type are allowed.
An element of such an array may have as its value a null reference or an instance of any subclass of the abstract class that is not itself abstract.
The supertypes of an array type are specified in ¬ß4.10.3
A variable of array type holds a reference to an object.
Declaring a variable of array type does not create an array object or allocate any space for array components.
It creates only the variable itself, which can contain a reference to an array.
The following are examples of declarations of array variables that do create array objects:
The [] may appear as part of the type at the beginning of the declaration, or as part of the declarator for a particular variable, or both.
Brackets are allowed in declarators as a nod to the tradition of C and C++
The general rules for variable declaration, however, permit brackets to appear on both the type and in declarators, so that the local variable declaration:
We do not recommend "mixed notation" in an array variable declaration, where brackets appear on both the type and in declarators.
Once an array object is created, its length never changes.
To make an array variable refer to an array of different length, a reference to a different array must be assigned to the variable.
A single variable of array type may contain references to arrays of different lengths, because an array's length is not part of its type.
This may result in a run-time exception on a later assignment; see ¬ß10.5 for a discussion.
An array creation expression specifies the element type, the number of levels of nested arrays, and the length of the array for at least one of the levels of nesting.
The array's length is available as a final instance variable length.
An array initializer creates an array and provides initial values for all its components.
The program declares a variable ia that has type array of int, that is, int[]
The variable ia is initialized to reference a newly created array object, created by an array creation expression (¬ß15.10)
The array creation expression specifies that the array should have 101 components.
The length of the array is available using the field length, as shown.
Arrays must be indexed by int values; short, byte, or char values may also be used as index values because they are subjected to unary numeric promotion (¬ß5.6.1) and become int values.
An attempt to access an array component with a long index value results in a compile-time error.
All array accesses are checked at run time; an attempt to use an index that is less than zero or greater than or equal to the length of the array causes an ArrayIndexOutOfBoundsException to be thrown.
For an array whose type is A[], where A is a reference type, an assignment to a component of the array is checked at run time to ensure that the value being assigned is assignable to the component.
If the type of the value being assigned is not assignment-compatible (¬ß5.2) with the component type, an ArrayStoreException is thrown.
If the component type of an array were not reifiable (¬ß4.7), the Java Virtual Machine could not perform the store check described in the preceding paragraph.
This is why an array creation expression with a non-reifiable element type is forbidden (¬ß15.10)
One may declare a variable of an array type whose element type is non-reifiable, but assignment of the result of an array creation expression to the variable will necessarily cause an unchecked warning (¬ß5.1.9)
A ColoredPoint can be assigned to a Point; therefore, the value of cpa can be assigned to pa.
A reference to this array pa, for example, testing whether pa[1] is null, will not result in a run-time type error.
This is because the element of the array of type ColoredPoint[] is a ColoredPoint, and every ColoredPoint can stand in for a Point, since Point is the superclass of ColoredPoint.
On the other hand, an assignment to the array pa can result in a run-time error.
At compile time, an assignment to an element of pa is checked to make sure that the value assigned is a Point.
But since pa holds a reference to an array of ColoredPoint, the assignment is valid only if the type of the value assigned at run time is, more specifically, a ColoredPoint.
The Java Virtual Machine checks for such a situation at run time to ensure that the assignment is valid; if not, an ArrayStoreException is thrown.
The following is repeated from ¬ß8.3 to make the presentation here clearer:
A trailing comma may appear after the last expression in an array initializer and is ignored.
Each variable initializer must be assignment-compatible (¬ß5.2) with the array's component type, or a compile-time error occurs.
It is a compile-time error if the component type of the array being initialized is not reifiable (¬ß4.7)
The length of the array to be constructed is equal to the number of variable initializers immediately enclosed by the braces of the array initializer.
Space is allocated for a new array of that length.
If there is insufficient space to allocate the array, evaluation of the array initializer completes abruptly by throwing an OutOfMemoryError.
Otherwise, a one-dimensional array is created of the specified length, and each component of the array is initialized to its default value (¬ß4.12.5)
The variable initializers immediately enclosed by the braces of the array initializer are then executed from left to right in the textual order they occur in the source code.
The n'th variable initializer specifies the value of the n-1'th array component.
If execution of a variable initializer completes abruptly, then execution of the array initializer completes abruptly for the same reason.
If the component type is an array type, then the variable initializer specifying a component may itself be an array initializer; that is, array initializers may be nested.
In this case, execution of the nested array initializer constructs and initializes an array object by recursive application of the algorithm above, and assigns it to the component.
The members of an array type are all of the following: ‚Ä¢ The public final field length, which contains the number of components of.
The public method clone, which overrides the method of the same name in.
A clone of a multidimensional array is shallow, which is to say that it creates only a single new array.
All the members inherited from class Object; the only method of Object that is not inherited is its clone method.
An array thus has the same public fields and methods as the following class:
Note that the cast in the example above would generate an unchecked warning (¬ß5.1.9) if arrays were really implemented this way.
See ¬ß9.6.3.4 for another situation where the difference between public and non-public methods of Object requires special care.
The fact that subarrays are shared when a multidimensional array is cloned is shown by this program:
Every array has an associated Class object, shared with all other arrays with the same component type.
The program uses the method getClass inherited from class Object, and the field length.
The result of the comparison of the Class objects in the first println.
In the Java programming language, unlike C, an array of char is not a String, and neither a String nor an array of char is terminated by '\u0000' (the NUL character)
A String object is immutable, that is, its contents never change, while an array of char has mutable elements.
The method toCharArray in class String returns an array of characters containing the same character sequence as a String.
The class StringBuffer implements useful methods on mutable arrays of characters.
An example of such a violation is an attempt to index outside the bounds of an array.
Some programming languages and their implementations react to such errors by peremptorily terminating the program; other programming languages allow an implementation to react in an arbitrary or unpredictable way.
Neither of these approaches is compatible with the design goals of the Java SE platform: to provide portability and robustness.
Instead, the Java programming language specifies that an exception will be thrown when semantic constraints are violated and will cause a non-local transfer of control from the point where the exception occurred to a point that can be specified by the programmer.
An exception is said to be thrown from the point where it occurred and is said to be caught at the point to which control is transferred.
Programs can also throw exceptions explicitly, using throw statements (¬ß14.18)
Explicit use of throw statements provides an alternative to the old-fashioned style of handling error conditions by returning funny values, such as the integer value -1 where a negative value would not normally be expected.
Experience shows that too often such funny values are ignored or not checked for by callers, leading to programs that are not robust, exhibit undesirable behavior, or both.
Every exception is represented by an instance of the class Throwable or one of its subclasses (¬ß11.1)
Such an object can be used to carry information from the point at which an exception occurs to the handler that catches it.
Handlers are established by catch clauses of try statements (¬ß14.20)
During the process of throwing an exception, the Java Virtual Machine abruptly completes, one by one, any expressions, statements, method and constructor invocations, initializers, and field initialization expressions that have begun but not completed execution in the current thread.
This process continues until a handler is found that indicates that it handles that particular exception by naming the class of the exception or a superclass of the class of the exception (¬ß11.2)
If no such handler is found, then the exception may be handled by one of a hierarchy of uncaught exception handlers (¬ß11.3) - thus every effort is made to avoid letting an exception go unhandled.
An exception is represented by an instance of the class Throwable (a direct subclass of Object) or one of its subclasses.
Throwable and all its subclasses are, collectively, the exception classes.
Note that a subclass of Throwable must not be generic (¬ß8.1.2)
The classes Exception and Error are direct subclasses of Throwable.
Exception is the superclass of all the exceptions from which ordinary programs may wish to recover.
Error is the superclass of all the exceptions from which ordinary programs are not ordinarily expected to recover.
Error and all its subclasses are, collectively, the error classes.
RuntimeException is the superclass of all the exceptions which may be thrown.
RuntimeException and all its subclasses are, collectively, the run-time exception classes.
The unchecked exception classes are the run-time exception classes and the error classes.
The checked exception classes are all exception classes other than the unchecked exception classes.
That is, the checked exception classes are all subclasses of Throwable other than RuntimeException and its subclasses and Error and its subclasses.
Programs can use the pre-existing exception classes of the Java SE platform API in throw statements, or define additional exception classes as subclasses of Throwable or of any of its subclasses, as appropriate.
To take advantage of compile-time checking for exception handlers (¬ß11.2), it is typical to define most new exception classes as checked exception classes, that is, as subclasses of Exception that are not subclasses of RuntimeException.
An abnormal execution condition was synchronously detected by the Java.
Virtual Machine, namely: ‚óÜ evaluation of an expression violates the normal semantics of the Java.
These exceptions are not thrown at an arbitrary point in the program, but rather at a point where they are specified as a possible result of an expression evaluation or statement execution.
Most exceptions occur synchronously as a result of an action by the thread in which they occur, and at a point in the program that is specified to possibly result in such an exception.
An asynchronous exception is, by contrast, an exception that can potentially occur at any point in the execution of a program.
An invocation of the (deprecated) stop method of class Thread or ThreadGroup.
The (deprecated) stop methods may be invoked by one thread to affect another thread or all the threads in a specified thread group.
They are asynchronous because they may occur at any point in the execution of the other thread or threads.
An internal error or resource limitation in the Java Virtual Machine that prevents it from implementing the semantics of the Java programming language.
In this case, the asynchronous exception that is thrown is an instance of a subclass of VirtualMethodError.
Note that StackOverflowError, a subclass of VirtualMethodError, may be thrown synchronously by method invocation (¬ß15.12.4.5) as well as asynchronously due to native method execution or Java Virtual Machine resource limitations.
The Java SE platform permits a small but bounded amount of execution to occur before an asynchronous exception is thrown.
Asynchronous exceptions are rare, but proper understanding of their semantics is necessary if high-quality machine code is to be generated.
The delay noted above is permitted to allow optimized code to detect and throw these exceptions at points where it is practical to handle them while obeying the semantics of the Java programming language.
A simple implementation might poll for asynchronous exceptions at the point of each control transfer instruction.
Since a program has a finite size, this provides a bound on the total delay in detecting an asynchronous exception.
Since no asynchronous exception will occur between control transfers, the code generator has some flexibility to reorder computation between control transfers for greater performance.
The Java programming language requires that a program contains handlers for checked exceptions which can result from execution of a method or constructor.
This compile-time checking for the presence of exception handlers is designed to reduce the number of exceptions which are not properly handled.
The checked exception classes (¬ß11.1.1) named in the throws clause are part of the contract between the implementor and user of the method or constructor.
The throws clause of an overriding method may not specify that this method will result in throwing any checked exception which the overridden method is not permitted, by its throws clause, to throw (¬ß8.4.8.3)
When interfaces are involved, more than one method declaration may be overridden by a single overriding declaration.
In this case, the overriding declaration must have a throws clause that is compatible with all the overridden declarations (¬ß9.4.1)
The unchecked exception classes (¬ß11.1.1) are exempted from compile-time checking.
Of the unchecked exception classes, error classes are exempted because they can occur at many points in the program and recovery from them is difficult or impossible.
Sophisticated programs may yet wish to catch and attempt to recover from some of these conditions.
Of the unchecked exception classes, run-time exception classes are exempted because, in the judgment of the designers of the Java programming language, having to declare such exceptions would not aid significantly in establishing the correctness of programs.
Many of the operations and constructs of the Java programming language can result in exceptions at run time.
The information available to a Java compiler, and the level of analysis a compiler performs, are usually not sufficient to establish that such run-time exceptions cannot occur, even though this may be obvious to the programmer.
Requiring such exception classes to be declared would simply be an irritation to programmers.
For example, certain code might implement a circular data structure that, by construction, can never involve null references; the programmer can then be certain that a NullPointerException cannot occur, but it would be difficult for a Java compiler to prove it.
The theorem-proving technology that is needed to establish such global properties of data structures is beyond the scope of this specification.
We say that a catch clause can catch its catchable exception class(es)
The catchable exception class of a uni-catch clause is the declared type of its exception parameter (¬ß14.20)
The catchable exception classes of a multi-catch clause are the alternatives in the union that denotes the type of its exception parameter (¬ß14.20)
A class instance creation expression (¬ß15.9) can throw an exception class E iff either:
The expression is a qualified class instance creation expression and the qualifying expression can throw E; or.
Some expression of the argument list can throw E; or.
The class instance creation expression includes a ClassBody, and some instance initializer block or instance variable initializer expression in the ClassBody can throw E.
Some expression of the argument list can throw E; or.
For every other kind of expression, the expression can throw an exception class E iff one of its immediate subexpressions can throw E.
A throw statement (¬ß14.18) whose thrown expression has static type E and is not a final or effectively final exception parameter can throw E or any exception class that the thrown expression can throw.
Formally, it is not the case that it "can throw" a subclass or superclass of java.io.FileNotFoundException.
A throw statement whose thrown expression is a final or effectively final exception parameter of a catch clause C can throw an exception class E iff:
A try statement (¬ß14.20) can throw an exception class E iff either: ‚Ä¢ The try block can throw E, or an expression used to initialize a resource (in a try-with-resources statement) can throw E, or the automatic invocation of the and E is not assignment compatible with any catchable exception class of any catch clause of the try statement, and either no finally block is present or the finally block can complete normally; or.
Some catch block of the try statement can throw E and either no finally block is present or the finally block can complete normally; or.
An explicit constructor invocation statement (¬ß8.8.7.1) can throw an exception class E iff either:
Some expression of the constructor invocation's parameter list can throw E; or.
Any other statement S can throw an exception class E iff an expression or statement immediately contained in S can throw E.
It is a compile-time error if a method or constructor body can throw some exception class E when E is a checked exception class and E is not a subclass of some class declared in the throws clause of the method or constructor.
It is a compile-time error if an instance variable initializer or instance initializer of a named class can throw a checked exception class unless that exception class or one of its superclasses is explicitly declared in the throws clause of each constructor of its class and the class has at least one explicitly declared constructor.
Note that no compile-time error is due if an instance variable initializer or instance initializer of an anonymous class (¬ß15.9.5) can throw an exception class.
In a named class, it is the responsibility of the programmer to propagate information about which exception classes can be thrown by initializers, by declaring a suitable throws clause on any explicit constructor declaration.
This relationship between the checked exception classes thrown by a class's initializers and the checked exception classes declared by a class's constructors is assured implicitly for an anonymous class declaration, because no explicit constructor declarations are possible and a Java compiler always generates a constructor with a suitable throws clause for that anonymous class declaration based on the checked exception classes that its initializers can throw.
It is not the case that statement "can throw" // a subtype or supertype of FileNotFoundException.
All subtypes of IOException that the try block // can throw have already been caught.
It is not the case // that m "can throw" a subtype or supertype of // IOException, e.g.
Exception, though Exception or // a supertype of Exception can always be caught.
By the rules above, each alternative in a multi-catch clause (¬ß14.20) must be able to catch some exception class thrown by the try block and uncaught by previous catch clauses.
For example, the second catch clause below would cause a compile-time error because exception analysis determines that SubclassOfFoo is already caught by the first catch clause:
A statement or expression is dynamically enclosed by a catch clause if it appears within the try block of the try statement of which the catch clause is a part, or if the caller of the statement or expression is dynamically enclosed by the catch clause.
If within a constructor or an instance initializer or the initializer for an instance.
If within a static initializer or an initializer for a static variable, then the caller is the expression that used the class or interface so as to cause it to be initialized (¬ß12.4)
Whether a particular catch clause can handle an exception is determined by comparing the class of the object that was thrown to the catchable exception classes of the catch clause.
The catch clause can handle the exception if one of its catchable exception classes is the class of the exception or a superclass of the class of the exception.
Equivalently, a catch clause will catch any exception object that is an instanceof (¬ß15.20.2) one of its catchable exception classes.
All exceptions (synchronous and asynchronous) are precise: when the transfer of control takes place, all effects of the statements executed and expressions evaluated before the point from which the exception is thrown must appear to have taken place.
No expressions, statements, or parts thereof that occur after the point from which the exception is thrown may appear to have been evaluated.
If optimized code has speculatively executed some of the expressions or statements which follow the point at which the exception occurs, such code must be prepared to hide this speculative execution from the user-visible state of the program.
If no catch clause that can handle an exception can be found, then the current thread (the thread that encountered the exception) is terminated.
If the current thread has an uncaught exception handler set, then that handler is executed.
Otherwise, the method uncaughtException is invoked for the ThreadGroup that is the parent of the current thread.
If the ThreadGroup and its parent ThreadGroups do not override uncaughtException, then the default handler's uncaughtException method is invoked.
In situations where it is desirable to ensure that one block of code is always executed after another, even if that other block of code completes abruptly, a try statement with a finally clause (¬ß14.20.2) may be used.
If a try or catch block in a try-finally or try-catch-finally statement completes abruptly, then the finally clause is executed during propagation of the exception, even if no matching catch clause is ultimately found.
If a finally clause is executed because of abrupt completion of a try block and the finally clause itself completes abruptly, then the reason for the abrupt completion of the try block is discarded and the new reason for abrupt completion is propagated from there.
The main method of class Test invokes the thrower method four times, causing exceptions to be thrown three of the four times.
The try statement in method main catches each exception that the thrower throws.
Whether the invocation of thrower completes normally or abruptly, a message is printed describing what happened.
The declaration of the method thrower must have a throws clause because it can throw instances of TestException, which is a checked exception class (¬ß11.1.1)
A compiletime error would occur if the throws clause were omitted.
It is organized around the life cycle of the Java Virtual Machine and of the classes, interfaces, and objects that form a program.
The Java Virtual Machine starts up by loading a specified class and then invoking the method main in this specified class.
Section ¬ß12.1 outlines the loading, linking, and initialization steps involved in executing main, as an introduction to the concepts in this chapter.
The Java Virtual Machine starts execution by invoking the method main of some specified class, passing it a single argument, which is an array of strings.
In the examples in this specification, this first class is typically called Test.
Here we present an overview of the process from the viewpoint of the Java programming language.
The manner in which the initial class is specified to the Java Virtual Machine is beyond the scope of this specification, but it is typical, in host environments that use command lines, for the fully-qualified name of the class to be specified as a command-line argument and for following command-line arguments to be used as strings to be provided as the argument to the method main.
We now outline the steps the Java Virtual Machine may take to execute Test, as an example of the loading, linking, and initialization processes that are described further in later sections.
The initial attempt to execute the method main of class Test discovers that the class Test is not loaded - that is, that the Java Virtual Machine does not currently contain a binary representation for this class.
The Java Virtual Machine then uses a class loader to attempt to find such a binary representation.
After Test is loaded, it must be initialized before main can be invoked.
And Test, like all (class or interface) types, must be linked before it is initialized.
Verification checks that the loaded representation of Test is well-formed, with a proper symbol table.
Verification also checks that the code that implements Test obeys the semantic requirements of the Java programming language and the Java Virtual Machine.
If a problem is detected during verification, then an error is thrown.
Preparation involves allocation of static storage and any data structures that are used internally by the implementation of the Java Virtual Machine, such as method tables.
Resolution is the process of checking symbolic references from Test to other classes and interfaces, by loading the other classes and interfaces that are mentioned and checking that the references are correct.
The resolution step is optional at the time of initial linkage.
An implementation may resolve symbolic references from a class or interface that is being linked very early, even to the point of resolving all symbolic references from the classes and interfaces.
This resolution may result in errors from these further loading and linking steps.) This implementation choice represents one extreme and is similar to the kind of "static" linkage that has been done for many years in simple implementations of the C language.
In these implementations, a compiled program is typically represented as an "a.out" file that contains a fully-linked version of the program, including completely resolved links to library routines used by the program.
Copies of these library routines are included in the "a.out" file.) An implementation may instead choose to resolve a symbolic reference only when it is actively used; consistent use of this strategy for all symbolic references would represent the "laziest" form of resolution.
In this case, if Test had several symbolic references to another class, then the references might be resolved one at a time, as they are used, or perhaps not at all, if these references were never used during execution of the program.
The only requirement on when resolution is performed is that any errors detected during resolution must be thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error.
Using the "static" example implementation choice described above, loading and linkage errors could occur before the program is executed if they involved a class or interface mentioned in the class Test or any of the further, recursively referenced, classes and interfaces.
In a system that implemented the "laziest" resolution, these errors would be thrown only when an incorrect symbolic reference is actively used.
In our continuing example, the Java Virtual Machine is still trying to execute the method main of class Test.
This is permitted only if the class has been initialized (¬ß12.4.1)
Initialization consists of execution of any class variable initializers and static initializers of the class Test, in textual order.
But before Test can be initialized, its direct superclass must be initialized, as well as the direct superclass of its direct superclass, and so on, recursively.
In the simplest case, Test has Object as its implicit direct superclass; if class Object has not yet been initialized, then it must be initialized before Test is initialized.
Class Object has no superclass, so the recursion terminates here.
If class Test has another class Super as its superclass, then Super must be initialized before Test.
This requires loading, verifying, and preparing Super if this has not already been done and, depending on the implementation, may also involve resolving the symbolic references from Super and so on, recursively.
Initialization may thus cause loading, linking, and initialization errors, including such errors involving other types.
Finally, after completion of the initialization for class Test (during which other consequential loading, linking, and initializing may have occurred), the method main of Test is invoked.
The method main must be declared public, static, and void.
It must specify a formal parameter (¬ß8.4.1) whose declared type is array of String.
Loading refers to the process of finding the binary form of a class or interface type with a particular name, perhaps by computing it on the fly, but more typically by retrieving a binary representation previously computed from source code by a Java compiler, and constructing, from that binary form, a Class object to represent the class or interface.
Here we present an overview of the process from the viewpoint of the Java programming language.
The method defineClass of class ClassLoader may be used to construct Class objects from binary representations in the class file format.
Given the same name, a good class loader should always return the same class object.
However, it could not undermine the security of the type system, because the Java Virtual Machine guards against this.
A basic principle of the design of the Java programming language is that the run-time type system cannot be subverted by code written in the Java programming language, not even by implementations of such otherwise sensitive system classes as ClassLoader and SecurityManager.
The loading process is implemented by the class ClassLoader and its subclasses.
In particular, a class loader may cache binary representations of classes and interfaces, prefetch them based on expected usage, or load a group of related classes together.
These activities may not be completely transparent to a running application if, for example, a newly compiled version of a class is not found because an older version is cached by a class loader.
It is the responsibility of a class loader, however, to reflect loading errors only at points in the program where they could have arisen without prefetching or group loading.
If an error occurs during class loading, then an instance of one of the following subclasses of class LinkageError will be thrown at any point in the program that (directly or indirectly) uses the type: ‚Ä¢ ClassCircularityError: A class or interface could not be loaded because it.
ClassFormatError: The binary data that purports to specify a requested.
NoClassDefFoundError: No definition for a requested class or interface could.
Because loading involves the allocation of new data structures, it may fail with an OutOfMemoryError.
Linking is the process of taking a binary form of a class or interface type and combining it into the run-time state of the Java Virtual Machine, so that it can be executed.
A class or interface type is always loaded before it is linked.
Three different activities are involved in linking: verification, preparation, and resolution of symbolic references.
Here we present an overview of the process from the viewpoint of the Java programming language.
This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that the semantics of the Java programming language are respected, that a class or interface is completely verified and prepared before it is initialized, and that errors detected during linkage are thrown at a point in the program where some action is taken by the program that might require linkage to the class or interface involved in the error.
For example, an implementation may choose to resolve each symbolic reference in a class or interface individually, only when it is used (lazy or late resolution), or to resolve them all at once while the class is being verified (static resolution)
This means that the resolution process may continue, in some implementations, after a class or interface has been initialized.
Because linking involves the allocation of new data structures, it may fail with an OutOfMemoryError.
Verification ensures that the binary representation of a class or interface is structurally correct.
For example, it checks that every instruction has a valid operation code; that every branch instruction branches to the start of some other instruction, rather than into the middle of an instruction; that every method is provided with a structurally correct signature; and that every instruction obeys the type discipline of the Java Virtual Machine language.
If an error occurs during verification, then an instance of the following subclass of class LinkageError will be thrown at the point in the program that caused the class to be verified: ‚Ä¢ VerifyError: The binary definition for a class or interface failed to pass a set of.
Preparation involves creating the static fields (class variables and constants) for a class or interface and initializing such fields to the default values (¬ß4.12.5)
This does not require the execution of any source code; explicit initializers for static fields are executed as part of initialization (¬ß12.4), not preparation.
Implementations of the Java Virtual Machine may precompute additional data structures at preparation time in order to make later operations on a class or interface more efficient.
One particularly useful data structure is a "method table" or other data structure that allows any method to be invoked on instances of a class without requiring a search of superclasses at invocation time.
For fields and methods, these symbolic references include the name of the class or interface type of which the field or method is a member, as well as the name of the field or method itself, together with appropriate type information.
Before a symbolic reference can be used it must undergo resolution, wherein a symbolic reference is checked to be correct and, typically, replaced with a direct reference that can be more efficiently processed if the reference is used repeatedly.
If an error occurs during resolution, then an error will be thrown.
Most typically, this will be an instance of one of the following subclasses of the class IncompatibleClassChangeError, but it may also be an instance of some other subclass of IncompatibleClassChangeError or even an instance of the class IncompatibleClassChangeError itself.
This error may be thrown at any point in the program that uses a symbolic reference to the type, directly or indirectly: ‚Ä¢ IllegalAccessError: A symbolic reference has been encountered that specifies.
This can occur, for example, if a field that is originally declared public is changed to be private after another class that refers to the field has been compiled (¬ß13.4.7)
InstantiationError: A symbolic reference has been encountered that is used in class instance creation expression, but an instance cannot be created because the reference turns out to refer to an interface or to an abstract class.
This can occur, for example, if a class that is originally not abstract is changed to be abstract after another class that refers to the class in question has been compiled (¬ß13.4.1)
NoSuchFieldError: A symbolic reference has been encountered that refers to a specific field of a specific class or interface, but the class or interface does not contain a field of that name.
This can occur, for example, if a field declaration was deleted from a class after another class that refers to the field was compiled (¬ß13.4.8)
NoSuchMethodError: A symbolic reference has been encountered that refers to a specific method of a specific class or interface, but the class or interface does not contain a method of that signature.
This can occur, for example, if a method declaration was deleted from a class after another class that refers to the method was compiled (¬ß13.4.12)
Additionally, an UnsatisfiedLinkError, a subclass of LinkageError, may be thrown if a class declares a native method for which no implementation can be found.
The error will occur if the method is used, or earlier, depending on what kind of resolution strategy is being used by an implementation of the Java Virtual Machine (¬ß12.3)
Initialization of a class consists of executing its static initializers and the initializers for static fields (class variables) declared in the class.
Initialization of an interface consists of executing the initializers for fields (constants) declared in the interface.
Before a class is initialized, its direct superclass must be initialized, but interfaces implemented by the class are not initialized.
Similarly, the superinterfaces of an interface are not initialized before the interface is initialized.
A class or interface type T will be initialized immediately before the first occurrence of any one of the following:
A static field declared by T is used and the field is not a constant variable.
A reference to a static field (¬ß8.3.1.1) causes initialization of only the class or interface that actually declares it, even though it might be referred to through the name of a subclass, a subinterface, or a class that implements an interface.
Invocation of certain reflective methods in class Class and in package java.lang.reflect also causes class or interface initialization.
A class or interface will not be initialized under any other circumstance.
The intent is that a class or interface type has a set of initializers that put it in a consistent state, and that this state is the first state that is observed by other classes.
The static initializers and class variable initializers are executed in textual order, and may not refer to class variables declared in the class whose declarations appear textually after the use, even though these class variables are in scope (¬ß8.3.2.3)
This restriction is designed to detect, at compile time, most circular or otherwise malformed initializations.
The fact that initialization code is unrestricted allows examples to be constructed (¬ß8.3.2.3) where the value of a class variable can be observed when it still has its initial default value, before its initializing expression is evaluated, but such examples are rare in practice.
Such examples can be also constructed for instance variable initialization (¬ß12.5).) The full power of the Java programming language is available in these initializers; programmers must exercise some care.
This power places an extra burden on code generators, but this burden would arise in any case because the Java programming language is concurrent (¬ß12.4.2)
The class One is never initialized, because it not used actively and therefore is never linked to.
The class Two is initialized only after its superclass Super has been initialized.
The reference to K.j is a reference to a field actually declared in interface J that is not a constant variable; this causes initialization of the fields of interface J, but not those of its superinterface I, nor those of interface K.
Despite the fact that the name K is used to refer to field j of interface J, interface K is not initialized.
Because the Java programming language is multithreaded, initialization of a class or interface requires careful synchronization, since some other thread may be trying to initialize the same class or interface at the same time.
There is also the possibility that initialization of a class or interface may be requested recursively as part of the initialization of that class or interface; for example, a variable initializer in class A might invoke a method of an unrelated class B, which might in turn invoke a method of class A.
The implementation of the Java Virtual Machine is responsible for taking care of synchronization and recursive initialization by using the following procedure.
The procedure assumes that the Class object has already been verified and prepared, and that the Class object contains state that indicates one of four situations:
This Class object is verified and prepared but not initialized.
This Class object is being initialized by some particular thread T.
This Class object is fully initialized and ready for use.
This Class object is in an erroneous state, perhaps because initialization was.
For each class or interface C, there is a unique initialization lock LC.
The mapping from C to LC is left to the discretion of the Java Virtual Machine implementation.
If the Class object for C indicates that initialization is in progress for C by the current thread, then this must be a recursive request for initialization.
If the Class object for C indicates that C has already been initialized, then no further action is required.
If the Class object for C is in an erroneous state, then initialization is not possible.
Otherwise, record the fact that initialization of the Class object for C is in progress by the current thread, and release LC.
Next, if C is a class rather than an interface, and its superclass SC has not yet been initialized, then recursively perform this entire procedure for SC.
If the initialization of SC completes abruptly because of a thrown exception, then acquire LC, label the Class object for C as erroneous, notify all waiting threads, release LC, and complete abruptly, throwing the same exception that resulted from initializing SC.
Next, determine whether assertions are enabled (¬ß14.10) for C by querying its defining class loader.
Next, execute either the class variable initializers and static initializers of the class, or the field initializers of the interface, in textual order, as though they were a single block.
If the execution of the initializers completes normally, then acquire LC, label the Class object for C as fully initialized, notify all waiting threads, release LC, and complete this procedure normally.
Otherwise, the initializers must have completed abruptly by throwing some exception E.
If the class of E is not Error or one of its subclasses, then create a new instance of the class ExceptionInInitializerError, with E as the argument, and use this object in place of E in the following step.
But if a new instance of ExceptionInInitializerError cannot be created because an OutOfMemoryError occurs, then instead use an OutOfMemoryError object in place of E in the following step.
Acquire LC, label the Class object for C as erroneous, notify all waiting threads, release LC, and complete this procedure abruptly with reason E or its replacement as determined in the previous step.
An implementation may optimize this procedure by eliding the lock acquisition in step 1 (and release in step 4/5) when it can determine that the initialization of the class has already completed, provided that, in terms of the memory model, all happens-before orderings that would exist if the lock were acquired, still exist when the optimization is performed.
Code generators need to preserve the points of possible initialization of a class or interface, inserting an invocation of the initialization procedure just described.
If this initialization procedure completes normally and the Class object is fully initialized and ready for use, then the invocation of the initialization procedure is no longer necessary and it may be eliminated from the code - for example, by patching it out or otherwise regenerating the code.
Compile-time analysis may, in some cases, be able to eliminate many of the checks that a type has been initialized from the generated code, if an initialization order for a group of related types can be determined.
Such analysis must, however, fully account for concurrency and for the fact that initialization code is unrestricted.
A new class instance is explicitly created when evaluation of a class instance creation expression (¬ß15.9) causes a class to be instantiated.
This might not occur if the same String has previously been interned (¬ß3.10.5).)
Boxing conversion may create a new object of a wrapper class associated with one of the primitive types.
String concatenation operators may also create temporary wrapper objects for a value of a primitive type.
Each of these situations identifies a particular constructor (¬ß8.8) to be called with specified arguments (possibly none) as part of the class instance creation process.
Whenever a new class instance is created, memory space is allocated for it with room for all the instance variables declared in the class type and all the instance variables declared in each superclass of the class type, including all the instance variables that may be hidden (¬ß8.3)
If there is not sufficient space available to allocate memory for the object, then creation of the class instance completes abruptly with an OutOfMemoryError.
Otherwise, all the instance variables in the new object, including those declared in superclasses, are initialized to their default values (¬ß4.12.5)
Just before a reference to the newly created object is returned as the result, the indicated constructor is processed to initialize the new object using the following procedure:
If this constructor begins with an explicit constructor invocation (¬ß8.8.7.1) of another constructor in the same class (using this), then evaluate the arguments and process that constructor invocation recursively using these same five steps.
If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason; otherwise, continue with step 5
This constructor does not begin with an explicit constructor invocation of another constructor in the same class (using this)
If this constructor is for a class other than Object, then this constructor will begin with an explicit or implicit invocation of a superclass constructor (using super)
Evaluate the arguments and process that superclass constructor invocation recursively using.
If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason.
Execute the instance initializers and instance variable initializers for this class, assigning the values of instance variable initializers to the corresponding instance variables, in the left-to-right order in which they appear textually in the source code for the class.
If execution of any of these initializers results in an exception, then no further initializers are processed and this procedure completes abruptly with that same exception.
If that execution completes abruptly, then this procedure completes abruptly for the same reason.
Unlike C++, the Java programming language does not specify altered rules for method dispatch during the creation of a new class instance.
If methods are invoked that are overridden in subclasses in the object being initialized, then these overriding methods are used, even before the new object is completely initialized.
First, space is allocated for the new ColoredPoint, to hold the fields x, y, and color.
All these fields are then initialized to their default values (in this case, 0 for each field)
Next, the ColoredPoint constructor with no arguments is first invoked.
Since ColoredPoint declares no constructors, a default constructor of the form:
This constructor then invokes the Point constructor with no arguments.
The Point constructor does not begin with an invocation of a constructor, so the Java compiler.
Therefore, the constructor for Object which takes no arguments is invoked.
The class Object has no superclass, so the recursion terminates here.
Next, any instance initializers and instance variable initializers of Object are invoked.
Next, the body of the constructor of Object that takes no arguments is executed.
No such constructor is declared in Object, so the Java compiler supplies a default one, which in this special case is:
Next, all initializers for the instance variables of class Point are executed.
As it happens, the declarations of x and y do not provide any initialization expressions, so no action is required for this step of the example.
Next, the initializers for the instance variables of class ColoredPoint are executed.
Finally, the rest of the body of the happen to be no statements in the rest of the body, so no further action is required and initialization is complete.
This shows that the invocation of printThree in the constructor for class Super does not invoke the definition of printThree in class Super, but rather invokes the overriding definition of printThree in class Test.
The later invocation of printThree in method main invokes the same definition of printThree, but by that point the initializer for instance variable three has been executed, and so the value 3 is printed.
The class Object has a protected method called finalize; this method can be overridden by other classes.
The particular definition of finalize that can be invoked for an object is called the finalizer of that object.
Before the storage for an object is reclaimed by the garbage collector, the Java Virtual Machine will invoke the finalizer of that object.
Finalizers provide a chance to free up resources that cannot be freed automatically by an automatic storage manager.
In such situations, simply reclaiming the memory used by an object would not guarantee that the resources it held would be reclaimed.
The Java programming language does not specify how soon a finalizer will be invoked, except to say that it will happen before the storage for the object is reused.
The Java programming language does not specify which thread will invoke the finalizer for any given object.
It is important to note that many finalizer threads may be active (this is sometimes needed on large shared memory multiprocessors), and that if a large connected data structure becomes garbage, all of the finalize methods for every object in that data structure could be invoked at the same time, each finalizer invocation running in a different thread.
The Java programming language imposes no ordering on finalize method calls.
Finalizers may be called in any order, or even concurrently.
As an example, if a circularly linked group of unfinalized objects becomes unreachable (or finalizer-reachable), then all the objects may become finalizable together.
Eventually, the finalizers for these objects may be invoked, in any order, or even concurrently using multiple threads.
If the automatic storage manager later finds that the objects are unreachable, then their storage can be reclaimed.
It is straightforward to implement a class that will cause a set of finalizer-like methods to be invoked in a specified order for a set of objects when all the objects become unreachable.
Defining such a class is left as an exercise for the reader.
It is guaranteed that the thread that invokes the finalizer will not be holding any user-visible synchronization locks when the finalizer is invoked.
If an uncaught exception is thrown during the finalization, the exception is ignored and finalization of that object terminates.
The completion of an object's constructor happens-before (¬ß17.4.5) the execution of its finalize method (in the formal sense of happens-before)
The finalize method declared in class Object takes no action.
The fact that class Object declares a finalize method means that the finalize method for any class can always invoke the finalize method for its superclass.
This should always be done, unless it is the programmer's intent to nullify the actions of the finalizer in the superclass.
Unlike constructors, finalizers do not automatically invoke the finalizer for the superclass; such an invocation must be coded explicitly.)
For efficiency, an implementation may keep track of classes that do not override the finalize method of class Object, or override it in a trivial way.
We encourage implementations to treat such objects as having a finalizer that is not overridden, and to finalize them more efficiently, as described in ¬ß12.6.1
A finalizer may be invoked explicitly, just like any other method.
The package java.lang.ref describes weak references, which interact with garbage collection and finalization.
As with any API that has special interactions with the Java programming language, implementors must be cognizant of any requirements imposed by the java.lang.ref API.
This specification does not discuss weak references in any way.
Every object can be characterized by two attributes: it may be reachable, finalizerreachable, or unreachable, and it may also be unfinalized, finalizable, or finalized.
A reachable object is any object that can be accessed in any potential continuing computation from any live thread.
A finalizer-reachable object can be reached from some finalizable object through some chain of references, but not from any live thread.
An unfinalized object has never had its finalizer automatically invoked.
A finalizable object has never had its finalizer automatically invoked, but the Java Virtual Machine may eventually automatically invoke its finalizer.
An object o is not finalizable until its constructor has invoked the constructor for Object on o and that invocation has completed successfully (that is, without throwing an exception)
Every pre-finalization write to a field of an object must be visible to the finalization of that object.
Furthermore, none of the pre-finalization reads of fields of that object may see writes that occur after finalization of that object is initiated.
Optimizing transformations of a program can be designed that reduce the number of objects that are reachable to be less than those which would naively be considered reachable.
For example, a Java compiler or code generator may choose to set a variable or parameter that will no longer be used to null to cause the storage for such an object to be potentially reclaimable sooner.
Another example of this occurs if the values in an object's fields are stored in registers.
The program may then access the registers instead of the object, and never access the object again.
Note that this sort of optimization is only allowed if references are on the stack, not stored in the heap.
The finalizer guardian forces super.finalize to be called if a subclass overrides finalize and does not explicitly call super.finalize.
If these optimizations are allowed for references that are stored on the heap, then a Java compiler can detect that the finalizerGuardian field is never read, null it out, collect the object immediately, and call the finalizer early.
This runs counter to the intent: the programmer probably wanted to call the Foo finalizer when the Foo instance became unreachable.
This sort of transformation is therefore not legal: the inner class object should be reachable for as long as the outer class object is reachable.
Transformations of this sort may result in invocations of the finalize method occurring earlier than might be otherwise expected.
In order to allow the user to prevent this, we.
If an object's finalizer can result in synchronization on that object, then that object must be alive and considered reachable whenever a lock is held on it.
Note that this does not prevent synchronization elimination: synchronization only keeps an object alive if a finalizer might synchronize on it.
Since the finalizer occurs in another thread, in many cases the synchronization could not be removed anyway.
It must be possible for the memory model (¬ß17.4) to decide when it can commit actions that take place in a finalizer.
This section describes the interaction of finalization with the memory model.
Each execution has a number of reachability decision points, labeled di.
Other than as explicitly mentioned, the comes-before ordering described in this section is unrelated to all other orderings in the memory model.
If r is a read that sees a write w and r comes-before di, then w must come-before di.
If x and y are synchronization actions on the same variable or monitor such that so(x, y) (¬ß17.4.4) and y comes-before di, then x must come-before di.
At each reachability decision point, some set of objects are marked as unreachable, and some subset of those objects are marked as finalizable.
These reachability decision points are also the points at which references are checked, enqueued, and cleared according to the rules provided in the API documentation for the package java.lang.ref.
The only objects that are considered definitely reachable at a point di are those that can be shown to be reachable by the application of these rules: ‚Ä¢ An object B is definitely reachable at di from static fields if there exists a write.
If an object C is definitely reachable from an object B, and object B is definitely reachable from an object A, then C is definitely reachable from A.
If an object X is marked as unreachable at di, then:
All reads that come-after di that see a reference to X must see writes to elements of objects that were unreachable at di, or see writes that came-after di.
An implementation of the Java programming language may unload classes.
A class or interface may be unloaded if and only if its defining class loader may be reclaimed by the garbage collector as discussed in ¬ß12.6
Classes and interfaces loaded by the bootstrap loader may not be unloaded.
Class unloading is an optimization that helps reduce memory use.
Obviously, the semantics of a program should not depend on whether and how a system chooses to implement an optimization such as class unloading.
Consequently, whether a class or interface has been unloaded or not should be transparent to a program.
However, if a class or interface C was unloaded while its defining loader was potentially reachable, then C might be reloaded.
Even if the class was not referenced by any other currently loaded class, it might be.
When D is loaded by C's defining loader, its execution might cause reloading of C.
Reloading may not be transparent if, for example, the class has static variables (whose state would be lost), static initializers (which may have side effects), or native methods (which may retain static state)
Furthermore, the hash value of the Class object is dependent on its identity.
Therefore it is, in general, impossible to reload a class or interface in a completely transparent manner.
Since we can never guarantee that unloading a class or interface whose loader is potentially reachable will not cause reloading, and reloading is never transparent, but unloading must be transparent, it follows that one must not unload a class or interface while its loader is potentially reachable.
A similar line of reasoning can be used to deduce that classes and interfaces loaded by the bootstrap loader can never be unloaded.
One must also argue why it is safe to unload a class C if its defining class loader can be reclaimed.
If the defining loader can be reclaimed, then there can never be any live references to it (this includes references that are not live, but might be resurrected by finalizers)
This, in turn, can only be true if there are can never be any live references to any of the classes defined by that loader, including C, either from their instances or from code.
Class unloading is an optimization that is only significant for applications that load large numbers of classes and that stop using most of those classes after some time.
A prime example of such an application is a web browser, but there are others.
A characteristic of such applications is that they manage classes through explicit use of class loaders.
As a result, the policy outlined above works well for them.
Strictly speaking, it is not essential that the issue of class unloading be discussed by this specification, as class unloading is merely an optimization.
However, the issue is very subtle, and so it is mentioned here by way of clarification.
A program terminates all its activity and exits when one of two things happens: ‚Ä¢ All the threads that are not daemon threads terminate.
Some thread invokes the exit method of class Runtime or class System, and the exit operation is not forbidden by the security manager.
Particular implementations may also store the source and binary of types in a versioning database and implement a ClassLoader that uses integrity mechanisms of the database to prevent linkage errors by providing binary-compatible versions of types to clients.
Developers of packages and classes that are to be widely distributed face a different set of problems.
In the Internet, which is our favorite example of a widely distributed system, it is often impractical or impossible to automatically recompile the pre-existing binaries that directly or indirectly depend on a type that is to be changed.
Instead, this specification defines a set of changes that developers are permitted to make to a package or to a class or interface type while preserving (not breaking) compatibility with pre-existing binaries.
Within the framework of Release-to-Release Binary Compatibility in SOM (Forman, Conner, Danforth, and Raper, Proceedings of OOPSLA '95), Java programming language binaries are binary compatible under all relevant transformations that the authors identify (with some caveats with respect to the addition of instance variables)
Using their scheme, here is a list of some important binary compatible changes that the Java programming language supports: ‚Ä¢ Reimplementing existing methods, constructors, and initializers to improve.
Changing methods or constructors to return values on inputs for which they previously either threw exceptions that normally should not occur or failed by going into an infinite loop or causing a deadlock.
Adding new fields, methods, or constructors to an existing class or interface.
When an entire package is updated, deleting default (package-only) access fields, methods, or constructors of classes and interfaces in the package.
Reordering the fields, methods, or constructors in an existing type declaration.
Reordering the list of direct superinterfaces of a class or interface.
Inserting new class or interface types in the type hierarchy.
This chapter specifies minimum standards for binary compatibility guaranteed by all implementations.
The Java programming language guarantees compatibility when binaries of classes and interfaces are mixed that are not known to be from compatible sources, but whose sources have been modified in the compatible ways described here.
Note that we are discussing compatibility between releases of an application.
A discussion of compatibility among releases of the Java SE platform is beyond the scope of this chapter.
We encourage development systems to provide facilities that alert developers to the impact of changes on pre-existing binaries that cannot be recompiled.
This chapter first specifies some properties that any binary format for the Java programming language must have (¬ß13.1)
It next defines binary compatibility, explaining what it is and what it is not (¬ß13.2)
Programs must be compiled either into the class file format specified by The Java Virtual Machine Specification, Java SE 7 Edition, or into a representation that can be mapped into that format by a class loader written in the Java programming language.
A number of these properties are specifically chosen to support source code transformations that preserve binary compatibility.
A reference to another class or interface type must be symbolic, using the binary name of the type.
References to fields that are constant variables (¬ß4.12.4) are resolved at compile time to the constant value that is denoted.
No reference to such a field should be present in the code in a binary file (except in the class or interface containing the field, which will have code to initialize it)
Such a field must the type of such a field must never be observed.
Vn, then the qualifying type of the reference is V1
Otherwise, the compile-time type of Primary is the qualifying type of the reference.
If the expression is of the form super.f then the superclass of C is the qualifying type of the reference.
If the expression is of the form X.super.f then the superclass of X is the qualifying type of the reference.
If the reference is of the form X.f, where X denotes a class or interface, then the class or interface denoted by X is the qualifying type of the reference.
If the expression is referenced by a simple name, then if f is a member of the current class or interface, C, then let T be C.
Otherwise, let T be the innermost lexically enclosing class of which f is a member.
In either case, T is the qualifying type of the reference.
The reference to f must be compiled into a symbolic reference to the erasure (¬ß4.6) of the qualifying type of the reference, plus the simple name of the field, f.
The reference must also include a symbolic reference to the erasure of the declared type of the field so that the verifier can check that the type is as expected.
Given a method invocation expression in a class or interface C referencing a method named m declared (or implicitly declared (¬ß9.2)) in a (possibly distinct) class or interface D, we define the qualifying type of the method invocation as follows:
If D is Object then the qualifying type of the expression is Object.
Otherwise: ‚óÜ If the expression is of the form Primary.m then:
Vn, then the qualifying type of the method invocation is V1
Otherwise, the compile-time type of Primary is the qualifying type of the method invocation.
If the expression is of the form super.m then the superclass of C is the qualifying type of the method invocation.
If the expression is of the form X.super.m then the superclass of X is the qualifying type of the method invocation.
If the reference is of the form X.m, where X denotes a class or interface, then the class or interface denoted by X is the qualifying type of the method invocation.
If the method is referenced by a simple name, then if m is a member of the current class or interface, C, then let T be C.
Otherwise, let T be the innermost lexically enclosing class of which m is a member.
In either case, T is the qualifying type of the method invocation.
If the expression is of the form new D(...) or X.new D(...), then the qualifying type of the invocation is D.
If the expression is of the form super(...) or Primary.super(...) then the qualifying type of the expression is the direct superclass of C.
If the expression is of the form this(...), then the qualifying type of the expression is C.
Any constructs introduced by a Java compiler that do not have a corresponding construct in the source code must be marked as synthetic, except for default constructors, the class initialization method, and the values and valueOf methods of the Enum class.
A binary representation for a class or interface must also contain all of the following:
If it is a class and is not class Object, then a symbolic reference to the erasure (¬ß4.6) of the direct superclass of this class.
A symbolic reference to the erasure of each direct superinterface, if any.
If it is a class, then the erased signature of each constructor, as described above.
For each method declared in the class or interface (excluding, for an interface,
Every class that contains a nested class must contain symbolic references to all of its member classes, and to all local and anonymous classes that appear in its methods, constructors, and static or instance initializers.
The following sections discuss changes that may be made to class and interface type declarations without breaking compatibility with pre-existing binaries.
Under the translation requirements given above, the Java Virtual Machine and its class file format support these changes.
Any other valid binary format, such as a compressed or encrypted representation that is mapped back into class files by a class loader under the above requirements, will necessarily support these changes as well.
A change to a type is binary compatible with (equivalently, does not break binary compatibility with) pre-existing binaries if pre-existing binaries that previously linked without error will continue to link without error.
Binaries are compiled to rely on the accessible members and constructors of other classes and interfaces.
To preserve binary compatibility, a class or interface should treat its accessible members and constructors, their existence and behavior, as a contract with its users.
The Java programming language is designed to prevent additions to contracts and accidental name collisions from breaking binary compatibility.
Specifically, addition of more methods overloading a particular method name does not break compatibility with pre-existing binaries.
The method signature that the pre-existing binary will use for method lookup is chosen by the method overload resolution algorithm at compile time (¬ß15.12.2)
If the Java programming language had been designed so that the particular method to be executed was chosen at run time, then such an ambiguity might be detected at run time.
Such a rule would imply that adding an additional overloaded method so as to make ambiguity possible at a call site could break compatibility with an unknown number of pre-existing binaries.
In particular, the example in ¬ß13.4.6 shows that a set of compatible binaries can be produced from sources that will not compile all together.
This example is typical: a new declaration is added, changing the meaning of a name in an unchanged part of the source code, while the pre-existing binary for that unchanged part of the source code retains the fully-qualified, previous meaning of the name.
A new top level class or interface type may be added to a package without breaking compatibility with pre-existing binaries, provided the new type does not reuse a name previously given to an unrelated type.
If a new type reuses a name previously given to an unrelated type, then a conflict may result, since binaries for both types could not be loaded by the same class loader.
Changes in top level class and interface types that are not public and that are not a superclass or superinterface, respectively, of a public type, affect only types within the package in which they are declared.
Such types may be deleted or otherwise changed, even if incompatibilities are otherwise described here, provided that the affected binaries of that package are updated together.
This section describes the effects of changes to the declaration of a class and its members and constructors on pre-existing binaries.
If a class that was not declared abstract is changed to be declared abstract, then pre-existing binaries that attempt to create new instances of that class will throw either an InstantiationError at link time, or (if a reflective method is used) an InstantiationException at run time; such a change is therefore not recommended for widely distributed classes.
Changing a class that is declared abstract to no longer be declared abstract does not break compatibility with pre-existing binaries.
If a class that was not declared final is changed to be declared final, then a VerifyError is thrown if a binary of a pre-existing subclass of this class is loaded,
Changing a class that is declared final to no longer be declared final does not break compatibility with pre-existing binaries.
Changing a class that is not declared public to be declared public does not break compatibility with pre-existing binaries.
If a class that was declared public is changed to not be declared public, then an IllegalAccessError is thrown if a pre-existing binary is linked that needs but no longer has access to the class type; such a change is not recommended for widely distributed classes.
A ClassCircularityError is thrown at load time if a class would be a superclass of itself.
Changes to the class hierarchy that could result in such a circularity when newly compiled binaries are loaded with pre-existing binaries are not recommended for widely distributed classes.
Changing the direct superclass or the set of direct superinterfaces of a class type will not break compatibility with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class type loses no members.
If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, then linkage errors may result if pre-existing binaries are loaded with the binary of the modified class.
Suppose that a new version of class Super is then compiled:
This version of class Super is not a subclass of Hyper.
If we then run the existing binaries of Hyper and Test with the new version of Super, then a VerifyError is thrown at argument in place of a formal parameter of type Hyper, because Super is not a subclass of Hyper.
It is instructive to consider what might happen without the verification step: the program might run and print:
This demonstrates that without the verifier, the Java type system could be defeated by linking inconsistent binary files, even though each was produced by a correct Java compiler.
The lesson is that an implementation that lacks a verifier or fails to use it will not maintain type safety and is, therefore, not a valid implementation.
The requirement that alternatives in a multi-catch clause (¬ß14.20) not be subclasses or superclasses of each other is only a source restriction.
This is analogous to other situations where a class transformation that is binary compatible for a client might not be source compatible for the same client.
Adding or removing a type parameter of a class does not, in itself, have any implications for binary compatibility.
If such a type parameter is used in the type of a field or method, that may have the normal implications of changing the aforementioned type.
Renaming a type parameter of a class has no effect with respect to pre-existing binaries.
Changing the first bound of a type parameter of a class may change the erasure (¬ß4.6) of any member that uses that type parameter in its own type, and this may affect binary compatibility.
The change of such a bound is analogous to the change of the first bound of a type parameter of a method or constructor (¬ß13.4.13)
Changing any other bound has no effect on binary compatibility.
No incompatibility with pre-existing binaries is caused by adding an instance (respectively static) member that has the same name and accessibility (for fields), or same name and accessibility and signature and return type (for methods), as an instance (respectively static) member of a superclass or subclass.
No error occurs even if the set of classes being linked would encounter a compile-time error.
Deleting a class member or constructor that is not declared private may cause a linkage error if the member or constructor is used by a pre-existing binary.
Suppose that a new version of class Super is produced:
Then, recompiling Super and executing this new binary with the original binaries for Test and Hyper produces the output:
The super keyword can be used to access a method declared in a superclass, bypassing any methods declared in the current class.
The expression super.Identifier is resolved, at compile time, to a method m in the superclass S.
If the method m is an instance method, then the method which is invoked at run time is the method with the same signature as m that is a member of the direct superclass of the class containing the expression involving super.
Suppose that a new version of class Super is produced:
Then, if Super and Hyper are recompiled but not Test, then running the new binaries with the existing binary of Test produces the output:
Changing the declared access of a member or constructor to permit less access may break compatibility with pre-existing binaries, causing a linkage error to be thrown when these binaries are resolved.
Less access is permitted if the access modifier is changed from default access to private access; from protected access to default.
Changing a member or constructor to permit less access is therefore not recommended for widely distributed classes.
Perhaps surprisingly, the binary format is defined so that changing a member or constructor to be more accessible does not cause a linkage error when a subclass (already) defines a method to have less access.
If the method print in class Point is changed to be public, and then only the Point class is recompiled, and then executed with the previously existing binary for Test, then no linkage error occurs.
This happens even though it is improper, at compile time, for a class Test could not be recompiled using this new Point class unless print in Test were changed to be public.)
Allowing superclasses to change protected methods to be public without breaking binaries of pre-existing subclasses helps make binaries less fragile.
The alternative, where such a change would cause a linkage error, would create additional binary incompatibilities.
Widely distributed programs should not expose any fields to their clients.
Apart from the binary compatibility issues discussed below, this is generally good software engineering practice.
Adding a field to a class may break compatibility with pre-existing binaries that are not recompiled.
Assume a reference to a field f with qualifying type T.
Assume further that f is in fact an instance (respectively static) field declared in a superclass of T, S, and that the type of f is X.
If a new field of type X with the same name as f is added to a subclass of S that is a superclass of T or T itself, then a linkage error may occur.
Such a linkage error will occur only if, in addition to the above, either one of the following conditions hold: ‚Ä¢ The new field is less accessible than the old one.
In particular, no linkage error will occur in the case where a class could no longer be recompiled because a field access previously referenced a field of a superclass with an incompatible type.
The previously compiled class with such a reference will continue to reference the field declared in a superclass.
Then, recompiling Hyper and Super, and executing the resulting new binaries with the old binary of Test produces the output:
The field h of Hyper is output by the original binary of Test.
While this may seem surprising at first, it serves to reduce the number of incompatibilities that occur at run time.
In an ideal world, all source files that needed recompilation would be recompiled whenever any one of them changed, eliminating such surprises.
But such a mass recompilation is often impractical or impossible, especially in the Internet.
And, as was previously noted, such recompilation would sometimes require further changes to the source code.)
Suppose that a new version of class Super is then compiled:
If the resulting binary is used with the existing binaries for Hyper and Test, then the output is still:
Deleting a field from a class will break compatibility with any pre-existing binaries that reference this field, and a NoSuchFieldError will be thrown when such a.
Only private fields may be safely deleted from a widely distributed class.
If a field that was not declared final is changed to be declared final, then it can break compatibility with pre-existing binaries that attempt to assign new values to the field.
Suppose that a new version of class Super is produced:
If Super is recompiled but not Test, then running the new binary with the existing binary of Test results in a IllegalAccessError.
Deleting the keyword final or changing the value to which a field is initialized does not break compatibility with existing binaries.
If a field is a constant variable (¬ß4.12.4), then deleting the keyword final or changing its value will not break compatibility with pre-existing binaries by causing them not to run, but they will not see any new value for the usage of the field unless they are recompiled.
This is true even if the usage itself is not a compiletime constant expression (¬ß15.28)
This result is a side-effect of the decision to support conditional compilation, as discussed at the end of ¬ß14.21
Suppose that a new version of class Flags is produced:
If Flags is recompiled but not Test, then running the new binary with the existing binary of Test produces the output:
This behavior would not change if Flags were changed to be an interface, as in the modified example:
The best way to avoid problems with "inconstant constants" in widely-distributed code is to declare as compile-time constants only values which truly are unlikely ever to change.
Other than for true mathematical constants, we recommend that source code make very sparing use of class variables that are declared static and final.
If the read-only nature of final is required, a better choice is to declare a Thus we recommend:
We also recommend, as a general rule, that only truly constant values be declared in interfaces.
We note, but do not recommend, that if a field of primitive type of an interface may change, its value may be expressed idiomatically as in:
One other thing to note is that static final fields that have constant values (whether of primitive or String type) must never appear to have the default initial value for their type (¬ß4.12.5)
If a field that is not declared private was not declared static and is changed to be declared static, or vice versa, then a linkage error, specifically an IncompatibleClassChangeError, will result if the field is used by a pre-existing binary which expected a field of the other kind.
Such changes are not recommended in code that has been widely distributed.
Adding or deleting a transient modifier of a field does not break compatibility with pre-existing binaries.
Adding a method or constructor declaration to a class will not break compatibility with any pre-existing binaries, even in the case where a type could no longer be.
The previously compiled class with such a reference will continue to reference the method or constructor declared in a superclass.
Assume a reference to a method m with qualifying type T.
Assume further that m is in fact an instance (respectively static) method declared in a superclass of T, S.
If a new method of type X with the same signature and return type as m is added to a subclass of S that is a superclass of T or T itself, then a linkage error may occur.
Such a linkage error will occur only if, in addition to the above, either one of the following conditions hold: ‚Ä¢ The new method is less accessible than the old one.
Deleting a method or constructor from a class may break compatibility with any pre-existing binary that referenced this method or constructor; a NoSuchMethodError may be thrown when such a reference from a pre-existing binary is linked.
Such an error will occur only if no method with a matching signature and return type is declared in a superclass.
If the source code for a non-inner class contains no declared constructors, the Java compiler automatically supplies a default constructor with no parameters (¬ß8.8.9)
Adding one or more constructor declarations to the source code of such a class will prevent this default constructor from being supplied automatically, effectively deleting a constructor, unless one of the new constructors also has no parameters, thus replacing the default constructor.
The automatically supplied constructor with no parameters is given the same access modifier as the class of its declaration, so any replacement should have as much or more access if compatibility with preexisting binaries is to be preserved.
Adding or removing a type parameter of a method or constructor does not, in itself, have any implications for binary compatibility.
If such a type parameter is used in the type of the method or constructor, that may have the normal implications of changing the aforementioned type.
Renaming a type parameter of a method or constructor has no effect with respect to pre-existing binaries.
Changing the first bound of a type parameter of a method or constructor may change the erasure (¬ß4.6) of any member that uses that type parameter in its own type, and this may affect binary compatibility.
Specifically: ‚Ä¢ If the type parameter is used as the type of a field, the effect is as if the field was.
If the type parameter is used as the type of any formal parameter of a method, but not as the return type, the effect is as if that method were removed, and replaced with a new method that is identical except for the types of the aforementioned formal parameters, which now have the new erasure of the type parameter as their type.
If the type parameter is used as a return type of a method, but not as the type of any formal parameter of the method, the effect is as if that method were removed, and replaced with a new method that is identical except for the return type, which is now the new erasure of the type parameter.
If the type parameter is used as a return type of a method and as the type of one or more formal parameters of the method, the effect is as if that method were removed, and replaced with a new method that is identical except for the return type, which is now the new erasure of the type parameter, and except for the types of the aforementioned formal parameters, which now have the new erasure of the type parameter as their types.
Changing any other bound has no effect on binary compatibility.
Changing the name of a formal parameter of a method or constructor does not impact pre-existing binaries.
Changing the name of a method, or the type of a formal parameter to a method or constructor, or adding a parameter to or deleting a parameter from a method or constructor declaration creates a method or constructor with a new signature, and has the combined effect of deleting the method or constructor with the old signature and adding a method or constructor with the new signature (¬ß13.4.12)
Changing the result type of a method, or replacing a result type with void, or replacing void with a result type, has the combined effect of deleting the old method and adding a new method with the new result type or newly void result (see ¬ß13.4.12)
Changing a method that is declared abstract to no longer be declared abstract does not break compatibility with pre-existing binaries.
Changing a method that is not declared abstract to be declared abstract will break compatibility with pre-existing binaries that previously invoked the method, causing an AbstractMethodError.
Suppose that a new version of class Super is produced:
If Super is recompiled but not Test, then running the new binary with the existing binary of Test results in an AbstractMethodError, because class Test has no implementation of the method out, and is therefore is (or should be) abstract.
Changing a method that is declared final to no longer be declared final does not break compatibility with pre-existing binaries.
Changing an instance method that is not declared final to be declared final may break compatibility with existing binaries that depend on the ability to override the method.
Suppose that a new version of class Super is produced:
If Super is recompiled but not Test, then running the new binary with the existing binary of Test results in a VerifyError because the class Test improperly tries to override the instance method out.
Changing a class (static) method that is not declared final to be declared final does not break compatibility with existing binaries, because the method could not have been overridden.
Adding or deleting a native modifier of a method does not break compatibility with pre-existing binaries.
The impact of changes to types on pre-existing native methods that are not recompiled is beyond the scope of this specification and should be provided with.
Implementations are encouraged, but not required, to implement native methods in a way that limits such impact.
If a method that is not declared private is also declared static (that is, a class method) and is changed to not be declared static (that is, to an instance method), or vice versa, then compatibility with pre-existing binaries may be broken, resulting in a linkage time error, namely an IncompatibleClassChangeError, if these methods are used by the pre-existing binaries.
Such changes are not recommended in code that has been widely distributed.
Adding or deleting a synchronized modifier of a method does not break compatibility with pre-existing binaries.
Changes to the throws clause of methods or constructors do not break compatibility with pre-existing binaries; these clauses are checked only at compile time.
Changes to the body of a method or constructor do not break compatibility with pre-existing binaries.
The keyword final on a method does not mean that the method can be safely inlined; it means only that the method cannot be overridden.
It is still possible that a new version of that method will be provided at link-time.
Furthermore, the structure of the original program must be preserved for purposes of reflection.
Therefore, we note that a Java compiler cannot expand a method inline at compile time.
In general we suggest that implementations use late-bound (run-time) code generation and optimization.
Adding new methods or constructors that overload existing methods or constructors does not break compatibility with pre-existing binaries.
The signature to be used for each invocation was determined when these existing binaries were compiled;
While adding a new overloaded method or constructor may cause a compile-time error the next time a class or interface is compiled because there is no method or constructor that is most specific (¬ß15.12.2.5), no such error occurs when a program is executed, because no overload resolution is done at execution time.
Suppose that a new version of class Super is produced:
If Super is recompiled but not Test, then running the new binary with the existing binary of Test still produces the output:
However, if Test is then recompiled, using this new Super, the output is then:
If an instance method is added to a subclass and it overrides a method in a superclass, then the subclass method will be found by method invocations in preexisting binaries, and these binaries are not impacted.
If a class method is added to a class, then this method will not be found unless the qualifying type of the reference is the subclass type.
Adding, deleting, or changing a static initializer (¬ß8.7) of a class does not impact pre-existing binaries.
Adding or reordering constants in an enum type will not break compatibility with pre-existing binaries.
If a pre-existing binary attempts to access an enum constant that no longer exists, the client will fail at run time with a NoSuchFieldError.
Therefore such a change is not recommended for widely distributed enums.
In all other respects, the binary compatibility rules for enums are identical to those for classes.
This section describes the impact of changes to the declaration of an interface and its members on pre-existing binaries.
Changing an interface that is not declared public to be declared public does not break compatibility with pre-existing binaries.
If an interface that is declared public is changed to not be declared public, then an IllegalAccessError is thrown if a pre-existing binary is linked that needs but no longer has access to the interface type, so such a change is not recommended for widely distributed interfaces.
Changes to the interface hierarchy cause errors in the same way that changes to the class hierarchy do, as described in ¬ß13.4.4
In particular, changes that result in any previous superinterface of a class no longer being a superinterface can break compatibility with pre-existing binaries, resulting in a VerifyError.
Adding a method to an interface does not break compatibility with pre-existing binaries.
A field added to a superinterface of C may hide a field inherited from a superclass of C.
If the original reference was to an instance field, an IncompatibleClassChangeError will result.
If the original reference was an assignment, an IllegalAccessError will result.
Deleting a member from an interface may cause linkage errors in pre-existing binaries.
Suppose that a new version of interface I is compiled:
If I is recompiled but not Test, then running the new binary with the existing binary for Test will result in a NoSuchMethodError.
The effects of changes to the type parameters of an interface are the same as those of analogous changes to the type parameters of a class.
Adding or removing an element from an annotation type is analogous to adding or removing a method.
There are important considerations governing other changes to annotation types, but these have no effect on the linkage of binaries by the Java Virtual Machine.
Rather, such changes affect the behavior of reflective APIs that manipulate annotations.
The documentation of these APIs specifies their behavior when various changes are made to the underlying annotation types.
Adding or removing annotations has no effect on the correct linkage of the binary representations of programs in the Java programming language.
Some statements contain other statements as part of their structure; such other statements are substatements of the statement.
We say that statement S immediately contains statement U if there is no statement T different from S and U such that S contains T and T contains U.
In the same manner, some statements contain expressions (¬ß15) as part of their structure.
The first section of this chapter discusses the distinction between normal and abrupt completion of statements (¬ß14.1)
Most of the remaining sections explain the various kinds of statements, describing in detail both their normal behavior and any special treatment of abrupt completion.
Next a grammatical maneuver that sidesteps the familiar "dangling else" problem (¬ß14.5) is explained.
The last section (¬ß14.21) of this chapter addresses the requirement that every statement be reachable in a certain technical sense.
Every statement has a normal mode of execution in which certain computational steps are carried out.
The following sections describe the normal mode of execution for each kind of statement.
If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to complete normally.
However, certain events may prevent a statement from completing normally:
Evaluation of certain expressions may throw exceptions from the Java Virtual Machine (¬ß15.6)
An explicit throw (¬ß14.18) statement also results in an exception.
An exception causes a transfer of control that may prevent normal completion of statements.
If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to complete abruptly.
An abrupt completion always has an associated reason, which is one of the following:
A throw with a given value, including exceptions thrown by the Java Virtual Machine.
The terms "complete normally" and "complete abruptly" also apply to the evaluation of expressions (¬ß15.6)
If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason.
All succeeding steps in the normal mode of execution are not performed.
Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed.
Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.
A block is a sequence of statements, local class declarations, and local variable declaration statements within braces.
A block is executed by executing each of the local variable declaration statements and other statements in order from first to last (left to right)
If all of these block statements complete normally, then the block completes normally.
If any of these block statements complete abruptly for any reason, then the block completes abruptly for the same reason.
Every local class declaration statement is immediately contained by a block (¬ß14.2)
Local class declaration statements may be intermixed freely with other kinds of statements in the block.
Here is an example that illustrates several aspects of the rules given above:
The first statement of method foo creates an instance of the member class Global.Cyclic rather than an instance of the local class Cyclic, because the local class declaration is not yet in scope.
The fact that the scope of a local class encompasses its own declaration (not only its body) means that the definition of the local class Cyclic is indeed cyclic because it extends itself rather than Global.Cyclic.
Consequently, the declaration of the local class Cyclic will be rejected at compile time.
Since local class names cannot be redeclared within the same method (or constructor or initializer, as the case may be), the second and third declarations of Local result in compiletime errors.
However, Local can be redeclared in the context of another, more deeply nested, class such as AnotherLocal.
The fourth and last declaration of Local is legal, since it occurs outside the scope of any prior declaration of Local.
A local variable declaration statement declares one or more local variable names.
Every local variable declaration statement is immediately contained by a block.
Local variable declaration statements may be intermixed freely with other kinds of statements in the block.
A local variable declaration can also appear in the header of a for statement (¬ß14.14)
In this case it is executed in the same manner as if it were part of a local variable declaration statement.
Each declarator in a local variable declaration declares one local variable, whose name is the Identifier that appears in the declarator.
If the optional keyword final appears at the start of the declarator, the variable being declared is a final variable (¬ß4.12.4)
The declared type of a local variable is denoted by the Type that appears in the local variable declaration, followed by any bracket pairs that follow the Identifier in the declarator.
A local variable of type float always contains a value that is an element of the a value that is an element of the double value set.
It is not permitted for a local variable of type float to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a local variable of type double to contain an element of the double-extended-exponent value set that is not also an element of the double value set.
Every time it is executed, the declarators are processed in order from left to right.
If a declarator has an initialization expression, the expression is evaluated and its value is assigned to the variable.
If a declarator does not have an initialization expression, then every reference to the variable must be preceded by execution of an assignment to the variable, or a compile-time error occurs by the rules of ¬ß16
Each initialization (except the first) is executed only if evaluation of the preceding initialization expression completes normally.
Execution of the local variable declaration completes normally only if evaluation of the last initialization expression completes normally.
If the local variable declaration contains no initialization expressions, then executing it always completes normally.
There are many kinds of statements in the Java programming language.
Most correspond to statements in the C and C++ languages, but some are unique.
As in C and C++, the if statement of the Java programming language suffers from the so-called "dangling else problem," illustrated by this misleadingly formatted example:
The problem is that both the outer if statement and the inner if statement might conceivably own the else clause.
In this example, one might surmise that the programmer intended the else clause to belong to the outer if statement.
The Java programming language, like C and C++ and many programming languages before them, arbitrarily decrees that an else clause belongs to the innermost if to which it might possibly belong.
StatementNoShortIf: StatementWithoutTrailingSubstatement LabeledStatementNoShortIf IfThenElseStatementNoShortIf WhileStatementNoShortIf ForStatementNoShortIf The following are repeated from ¬ß14.9 to make the presentation here clearer:
Statements are thus grammatically divided into two categories: those that might end in an if statement that has no else clause (a "short if statement") and those that definitely do not.
Only statements that definitely do not end in a short if statement may appear as an immediate substatement before the keyword else in an if statement that does have an else clause.
The execution behavior of a statement with the "no short if" restriction is identical to the execution behavior of the same kind of statement without the "no short if" restriction; the distinction is drawn purely to resolve the syntactic difficulty.
The Identifier is declared to be the label of the immediately contained Statement.
The scope of a label of a labeled statement is the immediately contained Statement.
It is a compile-time error if the name of a label of a labeled statement (¬ß14.7) is used within the scope of the label as a label of another labeled statement.
There is no restriction against using the same identifier as a label and as the name of a package, class, interface, method, field, parameter, or local variable.
Use of an identifier to label a statement does not obscure (¬ß6.4.2) a package, class, interface, method, field, parameter, or local variable with the same name.
Use of an identifier as a class, interface, method, field, local variable or as the parameter of an exception handler (¬ß14.20) does not obscure a statement label with the same name.
A labeled statement is executed by executing the immediately contained Statement.
If the statement is labeled by an Identifier and the contained Statement completes abruptly because of a break with the same Identifier, then the labeled statement completes normally.
In all other cases of abrupt completion of the Statement, the labeled statement completes abruptly for the same reason.
Certain kinds of expressions may be used as statements by following them with semicolons.
An expression statement is executed by evaluating the expression; if the expression has a value, the value is discarded.
Execution of the expression statement completes normally if and only if evaluation of the expression completes normally.
Unlike C and C++, the Java programming language allows only certain forms of expressions to be used as expression statements.
On the other hand, the Java programming language allows all the most useful kinds of expressions in expressions statements, and it does not require a method invocation used as an expression statement to invoke a void method, so such a trick is almost never needed.
The if statement allows conditional execution of a statement or a conditional choice of two statements, executing one or the other but not both.
The Expression must have type boolean or Boolean, or a compile-time error occurs.
An if-then statement is executed by first evaluating the Expression.
If the result is of type Boolean, it is subject to unboxing conversion (¬ß5.1.8)
If evaluation of the Expression or the subsequent unboxing conversion (if any) completes abruptly for some reason, the if-then statement completes abruptly for the same reason.
Otherwise, execution continues by making a choice based on the resulting value: ‚Ä¢ If the value is true, then the contained Statement is executed; the if-then.
If the value is false, no further action is taken and the if-then statement completes normally.
An if-then-else statement is executed by first evaluating the Expression.
If the result is of type Boolean, it is subject to unboxing conversion (¬ß5.1.8)
If evaluation of the Expression or the subsequent unboxing conversion (if any) completes abruptly for some reason, then the if-then-else statement completes abruptly for the same reason.
Otherwise, execution continues by making a choice based on the resulting value: ‚Ä¢ If the value is true, then the first contained Statement (the one before the else.
If the value is false, then the second contained Statement (the one after the else keyword) is executed; the if-then-else statement completes normally if and only if execution of that statement completes normally.
An assertion is an assert statement containing a boolean expression.
If the assertion is enabled, execution of the assertion causes evaluation of the boolean expression and an error is reported if the expression evaluates to false.
If the assertion is disabled, execution of the assertion has no effect whatsoever.
It is a compile-time error if Expression1 does not have type boolean or Boolean.
An assert statement that is executed after its class has completed initialization is enabled if and only if the host system has determined that the top level class that lexically contains the assert statement enables assertions.
Whether or not a top level class enables assertions is determined no later than the earliest of the initialization of the top level class and the initialization of any class nested in the top level class, and cannot be changed after it has been determined.
An assert statement that is executed before its class has completed initialization is enabled.
This rule is motivated by a case that demands special treatment.
Recall that the assertion status of a class is set no later than the time it is initialized.
It is possible, though generally not desirable, to execute methods or constructors prior to initialization.
This can happen when a class hierarchy contains a circularity in its static initialization, as in the following example:
Because of the rule above, if the program above is executed without enabling assertions, it must print:
An enabled assert statement is executed by first evaluating Expression1
If the result is of type Boolean, it is subject to unboxing conversion (¬ß5.1.8)
If evaluation of Expression1 or the subsequent unboxing conversion (if any) completes abruptly for some reason, the assert statement completes abruptly for the same reason.
Otherwise, execution continues by making a choice based on the value of Expression1:
If the value is true, no further action is taken and the assert statement completes normally.
If the evaluation completes abruptly for some reason, the assert statement completes abruptly for the same reason.
If the evaluation completes normally, an AssertionError instance whose "detail message" is the resulting value of Expression2 is created.
If the instance creation completes abruptly for some reason, the assert.
If Expression2 is not present, an AssertionError instance with no "detail message" is created.
If the instance creation completes abruptly for some reason, the assert.
If the instance creation completes normally, the assert statement completes.
For example, after unmarshalling all of the arguments from a data buffer, a programmer might assert that the number of bytes of data remaining in the buffer is zero.
By verifying that the boolean expression is indeed true, the system corroborates the programmer's knowledge of the program and increases one's confidence that the program is free of bugs.
Typically, assertion-checking is enabled during program development and testing, and disabled for deployment, to improve performance.
Because assertions may be disabled, programs must not assume that the expressions contained in assertions will be evaluated.
Thus, these boolean expressions should generally be free of side effects.
Evaluating such a boolean expression should not affect any state that is visible after the evaluation is complete.
It is not illegal for a boolean expression contained in an assertion to have a side effect, but it is generally inappropriate, as it could cause program behavior to vary depending on whether assertions were enabled or disabled.
Along similar lines, assertions should not be used for argument-checking in public methods.
Argument-checking is typically part of the contract of a method, and this contract must be upheld whether assertions are enabled or disabled.
Another problem with using assertions for argument checking is that erroneous arguments should result in an appropriate run-time exception (such as IllegalArgumentException, ArrayIndexOutOfBoundsException, or NullPointerException)
Again, it is not illegal to use assertions for argument checking on public methods, but it is generally inappropriate.
It is intended that AssertionError never be caught, but it is possible to do so, thus the rules for try statements should treat assertions appearing in a try block similarly to the current treatment of throw statements.
The switch statement transfers control to one of several statements depending on the value of an expression.
The type of the Expression must be char, byte, short, int, Character, Byte, Short, Integer, String, or an enum type (¬ß8.9), or a compile-time error occurs.
The body of a switch statement is known as a switch block.
Any statement immediately contained by the switch block may be labeled with one or more switch labels, which are case or default labels.
All of the following must be true, or a compile-time error occurs: ‚Ä¢ Every case constant expression associated with a switch statement must be.
No two of the case constant expressions associated with a switch statement may.
At most one default label may be associated with the same switch statement.
The prohibition against using null as a switch label prevents one from writing code that can never be executed.
If the switch expression is of a reference type, that is, String or a boxed primitive type or an enum type, then a run-time error will occur if the expression evaluates to null at run time.
In the judgment of the designers of the Java programming language, this is a better outcome than silently skipping the entire switch statement or choosing to execute the statements (if any) after the default label (if any)
A Java compiler is encouraged (but not required) to provide a warning if a switch on an enum-valued expression lacks a default label and lacks case labels for one or more of the enum type's constants.
Such a statement will silently do nothing if the expression evaluates to one of the missing constants.)
In C and C++ the body of a switch statement can be a statement and statements with case labels do not have to be immediately contained by that statement.
A trick known as Duff's device can be used in C or C++ to unroll the loop, but this is not valid code in the Java programming language:
Fortunately, this trick does not seem to be widely known or used.
Moreover, it is less needed nowadays; this sort of code transformation is properly in the province of state-of-the-art optimizing compilers.
When the switch statement is executed, first the Expression is evaluated.
If the Expression evaluates to null, a NullPointerException is thrown and the entire switch statement completes abruptly for that reason.
Otherwise, if the result is of a reference type, it is subject to unboxing conversion (¬ß5.1.8)
If evaluation of the Expression or the subsequent unboxing conversion (if any) completes abruptly for some reason, the switch statement completes abruptly for the same reason.
Otherwise, execution continues by comparing the value of the Expression with each case constant, and there is a choice: ‚Ä¢ If one of the case constants is equal to the value of the expression, then we say.
If all these statements complete normally, or if there are no statements after the matching case label, then the entire switch statement completes normally.
If no case matches but there is a default label, then all statements after the matching default label in the switch block, if any, are executed in sequence.
If all these statements complete normally, or if there are no statements after the default label, then the entire switch statement completes normally.
If no case matches and there is no default label, then no further action is taken and the switch statement completes normally.
If any statement immediately contained by the Block body of the switch statement completes abruptly, it is handled as follows: ‚Ä¢ If execution of the Statement completes abruptly because of a break with no.
If execution of the Statement completes abruptly for any other reason, the switch.
The case of abrupt completion because of a break with a label is handled by the general rule for labeled statements (¬ß14.7)
As in C and C++, execution of statements in a switch block "falls through labels."
If code is not to fall through case to case in this manner, then break statements should be used, as in this example:
The while statement executes an Expression and a Statement repeatedly until the value of the Expression is false.
The Expression must have type boolean or Boolean, or a compile-time error occurs.
A while statement is executed by first evaluating the Expression.
If the result is of type Boolean, it is subject to unboxing conversion (¬ß5.1.8)
If evaluation of the Expression or the subsequent unboxing conversion (if any) completes abruptly for some reason, the while statement completes abruptly for the same reason.
Otherwise, execution continues by making a choice based on the resulting value: ‚Ä¢ If the value is true, then the contained Statement is executed.
If the (possibly unboxed) value of the Expression is false, no further action is taken and the while statement completes normally.
If the (possibly unboxed) value of the Expression is false the first time it is evaluated, then the Statement is not executed.
Abrupt completion of the contained Statement is handled in the following manner: ‚Ä¢ If execution of the Statement completes abruptly because of a break with no.
If execution of the Statement completes abruptly because of a continue with no.
If execution of the Statement completes abruptly because of a continue with.
If the while statement does not have label L, the while statement completes.
If execution of the Statement completes abruptly for any other reason, the while.
The case of abrupt completion because of a break with a label is handled by the general rule for labeled statements (¬ß14.7)
The do statement executes a Statement and an Expression repeatedly until the value of the Expression is false.
The Expression must have type boolean or Boolean, or a compile-time error occurs.
A do statement is executed by first executing the Statement.
Then there is a choice: ‚Ä¢ If execution of the Statement completes normally, then the Expression is.
If the result is of type Boolean, it is subject to unboxing conversion (¬ß5.1.8)
If evaluation of the Expression or the subsequent unboxing conversion (if any) completes abruptly for some reason, the do statement completes abruptly for the same reason.
Otherwise, there is a choice based on the resulting value: ‚óÜ If the value is true, then the entire do statement is executed again.
If the value is false, no further action is taken and the do statement completes.
Executing a do statement always executes the contained Statement at least once.
Abrupt completion of the contained Statement is handled in the following manner: ‚Ä¢ If execution of the Statement completes abruptly because of a break with no.
If execution of the Statement completes abruptly because of a continue with no label, then the Expression is evaluated.
Then there is a choice based on the resulting value: ‚óÜ If the value is true, then the entire do statement is executed again.
If the value is false, no further action is taken and the do statement completes.
If execution of the Statement completes abruptly because of a continue with label L, then there is a choice: ‚óÜ If the do statement has label L, then the Expression is evaluated.
If the value of the Expression is false, no further action is taken and the do.
If the do statement does not have label L, the do statement completes abruptly.
If execution of the Statement completes abruptly for any other reason, the do.
The case of abrupt completion because of a break with a label is handled by the general rule for labeled statements (¬ß14.7)
The following code is one possible implementation of the toHexString method of class Integer:
Because at least one digit must be generated, the do statement is an appropriate control structure.
The basic for statement executes some initialization code, then executes an Expression, a Statement, and some update code repeatedly until the value of the Expression is false.
The Expression must have type boolean or Boolean, or a compile-time error occurs.
If evaluation of any expression completes abruptly for some reason, the for statement completes abruptly for the same reason; any ForInit statement expressions to the right of the one that completed abruptly are not evaluated.
If the ForInit code is a local variable declaration, it is executed as if it were a local variable declaration statement (¬ß14.4) appearing in a block.
If execution of the local variable declaration completes abruptly for any reason, the for statement completes abruptly for the same reason.
If the ForInit part is not present, no action is taken.
Next, a for iteration step is performed, as follows: ‚Ä¢ If the Expression is present, it is evaluated.
If evaluation of the Expression or the subsequent unboxing conversion (if any) completes abruptly, the for statement completes abruptly for the same reason.
Otherwise, there is then a choice based on the presence or absence of the Expression and the resulting value if the Expression is present; see next bullet.
If the Expression is not present, or it is present and the value resulting from its evaluation (including any possible unboxing) is true, then the contained Statement is executed.
Then there is a choice: ‚óÜ If execution of the Statement completes normally, then the following two steps.
If evaluation of any expression completes abruptly for some reason, the for statement completes abruptly for the same reason; any ForUpdate statement expressions to the right of the one that completed abruptly are not evaluated.
If the ForUpdate part is not present, no action is taken.
If the Expression is present and the value resulting from its evaluation (including any possible unboxing) is false, no further action is taken and the for statement completes normally.
If the (possibly unboxed) value of the Expression is false the first time it is evaluated, then the Statement is not executed.
If the Expression is not present, then the only way a for statement can complete normally is by use of a break statement.
Abrupt completion of the contained Statement is handled in the following manner: ‚Ä¢ If execution of the Statement completes abruptly because of a break with no.
If execution of the Statement completes abruptly because of a continue with no.
If the ForUpdate part is not present, no action is taken.
If execution of the Statement completes abruptly because of a continue with.
First, if the ForUpdate part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded.
If the ForUpdate is not present, no action is taken.
If the for statement does not have label L, the for statement completes.
If execution of the Statement completes abruptly for any other reason, the for.
Note that the case of abrupt completion because of a break with a label is handled by the general rule for labeled statements (¬ß14.7)
The type of the Expression must be Iterable or an array type (¬ß10.1), or a compiletime error occurs.
The meaning of the enhanced for statement is given by translation into a basic for statement, as follows:
If the type of Expression is a subtype of Iterable, then the translation is as follows.
The enhanced for statement is equivalent to a basic for statement of the form:
If Type (in the FormalParameter production) is a reference type, then TargetType is Type; otherwise, TargetType is the upper bound of the capture conversion of the type argument of I, or Object if I is raw.
Lm be the (possibly empty) sequence of labels immediately preceding the enhanced for statement.
The enhanced for statement is equivalent to a basic for statement of the form:
TargetType is the type of the loop variable as denoted by the Type that appears in the FormalParameter followed by any bracket pairs that follow the Identifier in the FormalParameter (¬ß10.2)
The following program, which calculates the sum of an integer array, shows how enhanced for works for arrays:
The following program combines the enhanced for statement with auto-unboxing to translate a histogram into a frequency table:
A break statement transfers control out of an enclosing statement.
A break statement with no label attempts to transfer control to the innermost enclosing switch, while, do, or for statement of the immediately enclosing method or initializer; this statement, which is called the break target, then immediately completes normally.
To be precise, a break statement with no label always completes abruptly, the reason being a break with no label.
If no switch, while, do, or for statement in the immediately enclosing method, constructor, or initializer contains the break statement, a compile-time error occurs.
A break statement with label Identifier attempts to transfer control to the enclosing labeled statement (¬ß14.7) that has the same Identifier as its label; this statement, which is called the break target, then immediately completes normally.
In this case, the break target need not be a switch, while, do, or for statement.
To be precise, a break statement with label Identifier always completes abruptly, the reason being a break with label Identifier.
A break statement must refer to a label within the immediately enclosing method, constructor, or initializer.
It can be seen, then, that a break statement always completes abruptly.
The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any try statements (¬ß14.20) within the break target whose try blocks or catch clauses contain the break statement, then any finally clauses of those try statements are executed, in order, innermost to outermost, before control is transferred to the break target.
Abrupt completion of a finally clause can disrupt the transfer of control initiated by a break statement.
In the following example, a mathematical graph is represented by an array of arrays.
A graph consists of a set of nodes and a set of edges; each edge is an arrow that points from some node to some other node, or from a node to itself.
In this example it is assumed that there are no redundant edges; that is, for any two nodes P and Q, where Q may be the same as P, there is at most one edge from P to Q.
The task of the method loseEdges, given integers i and j, is to construct a new graph by copying a given graph but omitting the edge from node i to node j, if any, and the edge from node j to node i, if any:
Note the use of two statement labels, edgelist and search, and the use of break statements.
This allows the code that copies a list, omitting one edge, to be shared between two separate tests, the test for an edge from node i to node j, and the test for an edge from node j to node i.
A continue statement may occur only in a while, do, or for statement; statements of these three kinds are called iteration statements.
Control passes to the loopcontinuation point of an iteration statement.
A continue statement with no label attempts to transfer control to the innermost enclosing while, do, or for statement of the immediately enclosing method, constructor, or initializer; this statement, which is called the continue target, then immediately ends the current iteration and begins a new one.
To be precise, such a continue statement always completes abruptly, the reason being a continue with no label.
If no while, do, or for statement of the immediately enclosing method, constructor, or initializer contains the continue statement, a compile-time error occurs.
A continue statement with label Identifier attempts to transfer control to the enclosing labeled statement (¬ß14.7) that has the same Identifier as its label; that statement, which is called the continue target, then immediately ends the current iteration and begins a new one.
To be precise, a continue statement with label Identifier always completes abruptly, the reason being a continue with label Identifier.
The continue target must be a while, do, or for statement, or a compile-time error occurs.
A continue statement must refer to a label within the immediately enclosing method, constructor, or initializer.
If no labeled statement with Identifier as its label in the immediately enclosing method, constructor, or initializer contains the continue statement, a compile-time error occurs.
It can be seen, then, that a continue statement always completes abruptly.
The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any try statements (¬ß14.20) within the continue target whose try blocks or catch clauses contain the continue statement, then any finally clauses of those try statements are executed, in order, innermost to outermost, before control is transferred to the continue target.
Abrupt completion of a finally clause can disrupt the transfer of control initiated by a continue statement.
In the Graph class in ¬ß14.15, one of the break statements is used to finish execution of the entire body of the outermost for loop.
This break can be replaced by a continue if the for loop itself is labeled:
Which to use, if either, is largely a matter of programming style.
A return statement is contained in the innermost constructor, method, or initializer whose body encloses the return statement.
A return statement with no Expression attempts to transfer control to the invoker of the method or constructor that contains it.
To be precise, a return statement with no Expression always completes abruptly, the reason being a return with no value.
A return statement with an Expression must be contained in a method declaration that is declared to return a value (¬ß8.4), or a compile-time error occurs.
The Expression must denote a variable or value of some type T, or a compile-time error occurs.
The type T must be assignable (¬ß5.2) to the declared result type of the method, or a compile-time error occurs.
A return statement with an Expression attempts to transfer control to the invoker of the method that contains it; the value of the Expression becomes the value of the method invocation.
More precisely, execution of such a return statement first evaluates the Expression.
If the evaluation of the Expression completes abruptly for some reason, then the return statement completes abruptly for that reason.
If evaluation of the Expression completes normally, producing a value V, then the return statement completes abruptly, the reason being a return with value V.
If the expression is of type double and is not FP-strict, then the value may be an element of either the double value set or the double-extended-exponent value set.
It can be seen, then, that a return statement always completes abruptly.
The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any try statements (¬ß14.20) within the method or constructor whose try blocks or catch clauses contain the return statement, then any finally clauses of those try statements will be executed, in order, innermost to outermost, before control is transferred to the invoker of the method or constructor.
Abrupt completion of a finally clause can disrupt the transfer of control initiated by a return statement.
A throw statement causes an exception (¬ß11) to be thrown.
The reference type of the Expression will always be a class type (since no interface types are assignable to Throwable) which is not parameterized (since a subclass of Throwable cannot be generic (¬ß8.1.2))
At least one of the following three conditions must be true, or a compile-time error occurs:
The throw statement is contained in the try block of a try statement (¬ß14.20) and it is not the case that the try statement can throw an exception of the type of the Expression.
In this case we say the thrown value is caught by the try statement.)
The exception types that a throw statement can throw are specified in ¬ß11.2.2
If evaluation of the Expression completes abruptly for some reason, then the throw completes abruptly for that reason.
If evaluation of the Expression completes normally, producing a non-null value V, then the throw statement completes abruptly, the reason being a throw with value V.
If evaluation of the Expression completes normally, producing a null value, then an instance V' of class NullPointerException is created and thrown instead of null.
The throw statement then completes abruptly, the reason being a throw with value V'
It can be seen, then, that a throw statement always completes abruptly.
If there are any enclosing try statements (¬ß14.20) whose try blocks contain the throw statement, then any finally clauses of those try statements are executed as control is transferred outward, until the thrown value is caught.
Note that abrupt completion of a finally clause can disrupt the transfer of control initiated by a throw statement.
If a throw statement is contained in a method declaration, but its value is not caught by some try statement that contains it, then the invocation of the method completes abruptly because of the throw.
If a throw statement is contained in a constructor declaration, but its value is not caught by some try statement that contains it, then the class instance creation expression that invoked the constructor will complete abruptly because of the throw (¬ß15.9.4)
If at run time, despite this check, the value is not caught by some try statement that contains the throw statement, then the value is rethrown if it is an instance of class Error or one of its subclasses; otherwise, it is wrapped in an ExceptionInInitializerError object, which is then thrown (¬ß12.4.2)
If a throw statement is contained in an instance initializer (¬ß8.6), then a compiletime check (¬ß11.2.3) ensures that either its value is always an unchecked exception or its value is always caught by some try statement that contains it, or the type of the thrown exception (or one of its superclasses) occurs in the throws clause of every constructor of the class.
By convention, user-declared throwable types should usually be declared to be subclasses of class Exception, which is a subclass of class Throwable (¬ß11.1.1)
A synchronized statement acquires a mutual-exclusion lock (¬ß17.1) on behalf of the executing thread, executes a block, then releases the lock.
While the executing thread owns the lock, no other thread may acquire the lock.
The type of Expression must be a reference type, or a compile-time error occurs.
A synchronized statement is executed by first evaluating the Expression.
Then: ‚Ä¢ If evaluation of the Expression completes abruptly for some reason, then the synchronized statement completes abruptly for the same reason.
Otherwise, if the value of the Expression is null, a NullPointerException is thrown.
Otherwise, let the non-null value of the Expression be V.
Then the Block is executed, and then there is a choice: ‚óÜ If execution of the Block completes normally, then the monitor is unlocked.
If execution of the Block completes abruptly for any reason, then the monitor.
The locks acquired by synchronized statements are the same as the locks that are acquired implicitly by synchronized methods (¬ß8.4.3.6)
A single thread may acquire a lock more than once.
Acquiring the lock associated with an object does not in itself prevent other threads from accessing fields of the object or invoking un-synchronized methods on the object.
Other threads can also use synchronized methods or the synchronized statement in a conventional manner to achieve mutual exclusion.
Note that this program would deadlock if a single thread were not permitted to lock a monitor more than once.
If a value is thrown and the try statement has one or more catch clauses that can catch it, then control will be transferred to the first such catch clause.
If the try statement has a finally clause, then another block of code is executed, no matter whether the try block completes normally or abruptly, and no matter whether a catch clause is first given control.
The Block immediately after the keyword try is called the try block of the try statement.
The Block immediately after the keyword finally is called the finally block of the try statement.
A try statement may have catch clauses, also called exception handlers.
A catch clause has exactly one parameter, which is called an exception parameter.
An exception parameter may denote its type as either a single class type or a union of two or more class types (called alternatives)
The alternatives of a union are syntactically separated by |
A catch clause whose exception parameter is denoted as a single class type is called a uni-catch clause.
A catch clause whose exception parameter is denoted as a union of types is called a multi-catch clause.
Each class type used in the denotation of the type of an exception parameter must be the class Throwable or a subclass of Throwable, or a compile-time error occurs.
It is a compile-time error if a type variable is used in the denotation of the type of an exception parameter.
The declared type of an exception parameter that denotes its type with a single class type is that class type.
An exception parameter of a multi-catch clause is implicitly declared final if it is not explicitly declared final.
It is a compile-time error if an exception parameter that is implicitly or explicitly declared final is assigned to within the body of the catch clause.
In a uni-catch clause, an exception parameter that is not declared final (implicitly or explicitly) is considered effectively final if it never occurs within its scope as the left-hand operand of an assignment operator (¬ß15.26)
An implicitly final exception parameter is final by virtue of its declaration, while an effectively final exception parameter is (as it were) final by virtue of how it is used.
An exception parameter of a multi-catch clause is implicitly final, so will never occur as the left-hand operand of an assignment operator, but it is not considered effectively final.
If an exception parameter is effectively final (in a uni-catch clause) or implicitly final (in a multi-catch clause), then adding an explicit final modifier to its declaration will not introduce any compile-time errors.
However, if the exception parameter of a uni-catch clause is explicitly declared final, then removing the final modifier may introduce compile-time errors.
This is because the exception parameter, while still effectively final, can no longer be referenced by, for example, local classes.
On the other hand, if there are no compile-time errors, it is possible to further change the program so that the exception parameter is re-assigned and no longer effectively final.
The exception types that a try statement can throw are specified in ¬ß11.2.2
The relationship of the exceptions thrown by the try block of a try statement and caught by the catch clauses (if any) of the try statement is specified in ¬ß11.2.3
Exception handlers are considered in left-to-right order: the earliest possible catch clause accepts the exception, receiving as its argument the thrown exception object, as specified in ¬ß11.3
A multi-catch clause can be thought of as a sequence of uni-catch clauses.
A Java compiler is neither required nor recommended to compile a multi-catch clause by duplicating code in this manner, since it is possible to represent the multi-catch clause in a class file without duplication.
A finally clause ensures that the finally block is executed after the try block and any catch block that might be executed, no matter how control leaves the try block or catch block.
A try statement is permitted to omit catch clauses and a finally clause if it is a try-with-resources statement (¬ß14.20.3)
A try statement without a finally block is executed by first executing the try block.
Then there is a choice: ‚Ä¢ If execution of the try block completes normally, then no further action is taken.
The value V is assigned to the parameter of the selected catch clause, and the Block of that catch clause is executed, and then there is a choice: ‚ùñ If that block completes normally, then the try statement completes.
If that block completes abruptly for any reason, then the try statement.
If the run-time type of V is not assignment compatible with a catchable.
If execution of the try block completes abruptly for any other reason, then the try statement completes abruptly for the same reason.
Here, the exception BlewIt is thrown by the method blowUp.
The try-catch statement in the body of main has two catch clauses.
The run-time type of the exception is BlewIt which is not assignable to a variable of type RuntimeException, but is assignable to a variable of type BlewIt, so the output of the example is:
A try statement with a finally block is executed by first executing the try block.
If execution of the try block completes normally, then the finally block is executed, and then there is a choice: ‚óÜ If the finally block completes normally, then the try statement completes.
If the finally block completes abruptly for reason S, then the try statement.
If execution of the try block completes abruptly because of a throw of a value V, then there is a choice: ‚óÜ If the run-time type of V is assignment compatible with a catchable exception.
The value V is assigned to the parameter of the selected catch clause, and the Block of that catch clause is executed.
Then there is a choice: ‚ùñ If the catch block completes normally, then the finally block is executed.
Then there is a choice: ‚ú¶ If the finally block completes normally, then the try statement.
If the finally block completes abruptly for any reason, then the try.
If the catch block completes abruptly for reason R, then the finally block.
Then there is a choice: ‚ú¶ If the finally block completes normally, then the try statement.
If the finally block completes abruptly for reason S, then the try.
If the run-time type of V is not assignment compatible with a catchable exception class of any catch clause of the try statement, then the finally block is executed.
Then there is a choice: ‚ùñ If the finally block completes normally, then the try statement completes.
If the finally block completes abruptly for reason S, then the try statement.
If execution of the try block completes abruptly for any other reason R, then the finally block is executed, and then there is a choice: ‚óÜ If the finally block completes normally, then the try statement completes.
If the finally block completes abruptly for reason S, then the try statement.
The NullPointerException (which is a kind of RuntimeException) that is thrown by method blowUp is not caught by the try statement in main, because a.
NullPointerException is not assignable to a variable of type BlewIt.
This causes the finally clause to execute, after which the thread executing main, which is the only thread of the test program, terminates because of an uncaught exception, which typically results in printing the exception name and a simple backtrace.
The problem with mandating a backtrace is that an exception can be created at one point in the program and thrown at a later one.
It is prohibitively expensive to store a stack trace in an exception unless it is actually thrown (in which case the trace may be generated while unwinding the stack)
Hence we do not mandate a back trace in every exception.
A try-with-resources statement is parameterized with variables (known as resources) that are initialized before execution of the try block and closed automatically, in the reverse order from which they were initialized, after execution of the try block.
A ResourceSpecification declares one or more local variables with initializer expressions to act as resources for the try statement.
A resource declared in a ResourceSpecification is implicitly declared final (¬ß4.12.4) if it is not explicitly declared final.
The type of a variable declared in a ResourceSpecification must be a subtype of AutoCloseable, or a compile-time error occurs.
It is a compile-time error for a ResourceSpecification to declare two variables with the same name.
If a resource fails to initialize (that is, its initializer expression throws an exception), then all resources initialized so far by the try-with-resources statement are closed.
If all resources initialize successfully, the try block executes as normal and then all non-null resources of the try-withresources statement are closed.
Resources are closed in the reverse order from that in which they were initialized.
A resource is closed only if it initialized to a non-null value.
An exception from the closing of one resource does not prevent the closing of other resources.
Such an exception is suppressed if an exception was thrown previously by an initializer, the try block, or the closing of a resource.
A try-with-resources statement with a ResourceSpecification clause that declares multiple resources is treated as if it were multiple try-with-resources statements, each of which has a ResourceSpecification clause that declares a single Resource.
After n such translations, there are n nested try-catch-finally statements, and the overall translation is complete.
A try-with-resources statement with no catch clauses or finally clause is called a basic try-with-resources statement.
If the ResourceSpecification declares one resource, then ResourceSpecification_tail is empty (and the try-catch-finally statement is not itself a try-with-resources statement)
Reachability and definite assignment rules for the basic try-with-resources statement are implicitly specified by the translation above.
In a basic try-with-resources statement that manages a single resource: ‚Ä¢ If the initialization of the resource completes abruptly because of a throw of a.
If the initialization of the resource completes normally, and the try block completes abruptly because of a throw of a value V, then: ‚óÜ If the automatic closing of the resource completes normally, then the try-withresources statement completes abruptly because of a throw of the value V.
If the initialization of the resource completes normally, and the try block completes normally, and the automatic closing of the resource completes abruptly because of a throw of a value V, then the try-with-resources statement completes abruptly because of a throw of the value V.
In a basic try-with-resources statement that manages multiple resources: ‚Ä¢ If the initialization of a resource completes abruptly because of a throw of a.
If the initialization of all resources completes normally, and the try block completes abruptly because of a throw of a value V, then: ‚óÜ If the automatic closings of all initialized resources complete normally, then.
If the initialization of every resource completes normally, and the try block completes normally, then: ‚óÜ If one automatic closing of an initialized resource completes abruptly because.
A try-with-resources statement with at least one catch clause and/or a finally clause is called an extended try-with-resources statement.
The effect of the translation is to put the ResourceSpecification "inside" the try statement.
This allows a catch clause of an extended try-with-resources statement to catch an exception due to the automatic initialization or closing of any resource.
Furthermore, all resources will have been closed (or attempted to be closed) by the time the finally block is executed, in keeping with the intent of the finally keyword.
It is a compile-time error if a statement cannot be executed because it is unreachable.
This section is devoted to a precise explanation of the word "reachable." The idea is that there must be some possible execution path from the beginning of the constructor, method, instance initializer, or static initializer that contains the statement to the statement itself.
Except for the special treatment of while, do, and for statements whose condition expression has the constant value true, the values of expressions are not taken into account in the flow analysis.
To shorten the description of the rules, the customary abbreviation "iff" is used to mean "if and only if." A reachable break statement exits a statement if, within the break target, either there are no try statements whose try blocks contain the break statement, or there are try statements whose try blocks contain the break statement and all finally clauses of those try statements can complete normally.
This definition is based on the logic around "attempts to transfer control" in ¬ß14.15
A continue statement continues a do statement if, within the do statement, either there are no try statements whose try blocks contain the continue statement, or there are try statements whose try blocks contain the continue statement and all finally clauses of those try statements can complete normally.
The block that is the body of a constructor, method, instance initializer, or static initializer is reachable.
An empty block that is not a switch block can complete normally iff it is reachable.
A non-empty block that is not a switch block can complete normally iff the last statement in it can complete normally.
The first statement in a non-empty block that is not a switch block is reachable iff the block is reachable.
Every other statement S in a non-empty block that is not a switch block is reachable iff the statement preceding S can complete normally.
A local class declaration statement can complete normally iff it is reachable.
A local variable declaration statement can complete normally iff it is reachable.
An empty statement can complete normally iff it is reachable.
A labeled statement can complete normally if at least one of the following is true:
There is a reachable break statement that exits the labeled statement.
The contained statement is reachable iff the labeled statement is reachable.
An expression statement can complete normally iff it is reachable.
An if-then statement can complete normally iff it is reachable.
The then-statement is reachable iff the if-then statement is reachable.
An if-then-else statement can complete normally iff the then-statement can complete normally or the else-statement can complete normally.
The then-statement is reachable iff the if-then-else statement is reachable.
The else-statement is reachable iff the if-then-else statement is reachable.
This handling of an if statement, whether or not it has an else part, is rather unusual.
The rationale is given at the end of this section.
An assert statement can complete normally iff it is reachable.
A switch statement can complete normally iff at least one of the following is.
The switch block is empty or contains only switch labels.
The last statement in the switch block can complete normally.
There is at least one switch label after the last switch block statement group.
There is a reachable break statement that exits the switch statement.
A switch block is reachable iff its switch statement is reachable.
A statement in a switch block is reachable iff its switch statement is reachable.
There is a statement preceding it in the switch block and that preceding.
A while statement can complete normally iff at least one of the following is true: ‚óÜ The while statement is reachable and the condition expression is not a constant.
There is a reachable break statement that exits the while statement.
The contained statement is reachable iff the while statement is reachable and the condition expression is not a constant expression whose value is false.
A do statement can complete normally iff at least one of the following is true: ‚óÜ The contained statement can complete normally and the condition expression.
The do statement contains a reachable continue statement with no label, and.
The do statement contains a reachable continue statement with a label L, and the do statement has label L, and the continue statement continues that do statement, and the condition expression is not a constant expression with value true.
There is a reachable break statement that exits the do statement.
The contained statement is reachable iff the do statement is reachable.
A basic for statement can complete normally iff at least one of the following is true: ‚óÜ The for statement is reachable, there is a condition expression, and the.
There is a reachable break statement that exits the for statement.
The contained statement is reachable iff the for statement is reachable and the condition expression is not a constant expression whose value is false.
An enhanced for statement can complete normally iff it is reachable.
A break, continue, return, or throw statement cannot complete normally.
A synchronized statement can complete normally iff the contained statement can complete normally.
The contained statement is reachable iff the synchronized statement is reachable.
A try statement can complete normally iff both of the following are true: ‚óÜ The try block can complete normally or any catch block can complete.
If the try statement has a finally block, then the finally block can complete.
The try block is reachable iff the try statement is reachable.
A catch block C is reachable iff both of the following are true:
Either the type of C's parameter is an unchecked exception type or Throwable; or some expression or throw statement in the try block is reachable and can throw a checked exception whose type is assignable to the parameter of the catch clause C.
An expression is reachable iff the innermost statement containing it is reachable.
There is no earlier catch block A in the try statement such that the type of C's.
The Block of a catch block is reachable iff the catch block is reachable.
If a finally block is present, it is reachable iff the try statement is reachable.
One might expect the if statement to be handled in the following manner:
An if-then statement can complete normally iff at least one of the following is true:
The if-then statement is reachable and the condition expression is not a constant expression whose value is true.
The then-statement is reachable iff the if-then statement is reachable and the condition expression is not a constant expression whose value is false.
An if-then-else statement can complete normally iff the then-statement can complete normally or the else-statement can complete normally.
The then-statement is reachable iff the if-then-else statement is reachable and the condition expression is not a constant expression whose value is false.
The else-statement is reachable iff the if-then-else statement is reachable and the condition expression is not a constant expression whose value is true.
This approach would be consistent with the treatment of other control structures.
However, in order to allow the if statement to be used conveniently for "conditional compilation" purposes, the actual rules differ.
As an example, the following statement results in a compile-time error:
An optimizing compiler may realize that the the technical sense specified here.
The rationale for this differing treatment is to allow programmers to define "flag variables" such as:
The idea is that it should be possible to change the value of DEBUG from false to true or from true to false and then compile the code correctly with no other changes to the program text.
This ability to "conditionally compile" has a significant impact on, and relationship to, binary compatibility (¬ß13)
If a set of classes that use such a "flag" variable are compiled and conditional code is omitted, it does not suffice later to distribute just a new version of the class or interface that contains the definition of the flag.
A change to the value of a flag is, therefore, not binary compatible with pre-existing binaries (¬ß13.4.9)
There are other reasons for such incompatibility as well, such as the use of constants in case labels in switch statements; see ¬ß13.4.9.)
This chapter specifies the meanings of expressions and the rules for their evaluation.
When an expression in a program is evaluated (executed), the result denotes one of three things:
Such an expression can be used only as an expression statement (¬ß14.8), because every other context in which an expression can appear requires the expression to denote something.
An expression statement that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded.
Value set conversion (¬ß5.1.13) is applied to the result of every expression that produces a value.
The declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in an annotation, or in the code for a method.
An annotation (¬ß9.7) of a package or of a top level type declaration.
If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used.
In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression.
If the value of a variable of type float or double is used in this manner, then value set conversion (¬ß5.1.13) is applied to the value of the variable.
If an expression denotes a variable or a value, then the expression has a type known at compile time.
The rules for determining the type of an expression are explained separately below for each kind of expression.
Likewise, the value stored in a variable is always compatible with the type of the variable, unless heap pollution occurs.
In other words, the value of an expression whose type is T is always suitable for assignment to a variable of type T.
Note that an expression whose type is a class type F that is declared final is guaranteed to have a value that is either a null reference or an object whose class is F itself, because final types have no subclasses.
If the type of an expression is float or double, then there is a question as to what value set (¬ß4.2.3) the value of the expression is drawn from.
This is governed by or not the expression is FP-strict.
If an expression is not a compile-time constant expression, then consider all the class declarations, interface declarations, and method declarations that contain the expression.
If a class, interface, or method, X, is declared strictfp, then X and any class, interface, method, constructor, instance initializer, static initializer or variable initializer within X is said to be FP-strict.
It follows that an expression is not FP-strict if and only if it is not a compiletime constant expression and it does not appear within any declaration that has the strictfp modifier.
Within an FP-strict expression, all intermediate values must be elements of the float value set or the double value set, implying that the results of all FPstrict expressions must be those predicted by IEEE 754 arithmetic on operands represented using single and double formats.
Within an expression that is not FP-strict, some leeway is granted for an implementation to use an extended exponent range to represent intermediate results; the net effect, roughly speaking, is that a calculation might produce "the correct answer" in situations where exclusive use of the float value set or double value set might result in overflow or underflow.
If the type of an expression is a primitive type, then the value of the expression is of that same primitive type.
If the type of an expression is a reference type, then the class of the referenced object, or even whether the value is a reference to an object rather than null, is not necessarily known at compile time.
There are a few places in the Java programming language where the actual class of a referenced object affects program execution in a manner that cannot be deduced from the type of the expression.
The particular method used for an invocation o.m(...) is chosen based on the methods that are part of the class or interface that is the type of o.
For instance methods, the class of the object referenced by the run-time value of o participates because a subclass may override a specific method already declared in a parent class so that this overriding method is invoked.
The overriding method may or may not choose to further invoke the original overridden m method.)
An expression whose type is a reference type may be tested using instanceof to find out whether the class of the object referenced by the run-time value of the expression is assignment compatible (¬ß5.2) with some other reference type.
The class of the object referenced by the run-time value of the operand expression might not be compatible with the type specified by the cast.
For reference types, this may require a run-time check that throws an exception if the class of the referenced object, as determined at run time, is not assignment compatible (¬ß5.2) with the target type.
An exception is caught by a catch clause only if the class of the thrown exception object is an instanceof the type of the formal parameter of the catch clause.
Situations where the class of an object is not statically known may lead to run-time type errors.
In addition, there are situations where the statically known type may not be accurate at run time.
Such situations can arise in a program that gives rise to compile-time unchecked warnings.
Such warnings are given in response to operations that cannot be statically guaranteed to be safe, and cannot immediately be subjected to dynamic checking because they involve non-reifiable (¬ß4.7) types.
A run-time type error can occur only in these situations:
In a cast, when the actual class of the object referenced by the value of the operand expression is not compatible with the target type specified by the cast.
In an automatically generated cast introduced to ensure the validity of an operation on a non-reifiable type (¬ß4.7)
In an assignment to an array component of reference type, when the actual class of the object referenced by the value to be assigned is not compatible with the case an ArrayStoreException is thrown.
When an exception is not caught by any catch clause of a try statement attempts to invoke an uncaught exception handler (¬ß11.3) and then terminates.
Every expression has a normal mode of evaluation in which certain computational steps are carried out.
The following sections describe the normal mode of evaluation for each kind of expression.
If all the steps are carried out without an exception being thrown, the expression is said to complete normally.
If, however, evaluation of an expression throws an exception, then the expression is said to complete abruptly.
An abrupt completion always has an associated reason, which is always a throw with a given value.
An array creation expression (¬ß15.10) throws a NegativeArraySizeException if the value of any dimension expression is less than zero.
A field access expression (¬ß15.11) throws a NullPointerException if the value of the object reference expression is null.
A method invocation expression (¬ß15.12) that invokes an instance method throws a NullPointerException if the target reference is null.
An array access expression (¬ß15.13) throws a NullPointerException if the value of the array reference expression is null.
An array access expression (¬ß15.13) throws an ArrayIndexOutOfBoundsException if the value of the array index expression is negative or greater than or equal to the length of the array.
A cast expression (¬ß15.16) throws a ClassCastException if a cast is found to be impermissible at run time.
A method invocation expression can also result in an exception being thrown if an exception occurs that causes execution of the method body to complete abruptly.
A class instance creation expression can also result in an exception being thrown if an exception occurs that causes execution of the constructor to complete abruptly.
Various linkage and virtual machine errors may also occur during the evaluation of an expression.
By their nature, such errors are difficult to predict and difficult to handle.
If an exception occurs, then evaluation of one or more expressions may be terminated before all steps of their normal mode of evaluation are complete; such expressions are said to complete abruptly.
If evaluation of an expression requires evaluation of a subexpression, then abrupt completion of the subexpression always causes the immediate abrupt completion of the expression itself, with the same reason, and all succeeding steps in the normal mode of evaluation are not performed.
The terms "complete normally" and "complete abruptly" are also applied to the execution of statements (¬ß14.1)
A statement may complete abruptly for a variety of reasons, not just because an exception is thrown.
The Java programming language guarantees that the operands of operators appear to be evaluated in a specific evaluation order, namely, from left to right.
It is recommended that code not rely crucially on this specification.
Code is usually clearer when each expression contains at most one side effect, as its outermost operation, and when code does not depend on exactly which exception arises as a consequence of the left-toright evaluation of expressions.
The left-hand operand of a binary operator appears to be fully evaluated before any part of the right-hand operand is evaluated.
If the operator is a compound-assignment operator (¬ß15.26.2), then evaluation of the left-hand operand includes both remembering the variable that the left-hand operand denotes and fetching and saving that variable's value for use in the implied binary operation.
If evaluation of the left-hand operand of a binary operator completes abruptly, no part of the right-hand operand appears to have been evaluated.
In the following program, the * operator has a left-hand operand that contains an assignment to a variable and a right-hand operand that contains a reference to the same variable.
The value produced by the reference will reflect the fact that the assignment occurred first.
It is not permitted for either assignment (compound for a, simple for b) to produce the result 6
The Java programming language respects the order of evaluation indicated explicitly by parentheses and implicitly by operator precedence.
An implementation of the Java programming language may not take advantage of algebraic identities such as the associative law to rewrite expressions into a more convenient computational order unless it can be proven that the replacement expression is equivalent in value and in its observable side effects, even in the presence of multiple threads of execution (using the thread execution model in ¬ß17), for all possible computational values that might be involved.
In the case of floating-point calculations, this rule applies also for infinity and nota-number (NaN) values.
Specifically, floating-point calculations that appear to be mathematically associative are unlikely to be computationally associative.
In contrast, integer addition and multiplication are provably associative in the Java programming language.
For example a+b+c, where a, b, and c are local variables (this simplifying assumption avoids issues involving multiple threads and volatile variables), will always produce nearby in the code, a smart Java compiler may be able to use this common subexpression.
In a method or constructor invocation or class instance creation expression, argument expressions may appear within the parentheses, separated by commas.
Each argument expression appears to be fully evaluated before any part of any argument expression to its right.
If evaluation of an argument expression completes abruptly, no part of any argument expression to its right appears to have been evaluated.
The order of evaluation for some expressions is not completely covered by these general rules, because these expressions may raise exceptional conditions at times that must be specified.
Primary expressions include most of the simplest kinds of expressions, from which all others are constructed: literals, class literals, field accesses, method invocations, and array accesses.
A parenthesized expression is also treated syntactically as a primary expression.
This part of the grammar of the Java programming language is unusual, in two ways.
First, one might expect simple names, such as names of local variables and method parameters, to be primary expressions.
For technical reasons, names are grouped together with primary expressions a little later when postfix expressions are introduced (¬ß15.14)
The technical reasons have to do with allowing left-to-right parsing of Java programs with only one-token lookahead.
At the point that the look-ahead symbol is [, a left-to-right parse will have reduced the z to the nonterminal Name.
In the context of a cast we prefer not to have to reduce the name to a Primary, but if Name were one of the alternatives for Primary, then we could not tell whether to do the reduction (that is, we could not determine whether the current situation would turn out to be a parenthesized array access or a cast) without looking ahead two tokens, to the token following the [
The Java grammar presented here avoids the problem by keeping Name and Primary separate and allowing either in certain other syntax rules (those for MethodInvocation, ArrayAccess, PostfixExpression, but not for FieldAccess, because this uses an identifier directly)
This strategy effectively defers the question of whether a Name should be treated as a Primary until more context can be examined.
This ambiguity is eliminated by splitting the expected definition of Primary into Primary and PrimaryNoNewArray.
This may be compared to the splitting of Statement into Statement and StatementNoShortIf (¬ß14.5) to avoid the "dangling else" problem.)
The following production from ¬ß3.10 is repeated here for convenience:
The type of any other integer literal is int (¬ß4.2.1)
The type of any other floating-point literal is double and its value must be an element of the double value set (¬ß4.2.3)
A class literal is an expression consisting of the name of a class, interface, array, or primitive type, or the pseudo-type void, followed by a '.' and the token class.
A class literal evaluates to the Class object for the named type (or for void) as defined by the defining class loader (¬ß12.2) of the class of the current instance.
The keyword this may be used only in the body of an instance method, instance initializer, or constructor, or in the initializer of an instance variable of a class.
When used as a primary expression, the keyword this denotes a value that is a reference to the object for which the instance method was invoked (¬ß15.12), or to the object being constructed.
The type of this is the class C within which the keyword this occurs.
At run time, the class of the actual object referred to may be the class C or any subclass of C.
The keyword this is also used in a special explicit constructor invocation statement, which can appear at the beginning of a constructor body (¬ß8.8.7)
Here, the class IntVector implements a method equals, which compares two vectors.
If the other vector is the same vector object as the one for which the equals method was invoked, then the check can skip the length and value comparisons.
The equals method implements this check by comparing the reference to the other object to this.
Any lexically enclosing instance (¬ß8.1.3) can be referred to by explicitly qualifying the keyword this.
Let n be an integer such that C is the n'th lexically enclosing class of the class in which the qualified this expression appears.
The value of an expression of the form ClassName.this is the n'th lexically enclosing instance of this.
It is a compile-time error if the current class is not an inner class of class C or C itself.
A parenthesized expression is a primary expression whose type is the type of the contained expression and whose value at run time is the value of the contained expression.
If the contained expression denotes a variable then the parenthesized expression also denotes that variable.
A class instance creation expression is used to create new objects that are instances of classes.
If the constructor is generic (¬ß8.8.4), the type arguments to the constructor may similarly either be inferred or passed explicitly.
If passed explicitly, the type arguments to the constructor immediately follow the keyword new.
It is a compile-time error if a class instance creation expression provides a constructor type argument list but uses "<>" in place of a class type argument list.
This rule is introduced because inference of a generic class's type arguments may influence the constraints on a generic constructor's type arguments.
It is a compile-time error if any of the type arguments used in a class instance creation expression are wildcard type arguments (¬ß4.5.1)
The exception types that a class instance creation expression can throw are specified in ¬ß11.2.1
Unqualified class instance creation expressions begin with the keyword new.
A qualified class instance creation expression enables the creation of instances of inner member classes and their anonymous subclasses.
Both unqualified and qualified class instance creation expressions may optionally end with a class body.
Such a class instance creation expression declares an anonymous class (¬ß15.9.5) and creates an instance of it.
It is a compile-time error if a class instance creation expression declares an anonymous class using the "<>" form for the class's type arguments.
We say that a class is instantiated when an instance of the class is created by a class instance creation expression.
Class instantiation involves determining what class is to be instantiated, what the enclosing instances (if any) of the newly created.
If the class instance creation expression ends in a class body, then the class being instantiated is an anonymous class.
Then: ‚Ä¢ If the class instance creation expression is an unqualified class instance creation.
If T denotes a class, then an anonymous direct subclass of the class named by T is declared.
It is a compile-time error if the class denoted by T is a final class.
If T denotes an interface, then an anonymous direct subclass of Object that implements the interface named by T is declared.
In either case, the body of the subclass is the ClassBody given in the class instance creation expression.
Otherwise, the class instance creation expression is a qualified class instance.
It is a compile-time error if the name is ambiguous (¬ß8.5) or denotes an enum type.
When TypeArguments are provided after the name, it is a compile-time error if the type arguments, when applied to the named class, do not denote a wellformed parameterized type (¬ß4.5)
Let T be the type named by the Identifier and any type arguments.
An anonymous direct subclass of the class named by T is declared.
The body of the subclass is the ClassBody given in the class instance creation expression.
If a class instance creation expression does not declare an anonymous class, then:
If the class instance creation expression is an unqualified class instance creation expression, then the TypeDeclSpecifier must denote a class that is accessible (¬ß6.6) and is not an enum type and not abstract, or a compile-time error occurs.
When TypeArguments are provided after the class name, it is a compile-time error if the type arguments, when applied to the class, do not denote a well-formed parameterized type (¬ß4.5)
When "<>" is used to elide type arguments after the class name, it is a compiletime error if the class is not generic.
The class being instantiated is the class denoted by the TypeDeclSpecifier.
Otherwise, the class instance creation expression is a qualified class instance.
When TypeArguments are provided after the name, it is a compile-time error if the type arguments, when applied to C, do not denote a well-formed parameterized type (¬ß4.5)
When "<>" is used to elide type arguments after the name, it is a compile-time error if C is not generic.
The type of the class instance creation expression is the class type being instantiated, as defined above.
Let C be the class being instantiated, and let i be the instance being created.
If C is an inner class then i may have an immediately enclosing instance.
The immediately enclosing instance of i (¬ß8.1.3) is determined as follows.
If the class instance creation expression occurs in a static context (¬ß8.1.3), then i has no immediately enclosing instance.
If C is a local class (¬ß14.3), then let O be the innermost lexically enclosing class of C.
Let n be an integer such that O is the n'th lexically enclosing class of the class in which the class instance creation expression appears.
If C occurs in a static context, then i has no immediately enclosing instance.
Otherwise, if the class instance creation expression occurs in a static context,
Otherwise, the immediately enclosing instance of i is the n'th lexically enclosing instance of this (¬ß8.1.3)
Otherwise, if C is a member of an enclosing class then let O be the innermost.
The immediately enclosing instance of i is the n'th lexically enclosing instance of this.
Otherwise, the class instance creation expression is a qualified class instance creation expression.
The immediately enclosing instance of i is the object that is the value of the Primary expression.
In addition, if C is an anonymous class, and the direct superclass of C, S, is an inner class, then i may have an immediately enclosing instance with respect to S.
If S is a local class (¬ß14.3), then let O be the innermost lexically enclosing class of S.
Let n be an integer such that O is the n'th lexically enclosing class of the class in which the class instance creation expression appears.
If S occurs within a static context, then i has no immediately enclosing instance with respect to S.
Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.
Otherwise, the immediately enclosing instance of i with respect to S is the n'th lexically enclosing instance of this.
Otherwise, if S is a member of an enclosing class, then let O be the innermost.
The immediately enclosing instance of i with respect to S is the n'th lexically enclosing instance of this.
Otherwise, the class instance creation expression is a qualified class instance creation expression.
The immediately enclosing instance of i with respect to S is the object that is the value of the Primary expression.
To create an instance of C, i, a constructor of C is chosen at compile time by the following rules.
First, the actual arguments to the constructor invocation are determined: ‚Ä¢ If C is an anonymous class, and the direct superclass of C, S, is an inner class, then:
If S is a local class and S occurs in a static context, then the arguments in the argument list, if any, are the arguments to the constructor, in the order they appear in the expression.
Otherwise, the immediately enclosing instance of i with respect to S is the first argument to the constructor, followed by the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the expression.
Otherwise the arguments in the argument list, if any, are the arguments to the constructor, in the order they appear in the expression.
Let #m be an automatically generated name that is distinct from all constructor and method names in C.
The return type of mj is Œ∏j applied to C<F1,...,Fp>
The (possibly empty) list of argument types of mj is Œ∏j applied to the argument.
The (possibly empty) list of thrown types of mj is Œ∏j applied to the thrown.
To choose a constructor, we temporarily consider m1...mn to be members of C.
It is a compile-time error if there is no unique most-specific method that is both applicable and accessible.
Otherwise, where mj is the selected method, cj is the chosen constructor.
The result type and throws clause of cj are the same as the return type and throws clause determined for mj (¬ß15.12.2.6)
Otherwise, the class instance creation expression does not use "<>" to elide class type arguments.
Let T be the type denoted by C followed by any class type arguments in the expression.
The process described in ¬ß15.12.2, modified to handle constructors, is used to select one of the constructors of T and determine its throws clause.
As in method invocations, it is a compile-time error if there is no unique mostspecific constructor that is both applicable and accessible.
Finally, the type of the class instance creation expression is the result type of the chosen constructor, as defined above.
Note that the type of the class instance creation expression may be an anonymous class type, in which case the constructor being invoked is an anonymous constructor (¬ß15.9.5.1)
At run time, evaluation of a class instance creation expression is as follows.
First, if the class instance creation expression is a qualified class instance creation expression, the qualifying primary expression is evaluated.
If the qualifying expression evaluates to null, a NullPointerException is raised, and the class instance creation expression completes abruptly.
If the qualifying expression completes abruptly, the class instance creation expression completes abruptly for the same reason.
If there is insufficient space to allocate the object, evaluation of the class instance creation expression completes abruptly by throwing an OutOfMemoryError.
The new object contains new instances of all the fields declared in the specified class type and all its superclasses.
As each new field instance is created, it is initialized to its default value (¬ß4.12.5)
Next, the actual arguments to the constructor are evaluated, left-to-right.
If any of the argument evaluations completes abruptly, any argument expressions to its right are not evaluated, and the class instance creation expression completes abruptly for the same reason.
Next, the selected constructor of the specified class type is invoked.
This results in invoking at least one constructor for each superclass of the class type.
The value of a class instance creation expression is a reference to the newly created object of the specified class.
Every time the expression is evaluated, a fresh object is created.
If evaluation of a class instance creation expression finds there is insufficient memory to perform the creation operation, then an OutOfMemoryError is thrown.
An anonymous class declaration is automatically derived from a class instance creation expression by the Java compiler.
Instead, a Java compiler must automatically provide an anonymous constructor for the anonymous class.
The form of the anonymous constructor of an anonymous class C with direct superclass S is as follows:
If S is not an inner class, or if S is a local class that occurs in a static context, then the anonymous constructor has one formal parameter for each actual argument to the class instance creation expression in which C is declared.
The actual arguments to the class instance creation expression are used to determine a constructor cs of S, using the same rules as for method invocations (¬ß15.12)
The type of each formal parameter of the anonymous constructor must be identical to the corresponding formal parameter of cs.
The body of the constructor consists of an explicit constructor invocation (¬ß8.8.7.1) of the form super(...), where the actual arguments are the formal parameters of the constructor, in the order they were declared.
Otherwise, the first formal parameter of the constructor of C represents the value of the immediately enclosing instance of i with respect to S.
The type of this parameter is the class type that immediately encloses the declaration of S.
The constructor has an additional formal parameter for each actual argument to the class instance creation expression that declared the anonymous class.
The n'th formal parameter e corresponds to the n-1'th actual argument.
The actual arguments to the class instance creation expression are used to determine a constructor cs of S, using the same rules as for method invocations (¬ß15.12)
The type of each formal parameter of the anonymous constructor must be identical to the corresponding formal parameter of cs.
The body of the constructor consists of an explicit constructor invocation (¬ß8.8.7.1) of the form o.super(...), where o is the first formal parameter of the constructor, and the actual arguments are the subsequent formal parameters of the constructor, in the order they were declared.
In all cases, the throws clause of an anonymous constructor must list all the checked exceptions thrown by the explicit superclass constructor invocation statement contained within the anonymous constructor, and all checked exceptions thrown by any instance initializers or instance variable initializers of the anonymous class.
Note that it is possible for the signature of the anonymous constructor to refer to an inaccessible type (for example, if such a type occurred in the signature of the superclass constructor cs)
This does not, in itself, cause any errors at either compile-time or run-time.
An array creation expression is used to create new arrays (¬ß10)
An array creation expression creates an object that is a new array whose elements are of the type specified by the PrimitiveType or ClassOrInterfaceType.
It is a compile-time error if the ClassOrInterfaceType does not denote a reifiable type (¬ß4.7)
The rules above imply that the element type in an array creation expression cannot be a parameterized type, other than an unbounded wildcard.
The type of each dimension expression within a DimExpr must be a type that is convertible (¬ß5.1.8) to an integral type, or a compile-time error occurs.
The promoted type must be int, or a compile-time error occurs.
The type of the array creation expression is an array type that can denoted by a copy of the array creation expression from which the new keyword and every DimExpr expression and array initializer have been deleted.
At run time, evaluation of an array creation expression behaves as follows: ‚Ä¢ If there are no dimension expressions, then there must be an array initializer.
A newly allocated array will be initialized with the values provided by the array initializer as described in ¬ß10.6
The value of the array initializer becomes the value of the array creation expression.
Otherwise, there is no array initializer, and: ‚óÜ First, the dimension expressions are evaluated, left-to-right.
If the value of any DimExpr expression is less than zero, then a NegativeArraySizeException is thrown.
If there is insufficient space to allocate the array, evaluation of the array creation expression completes abruptly by throwing an OutOfMemoryError.
Then, if a single DimExpr appears, a one-dimensional array is created of the specified length, and each component of the array is initialized to its default value (¬ß4.12.5)
Otherwise, if n DimExpr expressions appear, then array creation effectively executes a set of nested loops of depth n-1 to create the implied arrays of arrays.
A multidimensional array need not have arrays of the same length at each level.
In an array creation expression with one or more dimension expressions, each dimension expression is fully evaluated before any part of any dimension expression to its right.
If evaluation of a dimension expression completes abruptly, no part of any dimension expression to its right will appear to have been evaluated.
These arrays can be filled in later by other code, such as:
If evaluation of an array creation expression finds there is insufficient memory to perform the creation operation, then an OutOfMemoryError is thrown.
If the array creation expression does not have an array initializer, then this check occurs only after evaluation of all dimension expressions has completed normally.
A field access expression may access a field of an object or array, a reference to which is the value of either an expression or the special keyword super.
The meaning of a field access expression is determined using the same rules as for qualified names (¬ß6.5.6.2), but limited by the fact that an expression cannot denote a package, class type, or interface type.
It is also possible to refer to a field of the current instance or current class by using a simple name (¬ß6.5.6.1)
The type of the Primary must be a reference type T, or a compile-time error occurs.
If the identifier does not name an accessible member field in type T, then the.
Otherwise, the identifier names a single accessible member field in type T, and.
At run time, the result of the field access expression is computed as follows: (assuming that the program is correct with respect to definite assignment analysis, i.e.
The Primary expression is evaluated, and the result is discarded.
If evaluation of the Primary expression completes abruptly, the field access expression completes abruptly for the same reason.
If the field is a non-blank final field, then the result is the value of the specified class variable in the class or interface that is the type of the Primary expression.
If the field is not final, or is a blank final and the field access occurs in a constructor, then the result is a variable, namely, the specified class variable in the class that is the type of the Primary expression.
If the field is not static: ‚óÜ The Primary expression is evaluated.
If the value of the Primary is null, then a NullPointerException is thrown.
If the field is a non-blank final, then the result is the value of the named member field in type T found in the object referenced by the value of the Primary.
If the field is not final, or is a blank final and the field access occurs in a constructor, then the result is a variable, namely the named member field in type T found in the object referenced by the value of the Primary.
Note that only the type of the Primary expression, not the class of the actual object referred to at run time, is used in determining which field to use.
The last line shows that, indeed, the field that is accessed does not depend on the runtime class of the referenced object; even if s holds a reference to an object of class T, the expression s.x refers to the x field of class S, because the type of the expression s is S.
Objects of class T contain two fields named x, one for class T and one for its superclass S.
This lack of dynamic lookup for field accesses allows programs to be run efficiently with straightforward implementations.
The power of late binding and overriding is available, but only when instance methods are used.
Consider the same example using instance methods to access the fields:
The last line shows that, indeed, the method that is accessed does depend on the runtime class of the referenced object; when s holds a reference to an object of class T, the expression s is S.
Method z of class T overrides method z of class S.
The following program demonstrates that a null reference may be used to access a class (static) variable without causing an exception:
That "Mount " is printed demonstrates that the Primary expression is indeed fully evaluated at run time, despite the fact that only its type, not its value, is used to determine which field to access (because the field mountain is static)
The form super.Identifier refers to the field named Identifier of the current object, but with the current object viewed as an instance of the superclass of the current class.
The form T.super.Identifier refers to the field named Identifier of the lexically enclosing instance corresponding to T, but with that instance viewed as an instance of the superclass of T.
The forms using the keyword super are valid only in an instance method, instance initializer, or constructor, or in the initializer of an instance variable of a class.
These are exactly the same situations in which the keyword this may be used (¬ß15.8.3)
It is a compile-time error if the forms using the keyword super appear in the declaration of class Object, since Object has no superclass.
If a field access expression super.name appears within class C, and the immediate superclass of C is class S, then super.name is treated exactly as if it had been the expression this.name in the body of class S.
Thus it can access the field name that is visible in class S, even if that field is hidden by a declaration of a field name in class C.
If a field access expression T.super.name appears within class C, and the immediate superclass of the class denoted by T is a class whose fully qualified name is S, then T.super.name is treated exactly as if it had been the expression this.name in the body of class S.
Thus it can access the field name that is visible in class S, even if that field is hidden by a declaration of a field name in class T.
It is a compile-time error if the current class is not an inner class of class T or T itself.
Within class T3, the expression super.x is treated as if it were:
Note that super.x is not specified in terms of a cast, due to difficulties around access to protected members of the superclass.
A method invocation expression is used to invoke a class or instance method.
NonWildTypeArguments Identifier ( ArgumentListopt ) The definition of ArgumentList from ¬ß15.9 is repeated here for convenience:
Resolving a method name at compile time is more complicated than resolving a field name because of the possibility of method overloading.
Invoking a method at run time is also more complicated than accessing a field because of the possibility of instance method overriding.
Determining the method that will be invoked by a method invocation expression involves several steps.
The following three sections describe the compile-time processing of a method invocation; the determination of the type of the method invocation expression is described in ¬ß15.12.3
The first step in processing a method invocation at compile time is to figure out the name of the method to be invoked and which class or interface to check for definitions of methods of that name.
There are several cases to consider, depending on the form that precedes the left parenthesis, as follows.
If the form is MethodName, then there are three subcases:
If it is a simple name, that is, just an Identifier, then the name of the method is the Identifier.
It effectively looks for methods in a nested class's superclass hierarchy before looking for methods in an enclosing class and its superclass hierarchy.
There is no class or interface to search, as the method to be invoked is determined later (¬ß15.12.2)
If it is a qualified name of the form TypeName.
Identifier, then the name of the method is the Identifier and the class to search is the one named by the TypeName.
If TypeName is the name of an interface rather than a class, then a compile-time error occurs, because this form can invoke only static methods and interfaces have no static methods.
In all other cases, the qualified name has the form FieldName.
The name of the method is the Identifier and the class or interface to search is the declared type T of the field named by the FieldName, if T is a class or interface type, or the upper bound of T if T is a type variable.
NonWildTypeArgumentsopt Identifier, then the name of the method is the Identifier.
The class or interface to be searched is T if T is a class or interface type, or the upper bound of T if T is a type variable.
It is a compile-time error if T is not a reference type.
NonWildTypeArgumentsopt Identifier, then the name of the method is the Identifier and the class to be searched is the superclass of the class whose declaration contains the method invocation.
Let T be the type declaration immediately enclosing the method invocation.
It is a compile-time error if T is the class Object or T is an interface.
NonWildTypeArgumentsopt Identifier, then the name of the method is the Identifier and the class to be searched is the superclass of the class C denoted by ClassName.
It is a compile-time error if C is not a lexically enclosing class of the current class.
It is a compile-time error if C is the class Object.
Let T be the type declaration immediately enclosing the method invocation.
It is a compile-time error if T is the class Object or T is an interface.
NonWildTypeArguments Identifier, then the name of the method is the Identifier and the class to be searched is the class C denoted by TypeName.
If TypeName is the name of an interface rather than a class, then a compile-time error occurs, because this form can invoke only static methods and interfaces have no static methods.
The second step searches the type determined in the previous step for member methods.
This step uses the name of the method and the types of the argument expressions to locate methods that are both accessible and applicable, that is, declarations that can be correctly invoked on the given arguments.
There may be more than one such method, in which case the most specific one is chosen.
The descriptor (signature plus return type) of the most specific method is one used at run time to perform the method dispatch.
The process of determining applicability begins by determining the potentially applicable methods (¬ß15.12.2.1)
The remainder of the process is split into three phases, to ensure compatibility with versions of the Java programming language prior to Java SE 5.0
If no applicable method is found during this phase then processing continues to the second phase.
This guarantees that any calls that were valid in the Java programming language before Java SE 5.0 are not considered ambiguous as the result of the introduction of variable arity methods, implicit boxing and/or unboxing.
However, the declaration of a variable arity method (¬ß8.4.1) can change the method chosen for a given method method invocation expression, because a variable arity method is treated as a fixed arity method in the first phase.
For example, declaring m(Object...) in a class which already declares m(Object) causes m(Object) to no longer be chosen for some invocation expressions (such as m(null)), as m(Object[]) is more specific.
The second phase (¬ß15.12.2.3) performs overload resolution while allowing boxing and unboxing, but still precludes the use of variable arity method invocation.
If no applicable method is found during this phase then processing continues to the third phase.
This ensures that a method is never chosen through variable arity method invocation if it is applicable through fixed arity method invocation.
The third phase (¬ß15.12.2.4) allows overloading to be combined with variable arity methods, boxing, and unboxing.
Deciding whether a method is applicable will, in the case of generic methods (¬ß8.4.4), require that type arguments be determined.
If they are passed implicitly, they must be inferred (¬ß15.12.2.7) from the types of the argument expressions.
If several applicable methods have been identified during one of the three phases of applicability testing, then the most specific one is chosen, as specified in section ¬ß15.12.2.5
For the method invocation two(1) within class Doubler, there are two accessible methods named two, but only the second one is applicable, and so that is the one invoked at run time.
For the method invocation Doubler.two(3), the class Doubler, not class Test, is searched for methods named two; the only applicable method is not accessible, and so this method invocation causes a compile-time error.
Here, a compile-time error occurs for the second invocation of setColor, because no applicable method can be found at compile time.
The type of the literal 37 is int, and int cannot be converted to byte by method invocation conversion.
Assignment conversion, which is used in the initialization of the variable color, performs an implicit conversion of the constant from type int to byte, which is permitted because the value 37 is small enough to be represented in type byte; but such a conversion is not allowed for method invocation conversion.
If the method setColor had, however, been declared to take an int instead of a byte, then both method invocations would be correct; the first invocation would be allowed because method invocation conversion does permit a widening conversion from byte to int.
However, a narrowing cast would then be required in the body of setColor:
The problem is that there are two declarations of test that are applicable and accessible, and neither is more specific than the other.
Here, the most specific declaration of method test is the one taking a parameter of type ColoredPoint.
Because the result type of the method is int, a compile-time error occurs because an int cannot be converted to a String by assignment conversion.
This example shows that the result types of methods do not participate in resolving overloaded methods,
The most specific method is chosen at compile time; its descriptor determines what method is actually executed at run time.
If a new method is added to a class, then source code that was compiled with the old definition of the class might not use the new method, even if a recompilation would cause this method to be chosen.
So, for example, consider two compilation units, one for class Point:
Copy all relevant fields of the argument into this ColoredPoint object.
The programmer who coded class Test has expected to see the word green, because the actual argument, a ColoredPoint, has a color field, and color would seem to be a "relevant field"
Of course, the documentation for the package points ought to have been much more precise!)
Notice, by the way, that the most specific method (indeed, the only applicable method) for the method invocation of adopt has a signature that indicates a method of one parameter, and the parameter is of type Point.
This signature becomes part of the binary representation of class Test produced by the Java compiler and is used by the method invocation at run time.
Suppose the programmer reported this software error and the maintainer of the points ColoredPoint:
If the programmer then runs the old binary file for Test with the new binary file for ColoredPoint, the output is still:
If the source code for Test is recompiled, the Java compiler will then discover that there are now two applicable adopt methods, and that the signature for the more specific one is "one parameter, whose type is ColoredPoint; void"; running the program will then produce the desired output:
With forethought about such problems, the maintainer of the points package could fix the ColoredPoint class to work with both newly compiled and old code, by adding defensive code to the old adopt method for the sake of old code that still invokes it on ColoredPoint arguments:
Ideally, source code should be recompiled whenever code that it depends on is changed.
However, in an environment where different classes are maintained by different organizations, this is not always feasible.
Defensive programming with careful attention to the problems of class evolution can make upgraded code much more robust.
See ¬ß13 for a detailed discussion of binary compatibility and type evolution.
A member method is potentially applicable to a method invocation if and only if all of the following are true:
The name of the member is identical to the name of the method in the method invocation.
The member is accessible (¬ß6.6) to the class or interface in which the method invocation appears.
Whether a member method is accessible at a method invocation depends on the access modifier (public, none, protected, or private) in the member's declaration and on where the method invocation appears.
If the member is a variable arity method with arity n, the arity of the method invocation is greater or equal to n-1
If the member is a fixed arity method with arity n, the arity of the method invocation is equal to n.
If the method invocation includes explicit type arguments, and the member is a generic method, then the number of type arguments is equal to the number of type parameters of the method.
This clause implies that a non-generic method may be potentially applicable to an invocation that supplies explicit type arguments.
In such a case, the type arguments will simply be ignored.
This rule stems from issues of compatibility and principles of substitutability.
Since interfaces or superclasses may be generified independently of their subtypes, we may override a generic method with a non-generic one.
However, the overriding (nongeneric) method must be applicable to calls to the generic method, including calls that explicitly pass type arguments.
Otherwise the subtype would not be substitutable for its generified supertype.
If the search does not yield at least one method that is potentially applicable, then a compile-time error occurs.
Fn be the types of the formal parameters of m, and let R1 ...
Up be the explicit type arguments given in the method invocation.
Sn be the types of the formal parameters of m.
Otherwise, the most specific method (¬ß15.12.2.5) is chosen among the methods that are applicable by subtyping.
Fn be the types of the formal parameters of m, and let R1 ...
Up be the explicit type arguments given in the method invocation.
Sn be the types of the formal parameters of m.
Otherwise, the most specific method (¬ß15.12.2.5) is chosen among the methods that are applicable by method invocation conversion.
Up be the explicit type arguments given in the method invocation.
If no applicable variable arity method is found, a compile-time error occurs.
Otherwise, the most specific method (¬ß15.12.2.5) is chosen among the applicable variable-arity methods.
If more than one member method is both accessible and applicable to a method invocation, it is necessary to choose one to provide the descriptor for the runEXPRESSIONS Method Invocation Expressions 15.12
The Java programming language uses the rule that the most specific method is chosen.
The informal intuition is that one method is more specific than another if any invocation handled by the first method could be passed on to the other one without a compile-time type error.
The declared types of the parameters of the other method are U1, ..., Un.
If the second method is generic, then let R1 ...
If the second method is a generic method as described above, then Al <:
One variable arity member method named m is more specific than another variable arity member method of the same name if either:
If the second method is generic then let R1 ...
If the second method is generic, then let R1 ...
The above conditions are the only circumstances under which one method may be more specific than another.
A method is said to be maximally specific for a method invocation if it is accessible and applicable and there is no other method that is applicable and accessible that is strictly more specific.
If there is exactly one maximally specific method, then that method is in fact the most specific method; it is necessarily more specific than any other accessible method that is applicable.
It is then subjected to some further compile-time checks as described in ¬ß15.12.3
It is possible that no method is the most specific, because there are two or more methods that are maximally specific.
Otherwise, if all the maximally specific methods are declared abstract, and.
However, the most specific method is considered to throw a checked exception if and only if that exception or its erasure is declared in the throws clauses of each of the maximally specific methods.
Otherwise, we say that the method invocation is ambiguous, and a compile-time error occurs.
The result type of the chosen method is determined as follows: ‚Ä¢ If the chosen method is declared with a return type of void, then the result is void.
Otherwise, if unchecked conversion was necessary for the method to be applicable, then the result type is the erasure (¬ß4.6) of the method's declared return type.
The result type is obtained by applying capture conversion (¬ß5.1.10) to.
Otherwise, the result type is obtained by applying capture conversion (¬ß5.1.10) to the return type of the chosen method.
The exception types of the throws clause of the chosen method are determined as follows:
If unchecked conversion was necessary for the method to be applicable, then the throws clause is composed of the erasure (¬ß4.6) of the types in the method's declared throws clause.
Otherwise, the type of the throws clause is the type given in the method declaration.
The exception types that a method invocation expression can throw are specified in ¬ß11.2.1
In this section, we describe the process of inferring type arguments for method and constructor invocations.
Therefore, it is useful to give an informal overview of the process before delving into the detailed specification.
Generally, the constraints require that the statically known types of the actual arguments are acceptable given the declared formal parameter types.
Given these initial constraints, one may derive a set of supertype and/or equality constraints on the type parameters of the method or constructor.
Next, one must try and find a solution that satisfies the constraints on the type parameters.
As a first approximation, if a type parameter is constrained by an equality constraint, then that constraint gives its solution.
Bear in mind that the constraint may equate one type parameter with another, and only when the entire set of constraints on all type variables is resolved will we have a solution.
A supertype constraint T :> X implies that the solution is one of supertypes of X.
Given several such constraints on T, we can intersect the sets of supertypes implied by each of the constraints, since the type parameter must be a member of all of them.
We can then choose the most specific type that is in the intersection.
Computing the intersection is more complicated than one might first realize.
However, a more sophisticated analysis yields a set containing List<?>
Similarly, if a type parameter T is constrained to be a supertype of two unrelated interfaces I and J, we might infer T must be Object, or we might obtain a tighter bound of I & J.
These issues are discussed in more detail later in this section.
The letter A is only used to denote the type of an actual argument, and F is only used to denote the type of a formal parameter.
Type parameters are represented using the letters S and T ‚Ä¢ Arguments to parameterized types are represented using the letters X and Y.
Generic type declarations are represented using the letters G and H.
In a simpler world, the constraints could be of the form A <: F - simply requiring that the actual argument types be subtypes of the formal ones.
As discussed earlier, method applicability testing consists of up to three phases; this is required for compatibility reasons.
If a method is applicable by subtyping (¬ß15.12.2.2), the constraints are indeed subtyping constraints.
If a method is applicable by method invocation conversion (¬ß15.12.2.3), the constraints imply that the actual type is convertible to the formal type by method invocation conversion.
The situation is similar for the third phase (¬ß15.12.2.4), but the exact form of the constraints differ due to the variable arity.
We need to remember which participant in the relation includes a type to be inferred.
These constraints are then reduced to a set of simpler constraints of the forms T :> achieved by the procedure given below.
It may be that the initial constraints are unsatisfiable; we say that inference is overconstrained.
In that case, we do not necessarily derive unsatisfiable constraints on the type parameters.
Instead, we may infer type arguments for the invocation, but once we substitute the type arguments for the type parameters, the applicability test may fail because the actual argument types are not acceptable given the substituted formal parameter types.
An alternative strategy would be to have type inference itself fail in such cases.
A Java compiler may choose to do so, provided the effect is equivalent to that specified here.
If F does not involve a type parameter Tj then no constraint is implied on Tj.
Otherwise, F involves a type parameter Tj, and there are four cases to consider.
If A is the type of null, no constraint is implied on Tj.
Otherwise, if the constraint has the form A << F:
If A is a primitive type, then A is converted to a reference type U via boxing conversion and this algorithm is applied recursively to the constraint U << F.
This follows from the covariant subtype relation among array types.
Since array subtyping is covariant, it must be the case that V << U.
For simplicity, assume that G takes a single type argument.
If the method invocation being examined is to be applicable, it must be the case that A is a subtype of some invocation of G.
The formulation above merely generalizes this reasoning to generics with an arbitrary number of type arguments.
Again, let's keep things as simple as possible, and consider only the case where G has a single type argument.
As above, it must be the case that A is a subtype of some invocation of G.
The first variation is described (generalized to multiple arguments) by the sub-bullet directly wildcards imply that V << U.
Then this algorithm is applied recursively to the constraint V << U.
The rules of subtyping for wildcards again imply that V << U.
It may be that U will eventually be inferred to be Object, in which case the call may indeed be valid.
Therefore, we simply refrain from placing any constraint on U.
As usual, we consider only the case where G has a single type argument.
As above, it must be the case that A is a subtype of some invocation of G.
The first variation is described (generalized to multiple arguments) by the sub-bullet directly above.
Then this algorithm is applied recursively to the constraint V >> U.
It may be that U will eventually be inferred to the null type, in which case the call may indeed be valid.
Therefore, we simply refrain from placing any constraint on U.
Otherwise, if the constraint has the form A >> F:
We do not make use of such constraints in the main body of the inference algorithm.
This follows from the covariant subtype relation among array types.
Since array subtyping is covariant, it must be the case that V >> U.
In this case (once again restricting the analysis to the unary case), we have the A is not a parameterized type, it cannot depend upon the type argument U in any way.
It is a supertype of G<X> for every X that is a valid type argument to G.
No meaningful constraint on U can be derived from A.
Our goal here is to simplify the relationship between A and F.
We aim to recursively invoke the algorithm on a simpler case, where the type argument is known to be an invocation of the same generic type declaration as the formal.
Let's consider the case where both H and G have only a single type argument.
Since be the case that H is some proper superclass or superinterface of G.
If we replace F by V in the constraint, we will have accomplished the goal of relating two invocations of the same generic (as it happens, H)
We can now invoke the algorithm able to relate the type arguments of both invocations of H and extract the relevant constraints from them.
Once again restricting the analysis to the unary case, we have the constraint A >> F not a parameterized type, it cannot depend upon U in any way.
No meaningful constraint on U can be derived from A.
Our goal here is once more to simplify the relationship between A and F, and recursively invoke the algorithm on a simpler case, where the type argument is known to be an invocation of the same generic type as the formal.
Assume both H and G have only a single type argument.
Since we have the be the case that H is some proper superclass or superinterface of G.
By the subtyping rules for wildcards it must be the case that W >> U.
A must be a supertype of the generic type G.
However, since A is not a parameterized type, it cannot depend upon U in any way.
No meaningful constraint on U can be derived from A.
If A is an invocation of a generic type declaration H, where H is either G or superclass or superinterface of G, then:
This concludes the process of determining constraints on the type parameters of a method.
Note that this process does not impose any constraints on the type parameters based on their declared bounds.
Once type arguments are inferred, they will be tested against the declared bounds of the type parameters as part of applicability testing.
Note also that type inference does not affect soundness in any way.
If the types inferred are nonsensical, the invocation will yield a type error.
The type inference algorithm should be viewed as a heuristic, designed to perform well in practice.
If it fails to infer the desired result, explicit type paramneters may be used instead.
If U is not one of the type parameters of the method, then U is the type inferred.
Then all remaining constraints involving Tj are rewritten such that Tj is replaced with U.
There are necessarily no further equality constraints involving Tj, and processing continues with the next type parameter, if any.
Otherwise, if U is Tj, then this constraint carries no information and may be discarded.
Then, for each remaining type variable Tj, the constraints Tj :> U are considered.
Uk), computed as follows: For a type U, we write ST(U) for the set of supertypes of U, and define the erased supertype set of U:
The reason for computing the set of erased supertypes is to deal with situations where a type variable is constrained to be a supertype of several distinct invocations of a generic type declaration.
The erased candidate set for type parameter Tj, EC, is the intersection of all the sets EST(U) for each U in U1 ...
Because we are seeking to infer more precise types, we wish to filter out any candidates that are supertypes of other candidates.
The next step will be to recover type arguments for the inferred types themselves.
For any element G of MEC that is a generic type declaration, define the relevant invocations of G, Inv(G), to be:
We now will seek to find a type argument for List that contains (¬ß4.5.1) both String and Object.
This is done by means of the least containing invocation (lci) operation defined below.
The next line defines the operation on such lists, as a pairwise reduction on the which in turn relies on the notion of least containing type argument (lcta)
This will be our candidate invocation of G in the bound we infer for Tj.
Finally, we define a bound for Tj based on on all the elements of the minimal erased candidate set of its supertypes.
If any of these elements are generic, we use the.
It is possible that the process above yields an infinite type.
This is permissible, and a Java compiler must recognize such situations and represent them appropriately using cyclic data structures.
If any of the method's type arguments were not inferred from the types of the actual arguments, they are now inferred as follows.
If the method result occurs in a context where it will be subject to assignment.
If S is a reference type, then let S' be S.
Otherwise, if S is a primitive type, then let S' be the result of applying boxing conversion (¬ß5.1.7) to S.
If Ti appears as a type argument in any Uk, then Ti is inferred to be a type variable Any remaining type variable T that has not yet been inferred is then inferred to have type Object.
If a previously inferred type variable P uses T, then P is.
Otherwise, the unresolved type arguments are inferred by invoking the procedure described in this section under the assumption that the method result was assigned to a variable of type Object.
If there is a most specific method declaration for a method invocation, it is called the compile-time declaration for the method invocation.
The reason is that a method invocation of this form cannot be used to invoke an instance method in places where this (¬ß15.8.3) is not defined.
Otherwise, let C be the innermost enclosing class of which the compile-time declaration is a member.
If the invocation is not directly enclosed by C or an inner class of C, then a compile-time error occurs.
If the method invocation has, before the left parenthesis, a MethodName of the form TypeName.
Identifier, or if the method invocation, before the left parenthesis, has the form TypeName.
NonWildTypeArguments Identifier, then the compile-time declaration must be static, or a compile-time error occurs.
The reason is that a method invocation of this form does not specify a reference to an object that can serve as this within the instance method.
If the method invocation has, before the left parenthesis, the form super.
NonWildTypeArgumentsopt Identifier, then: ‚Ä¢ If the compile-time declaration is abstract, a compile-time error occurs.
If the method invocation occurs in a static context, a compile-time error occurs.
If the method invocation has, before the left parenthesis, the form ClassName.
NonWildTypeArgumentsopt Identifier, then: ‚Ä¢ If the compile-time declaration is abstract, a compile-time error occurs.
If the method invocation occurs in a static context, a compile-time error occurs.
If the invocation is not directly enclosed by C or an inner class of C, then a compile-time error occurs.
The reason is that such a method invocation produces no value and so must be used only in a situation where a value is not needed.
A method is signature polymorphic if and only if all of the following conditions hold: ‚Ä¢ It is declared in the java.lang.invoke.MethodHandle class.
In Java SE 7, the only signature polymorphic methods are the invoke and invokeExact methods of the class java.lang.invoke.MethodHandle.
If the compile-time declaration for the method invocation is not a signature polymorphic method, then the types of its parameters are the types of its formal parameters, and the result type is its chosen result type.
Otherwise, if the compile-time declaration for the method invocation is a signature polymorphic method, then:
The types of its parameters are the static types of the actual argument expressions.
An argument expression which is the null literal null (¬ß3.10.7) is treated as having the static type Void.
The result type is determined as follows: ‚óÜ If the method invocation expression is an expression statement, the method.
Otherwise, if the method invocation expression is the operand of a cast.
Otherwise, the return type is the method's declared return type, Object.
The following compile-time information is then associated with the method invocation for use at run time:
The number of parameters and the types of the parameters, in order.
The invocation mode, computed as follows: ‚óÜ If the compile-time declaration has the static modifier, then the invocation.
Otherwise, if the compile-time declaration has the private modifier, then the.
Otherwise, if the part of the method invocation before the left parenthesis is.
Otherwise, if the compile-time declaration is in an interface, then the invocation mode is interface.
If the compile-time declaration for the method invocation is not void, then the type of the method invocation expression is the result type specified in the compile-time declaration.
Third, the accessibility of the method to be invoked is checked.
Fourth, the actual code for the method to be executed is located.
Fifth, a new activation frame is created, synchronization is performed if necessary, and control is transferred to the method code.
If the first production for MethodInvocation, which includes a MethodName,
Otherwise, let T be the enclosing type declaration of which the method is.
Then the target reference is the n'th lexically enclosing instance (¬ß8.1.3) of this.
It is a compile-time error if the n'th lexically enclosing instance (¬ß8.1.3) of this does not exist.
If the MethodName is a qualified name of the form TypeName.
If the MethodName is a qualified name of the form FieldName.
Identifier, then there are two subcases: ‚óÜ If the invocation mode is static, then there is no target reference.
Otherwise, the target reference is the value of the expression FieldName.
If the second production for MethodInvocation, which includes a Primary, is involved, then there are two subcases: ‚Ä¢ If the invocation mode is static, then there is no target reference.
Otherwise, the expression Primary is evaluated and the result is used as the target reference.
In either case, if the evaluation of the Primary expression completes abruptly, then no part of any argument expression appears to have been evaluated, and the method invocation completes abruptly for the same reason.
If the third production for MethodInvocation, which includes the keyword super, is involved, then the target reference is the value of this.
When a target reference is computed and then discarded because the invocation mode is static, the reference is not examined to see whether it is null:
As part of an instance method invocation (¬ß15.12), there is an expression that denotes the object to be invoked.
This expression appears to be fully evaluated before any part of any argument expression to the method invocation is evaluated.
As a result, the startsWith method is invoked for target object "one" with argument "two", so the result of the invocation is false, as the string "one" does not start with "two"
It follows that the test program does not print "oops"
The process of evaluating the argument list differs, depending on whether the method being invoked is a fixed arity method or a variable arity method (¬ß8.4.1)
The preceding paragraphs are crafted to handle the interaction of parameterized types and array types that occurs in a Java Virtual Machine with erased generics.
Namely, if the element type T of the variable array parameter is non-reifiable, e.g.
By erasing the array type of the final expression in the argument list, we are guaranteed to obtain a reifiable element type.
Then, since the array creation expression appears in a method invocation context, an unchecked conversion (¬ß5.1.9) is possible from the array type with reifiable element type to an array type with non-reifiable element type, specifically that of the variable arity parameter.
A Java compiler is required by ¬ß5.1.9 to give a compile-time unchecked warning at this conversion.
Oracle's reference implementation of a Java compiler identifies the unchecked warning here as a more informative unchecked generic array creation.
The argument expressions (possibly rewritten as described above) are now evaluated to yield argument values.
Each argument value corresponds to exactly one of the method's n formal parameters.
The argument expressions, if any, are evaluated in order, from left to right.
If the evaluation of any argument expression completes abruptly, then no part of any.
Evaluation then continues, using the argument values, as described below.
An implementation of the Java programming language must ensure, as part of linkage, that the method m still exists in the type T.
If this is not true, then a NoSuchMethodError (which is a subclass of IncompatibleClassChangeError) occurs.
If the invocation mode is interface, then the implementation must also check that the target reference type still implements the specified interface.
If the target reference type does not still implement the interface, then an IncompatibleClassChangeError occurs.
The implementation must also ensure, during linkage, that the type T and the method m are accessible: ‚Ä¢ For the type T:
If T is in the same package as C, then T is accessible.
If T is in a different package than C, and T is public, then T is accessible.
If T is in a different package than C, and T is protected, then T is accessible.
If m is protected, then m is accessible if and only if either T is in the same.
If m has default (package) access, then m is accessible if and only if T is in the same package as C.
If m is private, then m is accessible if and only if C is T, or C encloses T, or T encloses C, or T and C are both enclosed by a third class.
If either T or m is not accessible, then an IllegalAccessError occurs (¬ß12.3)
The strategy for method lookup depends on the invocation mode.
If the invocation mode is static, no target reference is needed and overriding is not allowed.
Method m of class T is the one to be invoked.
Otherwise, an instance method is to be invoked and there is a target reference.
If the target reference is null, a NullPointerException is thrown at this point.
Otherwise, the target reference is said to refer to a target object and will be used as the value of the keyword this in the invoked method.
The other four possibilities for the invocation mode are then considered.
If the invocation mode is nonvirtual, overriding is not allowed.
Method m of class T is the one to be invoked.
Otherwise, if the invocation mode is virtual, and T and m jointly indicate a signature polymorphic method (¬ß15.12.3), then the target object is an instance of java.lang.invoke.MethodHandle.
The method handle encapsulates a type which is matched against the information associated with the method invocation at compile time (¬ß15.12.3)
If matching succeeds, the target method encapsulated by the method handle is directly and immediately invoked, and the procedure in ¬ß15.12.4.5 is not executed.
Otherwise, the invocation mode is interface, virtual, or super, and overriding may occur.
The dynamic lookup process starts from a class S, determined as follows: ‚Ä¢ If the invocation mode is interface or virtual, then S is initially the actual.
This is true even if the target object is an array instance.
Note that for invocation mode interface, R necessarily implements T; for invocation mode virtual, R is necessarily either T or a subclass of T.)
If the invocation mode is super, then S is initially the qualifying type (¬ß13.1) of the method invocation.
The dynamic method lookup uses the following procedure to search class S, and then the superclasses of class S, as necessary, for method m.
Let X be the compile-time type of the target reference of the method invocation.
If class S contains a declaration for a non-abstract method named m with the same descriptor (same number of parameters, the same parameter types,
If the invocation mode is virtual, and the declaration in S overrides.
If the invocation mode is virtual, and the declaration in S does not override X.m, and moreover X.m is declared abstract, then an AbstractMethodError is thrown.
Otherwise, if S has a superclass, this same lookup procedure is performed recursively using the direct superclass of S in place of S; the method to be invoked is the result of the recursive invocation of this lookup procedure.
The above procedure (if it terminates without error) will find a non-abstract, accessible method to invoke, provided that all classes and interfaces in the program have been consistently compiled.
However, if this is not the case, then various errors may occur.
We note that the dynamic lookup process, while described here explicitly, will often be implemented implicitly, for example as a side-effect of the construction and use of per-class method dispatch tables, or the construction of other per-class structures used for efficient dispatch.
Here, the subclass ColoredPoint extends the clear abstraction defined by its superclass Point.
It does so by overriding the clear method with its own method, which invokes the.
This method is then invoked whenever the target object for an invocation of clear is a ColoredPoint.
Even the method move in Point invokes the clear method of class ColoredPoint when the class of this is ColoredPoint, as shown by the output of this test program:
Overriding is sometimes called "late-bound self-reference"; in this example it means that the reference to clear in the body of Point.move (which is really syntactic shorthand for this.clear) invokes a method chosen "late" (at run time, based on the run-time class of the object referenced by this) rather than a method chosen "early" (at compile time, based only on the type of this)
This provides the programmer a powerful way of extending abstractions and is a key idea in object-oriented programming.
An overridden instance method of a superclass may be accessed by using the keyword super to access the members of the immediate superclass, bypassing any overriding declaration in the class that contains the method invocation.
When accessing an instance variable, super means the same as a cast of this (¬ß15.11.2), but this equivalence does not hold true for method invocation.
A cast does not change the class of an object; it only checks that the class is compatible with the specified type.
A method m in some class S has been identified as the one to be invoked.
Now a new activation frame is created, containing the target reference (if any) and the argument values (if any), as well as enough space for the local variables and.
If there is not sufficient memory available to create such an activation frame, a StackOverflowError is thrown.
The newly created activation frame becomes the current activation frame.
The effect of this is to assign the argument values to corresponding freshly created parameter variables of the method, and to make the target reference available as this, if there is a target reference.
If the erasure (¬ß4.6) of the type of the method being invoked differs in its signature from the erasure of the type of the compile-time declaration for the method invocation (¬ß15.12.3), then if any of the argument values is an object which is not an instance of a subclass or subinterface of the erasure of the corresponding formal parameter type in the compile-time declaration for the method invocation, then a ClassCastException is thrown.
If the method m is a native method but the necessary native, implementationdependent binary code has not been loaded or otherwise cannot be dynamically linked, then an UnsatisfiedLinkError is thrown.
If the method m is not synchronized, control is transferred to the body of the method m to be invoked.
If the method m is synchronized, then an object must be locked before the transfer of control.
No further progress can be made until the current thread can obtain the lock.
If there is a target reference, then the target object must be locked; otherwise the Class object for class S, the class of the method m, must be locked.
Control is then transferred to the body of the method m to be invoked.
The object is automatically unlocked when execution of the body of the method has completed, whether normally or abruptly.
The locking and unlocking behavior is exactly as if the body of the method were embedded in a synchronized statement (¬ß14.19)
String while the latter takes an argument of type Object.
The invocation fails with a ClassCastException before the body of the method is executed.
In the above example, the following bridge method would be created in class D:
This is the method that would actually be invoked by the Java Virtual Machine in response required.
An array access expression refers to a variable that is a component of an array.
An array access expression contains two subexpressions, the array reference expression (before the left bracket) and the index expression (within the brackets)
Note that the array reference expression may be a name or any primary expression that is not an array creation expression (¬ß15.10)
The type of the array reference expression must be an array type (call it T[], an array whose components are of type T), or a compile-time error occurs.
The promoted type must be int, or a compile-time error occurs.
The type of the array access expression is the result of applying capture conversion (¬ß5.1.10) to T.
The result of an array access expression is a variable of type T, namely the variable within the array selected by the value of the index expression.
This resulting variable, which is a component of the array, is never considered final, even if the array reference expression denoted a final variable.
An array access expression is evaluated using the following procedure: ‚Ä¢ First, the array reference expression is evaluated.
If this evaluation completes abruptly, then the array access completes abruptly for the same reason.
Otherwise, if the value of the array reference expression is null, then a NullPointerException is thrown.
Otherwise, the value of the array reference expression indeed refers to an array.
If the value of the index expression is less than zero, or greater than or equal to the array's length, then an ArrayIndexOutOfBoundsException is thrown.
Otherwise, the result of the array access is the variable of type T, within the array, selected by the value of the index expression.
In an array access, the expression to the left of the brackets appears to be fully evaluated before any part of the expression within the brackets is evaluated.
For example, in the original value of a is then subscripted by a value that is element 3 of another array (possibly the same array) that was referenced by b and is now also referenced by a.
If evaluation of the expression to the left of the brackets completes abruptly, no part of the expression within the brackets will appear to have been evaluated.
If the array reference expression produces null instead of a reference to an array, then a NullPointerException is thrown at run time, but only after all parts of the array access expression have been evaluated and only if these evaluations completed normally.
A NullPointerException never occurs, because the index expression must be completely evaluated before any part of the array access occurs, and that includes the check as to whether the value of the array reference expression is null.
Postfix expressions include uses of the postfix ++ and -- operators.
Names are not considered to be primary expressions (¬ß15.8), but are handled separately in the grammar to avoid certain ambiguities.
They become interchangeable only here, at the level of precedence of postfix expressions.
The rules for evaluating expression names are given in ¬ß6.5.6
A postfix expression followed by a ++ operator is a postfix increment expression.
The result of the postfix expression must be a variable of a type that is convertible (¬ß5.1.8) to a numeric type, or a compile-time error occurs.
The type of the postfix increment expression is the type of the variable.
The result of the postfix increment expression is not a variable, but a value.
At run time, if evaluation of the operand expression completes abruptly, then the postfix increment expression completes abruptly for the same reason and no incrementation occurs.
Otherwise, the value 1 is added to the value of the variable and the sum is stored back into the variable.
The value of the postfix increment expression is the value of the variable before the new value is stored.
If necessary, value set conversion is applied to the sum prior to its being stored in the variable.
A variable that is declared final cannot be incremented because when an access of such a final variable is used as an expression, the result is a value, not a variable.
Thus, it cannot be used as the operand of a postfix increment operator.
PostDecrementExpression: PostfixExpression -The result of the postfix expression must be a variable of a type that is convertible (¬ß5.1.8) to a numeric type, or a compile-time error occurs.
The type of the postfix decrement expression is the type of the variable.
The result of the postfix decrement expression is not a variable, but a value.
At run time, if evaluation of the operand expression completes abruptly, then the postfix decrement expression completes abruptly for the same reason and no decrementation occurs.
Otherwise, the value 1 is subtracted from the value of the variable and the difference is stored back into the variable.
The value of the postfix decrement expression is the value of the variable before the new value is stored.
If necessary, value set conversion is applied to the difference prior to its being stored in the variable.
A variable that is declared final cannot be decremented because when an access of such a final variable is used as an expression, the result is a value, not a variable.
Thus, it cannot be used as the operand of a postfix decrement operator.
A unary expression preceded by a ++ operator is a prefix increment expression.
The result of the unary expression must be a variable of a type that is convertible (¬ß5.1.8) to a numeric type, or a compile-time error occurs.
The type of the prefix increment expression is the type of the variable.
The result of the prefix increment expression is not a variable, but a value.
At run time, if evaluation of the operand expression completes abruptly, then the prefix increment expression completes abruptly for the same reason and no incrementation occurs.
Otherwise, the value 1 is added to the value of the variable and the sum is stored back into the variable.
The value of the prefix increment expression is the value of the variable after the new value is stored.
If necessary, value set conversion is applied to the sum prior to its being stored in the variable.
A variable that is declared final cannot be incremented because when an access of such a final variable is used as an expression, the result is a value, not a variable.
Thus, it cannot be used as the operand of a prefix increment operator.
The result of the unary expression must be a variable of a type that is convertible (¬ß5.1.8) to a numeric type, or a compile-time error occurs.
The type of the prefix decrement expression is the type of the variable.
The result of the prefix decrement expression is not a variable, but a value.
At run time, if evaluation of the operand expression completes abruptly, then the prefix decrement expression completes abruptly for the same reason and no decrementation occurs.
Otherwise, the value 1 is subtracted from the value of the variable and the difference is stored back into the variable.
The value of the prefix decrement expression is the value of the variable after the new value is stored.
If necessary, format conversion is applied to the difference prior to its being stored in the variable.
A variable that is declared final cannot be decremented because when an access of such a final variable is used as an expression, the result is a value, not a variable.
Thus, it cannot be used as the operand of a prefix decrement operator.
The type of the unary plus expression is the promoted type of the operand.
At run time, the value of the unary plus expression is the promoted value of the operand.
The type of the unary minus expression is the promoted type of the operand.
Note that unary numeric promotion performs value set conversion (¬ß5.1.13)
Whatever value set the promoted operand value is drawn from, the unary negation operation is carried out and the result is drawn from that same value set.
That result is then subject to further value set conversion.
At run time, the value of the unary minus expression is the arithmetic negation of the promoted value of the operand.
For integer values, negation is the same as subtraction from zero.
The Java programming language uses two's-complement representation for integers, and the range of two's-complement values is not symmetric, so negation of the maximum negative int or long results in that same maximum negative number.
Overflow occurs in this case, but no exception is thrown.
Unary minus merely inverts the sign of a floating-point number.
Special cases of interest: ‚Ä¢ If the operand is NaN, the result is NaN.
If the operand is a zero, the result is the zero of opposite sign.
The type of the unary bitwise complement expression is the promoted type of the operand.
At run time, the value of the unary bitwise complement expression is the bitwise complement of the promoted value of the operand.
The type of the operand expression of the unary ! operator must be boolean or Boolean, or a compile-time error occurs.
The type of the unary logical complement expression is boolean.
At run time, the operand is subject to unboxing conversion (¬ß5.1.8) if necessary.
The value of the unary logical complement expression is true if the (possibly converted) operand value is false, and false if the (possibly converted) operand value is true.
A cast expression converts, at run time, a value of one numeric type to a similar value of another numeric type; or confirms, at compile time, that the type of an expression is boolean; or checks, at run time, that a reference value refers to an object whose class is compatible with a specified reference type.
The parentheses and the type they contain are sometimes called the cast operator.
CastExpression: ( PrimitiveType ) UnaryExpression ( ReferenceType ) UnaryExpressionNotPlusMinus See ¬ß15.15 for a discussion of the distinction between UnaryExpression and UnaryExpressionNotPlusMinus.
The type of a cast expression is the result of applying capture conversion (¬ß5.1.10) to the type whose name appears within the parentheses.
The result of a cast expression is not a variable, but a value, even if the result of the operand expression is a variable.
A cast operator has no effect on the choice of value set (¬ß4.2.3) for a value of type float or type double.
Consequently, a cast to type float within an expression that is not FP-strict (¬ß15.4) does not necessarily cause its value to be converted to an.
It is a compile-time error if the compile-time type of the operand may never be cast to the type specified by the cast operator according to the rules of casting conversion (¬ß5.5)
Some casts can be proven, at compile time, always to be correct at run time.
For example, it is always correct to convert a value of a class type to the type of its superclass; such a cast should require no special action at run time.
Finally, some casts cannot be proven to be either always correct or always incorrect at compile time.
Otherwise, at run time, the operand value is converted (if necessary) by casting conversion to the type specified by the cast operator.
A ClassCastException is thrown if a cast is found at run time to be impermissible.
The multiplicative operators have the same precedence and are syntactically leftassociative (they group left-to-right)
The type of each of the operands of a multiplicative operator must be a type that is convertible (¬ß5.1.8) to a primitive numeric type, or a compile-time error occurs.
The type of a multiplicative expression is the promoted type of its operands.
If the promoted type is int or long, then integer arithmetic is performed.
If the promoted type is float or double, then floating-point arithmetic is performed.
The binary * operator performs multiplication, producing the product of its operands.
Multiplication is a commutative operation if the operand expressions have no side effects.
Integer multiplication is associative when the operands are all of the same type.
If an integer multiplication overflows, then the result is the low-order bits of the mathematical product as represented in some sufficiently large two's-complement format.
As a result, if overflow occurs, then the sign of the result may not be the same as the sign of the mathematical product of the two operand values.
The result of a floating-point multiplication is determined by the rules of IEEE 754 arithmetic:
If the result is not NaN, the sign of the result is positive if both operands have.
Multiplication of an infinity by a zero results in NaN.
Multiplication of an infinity by a finite value results in a signed infinity.
In the remaining cases, where neither an infinity nor NaN is involved, the exact.
If the type of the multiplication expression is float, then the float value set must be chosen.
If the type of the multiplication expression is double, then the double value set must be chosen.
If the multiplication expression is not FP-strict: ‚ùñ If the type of the multiplication expression is float, then either the float.
If the type of the multiplication expression is double, then either the double value set or the double-extended-exponent value set may be chosen, at the whim of the implementation.
Next, a value must be chosen from the chosen value set to represent the product.
If the magnitude of the product is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign.
Otherwise, the product is rounded to the nearest value in the chosen value set using IEEE 754 round-to-nearest mode.
Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a multiplication operator * never throws a run-time exception.
The binary / operator performs division, producing the quotient of its operands.
The left-hand operand is the dividend and the right-hand operand is the divisor.
There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for its type, and the divisor is -1, then integer overflow occurs and the result is equal to the dividend.
Despite the overflow, no exception is thrown in this case.
On the other hand, if the value of the divisor in an integer division is 0, then an ArithmeticException is thrown.
The result of a floating-point division is determined by the rules of IEEE 754 arithmetic:
If the result is not NaN, the sign of the result is positive if both operands have.
Division of an infinity by an infinity results in NaN.
Division of an infinity by a finite value results in a signed infinity.
Division of a finite value by an infinity results in a signed zero.
Division of a zero by a zero results in NaN; division of zero by any other finite value results in a signed zero.
Division of a nonzero finite value by a zero results in a signed infinity.
In the remaining cases, where neither an infinity nor NaN is involved, the exact mathematical quotient is computed.
If the type of the division expression is float, then the float value set must be chosen.
If the type of the division expression is double, then the double value set must be chosen.
If the division expression is not FP-strict: ‚ùñ If the type of the division expression is float, then either the float value.
If the type of the division expression is double, then either the double value set or the double-extended-exponent value set may be chosen, at the whim of the implementation.
Next, a value must be chosen from the chosen value set to represent the quotient.
If the magnitude of the quotient is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign.
Otherwise, the quotient is rounded to the nearest value in the chosen value set using IEEE 754 round-to-nearest mode.
Despite the fact that overflow, underflow, division by zero, or loss of information may occur, evaluation of a floating-point division operator / never throws a runtime exception.
The binary % operator is said to yield the remainder of its operands from an implied division; the left-hand operand is the dividend and the right-hand operand is the divisor.
In C and C++, the remainder operator accepts only integral operands, but in the Java programming language, it also accepts floating-point operands.
It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative, and can be positive only if the dividend is positive.
Moreover, the magnitude of the result is always less than the magnitude of the divisor.
If the value of the divisor for an integer remainder operator is 0, then an ArithmeticException is thrown.
The IEEE 754 remainder operation computes the remainder from a rounding division, not a truncating division, and so its behavior is not analogous to that of the usual integer remainder operator.
Instead, the Java programming language defines % on floating-point operations to behave in a manner analogous to that of the integer remainder operator; this may be compared with the C library function fmod.
The IEEE 754 remainder operation may be computed by the library routine Math.IEEEremainder.
If the result is not NaN, the sign of the result equals the sign of the dividend.
If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.
If the dividend is finite and the divisor is an infinity, the result equals the.
If the dividend is a zero and the divisor is finite, the result equals the dividend.
In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved,
Evaluation of a floating-point remainder operator % never throws a run-time exception, even if the right-hand operand is zero.
The operators + and - are called the additive operators.
The additive operators have the same precedence and are syntactically leftassociative (they group left-to-right)
If the type of either operand of a + operator is String, then the operation is string concatenation.
In every case, the type of each of the operands of the binary - operator must be a type that is convertible (¬ß5.1.8) to a primitive numeric type, or a compile-time error occurs.
If only one operand expression is of type String, then string conversion (¬ß5.1.11) is performed on the other operand to produce a string at run time.
The result of string concatenation is a reference to a String object that is the concatenation of the two operand strings.
The characters of the left-hand operand precede the characters of the right-hand operand in the newly created string.
An implementation may choose to perform conversion and concatenation in one step to avoid creating and then discarding an intermediate String object.
To increase the performance of repeated string concatenation, a Java compiler may use the StringBuffer class or a similar technique to reduce the number of intermediate String objects that are created by evaluation of an expression.
For primitive types, an implementation may also optimize away the creation of a wrapper object by converting directly from a primitive type to a string.
The + operator is syntactically left-associative, no matter whether it is determined by type analysis to represent string concatenation or numeric addition.
In some cases care is required to get the desired result.
Popular values for stuff include "pop" and "beer"; the most popular value for n is 100
Here is the output that results from running the program:
In the code, note the careful conditional generation of the singular "bottle" when appropriate rather than the plural "bottles"; note also how the string concatenation operator was used to break the long constant string:
The binary + operator performs addition when applied to two operands of numeric type, producing the sum of the operands.
The binary - operator performs subtraction, producing the difference of two numeric operands.
The type of an additive expression on numeric operands is the promoted type of its operands.
If this promoted type is int or long, then integer arithmetic is performed.
If this promoted type is float or double, then floating-point arithmetic is performed.
Addition is a commutative operation if the operand expressions have no side effects.
Integer addition is associative when the operands are all of the same type.
If an integer addition overflows, then the result is the low-order bits of the mathematical sum as represented in some sufficiently large two's-complement format.
If overflow occurs, then the sign of the result is not the same as the sign of the mathematical sum of the two operand values.
The sum of two infinities of opposite sign is NaN.
The sum of two infinities of the same sign is the infinity of that sign.
The sum of an infinity and a finite value is equal to the infinite operand.
The sum of two zeros of opposite sign is positive zero.
The sum of two zeros of the same sign is the zero of that sign.
The sum of a zero and a nonzero finite value is equal to the nonzero operand.
The sum of two nonzero finite values of the same magnitude and opposite sign.
In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, and the operands have the same sign or have different magnitudes, the exact mathematical sum is computed.
If the type of the addition expression is float, then the float value set must be chosen.
If the type of the addition expression is double, then the double value set must be chosen.
If the addition expression is not FP-strict: ‚ùñ If the type of the addition expression is float, then either the float value.
If the type of the addition expression is double, then either the double value set or the double-extended-exponent value set may be chosen, at the whim of the implementation.
Next, a value must be chosen from the chosen value set to represent the sum.
If the magnitude of the sum is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign.
Otherwise, the sum is rounded to the nearest value in the chosen value set using IEEE 754 round-to-nearest mode.
The binary - operator performs subtraction when applied to two operands of numeric type, producing the difference of its operands; the left-hand operand is the minuend and the right-hand operand is the subtrahend.
For both integer and floating-point subtraction, it is always the case that a-b produces the same result as a+(-b)
Note that, for integer values, subtraction from zero is the same as negation.
Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a numeric additive operator never throws a run-time exception.
The left-hand operand of a shift operator is the value to be shifted; the right-hand operand specifies the shift distance.
Unary numeric promotion (¬ß5.6.1) is performed on each operand separately.
Binary numeric promotion (¬ß5.6.2) is not performed on the operands.) It is a compile-time error if the type of each of the operands of a shift operator, after unary numeric promotion, is not a primitive integral type.
The type of the shift expression is the promoted type of the left-hand operand.
If the promoted type of the left-hand operand is int, only the five lowest-order bits of the right-hand operand are used as the shift distance.
If the promoted type of the left-hand operand is long, then only the six lowestorder bits of the right-hand operand are used as the shift distance.
At run time, shift operations are performed on the two's-complement integer representation of the value of the left operand.
The value of n << s is n left-shifted s bit positions; this is equivalent (even if overflow occurs) to multiplication by two to the power s.
The value of n >> s is n right-shifted s bit positions with sign-extension.
For non-negative values of n, this is equivalent to truncating integer division, as computed by the integer division operator /, by two to the power s.
The value of n >>> s is n right-shifted s bit positions with zero-extension, where:
If n is positive, then the result is the same as that of n >> s.
The type of each of the operands of a numerical comparison operator must be a type that is convertible (¬ß5.1.8) to a primitive numeric type, or a compile-time error occurs.
If the promoted type of the operands is int or long, then signed integer comparison is performed.
If the promoted type is float or double, then floating-point comparison is performed.
Comparison is carried out accurately on floating-point values, no matter what value sets their representing values were drawn from.
All values other than NaN are ordered, with negative infinity less than all finite.
Note, however, that the methods Math.min and Math.max treat negative zero as being strictly smaller than positive zero.
The value produced by the > operator is true if the value of the left-hand operand is greater than the value of the right-hand operand, and otherwise is false.
The type of the RelationalExpression operand of the instanceof operator must be a reference type or the null type; otherwise, a compile-time error occurs.
It is a compile-time error if the ReferenceType mentioned after the instanceof operator does not denote a reference type that is reifiable (¬ß4.7)
If a cast of the RelationalExpression to the ReferenceType would be rejected as a compile-time error, then the instanceof relational expression likewise produces a compile-time error.
In such a situation, the result of the instanceof expression could never be true.
At run time, the result of the instanceof operator is true if the value of the RelationalExpression is not null and the reference could be cast (¬ß15.16) to the ReferenceType without raising a ClassCastException.
The cast (Point)e is incorrect because no instance of Element or any of its possible subclasses (none are shown here) could possibly be an instance of any subclass of Point.
The instanceof expression is incorrect for exactly the same reason.
If, on the other hand, the class Point were a subclass of Element (an admittedly strange notion in this example):
The cast (Point)e would never raise an exception because it would not be executed if the value of e could not correctly be cast to type Point.
The equality operators are commutative if the operand expressions have no side effects.
The equality operators are analogous to the relational operators except for their truth value.
The equality operators may be used to compare two operands that are convertible (¬ß5.1.8) to numeric type, or two operands of type boolean or Boolean, or two operands that are each of either reference type or the null type.
If the promoted type of the operands is int or long, then an integer equality test is performed.
If the promoted type is float or double, then a floating-point equality test is performed.
Comparison is carried out accurately on floating-point values, no matter what value sets their representing values were drawn from.
Floating-point equality testing is performed in accordance with the rules of the IEEE 754 standard:
The methods Float.isNaN and Double.isNaN may also be used to test whether a value is NaN.
Otherwise, two distinct floating-point values are considered unequal by the equality operators.
In particular, there is one value representing positive infinity and one value representing negative infinity; each compares equal only to itself, and each compares unequal to all other values.
Subject to these considerations for floating-point numbers, the following rules then hold for integer operands or for floating-point operands other than NaN:
If the operands of an equality operator are both of type boolean, or if one operand is of type boolean and the other is of type Boolean, then the operation is boolean equality.
If one of the operands is of type Boolean, it is subjected to unboxing conversion (¬ß5.1.8)
If the operands of an equality operator are both of either reference type or the null type, then the operation is object equality.
It is a compile-time error if it is impossible to convert the type of either operand to the type of the other by a casting conversion (¬ß5.5)
The run-time values of the two operands would necessarily be unequal.
The result is false if the operands are distinct String objects, even if they contain the same sequence of characters (¬ß3.10.5)
The contents of two strings s and t can be tested for equality by the method invocation s.equals(t)
Each of these operators is syntactically left-associative (each groups left-to-right)
Each operator is commutative if the operand expressions have no side effects.
The bitwise and logical operators may be used to compare two operands of numeric type or two operands of type boolean.
The type of the bitwise operator expression is the promoted type of the operands.
For &, the result value is the bitwise AND of the operand values.
For ^, the result value is the bitwise exclusive OR of the operand values.
For |, the result value is the bitwise inclusive OR of the operand values.
In all cases, the operands are subject to unboxing conversion (¬ß5.1.8) as necessary.
For &, the result value is true if both operand values are true; otherwise, the result is false.
For ^, the result value is true if the operand values are different; otherwise, the result is false.
For |, the result value is false if both operand values are false; otherwise, the result is true.
The conditional-and operator is fully associative with respect to both side effects and result value.
Each operand of the conditional-and operator must be of type boolean or Boolean, or a compile-time error occurs.
At run time, the left-hand operand expression is evaluated first; if the result has type Boolean, it is subjected to unboxing conversion (¬ß5.1.8)
If the resulting value is false, the value of the conditional-and expression is false and the right-hand operand expression is not evaluated.
If the value of the left-hand operand is true, then the right-hand expression is evaluated; if the result has type Boolean, it is subjected to unboxing conversion (¬ß5.1.8)
The resulting value becomes the value of the conditional-and expression.
It differs only in that the right-hand operand expression is evaluated conditionally rather than always.
The conditional-or operator is fully associative with respect to both side effects and result value.
Each operand of the conditional-or operator must be of type boolean or Boolean, or a compile-time error occurs.
At run time, the left-hand operand expression is evaluated first; if the result has type Boolean, it is subjected to unboxing conversion (¬ß5.1.8)
If the resulting value is true, the value of the conditional-or expression is true and the right-hand operand expression is not evaluated.
If the value of the left-hand operand is false, then the right-hand expression is evaluated; if the result has type Boolean, it is subjected to unboxing conversion (¬ß5.1.8)
The resulting value becomes the value of the conditional-or expression.
It differs only in that the right-hand operand expression is evaluated conditionally rather than always.
The conditional operator ? : uses the boolean value of one expression to decide which of two other expressions should be evaluated.
The first expression must be of type boolean or Boolean, or a compile-time error occurs.
It is a compile-time error for either the second or the third operand expression to be an invocation of a void method.
In fact, by the grammar of expression statements (¬ß14.8), it is not permitted for a conditional expression to appear in any context where an invocation of a void method could appear.
The type of a conditional expression is determined as follows: ‚Ä¢ If the second and third operands have the same type (which may be the null type),
If one of the second and third operands is of primitive type T, and the type of the.
If one of the second and third operands is of the null type and the type of the other is a reference type, then the type of the conditional expression is that reference type.
If one of the operands is of type T where T is byte, short, or char, and the.
If one of the operands is of type T, where T is Byte, Short, or Character, and the other operand is a constant expression (¬ß15.28) of type int whose value is representable in the type U which is the result of applying unboxing conversion to T, then the type of the conditional expression is U.
Otherwise, binary numeric promotion (¬ß5.6.2) is applied to the operand types, and the type of the conditional expression is the promoted type of the second and third operands.
At run time, the first operand expression of the conditional expression is evaluated first.
The resulting boolean value is then used to choose either the second or the third operand expression: ‚Ä¢ If the value of the first operand is true, then the second operand expression is.
If the value of the first operand is false, then the third operand expression is chosen.
The chosen operand expression is then evaluated and the resulting value is converted to the type of the conditional expression as determined by the rules stated above.
The operand expression not chosen is not evaluated for that particular evaluation of the conditional expression.
There are 12 assignment operators; all are syntactically right-associative (they b and then assigns the value of b to a.
The result of the first operand of an assignment operator must be a variable, or a compile-time error occurs.
The type of the assignment expression is the type of the variable after capture conversion (¬ß5.1.10)
At run time, the result of the assignment expression is the value of the variable after the assignment has occurred.
The result of an assignment expression is not itself a variable.
A variable that is declared final cannot be assigned to (unless it is definitely unassigned (¬ß16)), because when an access of such a final variable is used as an expression, the result is a value, not a variable, and so it cannot be used as the first operand of an assignment operator.
A compile-time error occurs if the type of the right-hand operand cannot be converted to the type of the variable by assignment conversion (¬ß5.2)
At run time, the expression is evaluated in one of three ways.
Then, if the field denoted by e.f is not static and the result of the evaluation of e above is null, then a NullPointerException is thrown.
Otherwise, the variable denoted by e.f is assigned the value of the right hand operand as computed above.
If the left-hand operand is an array access expression (¬ß15.13), possibly enclosed in one or more pairs of parentheses, then:
First, the array reference subexpression of the left-hand operand array access expression is evaluated.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the righthand operand are not evaluated and no assignment occurs.
Otherwise, the index subexpression of the left-hand operand array access expression is evaluated.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
Otherwise, if the value of the array reference subexpression is null, then no assignment occurs and a NullPointerException is thrown.
Otherwise, the value of the array reference subexpression indeed refers to an array.
If the value of the index subexpression is less than zero, or greater.
Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression.
Also, let TC be the type of the lefthand operand of the assignment operator as determined at compile time.
Then there are two possibilities: ‚óÜ If TC is a primitive type, then SC is necessarily the same as TC.
The value of the right-hand operand is converted to the type of the selected array component, is subjected to value set conversion (¬ß5.1.13) to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the array component.
If TC is a reference type, then SC may not be the same as TC, but rather a type that extends or implements TC.
Let RC be the class of the object referred to by the value of the right-hand operand at run time.
A Java compiler may be able to prove at compile time that the array component will be of type TC exactly (for example, TC might be final)
But if a Java compiler cannot prove at compile time that the array component will be of type TC exactly, then a check must be performed at run time to ensure that the class RC is assignment compatible (¬ß5.2) with the actual type SC of the array component.
If class RC is not assignable to type SC, then no assignment occurs and an ArrayStoreException is thrown.
Otherwise, the reference value of the right-hand operand is stored into the selected array component.
Otherwise, three steps are required: ‚Ä¢ First, the left-hand operand is evaluated to produce a variable.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
Otherwise, the value of the right-hand operand is converted to the type of the lefthand variable, is subjected to value set conversion (¬ß5.1.13) to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable.
The most interesting case of the lot is thirteenth from the end:
The code is typecorrect at compile time: the assignment has a left-hand side of type Object[] and a righthand side of type Object.
At run time, the first actual argument to method testFour is a reference to an instance of "array of Thread" and the third actual argument is a reference to an instance of class StringBuffer.
At run time, the expression is evaluated in one of two ways.
If the left-hand operand expression is not an array access expression, then: ‚Ä¢ First, the left-hand operand is evaluated to produce a variable.
Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator.
If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
Otherwise, the result of the binary operation is converted to the type of the lefthand variable, subjected to value set conversion (¬ß5.1.13) to the appropriate.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the righthand operand are not evaluated and no assignment occurs.
Otherwise, the index subexpression of the left-hand operand array access expression is evaluated.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
Otherwise, if the value of the array reference subexpression is null, then no assignment occurs and a NullPointerException is thrown.
Otherwise, the value of the array reference subexpression indeed refers to an array.
If the value of the index subexpression is less than zero, or greater than or equal to the length of the array, then no assignment occurs and an ArrayIndexOutOfBoundsException is thrown.
Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression.
The value of this component is saved and then the right-hand operand is evaluated.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
For a simple assignment operator, the evaluation of the right-hand operand occurs before the checks of the array reference subexpression and the index subexpression, but for a compound assignment operator, the evaluation of the right-hand operand occurs after these checks.
Otherwise, consider the array component selected in the previous step, whose value was saved.
Also, let T be the type of the left-hand operand of the assignment operator as determined at compile time.
If T is a primitive type, then S is necessarily the same as T.
The saved value of the array component and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator.
If this operation completes abruptly (the only possibility is an integer division by zero - see ¬ß15.17.2), then the assignment expression completes abruptly for the same reason and no assignment occurs.
Otherwise, the result of the binary operation is converted to the type of the selected array component, subjected to value set conversion (¬ß5.1.13) to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the array component.
If T is a reference type, then it must be String.
Because class String is a final class, S must also be String.
Therefore the run-time check that is sometimes required for the simple assignment operator is never required for a compound assignment operator.
The saved value of the array component and the value of the right-hand operand are used to perform the binary operation (string concatenation) this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
Otherwise, the String result of the binary operation is stored into the array component.
The most interesting cases of the lot are eleventh and twelfth from the end:
They are the cases where a right-hand side that throws an exception actually gets to throw the exception; moreover, they are the only such cases in the lot.
This identical analysis applies to the case that uses a[0]
Unlike C and C++, the Java programming language has no comma operator.
A compile-time constant expression is an expression denoting a value of primitive type or a String that does not complete abruptly and is composed using only the following:
Compile-time constant expressions of type String are always "interned" so as to share unique instances, using the method String.intern.
A compile-time constant expression is always treated as FP-strict (¬ß15.4), even if it occurs in a context where a non-constant expression would not be considered to be FP-strict.
An access to its value consists of the simple name of the variable (or, for a field, the simple name of the field qualified by this) occurring anywhere in an expression For every access of a local variable or blank final field x, x must be definitely assigned before the access, or a compile-time error occurs.
Similarly, every blank final variable must be assigned at most once; it must be definitely unassigned when an assignment to it occurs.
Such an assignment is defined to occur if and only if either the simple name of the variable (or, for a field, its simple name qualified by this) occurs on the left hand side of an assignment operator.
For every assignment to a blank final variable, the variable must be definitely unassigned before the assignment, or a compile-time error occurs.
The remainder of this chapter is devoted to a precise explanation of the words "definitely assigned before" and "definitely unassigned before"
The idea behind definite assignment is that an assignment to the local variable or blank final field must occur on every possible execution path to the access.
Similarly, the idea behind definite unassignment is that no other assignment to the blank final variable is permitted to occur on any possible execution path to an assignment.
A Java compiler recognizes that k is definitely assigned before its access (as an argument of a method invocation) in the code:
Similarly, a Java compiler will recognize that in the code:
A Java compiler must produce a compile-time error for the code:
A Java compiler must operate according to the rules laid out in this section.
As another example, a Java compiler will accept the code:
Here, when true and when false refer to the value of the expression.
For example, the local variable k is definitely assigned a value after evaluation of the expression:
The phrase "V is definitely assigned after X" (where V is a local variable and X is a statement or expression) means "V is definitely assigned after X if X completes normally"
If X completes abruptly, the assignment need not have occurred, and the rules stated here take this into account.
A peculiar consequence of this definition is that "V is definitely assigned after break;" is always true! Because a break statement never completes normally, it is vacuously true that V has been assigned a value if the break statement completes normally.
The statement "V is definitely unassigned after X" (where V is a variable and X is a statement or expression) means "V is definitely unassigned after X if X completes normally"
An even more peculiar consequence of this definition is that "V is definitely unassigned after break;" is always true! Because a break statement never completes normally, it is vacuously true that V has not been assigned a value if the break statement completes normally.
For that matter, it is also vacuously true that the moon is made of green cheese if the break statement completes normally.)
In all, there are four possibilities for a variable V after a statement or expression has been executed: ‚Ä¢ V is definitely assigned and is not definitely unassigned.
The flow analysis rules prove that an assignment to V has occurred.) ‚Ä¢ V is definitely unassigned and is not definitely assigned.
The flow analysis rules prove that an assignment to V has not occurred.) ‚Ä¢ V is not definitely assigned and is not definitely unassigned.
The rules cannot prove whether or not an assignment to V has occurred.) ‚Ä¢ V is definitely assigned and is definitely unassigned.
It is impossible for the statement or expression to complete normally.) To shorten the rules, the customary abbreviation "iff" is used to mean "if and only if"
Throughout the rest of this chapter, we will, unless explicitly stated otherwise, write V to represent a local variable or a blank final field (for rules of definite assignment) or a blank final variable (for rules of definite unassignment)
Likewise, we will use a, b, c, and e to represent expressions, and S and T to represent statements.
We will use the phrase "a is V" to mean that a is either the simple name of the variable V, or V's simple name qualified by this (ignoring parentheses)
We will use the phrase "a is not V" to mean the negation of "a is V"
The definite unassignment analysis of loop statements raises a special problem.
In order to determine whether V is definitely unassigned within some subexpression of e, we need to determine whether V is definitely unassigned before e.
One might argue, by analogy with the rule for definite assignment (¬ß16.2.10), that V is definitely unassigned before e iff it is definitely unassigned before the while statement.
If e evaluates to true, the statement S will be executed.
Later, if V is assigned by S, then in the following iteration(s) V will have already been assigned when e is evaluated.
Under the rule suggested above, it would be possible to assign V multiple times, which is exactly what we have sought to avoid by introducing these rules.
A revised rule would be: "V is definitely unassigned before e iff it is definitely unassigned before the while statement and definitely unassigned after S"
However, when we formulate the rule for S, we find: "V is definitely unassigned before S iff it is definitely unassigned after e when true"
In effect, V is definitely unassigned before the loop condition e only if it is unassigned after the loop as a whole!
We break this vicious circle using a hypothetical analysis of the loop condition and body.
For example, if we assume that V is definitely unassigned before e (regardless of whether V.
Assuming V is definitely unassigned before e, V is definitely unassigned after e.
Variations on the above analysis are used to define well founded definite unassignment rules for all loop statements in the Java programming language.
Because a constant expression whose value is true never has the value false, and a constant expression whose value is false never has the value true, the first two rules are vacuously satisfied.
Suppose that b and c are expressions that are not boolean-valued.
Note that if a is V and V is not definitely assigned before a compound assignment such as a stated above includes the disjunct "a is V" even for compound assignment expressions, not just simple assignments, so that V will be considered to have been definitely assigned at.
Including the disjunct "a is V" does not affect the binary decision as to whether a program is acceptable or will result in a compile-time error, but it affects how many different points in the code may be regarded as erroneous, and so in practice it can improve the quality of error reporting.
A similar remark applies to the inclusion of the conjunct "a is not V" in the first rule for definite unassignment stated above.
This case applies to literals, names, this (both qualified and unqualified), unqualified class instance creation expressions with no arguments, initialized array creation expressions whose initializers contain no expressions, unqualified superclass field access expressions, named method invocations with no arguments, and unqualified superclass method invocations with no arguments.
There is a piece of subtle reasoning behind the assertion that a variable V can be known to be definitely unassigned after a method invocation.
Taken by itself, at face value and without qualification, such an assertion is not always true, because an invoked method can perform assignments.
But it must be remembered that, for the purposes of the Java programming language, the concept of definite unassignment is applied only to blank final variables.
If V is a blank final local variable, then only the method to which its declaration belongs can perform assignments to V.
If V is a blank final field, then only a constructor or an initializer for the class containing the declaration for V can perform assignments to V; no method can perform assignments to V.
For any immediate subexpression y of an expression x, V is [un]assigned before y iff one of the following situations is true:
A blank final member field V is definitely assigned (and moreover is not definitely unassigned) before the block (¬ß14.2) that is the body of any method in.
A local variable V is definitely unassigned (and moreover is not definitely assigned) before the block that is the body of the constructor, method, instance initializer or static initializer that declares V.
Let C be a class declared within the scope of V.
Then V is definitely assigned before the block that is the body of any constructor, method, instance initializer, or static initializer declared in C iff V is definitely assigned before the declaration of C.
Note that there are no rules that would allow us to conclude that V is definitely unassigned before the block that is the body of any constructor, method, instance initializer, or static initializer declared in C.
We can informally conclude that V is not definitely unassigned before the block that is the body of any constructor, method, instance initializer, or static initializer declared in C, but there is no need for such a rule to be stated explicitly.
We say that V is definitely unassigned everywhere in a block B iff: ‚Ä¢ V is definitely unassigned before B.
The assignment occurs in dead code, and V is vacuously definitely assigned.
In this case, the assignment will not actually take place, and we can assume that V is not being assigned by the assignment expression.
In this case the current assignment will cause a compile-time error.
So, we can conclude that if the conditions are met by a program that causes no compile time error, then any assignments to V in B will not actually take place at run time.
Either there is a default label in the switch block or V is [un]assigned after the switch expression.
Either the switch block contains no block-statement-groups or V is [un]assigned after the last block-statement of the last block-statement-group.
If a switch block contains at least one block-statement-group, then the following rules also apply:
Assuming V is definitely unassigned before e, V is definitely unassigned after S.
Assuming V is definitely unassigned before e, V is definitely unassigned before.
Assuming V is definitely unassigned before S, V is definitely unassigned after e when true.
Since the enhanced for (¬ß14.14.2) statement is defined by translation to a basic for statement, no special rules need to be provided for it.
Either a condition expression is not present or V is [un]assigned after the condition expression when false.
Assuming V is definitely unassigned before the condition part of the for statement, V is definitely unassigned after the contained statement.
Assuming V is definitely unassigned before the contained statement, V is definitely unassigned before every continue statement for which the for statement is the continue target.
No condition expression is present and V is [un]assigned after the initialization.
Otherwise, if the initialization part is empty, then V is [un]assigned after the.
Because a break, continue, return, or throw statement never completes normally, it vacuously satisfies this notion.
If a try statement does have a finally block, then these rules also apply: ‚Ä¢ V is definitely assigned after the try statement iff at least one of the following.
An exception parameter V of a catch clause (¬ß14.20) is definitely assigned (and moreover is not definitely unassigned) before the body of the catch clause.
The definite assignment/unassignment status of any construct within the class body of an enum constant is governed by the usual rules for classes.
It should be clear that if an anonymous class is implicitly defined by an enum constant, the rules of ¬ß16.5 apply.
Let C be a class, and let V be a blank final member field of C.
Then: ‚Ä¢ V is definitely assigned (and moreover, not definitely unassigned) before the.
Let C be a class declared within the scope of V.
Then: ‚Ä¢ V is definitely assigned before a member type declaration of C iff V is definitely.
Let C be a class declared within the scope of V.
Note that there are no rules that would allow us to conclude that V is definitely unassigned before a static variable initializer or enum constant.
We can informally conclude that V is not definitely unassigned before any static variable initializer of C, but there is no need for such a rule to be stated explicitly.
Let C be a class, and let V be a blank static final member field of C, declared in C.
Let C be a class, and let V be a blank static final member field of C, declared in a superclass of C.
Let C be a class declared within the scope of V.
Note that there are no rules that would allow us to conclude that V is definitely unassigned before an instance variable initializer.
We can informally conclude that V is not definitely unassigned before any instance variable initializer of C, but there is no need for such a rule to be stated explicitly.
Let C be a class, and let V be a blank final non-static member field of C, declared in C.
If C has no instance initializers or instance variable initializers, then V is not.
Let C be a class, and let V be a blank final member field of C, declared in a superclass of C.
These threads independently execute code that operates on values and objects residing in a shared main memory.
Threads may be supported by having many hardware processors, by time-slicing a single hardware processor, or by timeslicing many hardware processors.
The only way for a user to create a thread is to create an object of this class; each thread is associated with such corresponding Thread object.
The behavior of threads, particularly when not correctly synchronized, can be confusing and counterintuitive.
This chapter describes the semantics of multithreaded programs; it includes rules for which values may be seen by a read of shared memory that is updated by multiple threads.
As the specification is similar to the memory models for different hardware architectures, these semantics are known as the Java programming language memory model.
When no confusion can arise, we will simply refer to these rules as "the memory model"
These semantics do not prescribe how a multithreaded program should be executed.
Rather, they describe the behaviors that multithreaded programs are allowed to exhibit.
Any execution strategy that generates only allowed behaviors is an acceptable execution strategy.
The Java programming language provides multiple mechanisms for communicating between threads.
The most basic of these methods is synchronization, which is implemented using monitors.
Each object in Java is associated with a monitor, which a thread can lock or unlock.
Only one thread at a time may hold a lock on a monitor.
Any other threads attempting to lock that monitor are blocked until they can obtain a lock on that monitor.
A thread t may lock a particular monitor multiple times; each unlock reverses the effect of one lock operation.
The synchronized statement (¬ß14.19) computes a reference to an object; it then attempts to perform a lock action on that object's monitor and does not proceed further until the lock action has successfully completed.
After the lock action has been performed, the body of the synchronized statement is executed.
If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.
A synchronized method (¬ß8.4.3.6) automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed.
If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method)
If the method is static, it locks the monitor associated with the Class object that represents the class in which the method is defined.
If execution of the method's body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.
The Java programming language neither prevents nor requires detection of deadlock conditions.
Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary.
Other mechanisms, such as reads and writes of volatile variables and the use of classes in the java.util.concurrent package, provide alternative ways of synchronization.
Every object, in addition to having an associated monitor, has an associated wait set.
When an object is first created, its wait set is empty.
Elementary actions that add threads to and remove threads from wait sets are atomic.
Wait sets are manipulated solely through the methods Object.wait, Object.notify, and Object.notifyAll.
Wait set manipulations can also be affected by the interruption status of a thread, and by the Thread class's methods dealing with interruption.
Additionally, the Thread class's methods for sleeping and joining other threads have properties derived from those of wait and notification actions.
A call of wait(long millisecs) with a parameter of zero, or a call of wait(long millisecs, int nanosecs) with two zero parameters, is equivalent to an invocation.
A thread returns normally from a wait if it returns without throwing an InterruptedException.
Let thread t be the thread executing the wait method on object m, and let n be the number of lock actions by t on m that have not been matched by unlock actions.
If n is zero (i.e., thread t does not already possess the lock for target m), then an IllegalMonitorStateException is thrown.
If this is a timed wait and the nanosecs argument is not in the range of 0-999999 or the millisecs argument is negative, then an IllegalArgumentException is thrown.
If thread t is interrupted, then an InterruptedException is thrown and t's interruption status is set to false.
Thread t is added to the wait set of object m, and performs n unlock actions on m.
Thread t does not execute any further instructions until it has been removed from m's wait set.
The thread may be removed from the wait set due to any one of the following actions, and will resume sometime afterward:
A notify action being performed on m in which t is selected for removal from the wait set.
If this is a timed wait, an internal action removing t from m's wait set that.
Implementations are permitted, although not encouraged, to perform "spurious wake-ups", that is, to remove threads from wait sets and thus enable resumption without explicit instructions to do so.
Notice that this provision necessitates the Java coding practice of using wait only within loops that terminate only when some logical condition that the thread is waiting for holds.
Each thread must determine an order over the events that could cause it to be removed from a wait set.
That order does not have to be consistent with other orderings, but the thread must behave as though those events occurred in that order.
For example, if a thread t is in the wait set for m, and then both an interrupt of t and a notification of m occur, there must be an order over these events.
If the interrupt is deemed to have occurred first, then t will eventually return from wait by throwing InterruptedException, and some other thread in the wait set for m (if any exist at the time of the notification) must receive the notification.
If the notification is deemed to have occurred first, then t will eventually return normally from wait with an interrupt still pending.
If thread t was removed from m's wait set in step 2 due to an interrupt,
Notification actions occur upon invocation of methods notify and notifyAll.
Let thread t be the thread executing either of these methods on object m, and let n be the number of lock actions by t on m that have not been matched by unlock actions.
This is the case where thread t does not already possess the lock for target m.
If n is greater than zero and this is a notify action, then if m's wait set is not.
There is no guarantee about which thread in the wait set is selected.
This removal from the wait set enables u's resumption in a wait action.
Notice, however, that u's lock actions upon resumption cannot succeed until some time after t fully unlocks the monitor for m.
If n is greater than zero and this is a notifyAll action, then all threads are removed from m's wait set, and thus resume.
Notice, however, that only one of them at a time will lock the monitor required during the resumption of wait.
Interruption actions occur upon invocation of Thread.interrupt, as well as methods defined to invoke it in turn, such as ThreadGroup.interrupt.
Let t be the thread invoking u.interrupt, for some thread u, where t and u may be the same.
This action causes u's interruption status to be set to true.
Additionally, if there exists some object m whose wait set contains u, then u is removed from m's wait set.
This enables u to resume in a wait action, in which case this wait will, after re-locking m's monitor, throw InterruptedException.
The static method Thread.interrupted may be invoked by a thread to observe and clear its own interruption status.
The above specifications allow us to determine several properties having to do with the interaction of waits, notification, and interruption.
If a thread is both notified and interrupted while waiting, it may either: ‚Ä¢ return normally from wait, while still having a pending interrupt (in other words,
The thread may not reset its interrupt status and return normally from the call to wait.
Assume that a set s of threads is in the wait set of an object m, and another thread performs a notify on m.
Thread.sleep causes the currently executing thread to sleep (temporarily cease execution) for the specified duration, subject to the precision and accuracy of system timers and schedulers.
The thread does not lose ownership of any monitors, and resumption of execution will depend on scheduling and the availability of processors on which to execute the thread.
It is important to note that neither Thread.sleep nor Thread.yield have any synchronization semantics.
In particular, the compiler does not have to flush writes cached in registers out to shared memory before a call to Thread.sleep or Thread.yield, nor does the compiler have to reload values cached in registers after a call to Thread.sleep or Thread.yield.
For example, in the following (broken) code fragment, assume that this.done is a nonvolatile boolean field:
The compiler is free to read the field this.done just once, and reuse the cached value in each execution of the loop.
This would mean that the loop would never terminate, even if another thread changed the value of this.done.
A memory model describes, given a program and an execution trace of that program, whether the execution trace is a legal execution of the program.
The Java programming language memory model works by examining each read in an execution trace and checking that the write observed by that read is valid according to certain rules.
An implementation is free to produce any code it likes, as long as all resulting executions of a program produce a result that can be predicted by the memory model.
This provides a great deal of freedom for the implementor to perform a myriad of code transformations, including the reordering of actions and removal of unnecessary synchronization.
The semantics of the Java programming language allow compilers and microprocessors to perform optimizations that can interact with incorrectly synchronized code in ways that can produce behaviors that seem paradoxical.
Here are some examples of how incorrectly synchronized programs may exhibit surprising behaviors.
Consider, for example, the example program traces shown in Table 17.1
However, compilers are allowed to reorder the instructions in either thread, when this does not affect the execution of that thread in isolation.
Surprising results caused by statement reordering - valid compiler transformation.
However, it should be noted that this code is improperly synchronized:
This situation is an example of a data race (¬ß17.4.5)
When code contains a data race, counterintuitive results are often possible.
A Just-In-Time compiler in a Java Virtual Machine implementation may rearrange code, or the processor.
In addition, the memory hierarchy of the architecture on which a Java Virtual Machine implementation is run may make it appear as if code is being reordered.
In this chapter, we shall refer to anything that can reorder code as a compiler.
The memory model determines what values can be read at every point in the program.
The actions of each thread in isolation must behave as governed by the semantics of that thread, with the exception that the values seen by each read are determined by the memory model.
When we refer to this, we say that the program obeys intra-thread semantics.
Intra-thread semantics are the semantics for singlethreaded programs, and allow the complete prediction of the behavior of a thread based on the values seen by read actions within the thread.
To determine if the actions of thread t in an execution are legal, we simply evaluate the implementation of thread t as it would be performed in a single-threaded context, as defined in the rest of this specification.
Each time the evaluation of thread t generates an inter-thread action, it must match the inter-thread action a of t that comes next in program order.
If a is a read, then further evaluation of t uses the value seen by a as determined by the memory model.
This section provides the specification of the Java programming language memory model except for issues dealing with final fields, which are described in ¬ß17.5
The memory model specified herein is not fundamentally based in the object-oriented nature of the Java programming language.
For conciseness and simplicity in our examples, we often exhibit code fragments without class or method definitions, or explicit dereferencing.
Most examples consist of two or more threads containing statements with access to local variables, shared global variables, or instance fields of an object.
Memory that can be shared between threads is called shared memory or heap memory.
All instance fields, static fields, and array elements are stored in heap memory.
In this chapter, we use the term variable to refer to both fields and array elements.
Two accesses to (reads of or writes to) the same variable are said to be conflicting if at least one of the accesses is a write.
An inter-thread action is an action performed by one thread that can be detected or directly influenced by another thread.
There are several kinds of inter-thread action that a program may perform:
Actions that start a thread or detect that a thread has terminated (¬ß17.4.4)
An external action is an action that may be observable outside of an execution, and has a result based on an environment external to the execution.
A thread divergence action is only performed by a thread that is in an infinite loop in which no memory, synchronization, or external actions are performed.
If a thread performs a thread divergence action, it will be followed by an infinite number of thread divergence actions.
Thread divergence actions are introduced to model how a thread may cause all other threads to stall and fail to make progress.
We do not need to concern ourselves with intra-thread actions (e.g., adding two local variables and storing the result in a third local variable)
As previously mentioned, all threads need to obey the correct intra-thread semantics for Java programs.
We will usually refere to inter-thread actions more succinctly as simply actions.
For lock actions, v is the monitor being locked; for unlock actions, v is the monitor being unlocked.
If the action is a (volatile or non-volatile) read, v is the variable being read.
If the action is a (volatile or non-volatile) write, v is the variable being written.
This may be information as to the success or failure of the action, and any values read by the action.
Parameters to the external action (e.g., which bytes are written to which socket) are not part of the external action tuple.
These parameters are set up by other actions within the thread and can be determined by examining the intra-thread semantics.
Among all the inter-thread actions performed by each thread t, the program order of t is a total order that reflects the order in which these actions would be performed according to the intra-thread semantics of t.
A set of actions is sequentially consistent if all actions occur in a total order (the execution order) that is consistent with program order, and furthermore, each read r of a variable v sees the value written by the write w to v such that: ‚Ä¢ w comes before r in the execution order, and ‚Ä¢ there is no other write w' such that w comes before w' and w' comes before r in.
Sequential consistency is a very strong guarantee that is made about visibility and ordering in an execution of a program.
Within a sequentially consistent execution, there is a total order over all individual actions (such as reads and writes) which is consistent with the order of the program, and each individual action is atomic and is immediately visible to every thread.
If a program has no data races, then all executions of the program will appear to be sequentially consistent.
Sequential consistency and/or freedom from data races still allows errors arising from groups of operations that need to be perceived atomically and are not.
If we were to use sequential consistency as our memory model, many of the compiler and processor optimizations that we have discussed would be illegal.
A synchronization order is a total order over all of the synchronization actions of an execution.
Synchronization actions induce the synchronized-with relation on actions, defined as follows:
An unlock action on monitor m synchronizes-with all subsequent lock actions on m (where "subsequent" is defined according to the synchronization order)
A write to a volatile variable v (¬ß8.3.1.4) synchronizes-with all subsequent reads of v by any thread (where "subsequent" is defined according to the synchronization order)
An action that starts a thread synchronizes-with the first action in the thread it starts.
The write of the default value (zero, false, or null) to each variable synchronizes-with the first action in every thread.
Although it may seem a little strange to write a default value to a variable before the object containing the variable is allocated, conceptually every object is created at the start of the program with its default initialized values.
The source of a synchronizes-with edge is called a release, and the destination is called an acquire.
If one action happens-before another, then the first is visible to and ordered before the second.
If we have two actions x and y, we write hb(x, y) to indicate that x happens-before y.
If x and y are actions of the same thread and x comes before y in program order,
There is a happens-before edge from the end of a constructor of an object to the.
If an action x synchronizes-with a following action y, then we also have hb(x, y)
The wait methods of class Object (¬ß17.2.1) have lock and unlock actions associated with them; their happens-before relationships are defined by these associated actions.
It should be noted that the presence of a happens-before relationship between two actions does not necessarily imply that they have to take place in that order in an implementation.
If the reordering produces results consistent with a legal execution, it is not illegal.
For example, the write of a default value to every field of an object constructed by a thread need not happen before the beginning of that thread, as long as no read ever observes that fact.
More specifically, if two actions share a happens-before relationship, they do not necessarily have to appear to have happened in that order to any code with which they do not share a happens-before relationship.
Writes in one thread that are in a data race with reads in another thread may, for example, appear to occur out of order to those reads.
A set of synchronization edges, S, is sufficient if it is the minimal set such that the transitive closure of S with the program order determines all of the happens-before edges in the execution.
It follows from the above definitions that: ‚Ä¢ An unlock on a monitor happens-before every subsequent lock on that monitor.
A write to a volatile field (¬ß8.3.1.4) happens-before every subsequent read of.
All actions in a thread happen-before any other thread successfully returns from.
The default initialization of any object happens-before any other actions (other.
When a program contains two conflicting accesses (¬ß17.4.1) that are not ordered by a happens-before relationship, it is said to contain a data race.
Therefore, a data race cannot cause incorrect behavior such as returning the wrong length for an array.
A program is correctly synchronized if and only if all sequentially consistent executions are free of data races.
If a program is correctly synchronized, then all executions of the program will appear to be sequentially consistent (¬ß17.4.3)
Programmers do not need to reason about reorderings to determine that their code contains data races.
Therefore they do not need to reason about reorderings when determining whether their code is correctly synchronized.
Once the determination that the code is correctly synchronized is made, the programmer does not need to worry that reorderings will affect his or her code.
A program must be correctly synchronized to avoid the kinds of counterintuitive behaviors that can be observed when code is reordered.
The use of correct synchronization does not ensure that the overall behavior of a program is correct.
However, its use does allow a programmer to reason about the possible behaviors of a program in a simple way; the behavior of a correctly synchronized program is much less dependent on possible reorderings.
Without correct synchronization, very strange, confusing and counterintuitive behaviors are possible.
We say that a read r of a variable v is allowed to observe a write w to v if, in the happens-before partial order of the execution trace: ‚Ä¢ r is not ordered before w (i.e., it is not the case that hb(r, w)), and ‚Ä¢ there is no intervening write w' to v (i.e.
Informally, a read r is allowed to see the result of a write w if there is no happensbefore ordering to prevent that read.
A set of actions A is happens-before consistent if for all reads r in A, where W(r) is the write action seen by r, it is not the case that either hb(r, W(r)) or that there In a happens-before consistent set of actions, each read sees a write that it is allowed to see by the happens-before ordering.
Since there is no synchronization, each read can see either the write of the initial value or the write by the other thread.
In this execution, the reads see writes that occur later in the execution order.
This may seem counterintuitive, but is allowed by happens-before consistency.
Allowing reads to see later writes can sometimes produce unacceptable behaviors.
An execution is happens-before consistent if its set of actions is happens-before consistent (¬ß17.4.5)
Each read sees a write to the same variable in the execution.
All reads and writes of volatile variables are volatile actions.
For all reads r only if r is a volatile read, and the variable w.v is volatile if and only if w is a volatile write.
The happens-before order is given by the transitive closure of synchronizeswith edges and program order.
It must be a valid partial order: reflexive, transitive and antisymmetric.
For each thread t, the actions performed by t in A are the same as would be generated by that thread in program-order in isolation, with each write w writing the value V(w), given that each read r sees the value V(W(r))
Values seen by each read are determined by the memory model.
The program order given must reflect the program order in which the actions would be performed according to the intra-thread semantics of P.
For all volatile reads r in A, it is not the case that either so(r, W(r)) or that there.
We use f|d to denote the function given by restricting the domain of f to d.
We use p|d to represent the restriction of the partial order p to the elements in d.
For all x,y in d, p(x,y) if and only if p|d(x,y)
If either x or y are not in d, then it is not the case that p|d(x,y)
If all of the actions in A can be committed, then the execution satisfies the causality requirements of the Java programming language memory model.
To demonstrate that this is reasonable, for each Ci we need to demonstrate an execution E containing Ci that meets certain conditions.
All actions in Ci must share the same relative happensbefore order and synchronization order in both Ei and E.
Formally: The values written by the writes in Ci must be the same in both Ei and E.
Only the reads in Ci-1 need to see the same writes in Ei as in E.
Formally: All reads in Ei that are not in Ci-1 must see writes that happen-before them.
If sswi(x, y) and hbi(y, z) and z in Ci, then swj(x, y) for all j ‚â• i.
If an action y is committed, all external actions that happen-before y are also committed.
If y is in Ci, x is an external action and hbi(x, y), then x in Ci.
Happens-before consistency is a necessary, but not sufficient, set of constraints.
Merely enforcing happens-before consistency would allow for unacceptable behaviors - those that violate the requirements we have established for programs.
For example, happens-before consistency allows values to appear "out of thin air"
This can be seen by a detailed examination of the trace in Table 17.6
This may seem surprising, since it does not perform any synchronization actions.
Remember, however, that a program is correctly synchronized if, when it is executed in a sequentially consistent manner, there are no data races.
If this code is executed in a sequentially consistent way, each action will occur in program order, and neither of the writes will occur.
Since no writes occur, there can be no data races: the program is correctly synchronized.
Since this program is correctly synchronized, the only behaviors we can allow are sequentially consistent behaviors.
However, there is an execution of this program that is happens-before consistent, but not sequentially consistent:
This result is happens-before consistent: there is no happens-before relationship that prevents it from occurring.
However, it is clearly not acceptable: there is no sequentially consistent execution that would result in this behavior.
The fact that we allow a read to see a write that comes later in the execution order can sometimes thus result in unacceptable behaviors.
Although allowing reads to see writes that come later in the execution order is sometimes undesirable, it is also sometimes necessary.
As we saw above, the trace in Table 17.5 requires some reads to see writes that occur later in the execution order.
Since the reads come first in each thread, the very first action in the execution order must be a read.
If that read cannot see a write that occurs later, then it cannot see any value other than the initial value for the variable it reads.
We refer to the issue of when reads can see future writes as causality, because of issues that arise in cases like the one found in Table 17.6
In that case, the reads cause the writes to occur, and the writes cause the reads to occur.
Our memory model therefore needs a consistent way of determining which reads can see writes early.
Examples such as the one found in Table 17.6 demonstrate that the specification must be careful when stating whether a read can see a write that occurs later in the execution (bearing in mind that if a read sees a write that occurs later in the execution, it represents the fact that the write is actually performed early)
The memory model takes as input a given execution, and a program, and determines whether that execution is a legal execution of the program.
It does this by gradually building a set of "committed" actions that reflect which actions were executed by the program.
Usually, the next action to be committed will reflect the next action that can be performed by a sequentially consistent execution.
However, to reflect reads that need to see later writes, we allow some actions to be committed earlier than other actions that happen-before them.
Obviously, some actions may be committed early and some may not.
If, for example, one of the writes in Table 17.6 were committed before the read of that variable, the read could see the write, and the "out-of-thin-air" result could occur.
Informally, we allow an action to be committed early if we know that the action can occur without assuming some data race occurs.
In Table 17.6, we cannot perform either write early, because the writes cannot occur unless the reads see the result of a data race.
For programs that always terminate in some bounded finite period of time, their behavior can be understood (informally) simply in terms of their allowable executions.
For programs that can fail to terminate in a bounded amount of time, more subtle issues arise.
The observable behavior of a program is defined by the finite sets of external actions that the program may perform.
A program that, for example, simply prints "Hello" forever is described by a set of behaviors that for any non-negative integer i, includes the behavior of printing "Hello" i times.
Termination is not explicitly modeled as a behavior, but a program can easily be extended to generate an additional external action executionTermination that occurs when all threads have terminated.
If behavior is described by a set of external actions including a hang action, it indicates a behavior where after the external actions are observed, the program can run for an unbounded amount of time without performing any additional external actions or terminating.
Programs can hang if all threads are blocked or if the program can perform an unbounded number of actions without performing any external actions.
A thread can be blocked in a variety of circumstances, such as when it is attempting to acquire a lock or perform an external action (such as a read) that depends on external data.
An execution may result in a thread being blocked indefinitely and the execution's not terminating.
In such cases, the actions generated by the blocked thread must consist of all actions generated by that thread up to and including the action that caused the thread to be blocked, and no actions that would be generated by the thread after that action.
To reason about observable behaviors, we need to talk about sets of observable actions.
If O is a set of observable actions for an execution E, then set O must be a subset of E's actions, A, and must contain only a finite number of actions, even if A contains an infinite number of actions.
Furthermore, if an action y is in O, and either hb(x, y) or so(x, y), then x is in O.
Note that a set of observable actions are not restricted to external actions.
Rather, only external actions that are in a set of observable actions are deemed to be observable external actions.
A behavior B is an allowable behavior of a program P if and only if B is a finite set of external actions and either: ‚Ä¢ There exists an execution E of P, and a set O of observable actions for E, and B.
Note that a behavior B does not describe the order in which the external actions in B are observed, but other (internal) constraints on how the external actions are generated and performed may impose such constraints.
Fields declared final are initialized once, but never changed under normal circumstances.
The detailed semantics of final fields are somewhat different from those of normal fields.
In particular, compilers have a great deal of freedom to move reads of final fields across synchronization barriers and calls to arbitrary or unknown methods.
Correspondingly, compilers are allowed to keep the value of a final field cached in a register and not reload it from memory in situations where a non-final field would have to be reloaded.
A thread-safe immutable object is seen as immutable by all threads, even if a data race is used to pass references to the immutable object between threads.
This can provide safety guarantees against misuse of an immutable class by incorrect or malicious code.
An object is considered to be completely initialized when its constructor finishes.
A thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object's final fields.
The usage model for final fields is a simple one: Set the final fields for an object in that object's constructor; and do not write a reference to the object being constructed in a place where another thread can see it before the object's constructor is finished.
If this is followed, then when the object is seen by another thread, that thread will always see the correctly constructed version of that object's final fields.
It will also see versions of any object or array referenced by those final fields that are at least as up-to-date as the final fields are.
The program below illustrates how final fields compare to normal fields.
The class FinalFieldExample has a final int field x and a non-final int field y.
One thread might execute the method writer and another might execute the method reader.
Because the writer method writes f after the object's constructor finishes, the reader method will be guaranteed to see the properly initialized value for f.x: it will read the value 3
However, f.y is not final; the reader method is therefore not guaranteed to see the value 4 for it.
One thread (which we shall refer to as thread 1) executes:
String objects are intended to be immutable and string operations do not perform synchronization.
While the String implementation does not have any data races, other code could have data races involving the use of String objects, and the memory model makes weak guarantees for programs that have data races.
A later operation on the String object might see the correct offset of 4, so that the String object is perceived as being "/usr"
Many security features of the Java programming language depend upon String objects being perceived as truly immutable, even if malicious code is using data races to pass String references between threads.
Let o be an object, and c be a constructor for o in which a final field f is written.
A freeze action on final field f of o takes place when c exits, either normally or abruptly.
Note that if one constructor invokes another constructor, and the invoked constructor sets a final field, the freeze for the final field takes place at the end of the invoked constructor.
For each execution, the behavior of reads is influenced by two additional partial considered to be part of the execution (and thus, fixed for any particular execution)
These partial orders must satisfy the following constraints (which need not have a unique solution): ‚Ä¢ Dereference Chain: If an action a is a read or write of a field or element of an.
Memory Chain: There are several constraints on the memory chain ordering: ‚óÜ If r is a read that sees a write w, then it must be the case that mc(w, r)
If r and a are actions such that dereferences(r, a), then it must be the case that.
If w is a write of the address of an object o by a thread t that did not initialize.
For reads of final fields, the only writes that are deemed to come before the read of the final field are the ones derived through the final field semantics.
A read of a final field of an object within the thread that constructs that object is ordered with respect to the initialization of that field within the constructor by the.
If the read occurs after the field is set in the constructor, it sees the value the final field is assigned, otherwise it sees the default value.
In some cases, such as deserialization, the system will need to change the final fields of an object after construction.
The only pattern in which this has reasonable semantics is one in which an object is constructed and then the final fields of the object are updated.
The object should not be made visible to other threads, nor should the final fields be read, until all updates to the final fields of the object are complete.
Freezes of a final field occur both at the end of the constructor in which the final field is set, and immediately after each modification of a final field via reflection or other special mechanism.
If a final field is initialized to a compile-time constant expression (¬ß15.28) in the field declaration, changes to the final field may not be observed, since uses of that final field are replaced at compile time with the value of the constant expression.
Another problem is that the specification allows aggressive optimization of final fields.
Within a thread, it is permissible to reorder reads of a final field with those modifications of a final field that do not take place in the constructor.
In the d method, the compiler is allowed to reorder the reads of x and the call to g freely.
An implementation may provide a way to execute a block of code in a final-fieldsafe context.
If an object is constructed within a final-field-safe context, the reads of a final field of that object will not be reordered with modifications of that final field that occur within that final-field-safe context.
If a thread has seen an incorrectly published reference to an object that allows the thread to see the default value of a final field, and then, within a final-field-safe context, reads a properly published reference to the object, it will be guaranteed to see the correct value of the final field.
In the formalism, code executed within a final-field-safe context is treated as a separate thread (for the purposes of final field semantics only)
In an implementation, a compiler should not move an access to a final field into or out of a final-field-safe context (although it can be moved around the execution of such a context, so long as the object is not constructed within that context)
One place where use of a final-field-safe context would be appropriate is in an executor or thread pool.
By executing each Runnable in a separate final-field-safe context, the executor could guarantee that incorrect access by one Runnable to a object o will not remove final field guarantees for other Runnables handled by the same executor.
Normally, a field that is final and static may not be modified.
However, System.in, System.out, and System.err are static final fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut, and System.setErr.
We refer to these fields as being writeprotected to distinguish them from ordinary final fields.
The compiler needs to treat these fields differently from other final fields.
For example, a read of an ordinary final field is "immune" to synchronization: the barrier involved in a lock or volatile read does not have to affect what value is read from a final field.
Since the value of write-protected fields may be seen to change, synchronization events should have an effect on them.
Therefore, the semantics dictate that these fields be treated as normal fields that cannot be changed by user code, unless that user code is in the System class.
One consideration for implementations of the Java Virtual Machine is that every field and array element is considered distinct; updates to one field or element must not interact with reads or updates of any other field or element.
In particular, two threads that update adjacent elements of a byte array separately must not interfere or interact and do not need synchronization to ensure sequential consistency.
Some processors do not provide the ability to write to a single byte.
It would be illegal to implement byte array updates on such a processor by simply reading an entire word, updating the appropriate byte, and then writing the entire word back to memory.
This problem is sometimes known as word tearing, and on processors that cannot easily update a single byte in isolation some other approach will be required.
The following program is a test case to detect word tearing:
This makes the point that bytes must not be overwritten by writes to adjacent bytes.
Writes and reads of volatile long and double values are always atomic.
For efficiency's sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts.
Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible.
Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.
The grammar presented piecemeal in the preceding chapters (¬ß2.3) is much better for exposition, but it is not well suited as a basis for a parser.
The grammar presented in this chapter is the basis for the reference implementation.
Note that it is not an LL(1) grammar, though in many cases it minimizes the necessary look ahead.
Modifier: Annotation protected static abstract final native synchronized transient volatile strictfp.
Oracle hereby grants you a fully-paid, non-exclusive, non-transferable, worldwide, limited license (without the right to sublicense), under Oracle's applicable intellectual property rights to view, download, use and reproduce the Specification only for the purpose of internal evaluation.
This includes (i) developing applications intended to run on an implementation of the Specification, provided that such applications do not themselves implement any portion(s) of the Specification, and (ii) discussing the Specification with any third party; and (iii) excerpting brief portions of the Specification in oral or written communications which discuss the Specification provided that such excerpts do not in the aggregate constitute a significant portion of the Specification.
Oracle also grants you a perpetual, non-exclusive, non-transferable, worldwide, fully paid-up, royalty free, limited license (without the right to sublicense) under any applicable copyrights or, subject to the provisions of subsection 4 below, patent rights it may have covering the Specification to create and/or distribute an Independent Implementation of the Specification that: (a) fully implements the Specification including all its required interfaces and functionality; (b) does not modify, subset, superset or otherwise extend the Licensor Name Space, or include any public or protected packages, classes, Java interfaces, fields or methods within the Licensor Name Space other than those required/authorized by the Specification or Specifications being implemented; and (c) passes the Technology Compatibility Kit (including satisfying the requirements of the applicable TCK Users Guide) for such Specification ("Compliant Implementation")
In addition, the foregoing license is expressly conditioned on your not acting outside its scope.
Also, no right, title, or interest in or to any trademarks, service marks, or trade names of Oracle or Oracle's licensors is granted hereunder.
Java, and Java-related logos, marks and names are trademarks or registered trademarks of Oracle in the U.S.
You need not include limitations (a)-(c) from the previous paragraph or any other particular "pass through" requirements in any license You grant concerning the use of your Independent Implementation or products derived from it.
However, except with respect to Independent Implementations (and products derived from them) that satisfy limitations (a)-(c) from the previous paragraph, You may neither: (a) grant or otherwise pass through to your licensees any licenses under Oracle's applicable intellectual property rights; nor (b) authorize your licensees to make any claims concerning their implementation's compliance with the Specification in question.
With respect to any patent claims covered by the license granted under subparagraph 2 above that would be infringed by all technically feasible implementations of the Specification, such license is conditioned upon your offering on fair, reasonable and non-discriminatory terms, to any party seeking it from You, a perpetual, non-exclusive, non-transferable, worldwide license under Your patent rights which are or would be infringed by all technically feasible implementations of the Specification to develop, distribute and use a Compliant Implementation.
With respect to any patent claims owned by Oracle and covered by the license granted under subparagraph 2, whether or not their infringement can be avoided in a technically feasible manner when implementing the Specification, such license shall terminate with respect to such claims if You initiate a claim against Oracle that it has, in the course of performing its responsibilities as the Specification Lead, induced any other entity to infringe Your patent rights.
Also with respect to any patent claims owned by Oracle and covered by the license granted under subparagraph 2 above, where the infringement of such claims can be avoided in a technically feasible manner when implementing the Specification such license, with respect to such claims, shall terminate if You initiate a claim against Oracle that its making, having made, using, offering to sell, selling or importing a Compliant Implementation infringes Your patent rights.
For the purposes of this Agreement: "Independent Implementation" shall mean an implementation of the Specification that neither derives from any.
This Agreement will terminate immediately without notice from Oracle if you breach the Agreement or act outside the scope of the licenses granted above.
This document does not represent any commitment to release or implement any portion of the Specification in any product.
In addition, the Specification could include technical inaccuracies or typographical errors.
You will indemnify, hold harmless, and defend Oracle and its licensors from any claims arising or resulting from: (i) your use of the Specification; (ii) the use or distribution of your Java application, applet and/or implementation; and/or (iii)
Government: If this Specification is being acquired by or on behalf of the U.S.
Government prime contractor or subcontractor (at any tier), then the Government's rights in the Software and accompanying documentation shall be only as set forth in this license; this is in accordance with 48 C.F.R.
If you provide Oracle with any comments or suggestions concerning the Specification ("Feedback"), you hereby: (i) agree that such Feedback is provided on a non-proprietary and non-confidential basis, and (ii) grant Oracle a perpetual, non-exclusive, worldwide, fully paid-up, irrevocable license, with the right to sublicense through multiple levels of sublicensees, to incorporate, disclose, and use without limitation the Feedback for any purpose.
Any action related to this Agreement will be governed by California law and controlling U.S.
Convention for the International Sale of Goods and the choice of law rules of any jurisdiction will not apply.
Licensee agrees to comply strictly with all such laws and regulations and acknowledges that it has the responsibility to obtain such licenses to export, re-export or import as may be required after delivery to Licensee.
This Agreement is the parties' entire agreement relating to its subject matter.
It supersedes all prior or contemporaneous oral or written communications, proposals, conditions, representations and warranties and prevails over any conflicting or additional terms of any quote, order, acknowledgment, or other communication between the parties relating to its subject matter during the term of this Agreement.
No modification to this Agreement will be binding, unless in writing and signed by an authorized representative of each party.
