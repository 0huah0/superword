For your convenience Apress has placed some of the front matter material after the index.
Denying the impact of the Spring Framework in the Java world would be simply impossible.
Spring has brought so many advantages to the Java developer that I could say it has made better developers of all of us.
Spring’s core building blocks of Dependency Injection and Aspect Oriented Programming are widely applicable to many business and infrastructure concerns, and certainly application security can benefit from these core functionalities.
So this is Spring Security: an application-level security framework built on top of the powerful Spring Framework that deals mainly with the core security concepts of authentication and authorization.
Spring Security aims to be a full-featured security solution for your Java applications.
Although its main focus is on Web applications and the Java programming language, you will see that it goes beyond these two domains.
What I wanted to do in writing this book was to expose some of the internal works of Spring Security along with the standard explanations of how to use certain features.
My idea is to teach beyond the basics of how to do something in particular, and instead focus on the plumbing inside the framework.
For me, this is the best way of learning something: actually seeing how it is built in the core.
That’s not to say, of course, that the book doesn’t cover basic setups and give quick, practical advice on using the framework, because it certainly does.
With that said, I suggest that the best way to use this book is to have the Spring Security source code checked out on your computer and go through the examples with both the code from the book and the code from Spring Security itself.
This will not only help you understand each concept as it is introduced, but will also teach more than one good programming trick and good practice.
I recommend this approach to studying any software whenever you have the chance.
Sometimes a couple lines of code teach more than a thousand words.
Who This Book Is For This book is written mainly for Java developers who use Spring in their work and need to add security to their applications in a way that leverages Spring’s proven concepts and techniques.
The book will also be helpful to developers who want to add Web-layer security to their applications, even if those applications are not fully Spring powered at their core.
The book assumes you have knowledge of Java and some of its tools and libraries, such as Servlets and Maven.
It also assumes that you know what you want to use security for and in what context you want to use it.
This means, for example, I won’t explain protocols like LDAP in much depth; instead, I’ll concentrate on showing you how to integrate Spring Security with an LDAP user store.
An in-depth knowledge of Spring is not essential because many of the concepts are introduced as we go along, but the more you understand about Spring, the more you are likely to get out of this book.
How This Book Is Structured The book is divided into nine chapters that embody a progressive study of Spring Security.
Starting from a summary of basic applications and an explanation of how the framework is structured, the content moves on to more advanced topics, such as using Spring Security in different JVM languages.
The book follows a sequence that corresponds to the way this framework is normally used in real life.
Chapter 1:u�  Introduces security in general and how to approach security problems at the application level.
Chapter 2:u�  Introduces Spring Security with a simple example application that secures Web access at the URL level.
Chapter 3:u�  Provides a full introduction to the architecture of Spring Security.
The chapter covers its main components and how they interact with each other.
Chapter 4:u�  Gives in-depth coverage of the web-layer security options available in Spring Security.
Chapter 6:u�  Covers a wide array of authentication providers, including LDAP and JASS, that can be plugged into Spring Security.
Chapter 7:u�  Covers access control lists (ACL) that are used to secure individual domain objects and how they fit into the general security concerns.
Chapter 8:u�  Explains how to extend the core Spring Security functionality by making use of the many extension points supported by its modular architecture.
Chapter 9:u�  Shows how to integrate Spring Security with different Java frameworks and some.
Spring Security 3.1.3 was the version used throughout the book.
Jetty Web Server was used for the different web applications in the book, mainly through its Maven plugin.
You are free to use your own tools and operating system.
Because everything is Java based, you should be able to compile your programs on any platform without problems.
Downloading the code The code for the examples shown in this book is available on the Apress web site, www.apress.com.
A link can be found on the book’s information page under the Source Code/Downloads tab.
This tab is located underneath the Related Titles section of the page.
Contacting the Author You are more than welcome to send me any feedback regarding this book or any other subject I might help you with.
You can contact me via my blog at http://cscarioni.blogspot.com, or you can send me an email at carlo.scarioni@gmail.com.
It means so many different things in so many different contexts, but in the end, it is all about protecting sensitive and valuable resources against malicious usage.
In IT, we have many layers of infrastructure and code that can be subject to malicious attacks, and arguably we should ensure that all these layers get the appropriate levels of protection.
Of course, the growth of the Internet and the pursuit of reaching more people with our applications have opened more and more doors to cyber criminals trying to access these applications in illegitimate ways.
It is also true that proper care is not always taken to ensure that a properly secured set of services is being offered to the public.
And sometimes, even when good care is taken, some hackers are still smart enough to overcome security barriers that, superficially, appear adequate.
The three major security layers in an IT infrastructure are the network, the operating system, and the application itself.
The Network Security Layer This layer is probably the most familiar one in the IT world.
When people talk about IT security, they normally think of network-level security—in particular, security that uses firewalls.
Even though people often associate security with the network level, this is only a very limited layer of protection against attackers.
Generally speaking, it can do no more than defend IP addresses and filter network packets addressed to certain ports in certain machines in the network.
This is clearly not enough in the vast majority of cases, as traffic at this level is normally allowed to enter the these open services, as attackers can execute arbitrary commands that could compromise your security constraints.
There exist tools like the popular nmap(http://nmap.org/) that can be used to scan a machine to find open ports.
The use of tools like this is an easy first step to take in preparing an attack, because well-known attacks can be used against such open ports if they are not properly secured.
A very important part of the network-layer security, in the case of web applications, is the use of Secure Sockets Layer (SSL) to encode all sensitive information sent along the wire, but this is related more to the network protocol at the application level than to the network physical level at which firewalls operate.
The Operating System Layer This layer is probably the most important in the whole security schema, as a properly secured operating system (OS) environment could at least prevent a whole host machine from going down if a particular application is compromised.
If an attacker is somehow allowed to have unsecured access to the operating system, he can basically do whatever he wants—from spreading viruses to stealing passwords or deleting your whole server’s data and making it unusable.
Even worse perhaps, he could take control of your computer without you even noticing, and use it.
We can include in this layer the deployment model of the applications, as you need to know your operating system’s permission scheme to ensure that you don’t give your applications unnecessary privileges over your machine.
Applications should run as isolated as possible from the other components of the host machine.
The Application Layer The main focus of this book will be on this layer.
The application security layer refers to all the constraints we establish in our applications to make sure that only the right people can do only the right things when working through the application.
Applications, by default, are open to countless avenues of attack.
An improperly secured application can allow an attacker to steal information from the application, impersonate other users, execute restricted operations, corrupt data, gain access to operating system level, and perform many other malicious acts.
In this book, we will cover application-level security, which is the domain of Spring Security.
Application-level security is achieved by implementing several techniques, and there are a few concepts that will help you understand better what the rest of the book will cover.
These are the main concerns that Spring Security addresses to provide your applications with comprehensive protection against threats.
Authentication The process of authentication allows an application to validate that a particular user is who she claims she is.
In the authentication process, a user presents the application with information about herself (normally, a username and a password) that no one else knows.
If the information input by the user matches a record in the authentication server, the user is said to have successfully authenticated herself in the system.
The application will normally create an internal abstraction representing this authenticated user in the system.
Authorization When a user is authenticated, that only means that the user is known to the system and has been recognized by it.
It doesn’t mean that the user is free to do whatever she wants in said system.
The next logical step in securing an application is to determine which actions that user is allowed to perform, and which resources she has access to, and make sure that if the user doesn’t have the proper permissions she cannot carry out that particular action.
In the most common case, the authorization process compares the user’s set of permissions against the permissions required to execute a particular action in the application, and if a match is found, access is granted.
On the other hand, if no match is found, access is denied.
ACLs Access control lists (ACLs) are part of the authorization process explained in the previous section.
The key difference is that ACLs normally work at a finer grained level in the application.
ACLs are simply a collection of mappings between resources, users, and permissions.
Figure 1-2 shows how ACLs work, as they are just a special case of the general authorization process.
Authentication and Authorization: General Concepts In this section, I shall introduce and explain some fundamental security concepts that you will be coming across frequently in the rest of the book:
User abstractions are created in the system and given their own identity.
These are the users that will later be allowed to use the system.
Normally, in the shape of passwords (certificates are also a common way of presenting credentials), they are data that only the owner of it knows.
This logical grouping is normally done so the grouped users share a set of permissions in the application to access certain resources.
For example, all users with the role “admin” will have the same access and permissions to the same resources.
Roles serve simply as a way to group permissions to execute determined actions, making users with those Roles inherit such permissions.
For example, two users may be allowed to read a particular document, but only one of them is allowed to write to it.
Permissions can apply either to individual users or to users that share a particular role.
The idea is that you never store the plain text version of a password, but instead store an encrypted version so that nobody but the owner of such a password knows the original one.
This output number cannot be converted back into the original string.
This is why the technique is referred to as one-way encryption.
Here is the way to use it: A requesting client encrypts a string and sends the encrypted string to the server.
The server may have access to the original information from a previous registration process, for example, and if it does, it could apply the same hash function to it.
Then it compares the output from this hashing to the value sent by the client.
It could simply store the hashed version and then compare it with the incoming hash from the client.
A string of text is converted into an encrypted form and then can be converted back to the original string.
In this scheme, a sender and a receiver share the same keys so that they can encrypt and decrypt messages on both ends of the communication.
One problem with this scheme is how to share the key between the endpoints of the communication.
A common approach is to use a parallel secure channel to send the keys.
In this scheme, a different key is used for encryption than for decryption.
These two keys are referred as the public key, which is used to encrypt messages, and the private key, which is used to decrypt messages.
The advantage of this approach over symmetric encryption is that there is no need to share the decryption key, so no one but the intended receiver of the information is able to decrypt the message.
The intended recipient of messages shares its public key with everyone interested in u� sending information to it.
The senders encrypt the information with the receiver’s public key, and send the u� message.
The use of encryption achieves, among other things, two other security goals:
Encryption algorithms are the main helper in achieving this goal.
This is normally accomplished through the use of one-way cryptographic algorithms that make it almost impossible to alter an input and produce a corrupted message whose encrypted hash is the same as the original message (thus deceiving the receiver into thinking it is valid)
What to Secure Not every part of the application requires a strong security model, or even any security at all.
If, for example, one part of your application is supposed to serve static content to everyone interested in it, you can simply serve this content.
Anyway, when starting to work on a new application, you should think about the security constraints that your application will have.
You should think about concerns like those in the following list and whether or not they apply to your particular use case:
Usually, your application will do different things for different users, so you need a way to associate users with certain functionality.
You also need to be sure to protect each user’s identity information so that it can’t be compromised.
This applies both to the communication layer and to individual message transmission, as well as to credentials datastores.
Encryption will be used in different layers to achieve the most secure application possible.
More Security Concerns There are many more security concerns than the ones explained so far.
Because this is a Spring Security book and not a general application-security book, we will cover only things related to Spring Security.
Following is a quick overview of some of the most common ones.
This is only intended to make you aware of their existence, and I recommend you consult a different source (such as a general software security textbook) to gain a better understanding of all these concerns:
If data is not validated, an attacker could potentially write any kind of string as input (including SQL or server-side code) and send that information to the server.
If the server code is not properly written, the attacker could wreak significant havoc, as she could execute any arbitrary code on the server.
This is normally done by saturating the server with requests so that it utilizes all the server’s resources and makes it unresponsive to legitimate requests.
The idea is that the attacker can make an application return malicious code inside the web pages returned, and thus execute it in the user’s browser.
This way, the attacker invisibly executes actions using the real user’s authenticated session.
They cover areas ranging from a low-level permission system, through cryptography APIs, to an authentication and authorization scheme.
The list of security APIs offered in Java is very extensive, as the following list of the main ones shows:
It provides a pluggable system where authentication mechanisms can be plugged in independently to applications.
So it overlaps mainly with the JAAS Java API, although they can be used together, as you will see later in the book.
Most of the other APIs are leveraged in Spring Security.
For example, CertPath is used in X509AuthenticationFilter and JCE is used in the spring-security-crypto module.
Summary In this chapter, I introduced security from a general point of view.
I explained in a very abstract way the main concerns in IT security and especially from an application point of view.
I also described, very briefly, the main Java APIs that support security at different levels.
You can see that this chapter was a very quick overview of security concerns.
It is beyond the scope of this book to go any further than this on general topics, although we will study some of them in more depth when they apply to Spring Security.
Obviously this is nothing like a comprehensive software security guide, and if you are interested in learning more about software security in general you should consult the specialized literature.
In this chapter, you will learn what Spring Security is and how you can use it to address security concerns about your application.
We’ll start with a Servlet-based web application without any security, and then we’ll add security to it in a declarative, nonintrusive way.
Also in this chapter, we’ll take a look at the framework’s source code, how to build it, and the different modules that together form the powerful Spring Security project.
What Is Spring Security? Spring Security is a framework dedicated to providing a full array of security services to Java applications in a developer-friendly and flexible way.
It adheres to the well-established practices introduced by the Spring Framework.
Spring Security tries to address all the layers of security inside your application.
In addition, it comes packed with an extensive array of configuration options that make it very flexible and powerful.
Recall from the introduction in Chapter 1 that it can be said that Spring Security is simply a comprehensive authentication/authorization framework built on top of the Spring Framework.
Although the majority of applications that use the framework are web based, Spring Security’s core can also be used in standalone applications.
Many things make Spring Security immediately attractive to Java developers.
To name just a few, I compiled the following list:
It is built around good practices and two simple yet powerful concepts: dependency injection (DI) and Aspect-Oriented Programming (AOP)
Also important is that a lot of developers have experience with Spring, so they can leverage that experience when introducing Spring Security in their projects.
All this support means that Spring Security adapts to your security needs—and not only that, it can change if your needs change, without much effort involved for the developer.
This is important from a business point of view as well because the application can either adapt to the corporate authentication services or implement its own, thus requiring only straightforward configuration changes.
This also means that there is a lot less software for you to write, because you are making use of a great amount of ready-to-use code that has been written and tested by a large and.
You can, to a certain point, trust that this code works and use it with confidence.
And if it does not work, you can always fix it and send a patch to those in charge of maintaining the project.
You can pick and combine these features to achieve your security goals.
Imagine, for instance, that you offer services exposed through RMI, the Web, JMS, and others.
You could secure all of these interfaces, but maybe it’s better to secure just the business layer so that all requests are secured when they reach this layer.
Also, maybe you don’t care about securing individual business objects, so you can omit that module and use just the functionality you need.
It also has a large community and user base dedicated to testing and improving the framework.
Having the opportunity to work with open source software is an attractive feature for most developers.
I know that the ability to look into the source code of the tools you like and work with is an exciting prospect.
Whether our goal is to improve the tools or simply to understand how they work internally, we developers love to read code and learn from it.
But like anything else, it is not a tool that adapts to everything you want to do.
Where and why would you use Spring Security? Here is a list of reasons and scenarios:
So if you plan to work in a non-JVM language, Spring Security won’t be of any use to you.
You have a list of users and a list of resources and operations on those resources.
You group the users in roles and allow certain roles to access certain operations on certain resources.
When this is the case, the first thing to do is allow only the users that you want to have access to your application, while forbidding the all others from even reaching it.
Sometimes you might not be exactly sure what provider your business will require to authenticate against.
In this case, Spring Security makes your life easy by allowing you to switch between different providers in a painless way.
As such, it is better if it can be treated as a separate and modular add-on that you can declare, configure, and manage independently of your main business concerns.
By using Servlet Filters, XML configuration, and AOP concepts, the framework tries not to pollute your application with security rules.
Even when using annotations, they are still metadata on top of your code.
You configure users, roles, and providers in just one place, and both the service and web layers make use of this centralized security configuration in a transparent way.
Spring supports out-of-the-box, remember-me functionality so that a user can be automatically logged in on subsequent visits to your site, allowing them full or partial access to their profile’s functionality.
The server can also request a valid certificate from the client for establishing mutual authentication.
It is normally not enough for guaranteeing security, but it is very important from a usability point of view because it allows the application to show or hide content depending on the user that is currently logged in to the system.
Spring Security 3.1 uses the Spring Expression Language (SpEL) to allow you to customize access rules for your application.
For example, you can expose your application through REST endpoints that other applications can access with HTTP security.
If you are currently using Spring, you probably like it a lot.
Spring Security and Spring As I said before, Spring Security is part of the SpringSource portfolio of open source projects.
There are many more projects from SpringSource, and they are driven by a large and dynamic community of users.
All these projects are built on top of the facilities provided by the Spring Framework itself, which is the original project that started it all.
You can think of Spring as the hub of all these satellite projects, providing them with a consistent programming model and a set of established practices.
The main points you will see throughout the different projects is the use of DI, XML namespace-based configuration, and AOP, which as you will see in the next section, are the pillars upon which Spring is built on.
In the later versions of Spring, annotations have become the most popular way to configure both DI and AOP concerns.
So Spring Security is just one more of these projects, and it is dedicated exclusively to addressing security concerns in your application.
If you read the online documentation, you will find out that Spring Security started originally as a non-Spring project.
It was originally known as The Acegi Security System for Spring, and it was not the big and powerful framework it is today.
Originally, it dealt only with authorization and leveraged container-provided authentication.
So the project, for many years now, has been under the SpringSource umbrella of projects, powered by The Spring Framework itself.
It makes sense to give an overview of it at this point, because many of the Spring Security characteristics I will cover in the rest of the book rely on the building blocks of Spring.
I love Spring and have loved it for many years now.
I think Spring has so many advantages and so many great things that I can’t start a new Java project without using it.
Additionally, I tend to carry its concepts around when working with other languages and look for a way to apply them because they now feel so natural to me.
There are many things that attract me to Spring, but the main ones are the two major building blocks of the framework: dependency injection (DI) and Aspect-Oriented Programming (AOP)
Why are these two concepts so important? Both of them are important because they allow you to develop loosely coupled, single-responsibility, DRY (Don’t Repeat Yourself) code practically by default.
These two concepts, and Spring itself, are covered extensively in other books and online tutorials; however, I’ll give you a brief overview here.
Dependency Injection The basic idea of DI, a type of Inversion of Control (IoC), is simply that instead of having an object instantiate its needed dependencies, the dependencies are somehow given to the object.
In a polymorphic way, the objects that are given as dependencies to the target object that depends on them are known to this target  object just by an abstraction (like an interface in Java) and not by the exact implementation of the dependency.
It’s easier to look at this in code than explain it.
In this example, every instance of NonDiObject is responsible for instantiating its own Helper in the constructor.
You can see that it instantiates a HelperImpl, creating a tight, unnecessary coupling to this particular Helper implementation.
The object receives its dependencies from some external source (with dependency injection)
In this version, the Helper is passed to the DiObject at construction time.
It doesn’t even need to know how to do that or what particular implementation type the Helper is, or where it comes from.
It just needs a helper and uses it for whatever requirement it has.
The second version is loosely coupled to the Helper, depending only on the Helper interface, allowing the concrete implementation to be decided at runtime and thus giving lots of flexibility to the design.
Spring dependency injection configuration is normally defined in XML files, although later versions have turned more to annotation-based configuration and Java-based configuration.
Aspect Oriented Programming (AOP) AOP is a technique for extracting cross-cutting concerns from the main application code and applying them in a transverse way across the points where they are needed.
Typical examples of AOP concerns are transactions, logging, and security.
The main idea is that you decouple the main business logic of your application from special-purpose concerns that are peripheral to this core logic, and then apply this functionality in a transparent, unobtrusive way through your application.
By encapsulating this functionality (which is simply general application logic and not core business logic)  in its own modules, they can be used by many parts of the application that need them, avoiding the need to duplicate this code all over the place.
The entities that encapsulate this cross-cutting logic are referred to as Aspects in AOP terms.
The most popular, perhaps, is AspectJ which requires a special compilation process.
Spring supports AspectJ, but it also includes its own AOP implementation, known simply as Spring AOP, which is a pure Java implementation that requires no special compilation process.
Spring AOP using proxies is available only at the public-method level and just when it is called from outside the proxied object.
This makes sense because calling a method from inside the object won’t call the proxy; instead, it calls the real self object directly (basically a call on the this object)
This is something very important to be aware of when working with Spring, and sometimes it is overlooked by novice Spring developers.
Even when using its own AOP implementation, Spring leverages the AspectJ syntax and concepts for defining Aspects.
Spring AOP is a fairly big subject, but the principle behind the way it works is not difficult to understand.
Spring AOP works with the use of dynamically created proxy objects that take care of the AOP concerns around the invocation of your main business objects.
You can think of the proxy and Spring AOP in general simply as a Decorator Pattern implementation, where your business object is the component and the AOP proxy is the decorator.
Figure 2-1 shows a simple graphical representation of the concept.
Thinking about it this way, you should be able to understand Spring AOP easily.
Spring creates dynamically at runtime an object that conceptually looks like the following code.
Again, remember this simple idea and Spring AOP should be easier to understand.
An Initial Spring Security Secured Application Spring Security builds upon the concepts defined in the previous section and integrates nicely into the general Spring ecosystem.
You need to understand those concepts well to take maximum advantage of Spring Security.
However, you could start using Spring Security without really knowing all these details, and then learn them as you progress and look to do more advanced things.
It will need a tweak to make sense for our purposes.
In this example, we will create a simple web project powered by Spring Security.
To make sure that the examples in the book work as expected, try to use the same versions.
From the command line, go to any folder you want to use as the root of your projects and execute the following:
To do that, make the pom.xml file look like Listing 2-1
As you can see from the pom.xml listing, I included the Jetty plugin dependency.
I will be working throughout the book mostly with the Jetty server because it embeds nicely in the Maven life cycle.
Using any other container (like Apache Tomcat) to run the code from the book should be no problem, and it should work without issues.
Note N  Remember that you have to keep the conventional Maven file structure.
This means you have to create the /src/main/java folders for your source classes if you don’t have them yet.
Look at the Maven documentation online at http://maven.apache.org/ for more details.
In the command line, in the root of the project (where the pom.xml file resides), execute the following:
To make this work, you need to do the following:
Configure the users and roles that will be part of the system.
I’ll give more detail about each of these steps in the next four sections.
Adding Spring Security (and Spring Core Itself) to the Project In this section, we’ll start our journey into the inner workings of the framework and see its main building blocks and how it works.
I’ll conduct a full, in-depth review of the framework in the next chapter.
I could just tell you what to add to the project to make the application work, but I think it’s better to tell you first what the different components of the framework are so that you can start coding with a better knowledge of how the framework is built.
This means that I will tell you how to grab the source code of the project and build it, and then explain in a general way the different modules that make up the framework.
Spring Security Source Open source software has an invaluable characteristic for software developers: free access to all its source code.
With this, we can understand how our favorite tools and frameworks work internally, and we also can learn a lot about the way other (perhaps very good) developers work, including what practices, techniques, and patterns they use.
Free access to source code also enables us, in general, to gather ideas and experience for our own development.
Not only that; as a more practical matter, having access to the source code allows us to debug these applications in the context of our application: we can find bugs or simply follow our application’s execution through them.
I really like understanding the frameworks I work with and learning from the great work and effort put into them by some very talented developers around the world.
A lot of this book’s content is based on looking at the source code of Spring Security.
Where appropriate, some of that code will be printed in the pages of this book to make points more clear.
However, if you don’t, you should definitely take a look at it because it has become a standard public source-code repository for many open source projects in a multitude of programming languages.
Github (https://github.com/) is a repository, and a hosting service for Git repositories, with a very friendly management interface.
The Spring Security project can be found inside the SpringSource general Github section at https://github.com/SpringSource/spring-security.
To get the code, go to any location you want to have the project in your command-line terminal and execute the following command:
That’s it, now you have the Git repository cloned in your computer.
Let’s go inside the newly created directory and see what is there.
The first thing that is worth mentioning is that the current versions of Spring Security use Gradle as the build tool.
Until version 2.5.0.M1, Spring Security used Maven as the build tool.
Maven support was finally removed in version 3.1.0.M1, leaving only Gradle as the build system.
Gradle is a build tool written in Groovy that uses an internal Domain Specific Language to specify the build configuration of your project.
A detailed explanation of Gradle is outside the scope of this book, so I will just cover what you need to build Spring Security from the source code.
You can see that in the top directory there is a file named gradlew.
This is what is known as a Gradle Wrapper, and its main advantage is that it is a self-contained build script-tool.
When you run it, it will download Gradle for you and use the downloaded Gradle to build your project.
Go ahead and run gradlew build install from the top directory and wait for the project to build.
Note N  It is possible for the build to fail in your system.
Because we are working in the master branch of the framework, a lot of code is being committed there all the time.
It is not under my control if this build fails at any given time.
Later, you will simply use a stable tag for developing the examples in the book.
You should now have the project built and available in your current Maven repository.
Yes, when using Gradle, the dependencies can be simply stored in the Maven repository.) You can see that it is very straightforward to build the project from the source code.
Setting the project build aside for now, take another look at the contents of the top project directory.
Most of the folders in the directory correspond to individual subprojects or modules that break the functionality of Spring Security into more discrete and specialized units.
Every other module builds on top of this one because it provides core functionality to the rest of the framework.
In this module, you can find the main interfaces and classes that establish the concepts and hook points that the rest of the system uses.
It also contains the core implementations of the system, including the JDBC authentication support, the Java Authentication and Authorization Service (JAAS) authentication provider, the access voting system, MD5 and SHA password encoders, and a lot more.
It builds on the core and leverages its main abstractions and implementations to provide security to your web-based application.
In this module, you can find the Servlet Filters that deal with the pre-processing and post-processing of Servlet requests, the Servlet Session management, the Secure Sockets Layer (SSL) support, the Remember Me support, the HTTP status code generation, and more web-related things.
When you write your configuration files for your application using the XML definitions for the different Spring Security configuration options, this module is responsible for parsing that XML and creating standard bean definitions from them, wiring them together, and getting them ready to be instantiated by the Spring context-loading process.
Here, you will find the translation from namespaced xml elements to standard Spring Framework <bean> elements.
It contains the database model, including the SQL DDLs (Data Definition Language), to establish the rules and relationships between domain entities and their security restrictions.
I will cover ACLs in depth in the chapter dealing with business-layer security.
This module takes care of propagating the security context to these remote services.
It also includes an embeddable ApacheDS server implementation for testing and development purposes.
So if you want to authenticate with CAS, you need this module in your application.
There is also a samples folder inside the top directory.
Here, you can find some example applications to help you get to know the framework and how to configure your applications.
For our project example, you need to depend on the core, web, and config modules.
So we add them to our pom.xml, as shown in Listing 2-3
Note N  As you probably know, Maven handles transitive dependencies.
In our example, the dependencies we just defined in Listing 2-3 will translate into more real-world dependencies, including the needed dependencies from the Spring Framework.
This includes Spring web support and the core libraries for DI and ApplicationContext management.
Configuring the Web Project To Be Aware of Spring Security To activate Spring Security in a Java web application, you need to configure a particular Servlet filter that will take care of pre-processing and post-processing the requests, as well as managing the required security constraints.
You are specifying here that requests to all URLs (/*) will go through the DelegatingFilterProxy filter.
The name of this filter is important because it is the default name Spring Security will use to configure its filter chain.
You now need to define the actual Spring Security configuration.
For that, create a file named applicationContext-security.xml in the WEB-INF folder and put the content shown in Listing 2-5 into it:
That’s all we need to secure the given URL for the Scarvarez family only.
You can see that you are defining a role called "ROLE SCARVAREZ MEMBER" that is the only one that has access to the url "/hello"
You also see that you are assigning this role to all the Scarvarez family members.
To make this work, you need to reference this new file in the web.xml.
So open it again and add the content from Listing 2-6 to it.
It should be added at the top of the file after the <web-app> element.
Go to the command line, execute mvn jetty:run again, point your browser to the URL http://localhost:8080/hello, and press the Enter key.
You should see a login page asking you to provide the user name and password as Figure 2-4 shows.
Go ahead, impersonate a Scarvarez family member, and try to log in.
For example, use car as the user name and scarvarez as the password.
If you instead tried to log in as a nonexistent user, you should get the page shown in Figure 2-5
As a matter of fact, we haven’t written any code; we just did some XML configuration.
Now our Servlet-based application is secured to allow access only for authenticated users.
The fact that we are using this XML configuration to secure the application is very relevant, because it shows that we are adding security in a completely unobtrusive and declarative way to an application that is otherwise insecure.
This is all well and nice, but right now it looks like magic.
Where does this login form come from? How does this.
In the next section, we will cover the basics of what is going on.
A full, in-depth explanation of Spring Security follows in the next chapter.
Understanding the Simple Application You can see that with some relatively simple configuration, we managed to secure our regular Java Web application with a functional role-based authentication/authorization scheme.
I can imagine an application for which this simple configuration would be enough security—for example, an application that has an admin section and an open-to-all section, and where the admin user (or users) is predefined beforehand.
Even for this simple-looking configuration, there is a lot going on under the hood of your application, but Spring Security takes care of the heavy work and leaves you to worry about what you need to worry about:—establishing your security rules.
What follows is a general overview of the process, followed by a graphical representation of it:
Start the application (in this case, by using jetty run)
When the application is loading, it looks at its web.xml file.
This listener uses the path defined in the context param contextConfigLocation to find the Spring xml file that it needs to load.
This file uses the custom Spring Security namespace to define, in a friendly way, the different security concerns that we need to address.
Context LoaderListener after parsing the XML in the normal Spring way.
The result of trying to log in with an incorrect user name and password combination.
Your web.xml filter (of class DelegatingFilterProxy) is instantiated and added to the filter chain of your web application.
This Servlet filter implementation is a Spring contextaware filter that simply delegates the filtering to Spring-defined filter beans.
In this case, it will delegate to a bean named springSecurityFilterChain, which is defined implicitly by your use of the Spring Security XML namespace.
Jetty server, Jetty wraps it into an HttpServletRequest, and sends it through to the filter springSecurityFilterChain.
This filter is a composite of numerous filters that deal with different parts of the authentication/authorization process.
Spring looks at the current credentials in the web session and can’t find any user details with this role.
When Spring realizes (inside one of the filters) that there is no current user in the session with permission to access the requested URL, it generates a redirect response that redirects the user browser to a login URL that contains a self-generated login form.
When Spring Security detects that this URL has been requested, it tries to extract the user name and password from the request and creates an authentication request.
The authentication request is sent to an authentication manager, which you configured in your XML file.
Internally, the manager finds the user (if it exists) and fills one authentication object with the user details, credentials, and authorities.
This is now an authenticated user, and a session is associated with this user.
If the details contained in the authentication don’t match any user, an exception is thrown indicating that.
This exception is then handled by a different flow that takes care of presenting the login screen again with the error message.
A redirect response is created to the original requested URL.
When this new redirect request gets in the system, it goes through the filters again, but this time the authentication ones are not called because there is already an authenticated user.
This filter compares the authenticated user’s authorities against the authorities needed to have in order to access the requested resource (in this case, the /hello URL)
The framework decides that the user is allowed to access the resource, so the filter chain finally forwards the request to the Servlet.
This is the happy-path scenario of how the flow works.
If anything goes wrong (for example, if the user is not found), Spring Security normally throws an exception and, in the case of web security, maps that exception to a relevant HTTP status code.
This will be covered later in the book as we go deeper into the work of the framework.
Wow! That is a lot of work that Spring Security is doing on our behalf while we just had to define some simple XML configuration.
In the next chapter, I will dive deeply into how all this works internally when we look at the architecture of Spring Security.
Summary Right now, you should have a good idea of what Spring Security is and what it is useful for.
Along the way, I introduced some of the major architectural and design principles behind it and how they are layered on top of the great Spring Framework.
I also gave you a quick look at the source code of the Spring project and at the different modules that make up the framework.
I introduced dependency injection and AOP and gave an overview of the step-by-step process a typical web application goes through when it is secured with Spring Security.
In the next chapter, I’ll go deep into the architecture and design of the framework.
In the previous chapter, I developed an initial application secured with Spring Security.
I gave an overview of the way this application worked and looked in detail at some of the Spring Security components that are put into action in common Spring Security–secured application.
In this chapter, I am going to extend those explanations and delve deeply into the framework.
I’ll look at the main components of the framework, explain the work of the servlet filters for securing web applications, look at how Spring AOP (Aspect Oriented Programming) helps you add security in an unobtrusive way, and in general, show how the framework is designed internally.
I’ll offer a big-picture overview of the framework and then delve deeper into each major component.
The 10,000-Foot View Spring Security is a relatively complex framework that aims to make it easy for the developer to implement security in an application.
At the most general level, it’s a framework composed of intercepting rules for granting, or not granting, access to resources.
From this view, you can think of Spring Security simply as an extra layer built on top of your application, wrapping specific entry points into your logic with determined security rules.
The 1,000-Foot View Going into a little more detail, we arrive at AOP and servlet filters.
Spring Security’s interception model of security applies to two main areas of your application: URLs and method invocations.
Spring Security wraps around these two entry points of your application and allows access only when the security constraints are satisfied.
Both the method call and the filter-based security depend on a central Security Interceptor, where the main logic resides to make the decision whether or not access should be granted.
In Figure 3-2, you can see this more detailed overview of the framework.
In this view, both method calls and HTTP requests try to access a resource, but first they must go through SecurityInterceptor.
This next overview will show you the main collaborating parts that participate in the general process of ensuring that your security constraints are enforced.
This is particularly achievable with an open source project like Spring Security which allows you to get into the framework itself and appreciate its design and architecture by accessing directly the source code..
For me, what follows is the best way to understand Spring Security from the inside.
The enumeration of what I consider to be the main components of the framework will help you know where everything belongs and how your application is enforcing the security rules that you specify for it.
The Security Interceptor One of the most important components of the framework is the Security Interceptor.
With the main logic implemented in AbstractSecurityInterceptor and with two concrete implementations in the form of FilterSecurityInterceptor and MethodSecurityInterceptor (as shown in Figure 3-4), the Security Interceptor is in charge of deciding whether a particular petition should be allowed to go through to a secured resource.
MethodSecurityInterceptor, as its name should tell you, deals with petitions directed as method calls, while FilterSecurityInterceptor deals with petitions directed to web URLs.
The Security Interceptor works with a preprocessing step and a postprocessing step.
In the preprocessing step, it looks to see whether the requested resource is secured with some metadata information (or ConfigAttribute)
If it is not, the request is allowed to continue its way either to the requested URL or method.
If the requested resource is secured, the Security Interceptor retrieves the Authentication object from the current SecurityContext.
If necessary, the Authentication object will be authenticated against the configured AuthenticationManager.
After the object is authenticated, AccessDecisionManager is called to determine if the authenticated entity is able to finally access the resource.
AccessDecisionManager throws an AccessDeniedException if the authenticated entity is not allowed to access the resource.
If AccessDecisionManager decides that the Authentication object is allowed to access the resource, the Authentication object is passed to RunAsManager if this is configured.
If RunAsManager is not configured, a no-op implementation is called.
RunAsManager returns either null (if it’s not configured to be used) or a new Authentication object containing the same principal, credentials, and granted authorities as the original Authentication object, plus a new set of authorities based on the RUN_AS that is being used.
This new Authentication object is put into the current SecurityContext.
After this processing, and independently of whether or not a run-as Authentication object is used, the Security Interceptor creates a new InterceptorStatusToken with information about the SecurityContext and the ConfigAttributes.
This token will be used later in the postprocessing step of the Security Interceptor.
At this point, the Security Interceptor is ready to allow access to the secured resource, so it passes the invocation through and the.
After the invocation returns, the second phase of the Security Interceptor comes into play, and the postprocessing begins.
The postprocessing step is considerably simpler, and it involves only calling a AfterInvocationManager’s decide method if there is one configured.
In its current implementation AfterInvocationManager delegates to instances of PostInvocationAuthorizationAdvice, which ultimately can filter the returned objects or throw a AccessDeniedException if necessary.
This is the case if you are using the postinvocation filters in method-level security, as you will see in the following chapter.
In the case of web security, the AfterInvocationManager is null.
That is a lot of work for the Security Interceptor.
However, because the framework is nicely modular at the class level, you can see the Security Interceptor simply delegates most of the task to a series of well-defined collaborators, which in a very SRP (Single Responsibility Principle) way focus on single, narrowly scoped responsibilities.
This is good software design and an example you should emulate.
As shown in Listing 3-1, I paste the main parts of the code from the AbstractSecurityInterceptor itself so that you can see the things I’ve been talking about.
I include some comments in the code so that you can understand better what it does.
Here we are checking if this filter is able to process a // particular type of object.
For example FilterSecurityInterceptor is able to process // FilterInvocation objects.
Here we are retrieving the security metadata that maps to the // object we are receiving.
So if we are receiving a FilterInvocation, // the request is extracted from it and used to find the // ConfigAttribute (s) that match the request path pattern.
Here we are calling the decision manager to decide if // authorization is granted or not.
This will trigger the voting mechanism, // and in case that access is // not granted an exception // should be thrown.
It will take care of filtering the return value or actually // throwing an exception // if it is relevant to do so.
Every call to a secured resource in Spring Security passes through this interceptor.
The AbstractSecurityInterceptor shows its versatility when you realize that two not very related kinds of resources (URL endpoints and methods) leverage more of the functionality of this abstract interceptor.
This, once again, sh-ows the effort put into the design and implementation of the framework.
Figure 3-4 shows the interceptor in a UML (Unified Modeling Language) class diagram.
The XML Namespace The XML namespace is of extreme importance to the general appeal and usability of the framework, yet it is, in theory, not strictly necessary.
If you know how the Spring Framework’s namespaces work, you probably have a good idea of what is going on when you define your security-specific XML configuration in your application context definition files.
If you don’t know how they work, maybe you think Spring is somehow made aware of how to treat these specific elements and how to load them in the general Spring application context.
Either way, here I will explain in some detail the process behind the definition of a custom namespace in Spring, and particularly, the elements in the Spring Security namespace.
All that Spring understood was its own classes defined in the standard Spring Core namespace, where you can define <bean>s on a bean-to-bean basis and can’t really define anything conceptually more complex without adding that complexity yourself to the configuration.
This <bean>−based configuration was, and still is, very good for configuring general-purpose bean instances, but it could get messy really fast for defining more domain-specific utilities.
And beyond being messy, it is also very poor at expressing the business domain of the beans you are defining.
I’ll explore this manual configuration later in the book, but for standard cases it is not needed, and you should simply use the namespace.
However, keep in mind that under the hood the namespace is nothing more than syntactic sugar.
At the end of the day, you still end up with standard Spring beans and objects.
Since then, a lot of projects have made use of this facility, making them more attractive to work with.
An XML custom namespace is simply an XML-based Domain Specific Language (DSL), guided by the rules of an XML schema (xsd) file, that allow developers to create Spring beans using concepts and a syntax more in synch with the programming concerns they are trying to model.
Note N  A DSL is a language customized to represent the concepts of a particular application domain.
Sometimes, a whole new language is created to support the new domain.
Some other times, an existing language is tweaked to allow for new expressions that represent the concepts of the domain.
These are referred you are defining certain constraints about the elements (using XSD) and thus are creating an internal DSL to represent security concepts.
To make Spring aware of a new namespace is really simple.
That’s not to say it is simple to actually parse the information of the XML and convert it to beans—this depends on the complexity of your DSL.) All you need is the following:
A u� spring.handlers file where you specify which class is in charge of handling everything related to your namespace.
A bunch of parser classes that will be in charge of parsing each of the top elements defined in u� your XML file.
In Chapter 8 you will see some examples of how to create a new namespace element and integrate it with Spring Security.
For Spring Security, all the namespace configuration-related information resides in the config module.
In Figure 3-6, you can see the expanded structure of the config module as seen in the Eclipse integrated development environment (IDE)
The files spring.handlers and spring.schemas should reside on the META-INF directory in the classpath so that Spring can find them there.
When you create a  Spring -based application using XML-defined application context configuration with some of the Spring Security namespace definitions, and you run the application, when it starts to load up, it looks in the application context’s namespace definitions at the top of the XML configuration file.
Using the information from the mapping file spring.handlers, it will see that the file to handle the security elements is the final class, org.springframework.security.config.SecurityNamespaceHandler.
Spring calls the parse method of this class for every top element in the configuration file that uses the security namespace.
SecurityNamespaceHandler delegates to a series of BeanDefinitionParser objects for the individual parsing of each top-level element.
The whole list of elements supported in the Spring Security namespace configuration are defined in the class org.springframework.security.config.Elements as constants.
From the list of elements presented in the previous class, the top-level ones as used in the XML configuration files are as follows (in the previous listing, I refer to them by the name of the constant and not by the XML element name):
This element is used to configure the Lightweight Directory Access Protocol (LDAP) authentication provider for your application in case you require one.
This element is used to configure an LDAP server in your application.
This element configures the service for retrieving user details from.
This element defines the in-memory user service where you can store user names, credentials, and authorities directly in the application context definition file.
This element allows you to set up a database-driven user service, where you specify a DataSource and the queries to retrieve the user information from a database.
This element defines a DaoAuthenticationProvider, which is an authentication provider that delegates to an instance of UserDetailsService.
The UserDetailsService can be any of the ones defined in the previous three bullet points, or a reference to a customized one.
This element registers a global ProviderManager in the application and sets up the configured AuthenticationProviders on it.
It does this so that when a request is made to a method, the method can be retrieved and its security constraints can be checked.
For development purposes, this element registers a DebugFilter in the security filter chain.
This is the main element for a web-based secure application.
It allows the definition of URL-based security-mapping strategies, the configuration of the filters, the Secure Sockets Layer (SSL) support and other HTTP-related security configurations.
This element uses a firewall element and adds it to the filter chain if it is configured.
The firewall referenced should be an implementation of Spring’s own HttpFirewall interface.
These elements map the relationship between URLs and the ConfigAttributes required for accessing those URLs.
This element allows you to configure the Spring Security filter chain that will be used in the application, which filters you want to add to the chain, and a request matcher if you want to customize how the chain matches requests.
The most important request matchers are: ant based and regexp based.
You will be using the Spring Security namespace thoroughly throughout the book, so many of the elements described here will be revisited in later chapters.
The Filters and Filter Chain The filter chain model is what Spring Security uses to secure web applications.
This model is built on top of the standard servlet filter functionality.
Working as an Intercepting Filter Pattern, the filter chain in Spring Security is built of a few single-responsibility filters that cover all the different security constraints required by the application.
The filter chain in Spring Security preprocesses and postprocesses all the HTTP requests that are sent to the application and then applies security to URLs that require it.
The Spring Security filter chain is made up of Spring beans; however, standard servlet-based web applications don’t know about Spring beans.
For this reason, a special servlet filter is needed that can cross the boundaries between the standard servlet API and life cycle and the Spring application where the bean filters will reside.
This is the job of the org.springframework.web.filter.DelegatingFilterProxy defined in the web.xml, which will use under the hood the WebApplicationContextUtils.getWebApplicationContext utility method to retrieve the root application context of the application.
The filter in the web.xml file has the same name as the bean in the Spring application context so that the listener can find it.
The filter chain will be fully explained in Chapter 4
However, here I’ll provide an overview of which filters are available and what they do.
The available filters are defined as enums in the file org.springframework.security.
The enums are then referenced later in the startup process when instantiating the bean definitions for each filter.
This filter ensures that the request is handled by the correct channel— meaning, in most cases, it determines whether or not the request is handled by HTTPS.
Its main function is to query the session to see if it has expired (which happens mainly when the maximum number of concurrent sessions per user are reached) and to log out the user if that is the case.
This filter populates SecurityContextHolder with a new or existing security context to be used by the rest of the framework.
This filter is based, by default, on a particular URL invocation (/j_spring_security_logout)
It takes care of the logout process, including tasks such as clearing the cookies, removing the remember-me information, and clearing the security context.
The J2EE authenticated principal will be used as the pre-authenticated principal in the framework.
This filter is used when a user name and password is required on a login form.
This filter takes care of authenticating with the requested user name and password.
This filter processes OpenId authentication requests, handling both the initial request with the OpenId identity to the external server and the redirect from the OpenId server back to the application.
All this interaction is managed when the filter detects requests to  the preconfigured URL /j_spring_openid_security_check.
This filter generates a default login page when the user doesn’t provide a custom one.
It will be activated when the URL /spring_security_login is requested.
It will look for the presence of both Digest and Authorization HTTP request headers.
It can be used to provide Digest authentication to standard user agents, like browsers, or to application clients like SOAP.
On successful authentication, the SecurityContext will be populated with the valid Authentication object.
This filter processes the BASIC authentication headers in an HTTP request.
It looks for the header Authorization and tries to authenticate with these credentials.
This filter retrieves a request from the request-cache that matches the current request, and it sends the cached one through the rest of the filter chain.
This filter wraps the request in a request wrapper that implements the Servlet API security methods, like isUserInRole, and delegates it to SecurityContextHolder.
This allows for the convenient use of the request object itself to get the security information.
For example, you can use request.getAuthentication to retrieve the Authentication object.
This filter tries to obtain and use javax.security.auth.Subject, which is a final class, and continue the filter chain execution with this subject.
This filter checks to see whether there is already an Authentication in the context.
If there is not, it creates a new Anonymous one and sets it on the security context.
This filter passes the Authentication object that corresponds to the authenticated user who is logged in to the system to some configured session management processors in order to do session-related handling of the Authentication.
Mainly, these processors will do some kind of validation and throw SessionAuthenticationException if appropriate.
Currently, these processors (or strategies) include only one main class in the form of org.springframework.security.web.
This filter handles the translation between Spring Security exceptions (like AccessDeniedException) and the corresponding HTTP status code.
It also redirects to the application entry point in case the exception is thrown because there is not yet an authenticated user in the system.
It delegates to its parent class’ (AbstractSecurityInterceptor) functionality (which I’ll cover later in the chapter) the actual workflow logic of granting or not granting the access to the specific resource.
This filter allows a user to impersonate another one by visiting a particular URL (/j_spring_security_switch_user, by default)
This URL should be secured to allow just certain users access to this functionality.
Also, the method attemptSwitchUser in the implementing class SwitchUserFilter can be overridden to add constraints, so that you can use more finely grained information to decide if certain users are allowed or not allowed to impersonate other users.
ConfigAttribute The interface org.springframework.security.access.ConfigAttribute encapsulates the access information metadata present in a secured resource.
For example, for our study purposes, ROLE_ADMIN is a ConfigAttribute.
There are a few implementations of ConfigAttribute, as you can see in Figure 3-9
When you annotate a method with @Secured("ROLE_ADMIN") or something similar, or specify a URL with following.
On startup, as normal Spring functionality, all the bean postprocessors in the ApplicationContext get invoked.
And in the case of Spring Security, the process is the following.
What happens in the case of web requests is not really that complex.
In the parsing process, the private method parseInterceptUrlsForFilterInvocationRequestMap will be invoked.
This map, ultimately, will be set up in an instance of an implementation of the interface org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource inside the FilterSecurityInterceptor, which uses it when each request comes to match the requested URL against the keys in the map to find out if the URL is secured and then extracts the ConfigAttributes against which to check the authorities of the requesting Authentication object.
For method-level security, you have many options—the most common one being the configurations performed through the use of annotations.
There are a few different annotations available in the framework; however, the setup treatment by the framework is very similar.
In the case of the @Secured annotation, for instance, you need to make Spring aware that this special annotation needs a special security treatment.
To do that, you register the following in the security application context XML file:
When you set up that definition in the application context XML configuration, Spring Security creates a new MethodSecurityMetadataSourceAdvisor and registers it in the application context.
This advisor will be marked as an infrastructure advisor and will be picked up by Spring Core’s InfrastructureAdvisorAutoProxyCreator, which is a BeanPostProcessor that Spring initializes automatically.
This processes all the beans in the application context and determines if any of the configured advisors can be applied to any of the beans and their methods.
If so, it wraps the bean with the required advisor or advisors.
The postprocessor finds the MethodSecurityMetadataSourceAdvisor and eventually calls an implementation of the  MethodSecurityMetadataSource.getAttributes method for each bean and all their methods, to determine if they have  any ConfigAttribute configured as metadata in them.
If the MethodSecurityMetadataSource finds ConfigAttributes  in the bean, the InfrastructureAdvisorAutoProxyCreator, from Spring Core, calls its own method (createProxy) to apply MethodSecurityMetadataSourceAdvisor, which internally contains the Security Interceptor as the org.aopalliance.aop.Advice to apply to the bean.
Again, this is a lot of work that Spring and Spring Security do on your behalf.
At first sight, this looks like simple magic, but it takes a lot of hard work from Spring to do it.
And you have to thank the Spring and Spring Security developers for taking care of all this and giving you a simple and powerful API for resolving your security concerns.
The Authentication Object The Authentication object is an abstraction that represents the entity that logs in to the system—most likely, a user.
Because it is normally a user authenticating, I’ll assume and use the term “user” in the rest of the book.
There are a few implementations of the Authentication object in the framework, as you can see in Figure 3-12
An Authentication object is used both when an authentication request is created (when a user logs in), to carry around the different layers and classes of the framework the requesting data, and then when it is validated, containing the authenticated entity and storing it in SecurityContext.
The most common behavior is that when you log in to the application a new Authentication object will be created storing your user name, password, and permissions—most of which are technically known as Principal, Credentials, and Authorities, respectively.
Authentication is an interface, and it is pretty simple, as Listing 3-3 shows.
Note N  There are many implementations of the Authentication interface, and in the book I will be referring most of the time to the general Authentication interface when we are not interested in the particular implementation type.
Of course when I need to talk about the specifics of an implementation detail I will be referring to the concrete classes.
As Figure 3-12 shows, currently there are a few implementations of Authentication in the framework:
This is a simple implementation that contains, as its name clearly specifies, the user name and password information of the authenticated (or pending authentication) user.
It is the most common Authentication implementation used throughout the system, as many of the AuthenticationProvider objects depend directly on this class.
Pre-authenticated authentications are those where the actual authentication process is handled by an external system, and Spring Security deals only with extracting the principal (or user) information out of the external system’s messages.
This is an Authentication implementation used specifically for OpenID authentication schemes.
It is used by both the OpenID filter and the OpenID authentication provider.
This implementation is used by the RunAsManager, which is called by the Security Interceptor, when the accessed resource contains a ConfigAttribute that starts with the prefix 'RUN_AS_'
If there is a ConfigAttribute with this value, RunAsManager adds new GrantedAuthorities to the authenticated user corresponding to the RUN_AS value.
SecurityContext and SecurityContextHolder The interface org.springframework.security.core.context.SecurityContext (actually, its implementation is SecurityContextImpl) is the place where Spring Security stores the valid Authentication object, associating it with the current thread.
The org.springframework.security.core.context.SecurityContextHolder is the class used to access SecurityContext from many parts of the framework.
It is built mainly of static methods to store and access SecurityContext, delegating to configurable strategies the way to handle this SecurityContext—for example, one SecurityContext per thread (default), one global SecurityContext, or a custom strategy.
AuthenticationProvider AuthenticationProvider is the main entry point for authenticating an Authentication object.
This interface has only two methods, as Listing 3-6 shows.
This is one of the major extension points of the framework, as you can tell by the many classes that currently extend this interface.
Each of the implementing classes deals with a particular external provider to authenticate against.
So if you come across a particular provider that is not supported and need to authenticate against it, you probably need to implement this interface with the required functionality.
You will see examples of this later in the book.
Here are some of the existing providers that come with the framework:
AccessDecisionManager AccessDecisionManager is the class in charge of deciding if a particular Authentication object is allowed or not allowed to access a particular resource.
In its main implementations, it delegates to AccessDecisionVoter objects, which basically compares the GrantedAuthorities in the Authentication object against the ConfigAttribute(s) required by the resource that is being accessed, deciding whether or not access should be granted.
The AccessDecisionManager implementations take the output from the voters into consideration and apply a determined strategy on whether or not to grant access.
The current AccessDecisionManager implementations all delegate to voters, but they work in slightly different ways.
The current voters, which are described in the following list, are defined in the package org.springframework.security.access.vote.
AffirmativeBased This access decision manager calls all its configured voters, and if any of them votes that access should be granted, it is enough for the access decision manager to allow access to the secured resource.
If no voters vote to grant access and there is at least one voting not to grant it, the access decision manager throws an AccessDeniedException denying access.
If there are only abstaining voters, a decision is made based on the AccessDecisionManager’s instance variable allowIfAllAbstainDecisions, which is a Boolean that defaults to false, determining if access should be granted or not when all voters abstain.
ConsensusBased This access decision manager implementation calls all its configured voters to make a decision to either grant or deny access to a resource.
The difference with the AffirmativeBased decision manager is that the ConsensusBased decision manager decides to grant access only if there are more voters granting access than voters denying it.
If there are the same number of granting voters as denying voters, the value of the instance variable.
By default, this variable’s value is “true”, access is granted.
When all voters abstain, the access decision will be decided the same way as it is for the AffirmativeBased manager.
UnanimousBased As you probably guessed, this access decision manager will grant access to the resource only if all the configured voters vote in favor of allowing access to the resource.
If any voter votes to deny the access, the AccessDeniedException will be thrown.
AccessDecisionVoter This discussion of the AccessDecisionManager and its current implementations should have made clear the particular Authentication object has enough privileges to access a particular resource.
The org.springframework.security.access.AccessDecisionVoter interface is very simple as well, and you can see it in Listing 3-8
The satisfaction or not of the conditions is given  by analyzing the Authentication object’s rights against the required resource.
In practice this basically means that the Authentication’s authorities are compared against the resource’s security attributes looking for matches.
DenyAll won’t allow any access at all to the resource, independent of the security information carried by the Authentication object trying to access it.
PermitAll will allow access to everyone, regardless of what roles they have.
The RolesAllowed annotation can be configured with a series of roles.
If an Authentication object tries to access the resource, it must have one of the roles configured in the RolesAllowed annotation in order to get access granted by this voter.
This voter votes on resources with expression configurations based on @PreFilter and attribute that can have a SpEL expression.
The PreInvocationAuthorizationAdviceVoter is the one in charge of evaluating the SpEL expressions (of course with the help of Spring’s SpEL evaluation mechanism) provided in these annotations.
We will be explaining  and using SpEL expressions in several parts of the book so this concept will become clearer as the books advances.
This is the abstract class that has the skeleton to write voters dealing with domain ACL rules so that other implementing class built on its functionality to add voting behavior.
Currently, it is implemented in AclEntryVoter, which votes on users’ permissions on domain objects.
This voter will be covered in the chapter dedicated to ACL.
This voter votes whenever a ConfigAttribute referencing any of the three possible levels of authentication is present on the secured resource.
This is, perhaps, the most commonly used voter of them all.
This voter, by default, is able to vote on resources that have ConfigAttribute(s) containing security metadata starting with the prefix “ROLE_” (which can be overridden)
When an Authentication object tries to access the resource, its GrantedAuthorities will be matched against the relevant ConfigAttributes.
To make use of this voter, attribute needs to be added to the  <http> element.
The voters model is yet another one in the framework that is open for extension and customization.
You could easily create your own implementation and add it to the framework.
You will see how to do this in Chapter 8
UserDetailsService and AuthenticationUserDetailsService The interface org.springframework.security.core.userdetails.UserDetailsService is in charge of loading the user information from the underlying user store (in-memory, database, and so on) when an authentication request arrives in the application.
UserDetailsService makes use of the provided user name for looking up the rest of the required user data from the datastore.
It defines just one method, as you see in Listing 3-9
The interface org.springframework.security.core.userdetails.AuthenticationUserDetailsService is more generic—it allows you to retrieve a UserDetails using an Authentication object instead of a user name String, making it more flexible to implement.
Actually, there is an implementation of AuthenticationUserDetailsService (UserDetailsByNameServiceWrapper) that simply delegates to a UserDetailsService extracting the user name from the Authentication object.
These are the two main strategies (AuthenticationUserDetailsService and UserDetailsService) used.
They are usually called from the particular AuthenticationProvider that is being used in the application.
For example, the OpenIDAuthenticationProvider and CasAuthenticationProvider delegate to an AuthenticationUserDetailsService to obtain the user details, while the DaoAuthenticationProvider delegates directly to a UserDetailsService.
Some other providers don’t use a user details service of any kind (for example, JaasAuthenticationProvider uses its own mechanism to retrieve the Principal from a javax.security.auth.login.LoginContext), and some others use a completely custom one (for example, LdapAuthenticationProvider uses a UserDetailsContextMapper)
UserDetails The interface org.springframework.security.core.userdetails.UserDetails object is the main abstraction in the system, and it’s used to represent a full user in the context of Spring Security.
It is also made available to be accessed later in the system from any point that has access to SecurityContext.
Normally, developers create their own implementation of this interface to store particular user details they need or want (like email, telephone, address, and so on)
Later, they can access this information, which will be encapsulated in the Authentication object, and they can be obtained by calling the getPrincipal method on it.
Some of the current UserDetailsService (for example, InMemoryUserDetailsManager) implementations use the class org.springframework.security.core.userdetails.User, which is available in the core of the framework, as the UserDetails implementation returned by the method loadUserByUsername.
However, this is another of those configurable points of the framework, and you could easily create your own UserDetails implementation and use that in your application.
This means, in a general way, assigning an ID to each domain object in your application and creating a relationship between these objects and the different users of the application.
These relationships determine whether or not a determined user is allowed access to a particular domain.
The ACL model offers a fine-grained, access-level configuration you can use to define different rules for accessing the objects depending on who is trying to access it.
For example, a user might be allowed read access while another user will have write/read access over the same domain object.)
The current support for ACLs is configured to get the configuration rules from a relational database.
The DDL (Data Definition Language) for configuring the database comes along with the framework itself, and it can be found in the ACL module.
The tags are simple to use and, at the same time, very convenient for making a more usable web site.
They help you adapt the UI of your application on a per-user (or more commonly, per-role) basis.
The taglib will be covered in depth in Chapter 4
One of the great aspects of working with open source software is that you can (and I would say you should) look at the source code and understand the software at a new, deeper level.
Also, you can look at the way the software is built, at what is good, and at what is bad (at least by your own subjective standards) and just learn how other developers work.
This can have a great impact on the way you work, because you might discover a way of doing things that you couldn’t have learned on your own.
Sometimes, of course, you will find things you don’t like, but that is good as well.
You can learn from other people’s mistakes as much as you can learn from their successes.
For me, Spring in general and Spring Security in particular have achieved something that I found invaluable in the Java development space—that is, they can make us better developers even without us noticing it.
I think helping good practices almost without noticing is really a great achievement for Spring.
It won’t create great developers by itself for sure, but it helps the average developer to not make mistakes that he might make if he didn’t have the support of the framework, and its principles to adhere to.
As you might see from the description of the main components of the framework, Spring Security itself is built with good design principles and patterns in mind.
You’ll have a brief look here at some of the things I find interesting in the framework, and from which you can learn about.
This section won’t really help you to do more with Spring Security, but it will serve as a way to appreciate the good work that has been done in constructing this fantastic framework.
Strategy Pattern A big part of the pluggability and modularity of the framework is achieved thanks to the wide use of the Strategy pattern.
You can find it, for example, in the type of SecurityContext to be used, the AuthenticationProvider hierarchy, the AccessDecisionVoters, and many other elements.
Covering design patterns is outside the scope of this book but as a reminder of the strategy pattern’s power I leave you with this definition from the Wikipedia.
The strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable.
Strategy lets the algorithm vary independently from clients that use it”
That definition shows a great deal of the power that comes when working with interfaces.
You could have different implementations of the same interface and pass any of them to a client class for doing different kinds of work.
The client classes don’t need to know or care about the implementation details that it is working with.
Knowing the interface or contract is enough to leverage its job.
Decorator Pattern Built into Spring’s core AOP framework, you can find the Decorator pattern—mostly in the way that your annotated business classes and methods get security constraints applied to them.
In the listing, you can see how the objects are decorated with prefunctionality and postfunctionality that surrounds the invocation of the actual method.
There are many examples of it around the framework, because any object you choose seems to have one and only one responsibility.
For example, the AuthenticationProvider deals only with the general concern of authenticating a principal with its credentials in the system.
The SecurityInterceptor is simply in charge of intercepting the requests, and it delegates all security-checking logic to collaborating objects.
A lot more examples like this can be extracted from the framework.
Dependency injection (DI) is one of Spring’s most important features.
Almost every component in Spring Security is configured through the use of dependency injection.
The AccessDecisionManager is injected into the AbstractSecurityInterceptor, and AccessDecisionVoter implementations are injected into the AccessDecisionManager.
And like this, most of the framework is built by composing components together through dependency injection.
Summary This was a complex chapter, but going through the inner workings of a software tool is definitely the best way to understand it and take advantage out of it.
You looked at an in-depth explanation of Spring Security’s architecture, its major components, and the way it works from the inside.
You should now understand how the XML namespace works, how AOP fits into the framework, and how, in general, the Servlet Filter functionality is used to enforce web-level security.
You looked at some code snippets from the framework itself to get a greater appreciation of the work done in it, as well as to understand better why things work the way they do.
You also studied the modularity inherent in the framework and saw how it helps to create software that is both flexible and extensible.
Even with all we covered in this chapter, it is basically an introduction and a reference to have in hand when you read the upcoming chapters and you start looking at the options to secure your applications.
From now on, you will understand where everything fits in the framework and how the different components link to each other.
In the next chapter, you will start developing an example application.
At the beginning, it will be a simple web application, and you will see how to secure it.
You will use all your current knowledge of the framework to tweak the configuration and test different ways of implementing security at the web level.
In this chapter, I will explain how to apply security at the web layer for Java web-based applications.
You will see in detail the inner work of the security filter chain and the different metadata options at your disposal to define security constraints in your application.
I will also cover the Taglib facility for enforcing security constraints at the view level.
However, I will try to cover most of the options available for securing web applications with Spring Security, even if some of the options don’t seem realistic for an application of this kind.
As in Chapter 2, we will use Maven to start up and build the project.
Again, I will assume certain versions of the different tools we need.
Go to the command line, to a directory you like, and do the following:
Press enter on each prompt you get from the command line.
At the moment, we will use the same dependencies that we had in our program from Chapter 2
So make sure your pom.xml file has the content from Listing 4-1
Just to test that it works, go to the command line, and execute the following in the root of the application:
Note N  Jetty (http://jetty.codehaus.org/jetty/ and http://www.eclipse.org/jetty/) is both an HTTP server and a Java Servlet container in the same way as Apache Tomcat.
It is a powerful, flexible, open source server that can be used either standalone or embedded in applications.
I will use Jetty in all the examples of this book because I find it very convenient to work with in Maven environments.
With that said, most, if not all, of the examples should work as they are in any other Servlet container, such as Tomcat.
The application should start without a problem, and you should get output like that shown in Figure 4-2
In this chapter,  you will be working with Spring MVC instead of simple Servlets.
Spring MVC is a simple but powerful Model-View-Controller framework that is part of the Spring Framework.
Covering Spring MVC in depth is outside the scope of this book, but the examples used in the book should be easy enough to follow.
The first thing you will do is set up Spring MVC in your application.
Add the content of Listing 4-2 to your web.xml file.
This code snippet defines a Servlet that will be used to handle all incoming requests to your application.
You can see that its implementation is a Spring-specific class.
This class is the entry point into the Spring MVC world.
The <servlet-name> value given to the servlet is relevant because DispatcherServlet will look for a file in the path WEB-INF/terrormovies-servlet.xml, where the name terrormovies-servlet is picked up from the servlet-name value.
This file will be the one Spring uses to configure the MVC support in the framework.
You will define a minimal file here because that is all you need at the moment.
You will create this file with the contents of Listing 4-3
First iteration of the application displays the simple Hello World! page.
For this first controller, you will focus on the “admin” part of the application.
At the beginning,  you will handle administration tasks with a particular URL namespace (/admin/*)
Note that, for the purposes of web security, it doesn’t really matter if you use a Spring MVC controller, like we do here, or if you use simple Servlets as we did in Chapter 2, or for that matter, if you use any other Servlet-based framework for developing your application.
Remember that, at the core, the web part of Spring Security basically attaches itself to the standard Java Servlet Filter architecture.
So if your application uses Servlets and Filters, you can leverage Spring Security’s web support.
You can see that in this controller you specified the URL, the HTTP method, and the body of the request you will receive.
The URL is built with a combination between the class-level RequestMapping annotation’s value concatenated with the method-level RequestMapping annotation’s value.
The HTTP method is specified as POST in the RequestMapping annotation on the method.
The RequestBody annotation in the method parameter simply tells Spring to populate the movie parameter with the string that comes in the body of the request.
And the ResponseBody annotation at the method level tells Spring to use the return value of the method as the body content of the response.
First, make sure you restart the application by pressing Ctrl+C and mvn jetty:run again as you did before.
You will be using curl for this first simple example.
Later,  you will be using the user interface of the application itself.) Curl is a command-line tool you use to send HTTP requests to a server.
It can be configured to use any HTTP method, add any arbitrary headers, use certificates, and so on.
For testing your new functionality, you start your application (using mvn jetty:run as I explained in Chapter 2)
Then, from the command line in another terminal, execute the following:
You are reaching the endpoint with your POST request to create movies.
But in a real application context, maybe only an admin user should be allowed to create new movies on the system.
You have defined your first user and your first role.
You need to decide where you are going to store your users and your roles.
Because this is a greenfield fake application, you can decide to do whatever you want.
For starters, you will do the easiest thing and store your users and roles in memory with the application.
You will then modify this to a more realistic database-backed solution in later chapters.
In later chapters, you will also fully explore some of the other providers you can use and even implement your own.
For defining your admin user and roles in memory, you will use the same user-service as in Chapter 2
This is a simple couple of XML elements you need to define in your configuration file applicationContext-security.xml, which you will create in the WEB-INF directory with the contents of Listing 4-5
Here, you can see you are defining your new admin user.
The next step is to secure your URL, allowing access only to your newly defined admin user.
You will make sure that only users with the ROLE_ADMIN role are able to reach your AdminController.
Note N  There is a catch in defining the security constraints of Spring Security.
You cannot define them in the terrormovies-servlet.xml file, because they need to be loaded up with the Servlet listener and the filter chain.
So they need to be in a proper WebApplicationContext defined with a Servlet listener, not the Servlet-related one.
This is because the DelegatingFilterProxy will look for the root application context defined in the ServletContext that is loaded by the ContextLoaderListener.
If you define only a terrormovies-servlet.xml, because the filters load first, before the servlets, the filter won’t be able to find any application context.
In short, you need to define your Spring Security configuration in one of the root application contexts.
Next you need to create the Servlet listener that will be aware of the configuration file applicationContext-security.xml.
You also need to activate the Spring Security filter chain.
To do that, you add the contents of Listing 4-7 to the web.xml file.
Restart the application, and paste the following URL in your browser’s address bar: http://localhost:8080/admin/movies.
You will now look in more detail at what is going on in the application, and how the configuration you just defined is helping you secure the application.
You will follow the request throughout its trip through the framework and look at the different steps that it takes.
The request will go through all these filters in a predefined order.
When you make the HTTP request to the configured URL, and after your Servlet container (in this case, Jetty) deals with it, the request lands in the DelegatingFilterProxy, which in turn delegates the processing to the security FilterChainProxy.
Figure 4-7 shows each of the filters that your current request travels through in the framework.
The filter chain, with the filters invoked in the first request.
The first security filter that gets hit by the request is SecurityContextPersistenceFilter.
When the request hits this filter, the framework tries to retrieve a SecurityContext from the standard Servlet session (javax.servlet.http.HttpSession)
If there is not a context in the session, or the session itself is null (that is, it still doesn’t exist because it hasn’t been created yet), the framework creates a new empty SecurityContext (or, more accurately, an instance of its implementation class SecurityContextImpl)
A new SecurityContext is created and associated to the current thread of execution.
The request is then sent to the next filter in the chain.
Because the request is not for the URL /j_spring_security_ logout, the filter simply forwards the request to the next filter in the chain.
This interaction is really simple and is shown in Figure 4-9
Sequence diagram of the SecurityContextPersistenceFilter before forwarding the request to the next filter in the chain.
LogoutFilter no-op interaction when the logout URL is not requested.
Because this request is not for the URL /j_spring_security_check, the filter simply forwards the request to the next filter in the chain.
As with the previous filter, this interaction is simple and can be explained with the same diagram.
This filter will see that the request is not for the URL /spring_security_login and will forward the request to the next filter in the chain.
As in the previous two filters, this interaction is simple and can be explained with the same diagram.
Because none are found, the filter forwards the request to the next filter in the chain.
As in the previous three filters, this interaction is simple and can be explained with the same simple diagram.
The only difference is that instead of looking at the path of the request, this filter looks at the headers (request.getHeader("Authorization"))
The request arrives at the RequestCacheAwareFilter filter, which won’t find any cached requests matching the current request.
So it forwards the original request to the next filter.
Cached requests are used normally when you do temporal redirections (like when you redirect to the login page) and then want to redirect back to the previously requested URL.
This filter wraps the request in a SecurityContextHolderAwareRequestWrapper, which implements the Servlet API security methods and forwards this request to the next filter in the chain.
When your request hits this filter, the framework will see that there is no Authentication object currently set in the SecurityContext, and it creates an AnonymousAuthenticationToken.
This object plays the role of an anonymous user in the system.
As a matter of fact, it will have a username of anonymousUser and will be the granted authority ROLE_ANONYMOUS in the system.
The request is then forwarded to the next filter in the chain.
RequestCacheAwareFilter tries to find a previously cached request or uses the original one.
AnonymousAuthenticationFilter at work; there is no authentication already set in the SecurityContext.
At this moment, there is still no active Servlet session in the system for the particular agent that is accessing it.
This filter checks that the current request is with an anonymous Authentication object (which was set by the previous filter in the context) and, finding that it is, it simply forwards the request to the next filter in the chain.
When the request arrives here, the only processing is to wrap the invocation to the next filter in the chain in a try..catch block.
If any subsequent filter, or the request handler itself, throws an exception it will be caught by the catch block in this filter.
This actually happens for the current request, as you will see when I describe the next filter.
You see the interaction of this filter in Figure 4-12
You can see in the figure that when an exception is caught, the filter can invoke an instance of an implementation of AuthenticationEntryPoint (as AuthenticationEntryPoint is an interface)
An AuthenticationEntryPoint has the logic to start a new authentication process, and this normally means showing a login form to  the logged-in user.
You finally arrive at the last filter in the default-configured chain shown in Figure 4-7
I talked a lot about this filter in previous chapters, but I will refresh the information here in the context of our request.
When the request arrives in this filter, the filter creates a new FilterInvocation object that contains the request.
This object is passed by the filter to the core AbstractSecurityInterceptor (from which FilterSecurityInterceptor extends)
The interceptor (with some helpers’ help) extracts the requested path from in the <intercept-url> element.
The interceptor also extracts the Authentication object from the Security Context and sends these two elements (the Authentication object and the required authorities or config attributes) to the AffirmativeBased access-decision manager, which in turn sends them to the configured RoleVoter instance.
The voter will not find any matches, so it will vote to deny access to the resource.
When the AffirmativeBased AccessDecisionManager receives the votes, it will see the deny vote and throw an AccessDeniedException.
This exception bubbles all the way up to the catch block in the ExceptionTranslationFilter.
The catch block in this filter will see that the current Authentication object stored in the SecurityContext is an Anonymous authentication and will start a new authentication process to obtain a complete Authentication from a user.
This class builds a URL (/spring_security_login by default) and sends a redirect response to that URL using the standard Servlet redirect method response.sendRedirect(redirectUrl)
Figure 4-13 shows the work of the FilterSecurityInterceptor I just explained.
ExceptionTranslationFilter wraps the invocation of the next filter in the chain with a try-catch block so that it can handle any security exception.
When the browser is redirecting and asks for the URL /spring_security_login, the following occurs:
The process will be the same as for the first request until it reaches the u� DefaultLoginPageGeneratingFilter.
At this point, the filter detects that the request is for the URL /spring_security_login and writes the login form’s HTML data directly in the response object.
We’ll follow the request through the framework to see what happens:
In the login form, type the username user and the password uspass.
When the form is submitted, the filters are activated again in the same order as before.
This time, however, when the request arrives at the UsernamePasswordAuthenticationFilter, the filter checks whether the request is for the URL /j_spring_security_check and sees that this is indeed the case.
With this information, it creates the UsernamePasswordAuthenticationToken Authentication object, which then sends it to the AuthenticationManager (or more exactly, its default implementation ProviderManager) for authentication.
The DaoAuthentication provider is an implementation of AuthenticationProvider, which uses a strategy of UserDetailsService to retrieve the users from whichever storage they live in.
With the configuration you currently have, it will try to find a user with the username “user” using the configured InMemoryUserDetailsManager (the implementation of UserDetailsService that maintains an in-memory user storage in a java.util.Map)
Because there is no user with this username, the provider throws a UsernameNotFoundException exception.
The provider itself catches this exception and converts it into a BadCredentialsException to hide the fact that there is no such user in the application; instead; it treats the error as a common username-password combination error.
This filter delegates to an instance of an implementation of AuthenticationFailureHandler, which in turn decides to redirect the response to the URL /spring_security_login?login_error.
This way, the login form is shown again in the browser with an error message displayed.
First, let’s create a new endpoint in the controller to retrieve some simple text.
In the controller AdminController, create the method from Listing 4-8
Notice in the listing how you are using the GET HTTP method to handle requests.
Go back to the URL http:/localhost:8080/admin/movies, and type admin as the username and admin as the password in the form.
This time, InMemoryUserDetailsManager finds a user with the requested username and returns that to DaoAuthenticationProvider, which creates a successful Authentication object.
After successful authentication, the UsernamePasswordAuthenticationFilter delegates to an instance of SavedRequestAwareAuthenticationSuccessHandler, which looks for the original requested URL (/admin/movies) in the session and redirects the response to that URL.
When http://localhost:8080/admin/movies is requested, the request works its way through the filter chain as in the previous cases.
This time, though, you already have a fully authenticated entity in the system.
The FilterSecurityInterceptor receives an access request to the URL /admin/ movies.
Then it recovers the necessary credentials to access that URL (ROLE_ ADMIN)
The AffirmativeBased access-decision manager gets called, and in turn calls the RoleVoter voter.
The voter evaluates the list of authorities of the authenticated entity and compares them with the required credentials to access the resource.
The FilterSecurityInterceptor forwards the request to the next element in the request-handling chain, which in this case is Spring’s DispatcherServlet.
The request gets to the AdminController, which simply returns the string movie x, which then gets rendered to the browser.
This is the complete flow of the Authentication and Authorization process.
Figure 4-16 shows this full interaction in a pseudo flow chart.
The Special URLs From the preceding explanation, you can see that Spring Security’s support for web security defines a few preconfigured URLs for you to use in your application.
The framework will redirect to this URL when an authentication is needed but doesn’t exist yet.
From the previous URLs, the first thing that comes to mind is how to configure your own Login form in the application and, in general, how to customize the login process instead of using the default one.
Custom Login Form When you configure the <http> element as you did before, Spring Security takes care of setting up a default login process for you, including a login URL, login form, default URL after login, and some other options.
Basically, when Spring Security’s context starts to load up, it will find that there is no custom login page URL configured, so it will assume the default one and create a new instance of DefaultLoginPageGeneratingFilter that will be added to the filter chain.
As you saw before, this filter is the one that generates the login form for you.
If you want to configure your own form, you need to do the following.
The first thing is to tell the framework to replace the default handling with your own.
You define the following XML element as a child of the <http> element in the file applicationContext-security.xml:
This element tells Spring Security to change its default login-handling mechanism on startup.
With the new configuration in place, restart the application and try to access the URL http://localhost:8080/admin/movies.
Error 404 that appears when defining a new login handler page.
Let’s create a LoginController controller next to the AdminController in the project.
LoginController that handles the /custom_login URL specified in the configuration file.
This will be the name of the JSP file that has your login form.
Now you create the fantastically designed login.jsp from Listing 4-10 in the folder WEB-INF/views in your application.
You also add the XML snippet from Listing 4-11 into the terrormovies-servlet.xml file.
If you type admin as both the username and password, you get access to the movie x page as you did before with the default login form.
If you take a look at the login.jsp, you can see certain names for the username field, password field, and action attribute of the form element.
Spring Security expects the use of these particular names in order to treat the authentication process correctly.
Also, the form should use POST for sending the information to the server because this is required by the framework.
Restart the application, go to the URL /admin/movies, and log in with admin/admin.
You should be able to access the application without any problem.
The other attributes you can configure in the <form-login> element are these:
By default, this URL is the root of the application.
In the default Spring Security configuration, this URL is /spring_security_login?login_error.
This is the same as the normal login URL with a parameter of “login_error” appended to it.
You can do something similar with your custom login page.
If you now restart the application and try to access the URL http://localhost:8080/admin/movies and use an incorrect username and password, you will get the Login page again, but with the error message shown at the top.
Look at Figure 4-19 for the page you should be getting.
Note that this URL could be a different URL altogether, not related to the login URL at all.
But the common pattern is to allow the user another attempt at login, showing her any errors.
This bean will be called on successful authentication and should handle the next step after authentication, usually deciding the redirect destination in the application.
A current implementation in the form of SavedRequestAwareAuthenticationSuccessHandler takes care of redirecting the logged-in user to the original requested URL after successful authentication.
A standard behavior for this handler is to present the login screen again or return a 401 HTTP status error.
Let’s develop a simple example implementation of the AuthenticationFailureHandler interface.
It will simply return a 500 status code when failing to authenticate.
Create the class ServerErrorFailureHandler from Listing 4-13 in the package com.apress.pss.
Then, in the applicationContext-security.xml file, replace the <form-login> element with the following:
And define the following Spring <bean> somewhere in that same file:
Restart the application, go to http://localhost:8080/admin/movies URL, use a random username and password, and click the submit button.
Basic HTTP Authentication Sometimes, you can’t really use a login form for authenticating users.
For instance, if your application is meant to be called by other systems instead of a human user, it doesn’t make sense to show a login form to the other application.
Web services talk to each other without user interaction, ESB systems integrate systems with one another, and JMS clients produce and consume messages from other systems.
In the context of HTTP-exposed interfaces that require no human user to access them, a common approach is to use HTTP basic authentication headers.
For example, if you use the  username bart and the password simpson, the client creates the string bart:simpson and encodes it prior to sending it in the header.
The first and only thing you need to do is replace the <login-form> element in your configuration file applicationContext-security.xml with the following one: admin/movies in the browser.
A standard HTTP authentication box pops up asking you for your authentication details, as Figure 4-21 shows.
Type admin as the username and password, and send the request.
You successfully arrive in the movie x page that you already saw a couple of times before.
When you use the <http-basic/> configuration element, Spring Security's BasicAuthenticationFilter comes into action.
A BasicAuthenticationEntryPoint strategy will be configured into the ExceptionTranslationFilter on startup.
When you make the first request to the URL /admin/movies, the framework behaves as before, throwing an access-denied exception that is handled by the ExceptionTranslationFilter.
This filter delegates to a particular implementation strategy of AuthenticationEntryPoint—in this case, BasicAuthenticationEntryPoint.
The client should know how to handle this code and work accordingly.
In the case of a browser, it simply shows the authentication pop up.)
When you introduce the username and password and submit the request, the request again follows the filter chain until it reaches the BasicAuthenticationFilter.
The filter creates a UsernamePasswordAuthenticationToken object and sends it to the authentication manager for authentication in the standard way.
The authentication manager will ask the authentication provider to retrieve the user and then create an Authentication object with it.
This process is standard and independent of using Basic Authentication or form authentication.
Its main purpose is to avoid sending clear text passwords on the wire, as Basic Authentication does, by hashing the password prior to sending it to the server.
Digest Authentication works with HTTP headers the same way that Basic Authentication does.
Digest Authentication is based in the use of a nonce for hashing the passwords.
It is passed through the digest computation together with the username, password, nonce, URI being requested, and so on.
In the authentication process, both the server and client do the digest computation and they should match.
The main processing lies in two classes: DigestAuthenticationFilter and DigestAuthenticationEntryPoint.
DigestAuthenticationFilter queries the request’s headers looking for the Authorization header, and then it.
DigestAuthenticationEntryPoint is the class that is invoked to generate a response that demands that a digest security authentication process begin.
This class sets the header “WWW-Authenticate” with the correct values (including the nonce) so that the client agent (the browser) knows it has to start the digest authentication process.
To configure it, let’s add the filter to the filter chain.
Listing 4-14 shows the two new beans you need to define in the file applicationContext-security.xml.
You also need to give the ID “userService” to the configured.
If you restart the application and try to go to the URL http://localhost:8080/admin/movies, you will be presented with a browser dialog box asking for a username and password exactly like the one that was shown for Basic Authentication.
As I explained before, the entry point will fill the response object with the required headers so that the browser knows it needs to show the login form.
Log in with a username and password of admin, and you should be able to access the requested URL.
The browser will create its own digested message with the password input included and put it in the header.
An example “Digest” header that is sent to the server with your current request is the following:
When the request reaches DigestAuthenticationFilter, the headers of the request contain the required digest authentication header.
The information in this header arrives as a csv string containing all the required information as I showed you in the last paragraph, including the nonce and the client nonce (cnonce)
A nonce is an arbitrary number used only once in a cryptographic communication.
The filter extracts the information from the header, retrieves the user from the UserDetailsService, and then computes the digest with the password from the retrieved user to see if the digest matches the one sent in the header by the client.
Remember-Me Authentication The remember-me authentication functionality is used for allowing returning users of the application to use it without needing to log in every time.
Basically, the application will remember certain visitors, allowing them to just open the application and be greeted with their personalized version of the application, as if they were logged in.
Remember-me functionality is very convenient for users; however, it is also very dangerous and recommended for private (from home) use only.
If you use an application from a public computer and this application remembers your profile information, the next person who accesses that application from that computer will be able to impersonate you with minimum effort.
It is also common practice to offer just a limited amount of functionality in the remember-me session.
This means that even if you are logged-in automatically thanks to the remember-me functionality, you won’t have access to the whole functionality of the application.
More sensitive parts of the application might require you to formally log in to use them.
When you visit Amazon.com and log in, the next time you visit Amazon, the site will remember you, your recommendations, your name, and other information about you.
But if you want to buy something, it will ask you to log in fully to access that functionality.
Remember-me authentication is typically supported by sending a cookie to the browser, which then, on subsequent sessions in the application, will be sent back to the server for auto login.
How does remember-me functionality work in Spring Security? Remember-me functionality in Spring Security is supported mainly by two components: the.
Let’s see how they work in the context of a request.
To enable it, include the following element inside the <http>
When the application starts up, the RememberMeAuthenticationFilter will be in the filter chain.
Also, a TokenBasedRememberMeServices will be instantiated and injected into the AbstractAuthenticationProcessingFilter replacing the no-op NullRememberMeServices.
Go and visit the URL http://localhost:8080/admin/movies, and log in with admin as the username and password.
When the request gets into the application, UsernamePasswordAuthenticationFilter (a subclass of AbstractAuthenticationProcessingFilter) will handle the authentication process in the standard way already explained.
After the authentication is successful, UsernamePasswordAuthenticationFilter invokes the configured TokenBasedRememberMeServices's loginSuccess method.
This method looks to see if the request contains the parameter _spring_security_remember_me in order to apply the remember-me functionality.
If the property alwaysRemember is set to true in the service, it will also apply the remember-me functionality.) Because you didn’t send this request, nothing will happen.
So let’s add the parameter to the login form you have.
You should now see a check box along with the username and password fields.
This time, the request carries the required parameter and TokenBasedRememberMeServices does its work.
It extracts the username and password from the Authentication object and creates a token with this information and a time to expire.
It basically concatenates these three values and the remember-me key specified in the XML element (terror-key)
And it creates an MD5 encoding out of the resulting string.
You should be able to access the page without logging in.
When this request gets in the system, it is intercepted by the RememberMeAuthenticationFilter, which gets into action.
The first thing the filter does is check that there is no current Authentication in the SecurityContext.
Because this means there is no user logged in, the filter calls the RememberMeServices’s autoLogin method.
In the standard configuration, the TokenBasedRememberMeServices is the concrete class that implements RememberMeServices.
Then it retrieves the UserDetails from the UserDetailsService with the username, recomputes the hashed value with the retrieved user, and compares it with the arriving one.
If they do match, the UserDetails is checked and an Authentication object is created and returned to the caller.
The autoLogin method extracts the remember-me cookie out of the request, decodes it, does some validation and then calls the configured UserDetailsService's loadUserByUsername method with the username extracted from the cookie.
It then creates a RememberMeAuthenticationToken object (an implementation of Authentication)
The RememberMeAuthenticationFilter then tries to authenticate this new Authentication object against the AuthenticationProvider’s implementation of RememberMeAuthenticationProvider, which simply returns the same Authentication object after making sure that the hash from the incoming request matches the stored one for the remember-me key.
This Authentication object will be used by the Security Interceptor to allow access to the requested URL.
Allowing Remember-Me Access to Selected Parts of the Application Remember-me authentication can be easily configured so that certain URLs require a fully authenticated user (meaning the user is explicitly logged in) to access them.
You have added the access rule IS_AUTHENTICATED_FULLY to the access attribute.
AffirmativeBased, as I explained in Chapter 3, grants access to a.
By default, both the RoleVoter and the AuthenticatedVoter are configured in the manager, and the RoleVoter is queried first.
The RoleVoter will vote to grant access, so the AuthenticatedVoter won’t be called at all.
You need to define a UnanimousBased access-decision manager in your Spring Security configuration and reference that one from the <http> element.
Let’s add the bean definition from Listing 4-15  to your applicationContext-security.xml.
The way this check takes place is straightforward: the voter simply checks if the Authentication object implementation is neither an AnonymousAuthenticationToken nor a RememberMeAuthenticationToken instance, assuming it is then a fully authenticated Authentication object and allowing access.
In this case, access will be denied because the Authentication object is a remember-me implementation.
This means that the login form will be shown even if a remember-me option was used previously.
Remember-me authentication supports the use of persistent storage, so the token is kept in a datastore and survives application restarts.
The main class supporting persistent remember-me storage is PersistentTokenBasedRememberMeServices, which extends from AbstractRememberMeServices the same way that TokenBasedRememberMeServices does.
To activate the use of the persistent functionality, you need to add the attribute file.
This way, you can reference a data source bean in the application context.
In this attribute you need to put a reference to a bean of type PersistentTokenRepository, or more exactly, an implementation of PersistentTokenRepository as that is an interface.
If you were to use the implementation JdbcTokenRepositoryImpl, it would be as if you were defining the data-source-ref attribute that I explained before, because this is what such an attribute does internally.
However, using the attribute token-repository-ref, you also have available the implementation InMemoryTokenRepositoryImpl, which is backed by a simple in-memory map and is recommended for testing purposes only.
You could also create your own implementation based on some other kind of datastore and inject it into your <remember-me> element.
Persistent remember-me tokens come with a nice feature in the current implementation, which is detecting remember-me cookie thefts.
In the persistent model, tokens are stored against a series-id.
A series-id is simply a random Base64 string that is generated whenever a successful login is done in the system.
This series-id will be part of the remember-me cookie (SPRING_SECURITY_REMEMBER_ME_COOKIE) that is sent back to the browser together with the token when this successful login happens.
Every time a new autoLogin request comes to the PersistentTokenBasedRememberMeServices, the cookie values (series-id and token) are extracted and compared with the stored ones.
If they both match, another token is generated for the same serial-id and the datastore is updated with this new token value.
If the series-id matches but the token doesn’t match, it is assumed that a cookie theft has happened (or basically two people have the same cookie)
This is assumed because, as I just explained, the series-id is a quasi-unique random number that is generated on successful login and maintained for that user in the cookie.
That means it is virtually impossible that some other user in a different browser will have the same series-id, unless he had the same cookie.
This is because every time a remember-me autologin is performed, the series-id is used to retrieve the token from the store and then the token is updated.
On subsequent requests, if a user’s token doesn’t match the stored one, this is because someone else accessed the autologin functionality from somewhere else causing the token to be updated for the user’s series-id, so that the old legitimate user token doesn’t match the one that is now stored.
When the system detects this, it throws a CookieTheftException and removes all the user tokens from the datastore.
This implementation from Spring Security is based on the following article: http://jaspan.com/improved_persistent_login_cookie_best_practice.
When you log out of an application, you want the application to end your current session, but also to remove any information it might have stored on the client for you.
The only thing you need to do by default is to visit the URL /j_spring_security_logout.
Remove the latest added IS_AUTHENTICATED_FULLY from the configuration XML file and restart the application.
Now go to the URL http://localhost:8080/admin/movies and log in with admin/admin again.
Now if you look at the cookies stored in your browser, you should see two cookies for the localhost domain: JSESSIONID and SPRING_SECURITY_REMEMBER_ME_COOKIE.
You would expect that if you log out, these two cookies disappear from the browser, basically removing any trace of the application from your browser.
If you open the cookies of your browser, you will see that the cookie SPRING_SECURITY_REMEMBER_ME_COOKIE is gone.
The JSESSIONID cookie exists, but the session was already invalidated by the framework.
When the request arrives, it follows the filter chain until it arrives at the LogoutFilter.
This filter notices that the URL that is being requested is for logout.
The filter calls the configured LogoutHandler(s), which in the running application are SecurityContextLogoutHandler and TokenBasedRememberMeServices.
The SecurityContextLogoutHandler invalidates the Servlet session, in the standard Servlet way, calling the invalidate  method on the HttpSession object and also clearing the SecurityContext from Spring Security.
TokenBasedRememberMeServices simply removes the remember-me cookie by setting its age to 0
Let’s remove the JSESSIONID cookie from the browser when logging out.
To enable the CookieClearingLogoutHandler handler, add the following XML element as a child of the <http>
After restarting the application, logging in, and logging out, you can go to the cookies section in your browser and you will see that the JSESSIONID cookie is no longer there.
The LogoutFilter, after calling the LogoutHandler(s), calls the LogoutSuccessHandler’s onLogoutSuccess method, which, in the default configuration, redirects to a target URL.
By default, this URL is the root of the application.
The target URL can be configured using either a request parameter or the referrer header from the request.
Replace your current <logout> element in the applicationContext-security.xml file with the following one:
And somewhere else in the same file, define the following bean:
After this is done, go and restart the application, go to http:localhost:8080/admin/movies, log in, and then request the following URL:
AbstractAuthenticationTargetUrlRequestHandler, which is also used by the authentication process to redirect to a determined URL after authenticating successfully.
Both the successful authentication and successful logout use a redirection strategy for request handling.) You can go ahead and try it out using the attribute authentication-success-handler-ref in the <form-login> element and ensuring that your login form sends the required parameter for the redirection.
The Session (javax.servlet.http.HttpSession) and the SecurityContext Traditionally in Java web applications, user session information is managed with the HttpSession object.
In Spring Security, at a low level, this is still the case.
However, as I mentioned before, Spring Security introduces some new concepts for handling user-session information.
In an application using Spring Security, you will rarely access the Session object directly for retrieving user details.
Instead, you will use SecurityContext (and its implementation class) and SecurityContextHolder (and its implementing classes)
The SecurityContextHolder allows quick access to the SecurityContext, the SecurityContext allows quick access to the Authentication object, and the Authentication object allows quick access to the user details.
Go ahead and modify the current AdminController to look like Listing 4-16
Remember not to remove the package declaration or the imports from the file.
Let’s make it more interesting and add more information to your Users.
You will make your users have a last name and first name.
A message with username information extracted from the Authentication object.
You want to keep the InMemory model of storing and retrieving users, but you need a more flexible user model.
Our user model needs to implement directly or indirectly the UserDetails interface.
So let’s create the User class from Listing 4-17 in the package com.apress.pss.terrormovies.model.
You also need to create your own InMemory user details service, because the default one will create Spring Security’s own User instance and not your custom class instances.
In the package com.apress.pss.terrormovies.spring, create the class CustomInMemoryUserDetailsManager from Listing 4-20
Let’s restart the application, visit the URL http://localhost:8080/admin/movies, and log in.
Application using a custom User object and accessing the last name of the user.
SpEL makes it possible to use programming expressions inside bean definitions and other parts of the Spring portfolio—for example, in some annotations you will see later, which allows you to manipulate objects at runtime.
It basically allows the developer to embed code in the configuration files as simple strings and then evaluate those strings at runtime, very much like a dynamic language would allow you to.
Following is the current supported functionality of SpEL extracted directly from Spring documentation at http://static.springsource.org/spring/docs/3.0.x/reference/expressions.html:
The first one we are going to look at is web-layer security using SpEL.
It should come as no surprise that Spring Security’s main Web support for SpEL is configured using Servlet bit.
This time, when the Spring namespace parser mechanism is parsing the XML, it will notice that this attribute is in the <http> element.
When creating the FilterSecurityInterceptor bean definition, it adds a definition of ExpressionBasedFilterInvocationSecurityMetadataSource to it.
This final class will be used at startup to map URLs to SpEL parsed expressions.
In the default case, it will also add a WebExpressionVoter to the list of voters configured in the access-decision manager.
Let’s remove the custom access-decision manager bean from the configuration file, and let’s also remove the corresponding reference from the <http> element (the attribute access-decision-manager-ref), and let it use the default one that is configured when none is explicitly set.
When using the expression support, now the value in the access attribute of the <intercept-url> element will be interpreted as a SpEL expression.
Remember that before it was either a role or a value like IS_FULLY_AUTHENTICATED.)
Restart the application, go to http://localhost:8080/admin/movies, and log in with admin/admin.
Before and after logging in, the access-decision manager will make a call.
The WebExpressionVoter retrieves the attribute hasRole('ROLE_ADMIN') from the configuration for the.
Then it creates a SpEL evaluation context using the Authentication object and the FilterInvocation object.
An evaluation context is where references are resolved when encountered during expression evaluation.
In this case, an instance of WebSecurityExpressionRoot is created and used as the root of the evaluation context.
This means that methods called on the SpEL will evaluate against this root object.
In other words, the WebExpressionVoter for this particular expression will call the method hasRole in an instance of the class WebSecurityExpressionRoot.
If you go to the source of the class WebSecurityExpressionRoot and into its class hierarchy, you will find all its available variables and methods for access through expressions.
Restart the application, visit http://127.0.0.1:8080/admin/movies, and log in with admin/admin.
You should be able to access the page without a problem.
Extend with Your Own Expressions Although the default functionality offered by the expression-handling mechanism is rich, sometimes you might need to add more expressions that are not readily available.
Suppose that you want to support an expression such as “over18.” For that, you need to add your own ExpressionHandler to the configuration:
Define the following as a child element of the <http> element:
Create the class CustomWebSecurityExpressionHandler, as shown in Listing 4-22, in the package com.apress.pss.terrormovies.security.
This class instantiates the CustomWebSecurityExpressionRoot  you will create in the next step.
This class is needed because the default one, DefaultMethodSecurityExpressionHandler, has hardcoded the construction of MethodSecurityExpressionRoot.
Create the class CustomWebSecurityExpressionRoot as shown in Listing 4-23 in the the new method  you want to make available to the SpEL expressions.
Then create the following bean somewhere in the applicationContext-security.xml file:
At the end, your applicationContext-security.xml file should look like Listing 4-24
Restart the application, go to http://127.0.0.1:8080/admin/movies, and log in with admin/admin.
You should be able to reach the page without problems.
As you can see from the preceding description, SpEL can be really powerful and you can make it do almost anything you want, provided that you execute the expressions in the context of the object you need.
Basically, you could extend the expression root as much as you want to handle different methods that you can then use in your expressions.
Switching to a Different User Sometimes a user (normally an admin user) needs to execute an operation with the permissions of a different user.
Suppose that in our dumb application we have a new URL and access to it is allowed only to users with role ROLE_USER.
This role allows us to retrieve information for users of the application.
Create a new controller named MovieController in the package com.apress.pss.
The inMemoryUserServiceWithCustomUser bean with a new standard not admin user.
A user with access to the movie list through the role ROLE_USER.
Log in again with username admin and the password admin.
Both URLs need to be secured so that only the users who are allowed to switch users can use them.
In this case, they will be secured with a ROLE_ADMIN attribute.
Add the following two lines as children of the <http> element in the configuration file:
Add the filter into the filter chain, because it is not configured by default.
Restart the application, visit http://127.0.0.1:8080/movies/member/1, and log in with admin/admin.
The way this whole process works is by creating a new Authentication object with the user whom you are trying to impersonate as the principal.
Then the filter creates a new Authority for this new Authentication of type SwitchUserGrantedAuthority, which contains the original Authentication inside.
When you decide to exit the switched user, you can get back to your original Authentication.
Session Management Another area of Spring Security’s web support is the management of user sessions.
One very important thing to do regarding sessions is to make sure you create a new session ID when a user authenticates successfully.
Doing this reduces the likelihood of session fixation attacks, in which one user sets another user’s session identifier to.
Spring Security also offers a feature you can use to specify the number of concurrent sessions that the same user can have open at any given time.
These two features come in the form of the two classes SessionFixationProtectionStrategy and ConcurrentSessionControlStrategy (with the second one being a subclass of the first)
SessionFixationProtectionStrategy is already configured by default in the UsernamePasswordAuthenticationFilter that is configured in the application.
So when you log in, this strategy will be invoked.
When the strategy is invoked, it retrieves the current session (which is normally the anonymous session) and invalidates it.
It also tries to migrate certain attributes—normally, the ones used by Spring Security itself, but a list can also be specified.
To summarize this strategy, when you log in it invalidates the current session, creates a new one, and copies certain attributes from the old one to the new one.
By default, this strategy determines that a maximum of one session can be active for any user at any given time.
In the following step-by-step explanation, I assume Chrome and Firefox are accessible to you:
You should be able to access the page without a problem.
You should be able to access the page without a problem.
Change the value in the attribute max-sessions of the element before.
This time, you should have both sessions active at the same time.
At runtime, when a request arrives in the system, DefaultFilterInvocationSecurityMetadataSource sends the request to each of the configured RequestMatcher instances (more precisely, to one of its implementations) to see if they match that particular pattern and then retrieves the attribute needed to access the pattern.
Spring Security offers a few RequestMatcher implementations beyond the Ant one.
It basically supports standard Java regular expressions and standard Java case-insensitive regular expressions.
To enable support for using these matchers, you simply need to add the attribute request-matcher to the <http> element specifying the type of matcher your patterns will use within the values ant, regex, and ciRegex.
I won’t cover this here in any depth, because the idea is the same as for using Ant expressions.
Forcing the Request to HTTPS By default, the Spring Security–enabled application serve all content through the normal HTTP channel.
However, you can configure them so that they automatically ensure a particular web request is delivered over the HTTPS channel.
Note N  I’m assuming that, in general, you know the advantages of using HTTPS over HTTP.
First, it allows a connecting client to authenticate the web server that it is connecting to, ensuring that it is connecting to the proper certified website.
The other security concern addressed by HTTPS is the encryption of the information that is exchanged between client and server.
You can find more extensive information on this topic in Wikipedia (http://en.wikipedia.org/wiki/HTTP_Secure) and in many other places.
Setting this up is straightforward; you simply need to add a new configuration element to your Spring Security configuration.
If you do this, however, your current application won’t work.
The problem is that the Maven Jetty plugin  you use to start the application, by default, doesn’t recognize the 8443 port for SSL communication.
So the only thing you need to do here is replace the current pom.xml’s plugin section with the one in Listing 4-29
After that last step, you can restart the application and visit the URL http://localhost:8080/admin/movies as you have always done in this chapter.
This time, the application will automatically redirect to the URL https://localhost:8443/custom_login.
When the application starts up, the namespace parsing mechanism will note the presence of the attribute.
The class HttpConfigurationBuilder finds this attribute and then creates a map of RequestMatcher, ChannelAttributeFactory.
ChannelAttributeFactory creates ConfigAttribute instances based on the value of the requires-channel attribute.
For example, if the required channel is HTTPS, it creates an instance of an implementation of ConfigAttribute with the value REQUIRES_SECURE_CHANNEL associated with the appropriate URL pattern.
After the parser finds at least one intercept-url with the requires-channel attribute configured, it instantiates a new ChannelProcessingFilter bean configured with a ChannelDecisionManager implementation for deciding which channel to use for each request.
When a request is made, it will, as normal, travel through the filter chain.
There is a filter in the filter chain called ChannelProcessingFilter, as explained in the previous paragraph.
This filter delegates to its configured ChannelDecisionManager implementation the responsibility of deciding what to do with the request.
The decision manager, with the aid of certain helper classes, decides if the request can proceed or if, on the contrary, the requested channel is not admitted by the requested URL.
In the latter case, it delegates to a ChannelProcessor and a redirection strategy to send a redirect response to the proper channel URL.
Using the JSP Taglib Spring Security’s web offering comes with a nice suite of view-layer tags you can use to configure the presentation of your application according to the user who is currently logged in.
The taglib is oriented mostly to JSPs as a view technology, although in Spring Security 3.1 a new class hierarchy was introduced to support different view-rendering technologies.
The taglib comes packed with plenty of security-oriented tags and attributes.
Here is a full list of supported tags and their attributes:
It determines whether to hide or show data based on whether the requesting user has the proper authorization rights as expressed by the various attributes of this tag.
This attribute uses the same mechanism that you saw when I was explaining the use of expressions for securing URLs.
As a matter of the <http> element in your Spring Security configuration file.
When using this attribute, the AccessDecisionManager decides whether the current user has access to the requested URL.
The decision is based on which HTTP method was used in the current request.
It will show the content of the tag only if the user doesn’t have any of these roles.
It will show the content of the tag only if the user has all of these roles.
It will show the content of the tag only if the user has any of these roles.
It also allows you to render content conditionally based on the rights of the user on domain objects.
I will cover the first two tags here; for the third, please refer to Chapter 7
First, let’s create a new method in MovieController that allows both.
Create the method from Listing 4-30 in the MovieController class.
This new method simply creates one list of movies and passes it to the view as a ModelAndView Spring MVC object.
The important part is that you are using the standard jstl tag library to iterate through the list of movies  you are expecting to get back from your controller in the model.
Then, you use the <authorize> security tag that I explained before to secure certain parts of the view.
You can see that users with the role ROLE_USER can see the movie name.
Users with the role ROLE_VIP can see the movie budget.
Restart the application now, visit the URL http://localhost:8080/movies/, and log in with a username of paco and a password of tous.
Then visit the URL http://localhost:8080/movies/ again, and log in with the username lucas and the password fernandez.
In the “authentication” one, you are accessing the principal and the last name of the user.
In the “authorize” one, you are allowing only certain content to be shown based on the role of the logged-in user.
If you want to use the same conditions again later in the page, you can use the var attribute to cache the result of the condition evaluation so that you don’t need to evaluate it again.
For example, replace your movies.jsp with the content from Listing 4-32
If you do the same when logging in with the username of paco  and a password of tous, you won’t see the message output on the page.
Role Hierarchies So far, you have worked with simple roles assigned to users.
Spring allows you to do exactly that with the use of hierarchical roles.
That method returns all the reachable authorities for a particular list of authorities, which basically means all direct assigned authorities plus all the authorities that are children of those direct authorities.
Then it needs to make those available as GrantedAuthority objects to be queried and returned by the class’s main method.
The second class to set up is RoleHierarchyVoter, which extends from RoleVoter and simply delegates to RoleHierarchyImpl to retrieve the reachable roles for a particular user.
It then uses those roles for voting on accessing or denying access according to the logic from the RoleVoter class.
To make it simple and focus just on this functionality, go ahead and replace your whole applicationContext-security.xml file with the one from Listing 4-33
The preceding code demonstrates practically everything I’ve explained so far in this section.
The new things that you haven’t seen before are the last bean and its internal anonymous bean.
Here you are defining the new AccessDecisionVoter that is aware of role hierarchies, and RoleHierarchy itself.
Then you are assigning this voter to the AccessDecisionManager you configured (the AffirmativeBased one)
As you can see in the configuration file applicationContext-security.xml, this is a URL secured for users with the role ROLE_USER.
When the page shows the login form, log in as an admin user.
The one you have is “car”, so log in with a username of car and a password of scarvarez.
In previous examples, you would not be able to access the page; however, thanks to the hierarchical roles, now you are able to access the page, as Figure 4-30 shows.
Summary In this chapter, I covered one of the biggest concerns of the framework: web support in Spring Security.
You saw that the main functionality comes in the form of Servlet filters.
This is a good thing from a standards point of view, because it means you can leverage Spring Security web support in other frameworks that use the standard Java servlet model.
It can be used for simple Servlet applications as well, as shown in Chapter 2
You should now know a lot of details about the main filters that build the framework, how they work internally, and how they fit within each other and with the rest of the framework.
I explained all this in a practical way, trying to solve real-life scenarios (although in a not very real use-case)
I also explained how to attack them in a step-by-step process.
You should be able to understand both role-based security and the power of using SpEL for security rules.
You learned also how to extend the standard SpEL functionality to support new expressions.
You can now use the taglib support included in the framework to customize the user interface, depending on security constraints.
In the next chapter, I will cover the second major concern of Spring Security—namely, method-level security.
I will show you how it compares to web-level security, and you will see that you can leverage a lot of your current knowledge to apply it to the method-level security layer.
This chapter will drill down further into the core functionality of Spring Security.
Unlike in the previous chapter where I focused only on the web-level access to the application, here you will.
It can be seen as a more invasive type of configuration because it involves securing at the code level, while the web layer simply was concerned with URL matching.
However, you will see how the elegant way in which Spring can manage aspect-oriented programming (AOP) concerns will make business-level security as unobtrusive as its web-level counterpart.
The Limitations of Web-Level Security In the previous chapter, you established security constraints at the web layer of the application, mainly at the URL level and the view-rendering layer.
This is very nice and powerful; however, it is not a 100 effective solution in every use case.
The main concerns with applying only this kind of security are both functional and convenience related, as I will explain next.
First, by definition, web-layer security applies only to web applications, which makes it unusable for any other kind of Java application.
Although Spring Security’s main focus is on securing web applications, there is no reason why some of its parts can’t be used for different kinds of applications.
Second, the URL pattern-matching mechanism for security, although flexible, requires the developer to adopt certain rules or conventions just for the sake of security (like creating an /admin/ URL namespace for admin users and setting administrator rules on those URLs)
Third, securing at the URL level creates only a coarse-grained security, as a URL is the entry point into the application.
This means that security constraints are enforced on a per-request basis, greatly reducing flexibility.
For example, if you want to ensure that a particular Data Access Object (DAO) in your application is called only by an administrator user, you can’t do that with web security alone.
You need to make sure that all the URLs that call this DAO are secured for Admin users.
If, for some reason, you have a URL that is not secured correctly, that request will freely reach the DAO layer, where it could execute a potentially delicate operation.
You can surely find a few more reasons why web-only security is not enough sometimes, or simply not convenient enough to use by itself in your applications.
What Is Business Service-Level Security? Service-layer security (or more accurately method-level security) is a feature of Spring Security you use to enforce security constraints at the method level, much as web-level security does at the URL level.
At its core, method-level security relies on Spring AOP’s powerful support for providing you with its services.
This is the main difference in implementation with web-based security that depends on Servlet Filters, although it is worth noticing that under the hood most of the core code that will take care of the security constraints is the same.
This is of great importance, as it shows good care in designing a set of reusable and encapsulated components in the architecture.
As I said, service-layer security is normally used in combination with web-based security, and I will cover this scenario mostly in this chapter.
However, as you will see later, you can use service-layer security by itself without the context of a web application.
The traditional scenario for working with Spring Security is this: You have a web-based application, with a relatively thin web layer, backed by one Spring-implemented business service layer.
With regard to security, the web layer is configured to take care of ensuring that there is a user authenticated in the system (that is, it takes care of the authentication part of the security, using forms, http status codes, and so on)
The service layer has the authorization rules in per-operation criteria and with the needed level of granularity.
Most of the time, you secure the business services; some other times, you might need to secure the DAOs.
Setting Up the Example for the Chapter Let’s start doing some work and see how this whole thing works.
You will be using the same application from last chapter, so make sure you have it at hand.
So you need to add support for it in your application.
The only thing you will do to support it at the moment is break your classes (the ones you want to decorate with security concerns) into interfaceclass hierarchies.
For a start, you do this with the AdminController, creating an AdminController interface and an AdminControllerImpl implementation class, as you can see in Listing 5-1
You can see that I copied the Spring model view controller (MVC) annotations into this new interface.
If I had not done this and had left them on the implementation only, Spring MVC wouldn’t be able to find them when looking for a method to handle the incoming requests.
Note N  Normally, in simple controllers, you can keep the @RequestMapping annotations on the implementing class without needing to create an interface.
However, in the case of this example, you need to put the annotation on the interface because you will use security annotations in the class, which automatically will create a proxy object that needs the presence of an interface—for using standard Java Development Kit (JDK) proxy objects, as you will see in the upcoming paragraphs.
This proxy won’t know about the @RequestMapping annotation, so Spring’s MVC mechanism won’t be able to find the handler methods.
Later I will put the security annotations where they belong, in the service layer.
I’m putting them now in the controller simply to illustrate the simplest scenario.
In real life you would not do it this way and instead you would add it to the service layer as I will show you later in the chapter.
It is important anyway to bear in mind this behavior when working with Spring MVC or any other part of Spring that uses proxy objects around your objects..
Spring AOP comes in two flavors: standard java proxies that work with interfaces, and CGLIB support that creates proxies at the implementation-class level.
This new decorated object will be the actual bean used in the framework, transparently replacing the original object whenever it is accessed within the Spring application.
Basically, if you inject your defined bean into another bean, the object instance that gets injected is the proxy.
It then delegates to the original class of the object for the core behavior.
In general, Spring favors standard interface-based proxies instead of CGLIB, and that is what I will use in this book.
Listing 5-1 demonstrates how a new interface is added to allow Spring to use JDK proxies to enable cross-cutting concerns.
The next thing you’ll do is activate method-level security in the framework.
To do this, you open the applicationContext-security.xml file and leave it as it is shown in Listing 5-2
You can see that I removed a lot from the file, including the <intercept-url> elements.
That means you are no longer enforcing security at the URL level.
You still want your administration operations to be available only to administrator users, so I configured the AdminController to be accessible only by users with ROLE_ADMIN in their list of roles.
To do that, you simply need to add the annotation.
Note N  The @Secured annotation also can be used at the class level instead of at the method level.
If it’s used at the class level, all public methods of the class will inherit the behavior specified by the annotation.
A combination of class-level and method-level annotations also can be used.
In this case, method annotations will override the values of class-level annotations.
If you restart the application now and access the URL http://localhost:8080/admin/movies, you will be able to access it.
It will throw an exception, but one that is related to a class cast exception, as you can see in Figure 5-1
This exception is thrown because the @Secured annotation is not being detected by the framework for reasons I will explain next; and there is no User object instantiated at the point where the exception is thrown.
Instead, the application is using the anonymous authentication, whose principal is a string, which it then fails to cast to a fully built User object.
Non-security-related exception trying to access the application because the @Secured annotation is not being picked up.
As I said, you shouldn’t have been allowed access to that page, as you have configured the method-level annotation to ensure that only administrators can access it.
The problem is that the XML configuration element <security:global-method-security need to add it to the terrormovies-servlet.xml file to be able to use the annotations in the controller layer.
Note N  The way global-method-security works at startup is explained in Chapter 3
Refer to that chapter for an explanation of the startup process.
You can see that if you try to access the URL http://localhost:8080/admin/movies, you get redirected to the already familiar login form.
This means that the security annotation is now finally working.
How the Described Actions Happen Under the Hood The main work for enforcing the authorization process now happens in the MethodSecurityInterceptor, which is the method-level equivalent of the FilterSecurityInterceptor.
They both extend from the same abstract class AbstractSecurityInterceptor.) Remember that the main difference is that, in this case, Spring AOP mechanisms get into action to enforce security by decorating the method call, while in the filter case, the Servlet Filter standard itself helps to validate and enforce the constraints by intercepting the HTTP request.
Figure 5-3 shows how the MethodSecurityInterceptor executes within a proxy object around the target object (AdminControllerImpl)
Login form shown after ensuring that the @Secured annotation is being picked up.
The whole process works like this: As I explained before, on startup our AdminControllerImpl bean gets wrapped by Spring AOP into a Spring Security–aware AdminController implementation, also known as the Proxy object.
This proxy has all the information it needs to enforce security at the method level.
The main part of this information is an instance of MethodSecurityInterceptor that lives inside the Proxy object.
The Proxy object takes the target object (the original bean instance of AdminControllerImpl), the invoked method, and the arguments to the method (if there is any) and sends them to an instance of org.springframework.aop.framework.JdkDynamicAopProxy.
This object’s proceed method is invoked, which in turn invokes the MethodSecurityInterceptor’s invoke method, passing itself as a parameter.
So the MethodSecurityInterceptor will do this before invocation; after invocation, it checks around the real target method logic, the same way that the FilterSecurityInterceptor did.
The MethodSecurityInterceptor’s before-and-after logic is exactly the same as that for FilterSecurityInterceptor.
The difference is the implementation strategy of SecurityMetadataSource that each approach uses.
MethodSecurityInterceptor uses an instance of DelegatingMethodSecurityMetadataSource, which knows how to extract security metadata out of a ReflectiveMethodInvocation instance.
In the current execution, this SecurityMetadataSource finds the value "[ROLE_ADMIN]" in the method invocation.
Later, this will be used by the AccessDecisionManager’s current implementation (normally, ProviderManager) and the RoleVoter to decide whether or not access is granted, in exactly the same way as with the FilterSecurityInterceptor.
Creating a Business Layer in Your Application Although I have shown you how to use security annotations at the method level for your controllers, the truth is that you can use these annotations in any layer of your application, and normally they are used at the business service layer.
As a matter of fact, you probably won’t ever use them in the controller layer.
I only used them in that layer in the first part of the example to introduce the concepts step by step.
The only constraints to using security annotations in the service layer, as explained before, are that they have to be used in Spring managed beans, which can be proxied, and they can be applied only in public methods that can be proxied.
Note N  Remember that Spring creates a proxy that wraps your objects.
This proxy is visible only to external callers of methods in the object through the proxy interface.
Once a call reaches the object, any internal method calls within the object itself are not proxied and go directly against the object itself, so no AOP is applied in internal calls.
For continuing with the explanations for this chapter, let’s create a thin business layer where you will start adding your security constraints.
In a new package named com.apress.pss.terrormovies.service, let’s create the interface and class from Listing 5-3
JdkDynamicAopProxy is called by the proxy and invokes the interceptor.
Then replace our MovieController with the one from Listing 5-4
MovieController functionality simply Delegates to the MoviesService for Getting the Model which in this case is a Movie.
If you visit the URL http://localhost:8080/movies/die hard, you once again will be redirected to the login page.
Log in with "lucas" as username and "fernandez" as password and you should be able to access the requested page as expected.
Make sure you have a proper toString implemented in your Movie.java file.
Access granted in the service method for seeing the movie.
So you have moved the security authorization logic to the business layer and left the controller with the single responsibility of coordinating interactions and mapping views to models.
This should be the practice you implement most often, and as I said before, you normally won’t have security configured at the method level in controllers.
Note that although the authorization process has been moved to the business layer, the authentication process still exists in the web layer and the filter-chain logic.
This is the most common scenario where Spring Security fits in: a web-based front end application with a Spring-powered back-end business layer.
You will see later how you can use Spring Security in a non-web-based application.
This advantage also implies that someone coming from a JavaEE background, without Spring knowledge, can understand what is happening when she sees this annotation in place.
Note N  My attitude to standards is that using them is good, as long as they provide you with the functionality you need.
In my mind, you should not depend on the standards to drive your work.
Your work and your needs should be driving the standards, and the minute you can’t do it with standards you should consider finding a simpler solution that works (or develop it yourself if it is worth the effort), instead of trying to tweak the standard to work in an awkward way just to say that you still work within the standard.
I used to be a bigger believer in standards in Java, but my attitude has changed a lot through the years I have been developing software.
I tend to look for simple solutions that, to my eyes, look more elegant than unjustified complex systems.
My last experience was a few years ago when comparing different integration solutions (ESB-like tools)
But trying to get an understanding of OpenESB and Java Business Integration (JBI) was definitely not as straightforward.
This is a large subject of debate and is definitely outside the scope of this book.
To make @RolesAllowed work in your application is pretty simple.
Add the dependency from Listing 5-6 to the pom.xml file.
Now if you restart the application and access "http://localhost:8080/movies/die hard" from your browser, the behavior should be the same as before.
Again, it behaves pretty much like the RoleVoter, but it will make a decision based on the jsr250 annotations.
Securing the Application Using SpEL Expressions As in the case of web-based security, at the method level, you can use SpEL expressions to define security constraints.
This attribute gives you access to four different annotations in your methods.
The following annotations are all in the org.springframework.security.access.prepost package in the core module of the framework:
The argument to which it is applied needs to be a java.util.Collection type that responds to the remove method.
Basically, the SpEL expression is evaluated against each element in the collection, and if the expression evaluates to false, the element will be removed from the collection before it is passed to the method.
The returned value needs to be a java.util.Collection implementation that responds to the remove method.
The expression is evaluated against each of the elements of the returned collection.
If the expression evaluates to false for an element, the element will be removed from the collection.
You can use this annotation to make access decisions even after the target method has been accessed.
Remember that AbstractSecurityInterceptor has two concrete implementations: MethodSecurityInterceptor and FilterSecurityInterceptor.
However, the before and after processing are the same in both cases and it is inherited (both pre and post processing functionality) from the abstract class.) They are evaluated by a dedicated AccessDecisionVoter implementation.
The org.springframework.security.access.prepost .PreInvocationAuthorizationAdviceVoter delegates further to an instance of org.springframework.security.
Let’s take a look at the use of these annotations one by one.
In your current MoviesServiceImpl class, you replace the @RolesAllowed("ROLE_USER") annotation in the.
You then add import import org.springframework.security.access.prepost.PreAuthorize; to the list of.
You will be denied access and shown the login form.
The EvaluationContext is the context in which the SpEL expressions will be evaluated.
In Spring Security’s method invocation support, an instance of MethodSecurityEvaluationContext is created, which extends the Spring Core’s standard org.springframework.expression.spel.support.StandardEvaluationContext and adds support for accessing method parameters as variables in the SpEL expressions, as you did with the #name variable in the current example.
The “hasRole” expression you are using is defined by the org.springframework.security.
In the previous chapter, you looked at the methods that the interface SecurityExpressionOperations expose to be used from the SpEL expressions for web security.
This means you can use the same expressions I talked about before, like getAuthentication, isAnonymous, hasRole, and so on.
As you already should know, the MethodSecurityInterceptor wraps the call to the target method call between the beforeInvocation processing and an afterInvocation processing.
This behavior is inherited from the AbstractSecurityInterceptor from which the FilterSecurityInterceptor also inherits.
Access denied page you get because the SpEL expression in a @PreAuthorize failed an evaluation.
In the afterInvocation step (which is, in fact, a method in the AbstractSecurityInterceptor), an AfterInvocationManager implementation instance is consulted to make a final call in deciding if everything is OK to return the response to the requesting user.
The AfterInvocationManager delegates to a list of AfterInvocationProvider(s) implementation instances to make the final decision.
When you configured the use of expressions for method security in the configuration XML, an instance of PostInvocationAdviceProvider was configured, at startup, in the list of AfterInvocationProvider(s) inside the AfterInvocationManager.
If one attribute is found, an instance of ExpressionBasedPostInvocationAdvice is called.
Here, in this class, is where the expression context will be set up in order to evaluate the SpEL expression.
The expression context is set up the same way it was for the @PreAuthorize use case.
Let’s create another movie in the map you have in the MoviesServiceImpl class.
In the static block, add the the getMovieByName method and instead add the following one: @PostAuthorize("T(java.lang.Integer)
The first part, T(java.lang.Integer.parseInt), is simply getting hold of the static method parseInt from the class java.lang.
The parameter to parseInt is the property "budget" of the object returned from the model (the Movie object)
After this is done, if you restart the application and visit the URL http://localhost:8080/movies/two days in paris, you should be able to access it without a problem.
In this case, you don’t even need to log in, as you are not making constraints on the authenticated user.
Figure 5-9 shows the screen you see if you are following along.
Note N  Actually, you will get first the familiar login form.
You get the login form here and not in the previous case because that is the standard way Spring Security handles Access Denied errors in the framework when there is not a fully authenticated user accessing the system.
This means that before you log in, when an AccessDeniedException is thrown, Spring Security will note that there is no authenticated Authentication instance for the user trying to access the site.
There is probably only an AnonymousAuthenticationToken instance.) Spring Security will show the form, offering the user the opportunity to log in.
After the user logs in, if he gets the AccessDeniedException again, this time an error message is shown informing him that he is not allowed to access the requested resource.
You can see from this example that you have access to the returned object from the method in the SpEL the returned object.
As I commented before, the expression context in which the SpEL expressions are executed uses an instance of org.springframework.security.access.expression.method.MethodSecurityExpressionRoot as the root object as I said before.
Here, I will explain the general usage of these annotations and leave the ACL coverage for the next chapter.
The @PreFilter annotation allows you to filter collection parameters based on arbitrary expressions, removing certain elements so that they don’t even arrive at the target secured method.
Remember also to add these new methods you are creating to create movies in the server by sending them in a CSV string.
Next, restart the application, access the URL http://localhost:8080/admin/movies, and log in with "admin" "admin"
You get to the new movie’s page, which shows you the title and budget.
An error page is returned because an exception was thrown.
Figure 5-12 shows the important part of the error page, which says that it is trying to get the budget property from a null object.
Of course, you wouldn’t want to show that in real-life, productionready applications; instead, you would show a properly formatted, friendly error page and message.
I haven’t done anything in that regard because it isn’t relevant to the concepts I want to show you.
Inside the value of the annotation, you can use the special variable filterObject (which is really a getter method inside MethodSecurityExpressionRoot)
This variable references each of the elements of the collection that is being passed to the method.
Basically, when you are using this annotation, the expression handler iterates through the elements in the collection, sets the filterObject value in the expression root.
Next we see the listings for the jsp, controller and service updates referenced in the previous paragraphs.
This is the code needed for showing a form to the user and allow him to create movies.
The difference is that @PostFilter annotations are evaluated after the target method returns, and the SpEL expression in the annotation is evaluated against the returned collection from the target method.
As with the @PreFilter annotation, it applies only to collections and arrays.
If the return type is neither of these two, the DefaultMethodSecurityExpressionHandler (which is the one evaluating the expressions) will throw an IllegalArgumentException.
Let’s create a couple new methods and a new simple jsp file.
For the rest of the users, these movies will be filtered out from the returned collection so that the jsp won’t have access to them.
First, you add the method from Listing 5-10 to the MoviesServiceImpl class.
Next, you add the method from Listing 5-11 to the MovieController.
This method calls the service method and wraps the result in a model to be rendered in the view.
Finally, you create the jsp file that will support showing all the movies.
You create the file allMovies.jsp from Listing 5-12 in the folder WEB-INF/views.
Note N  In a real application, of course, you wouldn’t ask your users to manually visit the URL http://localhost:8080/j_spring_security_logout.
You would most likely have a Log Out link the user could click to log out.
You can see how powerful security is when it’s based on the SpEL expression.
You can use this approach to define and combine different expressions to achieve security at different levels of granularity.
In the current example, I was explaining only the way the annotation works and how to use useful expressions to filter out elements from a collection.
But the truth is that there is nothing particularly unsecure in returning the movies with budgets greater than $5 million to standard users in our current application.
Security Defined in XML Annotation-based security is the most common solution that developers, using Spring Security, utilize when creating their business-layer security constraints.
As with most of the Spring suite of products, Spring Security security can be configured using XML configuration files.
There are supporters and detractors of both types of configurations (annotations and XML), and undoubtedly there are good and bad parts to either.
One very good thing about the XML configuration for securing methods is that it can be applied to more than one method of more than one class at the same time using AspectJ pointcut expressions—the same way you would in the rest of Spring Security’s suite of products.
Here, I will just give you a quick overview to help you use it in our example.
The most common pattern used in pointcut expressions is to match an undefined list of methods based on these methods’ signatures.
Let’s say you want to make all your methods in MoviesService available only to users with ROLE_ADMIN.
For that, let’s remove all annotations from the MoviesServiceImpl class except for the @PostAuthorize one in getMovieByName, as you want to see how you can combine annotation security with XML configuration.
You can combine both methods (annotations and XML) to meet your particular set of requirements.
So your MoviesServiceImpl class should now look like Listing 5-13
Next, you add the required XML configuration to guarantee that these methods are called only by a.
For that, you simply add the dependency from Listing 5-14 to your pom.xml.
If you restart the application and visit the URL http://localhost:8080/movies/, you will be redirected to the login screen.
On the other hand, if you log in with "admin", "admin", you are granted access to the page and will be able to see the movies on the page, which looks like Figure 5-13 again.
You can see how powerful the XML configuration can be in grouping many methods into a single expression to secure them all at the same time.
The AspectJ expression language for pointcuts offers a lot of flexibility to determine which methods to match against.
For example, you could specify all methods named "doSecured" (or any other name) in your application to be secured, or methods that receive a particular parameter type, or that return a particular type.
Another way to handle security concerns in the XML configuration file is with the use of the element be secured and how they should be secured.
This is, to me, the less convenient way of securing your methods, as it removes the clarity of the annotations, and at the same time, removes the flexibility of the pointcut XML expressions.
Basically, it just adds XML verbosity in a place where some elegant annotations will do the same job.
This is all the configuration you need to do for securing that one method.
If you restart the application now and visit the URL http://localhost:8080/movies/, the login form will appear on the page.
If you log in with "admin", "admin", you be granted access to the page.
You have effectively secured the method for only ROLE_ADMIN users.
You can use wildcards in the method definitions to match more than one method at the same time.
Security Without a Web Layer Even if this chapter has focused on securing the business layer of applications through the use of method-level security, you are still working in the context of a web application.
This is the standard model in which Spring Security is used.
A web front end takes care of the authentication process, and a combination of URL and method security rules and constraints takes care of the authorization process.
The web layer, through the use of all the filters you reviewed in the previous chapter, give you a lot of out-ofthe-box functionality for authenticating users into the application.
Your only job is to configure certain beans in the application context so that you can leverage all this functionality.
However, there should be no reason why you can’t leverage the rest of the Spring Security infrastructure in a non-web environment.
Let’s take a look at how to do this in a simple command-line-based application.
You will reuse most of your current code in the service layer, but you’ll create a thin command-line layer you can use to interact with the system.
First, let’s see what you need to do to make this work.
Spring Security’s web support is focused mainly in the authentication part of security—the part where the user presents his credentials and is correctly identified by the system.
Most of the authorization part is handled by the AbstractSecurityInterceptor and all of its helping collaborators.
As I have explained in this chapter, MethodSecurityInterceptor is one of the AbstractSecurityInterceptor’s concrete implementations and does not, at all, depend on the application being web based.
The authentication process’ only concern, as I just said, is to take the username and credentials of a user (normally from a login form, but it can be from many different places), match these credentials to the saved users, and then create a new Authentication object (or, more accurately, one of its many implementations) that will carry all the necessary information of the just logged-in user, including her roles in the application.
So this part is the one you need to change for your command-line interface to work.
You need a way of providing the username and credentials, and then create an Authentication’s implementation object instance when the authentication infrastructure matches this user.
Thanks to Spring Security’s highly modular system, there are many places where you can plug in your new command-line “login” infrastructure, and then leverage most of the logic already provided by the framework.
In the following examples, I will cover the basic functionality of logging in to the application with a fully authenticated user, accessing a secured method, and then logging out.
Everything will be simple and concise and will serve to illustrate the idea.
First, you create the simple interface from Listing 5-16 in the package com.apress.pss.terrormovies.access of your application.
You can see three simple methods: one to log in, one to log out, and one to execute a random method (parameterless) in a Spring bean.
The idea is that this method will be secured with Spring Security, so you should get familiar behavior when trying to access it with different levels of an authenticated user.
Next, let’s define the class that will actually receive the command-line requests and translate them to invocations on this interface.
This will be your main class, and it will take care of starting the Spring application context.
Remember that previously the application context was loaded and started by a Servlet Listener configured in the web.xml file.
Listing 5-17 shows this Main class, which I created in the package com.apress.pss.terrormovies.standalone.
That is a very simple class, which simply loops through accepting command-line commands.
It supports only three types of commands, and you will see them here.
But first, let’s define the class that will take care of the actual authentication process and that will serve as the entry for invoking Spring bean methods.
This class should also be straightforward if you have followed through the book.
It handles all the authentication processing you require for your application.
When it is instantiated by the Spring loading process, it begins by setting a Security Context Strategy to MODE_GLOBAL.
This means that for the whole application there will be only the one and the same SecurityContext object instance (one SecurityContextImpl, to be more exact, with the implementation)
This strategy is only good in this kind of standalone (without a server part) application, where only one user will be using the application at any given time.
The next thing the code does is initialize the security context with an anonymous Authentication object (an instance of org.springframework.security.authentication.AnonymousAuthenticationToken), the same way AnonymousAuthenticationFilter does in web-based applications.
Next, you need to configure this object as a bean in the application context.
I copied the applicationContextsecurity.xml from the WEB-INF directory into the src/main/resources folder so that it can be found in the classpath when you run the application as a standalone application.
You should know how to run a simple java application with a main class, but just to make it easier, you can use this simple command to run the application in the Maven environment and set up its dependencies: and see how it works step by step.
Command outputs and exceptions will be truncated if necessary to show only the relevant values.
This time it works, as you are logged in correctly.u�
Try to execute the bean method, and again you get u� AccessDeniedException, as you have already logged out.
This flow should be familiar, as it is a simplified version of the flow that happens during Spring Security webbased authentication.
In step 1, you are trying to access a secured resource (a method, in this case) without being fully authenticated in.
The application uses, by default, an Anonymous Authentication, which is not enough for accessing this particular resource.
In step 2, you are trying to log in to the system with the wrong credentials.
Appropriately, Spring Security is throwing a BadCredentialsException indicating that this is, in fact, the case.
You can see in the stacktrace the process the authentication request follows until the exception is thrown by the DaoAuthenticationProvider.
In step 3, you are logging in with a correct username and password set.
This time, you get no output in the command line.
What is happening is simply that the DaoAuthenticationProvider is verifying that the password matches the saved credentials this time, so it is not throwing any exceptions.
In step 4, when you try to access the secured resource again, the framework under the hood will notice that there is an Authentication instance stored in the SecurityContext that has the required authority needed to access the resource.
This is enforced in the standard way you studied before.
The MethodSecurityInterceptor works together with the AccessDecisionManager and the AccessDecisionVoter to decide that the logged-in user has permission to access the requested method.
In step 5, you simply log out of the application.
The logout process here is simple, you clear the SecurityContext, and then initialize it again with an Anonymous Authentication.
I am simply demonstrating in this step that the logout process had the required effect in the application.
You can see how this simple application is leveraging most of the functionality from Spring Security.
You needed only a thin layer of authentication, working as an entry point, to get access to the full power of the security features that Spring Security offers.
This means you can integrate Spring Security into your Swing, AWT, command-line applications, among other types with relative ease.
It is always good to know that there is a tried and tested framework that can help you address the different concerns in your application.
In the case of security, you should consider Spring Security independently of the application stack you have, as you can probably leverage a lot of functionality from it.
The advantages of AspectJ over Spring are many and I will start to explain them by first explaining briefly what AspectJ is itself.
As we have explained to a certain degree, Aspect Oriented Programming (AOP) is a programming paradigm that allows to separate the crosscutting concerns of an application into their own dedicated modules.
AspectJ is a dedicated Java based implementation of AOP managed by eclipse.org.
AspectJ extends Java with an aspect-dedicated syntax and a new compiler that allows for the weaving of aspects to your applications.
Weaving in AOP parlance, is simply the process in which the aspect functionality is combined with the core business functionality to produce the final working entity that deals with both concerns (crosscutting and core business)
Weaving can happen at a few points in an application.
It can happen at compile time where a special compiler is able to combine the source code of u� the business class with the code of the aspect to generate a new class containing the required functionality.
In this case the bytecode is combined as classes are being loaded into u� the Java Virtual Machine (JVM)
In this case, which is the case we have been looking at so far with Spring u� AOP, aspect functionality is combined with the business functionality by composing objects together at runtime.
This is commonly achieved with the use of proxies as we have seen before.
While Spring AOP focus exclusively in runtime weaving,  AspectJ supports the other kinds of weaving.
This makes AspectJ a more powerful solution (as you are not just limited to intercepting public non static method calls) at the cost of more complexity.
In the majority of cases when using Spring, Spring AOP will be everything you need to use.
This is a very small module which contains only one Aspect and one AspectJ configuration file for load time weaving of the said Aspect.
Matches the execution of any public method in a type with the Secured * annotation, or any subtype of a type with the Secured annotation.
Matches the execution of any method with the Secured annotation.
In the previous Listing, you can see the use of AspectJ syntax (which I won’t explain here as it is outside the scope of the book)
The source code is well commented so you can get a sense of the way it works.
Remember that pointcuts define places that will match a particular piece of code where we want the aspect to execute, and in the code snippet from Listing 5-20, in every pointcut, it is explained where will it match.
Worth noting is the use of the AspectJMethodSecurityInterceptor which is yet another concrete implementation of the AbstractSecurityInterceptor that we have seen before.
We will be using compile time weaving in our example, and we will prove the use of AspectJ by securing a private method in our service layer.
Something we know is not possible with standard Spring AOP.
We will be starting from scratch for this example so let’s do some of the usual work.
Then we replace the pom.xml file with the one from Listing 5-21
In the previous Listing is important to note the introduction of the AspectJ dependencies and more importantly, the use of the aspectj-maven-plugin.
This plugin is the one that will take care of the process of weaving the Aspects into the application.
This element will find the already compiled aspect library that we want to weave into our application in the compilation process.
Note how I am using the spring-security-aspects module that I have just mentioned before.
This element will be picked up by the class GlobalMethodSecurityBeanDefinitionParser when the application is starting up, and will define the Aspect AnnotationSecurityAspect and inject the proper interceptor to it.
Make sure to save both previous classes in their corresponding package.
In the Service listing you can see that I have secured the private method methodB which is called by the public method in the same class method.
This, as you know, wouldn't have any effect if using Spring AOP.
From the root of the project, and as you have done so many times now, execute mvn clean install jetty:run.
After the application starts, if you visit the URL http://localhost:8080/hello/ you will be shown the login form that we have seen so many times now.
If you were to debug the Service class in both methods (method and methodB) you would note that there is not a typical Spring AOP Proxy around any of them (as we are not using Spring AOP but AspectJ)
That’s it on the cover of AspectJ with Spring Security.
You should have a good idea of when to use this type of security and how to apply it to different layers in your applications.
You should also know the different ways in which you can achieve method-level security, including using annotations, SpEL, and XML.
You saw that Spring Security can be used without a web layer, even when the standard use case is for web applications.
I also covered the use of  Spring Security with the powerful AspectJ library to secure private methods.
Also, you should have a clear understanding of the difference between the authentication and the authorization process.
One of Spring Security’s strongest points is that you can plug different authentication mechanisms into the framework.
Spring Security was built to create, as much as possible, a pluggable architecture model, where different things can be plugged into the framework in an easy and unobtrusive way.
In the authentication layer, this means that an abstraction exists that takes care of this part of the security process.
This abstraction comes in the form, mainly, of the AuthenticationProvider interface, but it also is supported by specific security Servlet filters and user details services.
Among the different authentication mechanisms I will cover are the following:
Most of this chapter deals with explaining how each of these authentication systems work, independently of Spring Security.
Although this gives you certain key details, it won’t be an in-depth explanation.
Of course, you will see how Spring Security implements each of these authentication mechanisms, and you will see that they have many things in common when it comes to the parts of Spring Security they use.
Database-Provided Authentication Database-provided authentication works almost exactly the same way as with the memory-provided authentication users.
The only difference is that the users are stored in the database and not in memory.
This happens at runtime when you define them in the application context configuration file.
When you are using database-authentication mechanisms, the AuthenticationProvider implementation doesn’t need to change at all—it’s still the DaoAuthenticationProvider you used for the in-memory user authentication.
As you may remember, this AuthenticationProvider implementation is based on using a UserDetailsService abstraction to retrieve the users, so the difference here is the UserDetailsService implementation you will use.
To configure the provisioning of users from the database is pretty simple, as you will see.
We will clean up and build on the application from Chapter 2
The first thing you do is define the database schema you need in order to make the authentication mechanism work.
The tables you need to make the authentication work are shown in Figure 6-1
Figure 6-1 shows a simple schema model for supporting authentication backed by a database.
Just by looking at the tables, you should be able to see how they work.
It is basically a one-to-one mapping from the in-memory implementation you have been using so far.
In the USER table, you store the user details—mainly, the username and the password.
Figure 6-2 shows an extended default option you can use to define groups and establish authorities related to those groups instead of to individual users.
This time, the schema allows you to create named groups and establish authorities belonging to these groups.
At the same time, users now can belong to groups as well, meaning that users can inherit the authorities defined for the groups to which they belong.
By default, the group mechanism is not activated in UserDetailsService.
To activate it, you need to configure a groupAuthoritiesByUsernameQuery attribute in the corresponding <jdbc-user-service> in the configuration file, as you will see later in the example.
Note N  For this example project and the rest of the examples in this chapter, unless otherwise noted, you will start with an application configured as follows.
Remember to replace the artifactId property with a unique name for your application.
Replace the generated web.xml file with the one in Listing 6-2
Starting applicationContext-security.xml to be used in all examples in this chapter.
Create a file named applicationContext-security.xml with the contents of Listing 6-3 in the generated WEB-INF folder.
Replace the generated pom.xml with the one from Listing 6-5
Remember to change the artifactId name with the name of your application.
We’ll use an HSQL database, so you need to configure its JDBC dependencies in the pom.xml file as Listing 6-5 shows.
Next let’s modify the configuration file applicationContext-security.xml to include the configuration changes needed to support database-driven user authentication.
Embedded datasources are a new feature introduced in Spring 3.0
You can use them to define different kinds of embedded datasources (basically, in-memory datasources that run within the Java process where they are used), such as HSQL and Derby.
You can also see here that in the tag you are also allowed to specify SQL script locations you want to execute when the datasource is started up.
The scripts execute in sequential order from the top down—in our example, security-schema.sql is executed first, and then users.sql is executed.
The SQL files you are specifying here allow you to create a simple database schema to support the configuration of users and authorities the way you defined them previously in the section.
Using this embedded datasource is very convenient for examples of this type and unit testing your application, but most likely you won’t use them in production environments.
For production environments, you will use full database solutions, such as MySQL, PostgreSQL, Oracle, and others.
Creating the Basic Tables Next you create the two SQL files you are referencing in the configuration file and put them in the root of the classpath.
Later, you will see groups coming into the picture as well.
Everything should be set up now, so start the application:
You should be able to log in and access the URL http://localhost:8080/hello only if you log in with the username car and the password scarvarez.
What is happening here is pretty simple and similar to what you have been working with up until now.
When you define the element <security:jdbc-user-service> in the configuration file applicationContext-security.xml, Spring Security instantiates a different kind of UserDetailsService at startup than the one used for in-memory user details.
This instance will be injected into the DaoAuthenticationProvider for retrieving users from a JDBC datastore.
Using Groups To use groups now, let’s modify the users.sql file a little bit and add the lines from Listing 6-9 to it.
Those lines effectively create a group and put the user “car” into that group.
You should also remove the SQL where you insert into the AUTHORITIES table the role for user “car”
The users.sql lines used to create a group and put members into group.
Now, to activate the use of groups in the UserDetailsService you need to set the property enableGroups to true in the JdbcDaoImpl implementation; however, for some reason, the <jdbc-user-service> namespace element currently doesn’t support the setting of this simple property directly.
What it does support is the setting of the attribute group-authorities-by-username-query, which allows you to specify the query to retrieve the groups from the database schema.
Setting this attribute automatically sets the property enableGroups to true.
The other option, of course, is not to use the XML namespace and instead use the standard bean definition and set the property.
Consider the query you specified in Listing 6-10; the group-authorities-by-username-query attribute is extracted directly from the class file JdbcDaoImpl (the query string, that is)
It is configured in the DEF_GROUP_AUTHORITIES_BY_USERNAME_QUERY constant in that file (JdbcDaoImpl), and it is the default query used by the class to retrieve the groups and authorities.
If you restart the application now, you should see the same behavior as before.
This time, however, the behavior internally is different because the group query is the one being executed to retrieve the authorities for the user.
The code that makes this choice in the JdbcDaoImpl is very simple, and you can see it in Listing 6-11
The property that is used in the second if condition is set automatically by Spring Security when starting up, particularly in the class JdbcUserServiceBeanDefinitionParser when you set the group-authorities-by-username-query attribute as I explained before.
The enableAuthorities property in the first if is automatically set to true in the JdbcDaoImpl class itself.
The advantage of using groups is that it offers a new level of organizing users into the same category and does not relate them directly to particular authorities.
All these authorities can be grouped into the same conceptual group, and at the same time, all users can be grouped into their respective groups.
This means that not all users need to reference all these authorities.
They simply need to be made part of the group.
Of course, a user can belong to more than one group at the same time.
Using Existing Schemas JdbcDaoImpl, by default, is configured to use the database schema and queries you have looked at already.
However, the schema configuration is flexible, and you can adapt your existing database user schema (if any) to be used by Spring Security JDBC UserDetails support instead of writing a custom schema just for Spring Security.
If you have those abstractions in place in your database, accessing the information from Spring Security’s JDBC support is straightforward.
The two attributes (authorities-by-username-query and group-authorities-by-username-query) in the element username when not using groups or when indeed using groups.
You saw the example in the previous section of how to use the group-authorities-by-username-query attribute.
The authorities-by-username-query is configured similarly, and it should be a query that returns a pair of columns in its resultset.
The first one represents the username, and the second one represents a particular authority.
The other attribute you need to change in the <jdbc-user-service> element is users-by-username-query.
Here you use the query needed to retrieve users using their username.
The query needs to return three columns in a record: username, password, and enabled.
You will change just some files from the example we are currently working on.
First, you will change your security-schema.sql and users.sql files to something that doesn’t really match the default values Spring Security expects.
Now restart the application, log in with the username car and the password scarvarez, and access the URL http://localhost:8080/hello.
You should be able to reach the page in exactly the same way as before.
A directory, in general, is simply an organized datastore that allows for easy queries in its particular domain.
For example, a TV Guide is a directory that allows you to find TV shows easily, and a phone book is a directory that provides easy access to phone numbers.
Probably the most widely known use of LDAP-like structures is the Microsoft Windows Active Directory system.
Other LDAP systems are widely used to store the corporate user databases of many companies that serve as the centralized user store.
I will use the same code as in the previous section, but modify it as needed to work with LDAP instead of database authentication.
Remember that in the previous section, I offered a bootstrap application to start working in all the examples in this chapter—including this one.
The first thing to do is configure your users in the LDAP directory.
To do this, you need to understand the LDAP Information Model, which defines the type of data you can store in your directory.
The data in LDAP is defined by entries, attributes, and values.
An entry is the basic unit of information in the directory and commonly represents an entity from the real world, like a user.
Each entry in the directory has an identification known as a Distinguished Name (or, more commonly, DN)
Each entry in the directory also has a set of attributes that describe different things about the entry.
Each attribute has a type and one or more values.
We will use users, groups, and credentials as we have been doing so far.
Commonly in LDAP, the user entry definition is known as People, so we will use that name to define the user entries.
Our user will also use the standard LDAP object class person to define its attributes.
Installing and Configuring LDAP We will be using an ApacheDS LDAP implementation, which is a pure Java implementation.
You need to download and install the ApacheDS server from its web site: http://directory.apache.org/
You should download and install both the Server (ApacheDS) and the Studio (Apache Directory Studio)
The installation process of both tools is straightforward and shouldn’t give you any issues.
The Apache Directory Studio allows you to access and query the server.
The Apache Directory Studio is an Eclipse application built of plugins adapted to access LDAP servers.
Regarding the ApacheDS server, when it is installed (at least on a Mac), it will be started up automatically; however, you also have the option of running the ApacheDS server as an embedded server within the application process instead of having a standalone, independent LDAP server.
We will be using the standalone server in the example.
After installing the Server and Studio, you need to connect to the Server from the Studio.
To do that, go to the File menu in the Studio, select New, and then select LDAP Connection, as shown in Figure 6-5
In the LDAP connection form, enter the values to connect to the local ApacheDS server as shown in Figure 6-6
Once the connection to the ApacheDS server is established, you need to create a context entry representing the top-level entry in the local directory.
In the first form in New Context Entry, you choose to create an entry from scratch.
Then, from the list of available object classes in the left panel, you select dNSDomain and click Add.
The idea here is that you are creating the top-level entry from which all other entries derive.
In the next input are the default values for the partition and the top-level context entry included in the ApacheDS server.
These values also partially identify every entry you create in the directory because, as I said before, LDAP follows a hierarchical structure that builds names for entries on top of its parent entries.
The next step is to import your users into the LDAP server.
I will be importing a couple of users using an LDIF file.
An LDIF file is a text file that uses LDIF formatting, a standard format for describing directory entries in LDAP.
It allows you to import and export your directory data into or from another LDAP directory in a standard way or just to create new data or modify existing data.
You use it here to import the data with your users.
You can see in Listing 6-5 the hierarchical nature of the directory and how everything inherits the DN two groups: administrators and users.
The password for both users is “scarvarez.” In this example, they are shown in plain text, although they could easily be stored in encrypted form.
Graphically, the hierarchy is simple enough and looks like Figure 6-9
To import the file from Listing 6-5, from Apache Directory Studio, right-click on the left panel in the newly created context entry.
The next thing you need to do is configure the example application to be able to connect to the LDAP server and query the information stored on it.
You have a clean application at the moment, with only the bootstrap components.
First, you add the Spring Security LDAP dependency to the pom.xml file.
In Listing 6-7, I show you the configuration file applicationContext-security.xml and then I shall explain how it works.
Listing 6-7 shows all the configuration needed to make your application work with LDAP-based authentication.
If you restart the application now with that configuration, you should be able to access the URL http://localhost:8080/hello only if you log in with the username mon and the password scarvarez.
The element <ldap-server> allows you to configure the LDAP server you will be connecting to from the application, and here, you are specifying the local ApacheDS server you configured in previous steps.
You also specify the Distinguished Name you will be using as part of the connection URL in this same <ldap-server> element.
This is basically the root path of your directory, as you specified before.
The element <ldap-authentication-provider> is where the meat of the configuration is.
You can see that instead of configuring a different UserDetailsService as in the case of database-based authentication, you are configuring a whole new AuthenticationProvider.
Here you are specifying three attributes: user-dn-pattern, group-search-base, and group-search-filter.
The user-dn-pattern specifies how the user will be authenticated in the directory.
Here it will replace the pattern {0} with the passed username for the user and then attempt a bind operation against the LDAP server.
Binding is the standard way of authenticating against an LDAP server.
In a bind operation, a user provides a DN and some credentials.
Then the LDAP server checks this information and, if it is a valid authentication information, the LDAP server marks that the user is authenticated while the connection remains open or the user authenticates again.
The attribute group-search-base specifies the base for where it will start to search for group membership.
It will look inside the hierarchy starting in this base for the groups defined.
The attribute group-search-filter specifies the attribute for a group in which the members of the group will be found.
The pattern {0} will be replaced by the DN of the user.
Figure 6-11 shows a graphical description of the process, up to the point of creating a successful Authentication object.
This class and method delegate the authentication process to an instance of LdapAuthenticator.
By default, the implementation used is BindAuthenticator, which as I mentioned before authenticates the user using a bind operation against the LDAP server.
If the user is authenticated successfully by the u� LdapAuthenticator, an LdapAuthoritiesPopulator implementation is called.
SpringSecurityLdapTemplate to query the LDAP directory and retrieve the cn attribute of the groups of which the retrieved user is a member.
The next step is that an implementation of u� UserDetailsContextMapper is called in order to create a UserDetails object (or, more exactly, one of its implementations) from the LDAP context information that was retrieved from the server and the retrieved authorities.
Then a successful u� Authentication object in the form of a UsernamePasswordAuthenticationToken instance is created with the corresponding user details, and the normal standard process continues through the filter chain.
This namespace offers some more attributes and elements you can use to configure different parts of the integration.
The element <ldap-authentication-provider> supports the following main attributes beside the ones we used in our example:
By default, the attribute used is cn when no attribute at all is specified explicitly, as you saw in the example.
When this element is used, a different kind of authentication process happens in the application.
Actually, a whole new implementation of LdapAuthenticator is used—namely, a PasswordComparisonAuthenticator.
The Spring namespace parsing process takes care of instantiating this class instead of the BindAuthenticator.
The difference between PasswordComparisonAuthenticator and BindAuthenticator is that the PasswordComparisonAuthenticator is used to compare the provided password at login time with the password stored in the LDAP repository.
This is done by performing an LDAP “compare” operation, through the use of an instance of SpringSecurityLdapTemplate, between both passwords.
The BindAuthenticator, as I said before, uses the standard bind functionality in LDAP to authenticate the user.
The <password-compare> element accepts a couple of attributes and one child element:
The second attribute is u� password-attribute, which allows you to specify what attribute in the user entries on the LDAP directory contains the password for the user, which by default is userPassword, which we used in the LDIF file.
If both are specified, the hash attribute will be ignored.
Using the hash attribute can be thought of a shortcut for the standard digest algorithms, and internally it creates a password encoder.
That listing is extracted directly from Spring Security’s source code for the class org.springframework.security.config.authentication.
Default password encoders that can be configured using the hash attribute on <password-compare>
As you can see from the example, configuring LDAP’s basic support as the authentication solution for your application with Spring Security is not that complex.
In fact, it is very straightforward thanks to the modular architecture and the well-thought-out XML namespace.
Although it is a simple hierarchical system (very much like the file system in your standard Unix box), some of the nomenclature and functionality seems a bit complex and very different from the database-based solution you explored in the previous section.
As I said before, using LDAP as your authentication solution makes great sense in the context of corporate intranets, where the company user base is already stored in LDAP-like directories in a centralized manner.
Plugins into this already existing user-management infrastructure are a good way to reuse the user information within the company instead of writing a parallel authentication datastore that then needs to be kept in sync with the main repository.
Authenticating with OpenID OpenID is an authentication solution that exists to address the problems inherent in having many user accounts in many different sites with many different sets of credentials.
It is common on the web for a user to be registered with many sites and applications at the same time.
Most of these applications, when you try to access them, ask you to authenticate against them directly—normally, asking you for a username and a password to access their functionality.
This is an obvious problem in terms of inconvenience and security.
OpenID allows users to rely on unique single authentication account to access different web sites.
In this way, it reduces the inconvenience of maintaining multiple accounts on multiple web sites.
Also, it reduces the risk of a password being compromised on any external site, because the OpenID identity provider manager is the only one that will know about your password.
There are many OpenID providers, including Google and Yahoo, as well as dedicated ones like myOpenID, which is the one I will use in the example.
You can open an account with myOpenID by visiting https://www.myopenid.com/
As I have been doing so far in the book, I will explain the concepts as I am developing the example.
It doesn’t include any authorization-related functionality, so it will probably need to be complemented with another mechanism to add the authorities and roles to the users.
Once again, we will use the simple application we have been using in the other examples in this chapter, with the required modifications needed to support OpenID authentication.
These libraries are the Spring Security OpenID module and the nekohtml (available at http://nekohtml.sourceforge.net/) library, which is used internally by the openid4java library (which is used by Spring Security and is resolved as a transitive dependency) for parsing HTML.
Configuration file for a Spring Security application with OpenID enabled.
The password is stored only in the OpenID provider environment (MyOpenID)
The strange username of http://carlo8172.myopenid.com/ is my OpenID account identifier.
If you open an account yourself, it will be very similar to this one.
You might find it a bit strange to define the user in the application in the <user-service> element if it is already defined in the MyOpenID site.
The reason is that, as I said before, you need to specify the authorities that your users will have within the application and you cannot do that in the OpenID provider because it provides only an authentication mechanism.
What you could do, however, is autoregister the users after they authenticate successfully with the OpenID provider and assign them a particular user role.
For example, many applications use only one generally available user role that is common to all the users that access the application.
In this case, you could simply assign that role by default to the user after she has been successfully authenticated by the OpenID provider.
This is a common way of working, and the Spring Security source code includes an example that shows exactly this kind of behavior by implementing a custom UserDetailsService for use with the LDAP authentication provider.
The User Datastore is populated when the user is succesfully logged in with OpenID.
Default login form now includes the option to log in with OpenID.
You should get to a page that looks like Figure 6-13, which presents you with a login form that has a new text field.
In the new Identity text field, I type my OpenID identifier http://carlo8172.myopenid.com/, and then click the second Login button.
I get redirected to the MyOpenID site, which shows me a form to type in my password.
The MyOpenID site asking me for my password to authenticate me.
After I correctly enter my password in the MyOpenID site, I get redirected back to the application.
OpenID Authentication Flow The way all this works is similar to the other authentication mechanisms you saw earlier, and many of the known abstractions still apply here, like the AuthenticationProvider and UserDetails abstraction.
This URL is detected by the DefaultLoginPageGeneratingFilter, which as you saw previously, generates the login form page.
This time, however, the filter sees that OpenID is enabled in the application and generates one extra form like this:
The form has a text field for entering the OpenID identifier like this:
When you enter the OpenID identifier in the text box and click Login, the request arrives at the OpenIDAuthenticationFilter, which detects the invoked URL /j_spring_openid_security_check as the URL it needs to process.
The filter then extracts the parameter openid_identifier from the request.
With the username it uses the openid4java library to discover the OpenID server provider to which the authentication.
Then it creates an OpenID authentication request with this information and redirects the response to the corresponding OpenID provider site.
When you introduce the correct password in the OpenID provider (MyOpenID, in this case), you get redirected back to the URL /j_spring_openid_security_check once again.
However, this time the URL contains a set of parameters that MyOpenID has included in the invocation.
The filter OpenIDAuthenticationFilter again recognizes this URL as a URL it should process and proceeds to extract the parameter opened.identity from the request.
This parameter was added by the OpenID provider, as I just said.)
Then the information sent by the provider is verified to see if it was successful.
After successful verification, an instance of OpenIDAuthenticationToken is created and sent to the OpenIDAuthenticationProvider's authenticate method.
The provider calls the configured UserDetailsService instance (an InMemoryUserDetailsManager) and retrieves the user configured for the given username.
OpenIDAuthenticationToken Authentication implementation, which includes the UserDetails information, including the authorities retrieved with the UserDetailsService.
As normal, the Authentication gets stored in the SecurityContext of the running application.
When you visit the URL /hello again, the normal process of authorization will start.
The authorities for the user match those required by the requested URL, so access will be granted to the URL.
Spring Security OpenID Namespace Spring Security’s OpenID namespace configuration provides other attributes and elements that enhance the functionality you have seen up to this point.
In general, though, the spring-security-openid module is very small and the core functionality is what I have covered so far in this section.
The main supported attributes in the before in the book.
It should not be used in combination with authentication-failure-url, because the implementation should always deal with navigation to the subsequent destination.
This means that the intended work of authentication-failure-url doesn’t make sense by itself because its job is taken care of by the handler.
If no login failure URL is specified, Spring Security automatically creates a failure login URL at /spring_security_login?login_error and a corresponding filter to render that login failure URL when requested.
It should not be used in combination with default-target-url (or always-use-default-target-url) because the implementation should always deal with navigation to the subsequent destination.
This means that the intended work of default-target-url doesn’t make sense by itself because its job is taken care of by the handler.
This generally happens if the user visits a login page without first requesting a secured operation that triggers authentication.
If unspecified, it defaults to the root of the application.
If no login URL is specified, Spring Security automatically creates a login URL at /spring_security_login and a corresponding filter to render that login URL when requested.
This element is used to use the OpenID Attribute Exchange (AX) functionality.
The AX functionality of OpenID allows for the interchange of information beyond simple authentication between the communicating endpoints of the authentication process.
For example, you could use it to fetch data from the OpenID provider or to store data.
I will show you how to configure it to retrieve some extra data when you are using the authentication process.
I will configure it to retrieve the email of the logged-in user.
If you are following the example and using MyOpenID as your OpenID provider, go to the URL https://www.myopenid.com/settings (when you are logged in already) and, in the right panel, on the Your Account menu, click the Registration Personas item.
This allows you to add information to your account profile in the MyOpenID provider.
After you add the information you want, it should look something like Figure 6-15
After you add this information to your account on the OpenID provider, you can ask for this information back when authenticating against it.
For example, let’s say that you want to retrieve the email of the user attempting to log in.
Attribute exchange configuration for fetching the email of the user.
Listing 6-10 shows how to retrieve a particular attribute from the OpenID account when logging in.
You can see that the type attribute specifies a particular URI that identifies how to retrieve this value in the particular OpenID provider.
The name attribute specifies the name that the attribute has in the local Authentication object after it is retrieved.
If you restart the application now and do the whole authentication process again, this time your email will be returned with a successful authentication with the OpenID provider.
The information will be stored in the OpenIDAuthenticationToken Authentication object under the attributes property, and you can access this information any time you want from the Authentication object that will be stored in the SecurityContext.
As I said before, there are many other OpenID providers out there, including Google and Yahoo, and they work in a similar manner to what you saw in this section with MyOpenID.
The main difference, in many cases, is that the user identifier URI related to each of the providers.
Using this approach, a scheme known as mutual authentication takes place between the client and the server.
In practice, mutual authentication means that, as part of the Secure Sockets Layer (SSL) handshake, the server requests that the client identify himself by providing a certificate.
In a production-ready server, the incoming client certificate needs to be issued and signed by a proper certificate-signing authority.
To work with client certificates, the application needs to be configured to use SSL channels in the sections that are expected to deal with the authenticated user, because the X.509 authentication protocol itself is part of the SSL protocol.
In Chapter 5, you configured the example application to use SSL channel and configured the pom.xml to be able to run a Jetty server with SSL support.
Here, I build on that example’s pom.xml file to explain the client-certificate solution.
You need to add a couple of properties to the Jetty plugin configuration.
Look at the properties wantClientAuth and needClientAuth that are configured in the last part of the plugin configuration.
The first thing you do now is to enable X.509 authentication on the Spring configuration file.
This element is all Spring Security needs in order to do its part of the work in activating the client-certificate authentication mechanism.
By configuring this element, Spring’s startup mechanism makes sure to instantiate an instance of org.springframework.security.web.
This is all the configuration Spring needs to handle client certificates.
Of course, things are not that simple and the job is not yet done.
In reality, Spring Security X.509 support doesn’t authenticate the user.
The user is assumed to be already authenticated, and Spring Security simply creates a successful Authentication object with information extracted from the certificate and stores it in the SecurityContext in the standard way.
So the entity that is actually in charge of authenticating the user (or more exactly accepting the user as a properly identified one) is the web server, which does this by accepting the provided client certificate.
Basically, if the server decides that the certificate sent by the user is a valid one, the user is who she claims to be and gets authenticated.
In a production system, the web server makes sure that the certificate provided by the client is signed by an authorized trusted authority.
However, we will use a test environment with our common Maven-configured Jetty installation, and for that we will configure a self-signed certificate and make sure that Jetty accepts it.
It is pretty straightforward to do, and we will use the openssl tool to do it:
Generate a certificate by executing the following command and pressing Enter at every prompt:
When executing that last step, it is important that when asked to introduce your name by the command-line prompt, you use the name “car” because that is the username you configured in the application configuration file.
The command line will show you the following prompt Common Name (e.g.
The next thing you need to do is to make Jetty trust the certificate authority associated with this certificate.
Note N  A truststore is a repository of certificates that are trusted by the JRE that uses such a truststore.
By default the JRE truststore trusts any certificates signed by a recognised Certificate Authority (CA)
If you have a certificate not signed by a CA (like the self signed certificates) you will need to add it manually to the truststore so the it can be trusted.
The execution of that file is shown in Figure 6-18
That simple line created the file jetty-ssl.truststore, which you will use as the trust store for the Jetty server to accept the user certificate.
Copy that file to the root of the application, and modify the pom.xml jetty plugin section to include the line <truststore>jetty-ssl.
Next you need to add the certificate to the browser you will use to connect to the application.
The first thing to do is create a p12 file that contains information about the certificate and the private key associated with the certificate.
This is the file needed by the browser to identify the user.
To generate that file from the command line, in the same directory where you previously generated the key and the certificate, execute the following command.
To import that file into the client certificates of Firefox, do the following.
This example is on a Mac computer, and it should be similar on other systems.)
Locate client.p12 in the directory where it is stored, and double-click it.
The certificate is imported, and you should see a screen like Figure 6-20
Finally, the configuration is complete, and the application is ready.
The browser is also ready for the mutual authentication process to get underway.
You need to accept the self-signed certificate from the server to continue.
After you accept it, you will be presented with the screen shown in Figure 6-21, which asks you to select the certificate to use to authenticate.
Only one option is available: the certificate you just imported.
Most of the process is dealt with by the web browser and the web server SSL communication establishing the mutual authentication scheme.
AbstractPreAuthenticatedProcessingFilter is a base filter implementation that handles the special cases where a request arrives with information about a user already authenticated by an external system.
Filters extending this class assume that the user is already authenticated and that their only responsibility is to extract the authentication details from the request, create an instance of PreAuthenticatedAuthenticationToken, and pass it forward to the AuthenticationManager implementation.
There, it finds the whole client certificate sent by the browser in the request.
With the extracted certificate, the filter calls an instance of an implementation of org.springframework.security.web.authentication.preauth.x509.X509PrincipalExtractor to retrieve the username from the said certificate.
This is why it was important to use the name “car” when asked in the command prompt.
This regex pattern is what is used by the SubjectDnX509PrincipalExtractor to find the username in the certificate.
The Authentication object implementation, PreAuthenticatedAuthenticationToken, is instantiated with the username and the credentials.
The credentials that will be stored in the Authentication object are the full sun.security.x509.X509CertImpl instance that was extracted from the request.
This provider uses the configured UserDetailsService to retrieve the user for the application using the username from the Authentication object.
In the example, it uses the in-memory UserDetailsService you defined in the application file.
After it retrieves the UserDetails from the UserDetailsService, the provider creates a new fully authenticated PreAuthenticatedAuthenticationToken that now includes the authorities granted to the user as extracted from the UserDetailsService.
That is the whole flow that is followed by a request using client-certificate authentication.
As you can see, Spring Security support for it is pretty straightforward.
You can use JAAS as another authentication provider in Spring Security.
You initiate the authentication process by creating a new javax.security.auth.login.LoginContext.
The instance of LoginContext calls a configured instance of an implementation of javax.security.auth.spi.LoginModule, which is the one that performs the real authentication process.
The LoginModule extracts the username and password from the user (or uses a different kind of providing mechanism), and then verifies these credentials.
LoginModule communicates with the requesting client by means of callback methods registered with a javax.security.auth.callback.CallbackHandler implementation.
Those are the main steps for authentication with JAAS, and Spring Security can take care of this process with the use of the supplied JAAS authentication providers and some other helper classes.
You need to implement a simple LoginModule that will take care of the actual authentication of the user.
You will use a map as your user and password storage.
I will show you how to modify the code from the previous sections to adapt it to the JAAS authentication mechanism.
No specific dependencies are needed because JAAS support in Spring Security is in the core module.
Listing 6-13 shows the configuration file (applicationContext-security.xml) needed to use JAAS authentication in Spring Security in our example application.
Listing 6-13 is not as simple as the files you used in previous sections.
For a start, you are using standard Spring bean definitions instead of support from the XML namespace, because there is no XML schema for JAAS configuration.
The only high-level bean you need to define is for the authentication provider implementation you want to use.
The properties you defined in this bean are all important, and here is what they specify:
In this case, you are specifying it can be found in the root of the classpath.
I explain later the contents of the class referenced by the file.
Implementations of this class ideally query some datastore where the roles for a particular username exist.
In the example, you use a simple in-memory map in the class itself as Listing 6-15 shows.
You changed it to match the value defined in the pss_jaas.config file.
This method is invoked (as normal) in the initialize method of the LoginModule.
This part is actually a bit tricky to understand, and I’ll provide a better explanation when I get to the code of the SampleLoginModule class, which is shown in Listing 6-16
The pss_jaas.config file that specifies the class implementing LoginModule in the application.
RoleGranterFromMap, which contains a map with usernames and their assigned roles.
If you restart the application now with all this configuration in place and try to access the URL http://localhost:8080/hello, you get the form to log in that you have seen many times before.
The preceding code is very simple, and all it’s doing is simulating a user data store with an in-memory map.
Listing 6-16 shows the main class you need to create to support JAAS authentication with Spring Security.
It is the main class in the JAAS authentication scheme because it is the one that takes charge of the real authentication of the users into the application.
People or companies that want to implement a custom authentication solution to be plugged into JAAS definitely need to create an implementation of LoginModule.
In our implementation, you can see the use of some of the concepts I was talking about in previous sections, like the Callbacks and CallbackHandler implementation classes.
NameCallback and PasswordCallback are standard classes in JAAS that will eventually be called back with the contents of username and password, respectively.
The CallbackHandler implementation is in charge of retrieving the credentials needed to authenticate the user.
It then makes sure the relevant callbacks are called in order to populate the needed information for the rest of the process.
After the CallbackHandler returns, the Callback classes will have the required values set in, and you can extract them and store them for later.
When the login method is called, the introduced user details are easily accessible in the instance variables.
In the example, this simply means making sure that the pair username-password exists in the in-memory map of users defined in the static variable USER_PASSWORDS in the class.
If a match is not found, a LoginException is thrown indicating the authentication failure condition.
If a match is found, the principal is stored and the execution continues normally.
When you execute the application and try to log in with the username car and the password scarvarez, the following is what happens inside JaasAuthenticationProvider:
The u� Authentication object populated with the username and password arrives at the authenticate method.
The provider creates a new u� javax.security.auth.login.LoginContext with a constructor parameter that is a javax.security.auth.callback.CallbackHandler implementation that delegates handling to instances of org.springframework.security.authentication.jaas.
The login method in the u� javax.security.auth.login.LoginContext object created in the previous step is called.
This method calls the initialize method in your SampleLoginModule, passing the CallbackHandler created in the previous step.
Inside your initialize method, a new NameCallback and PasswordCallback are created and passed to the handle method of the CallbackHandler.
JaasNameCallbackHandler and JaasPasswordCallbackHandler’s handle method are called, with each callback and with the Authentication object.
The name of the user is obtained from the Authentication object.
The u� JaasPasswordCallbackHandler sets the password of the user in PasswordCallback.
The password of the user is obtained from the Authentication object.
The u� initialize method in the SampleLoginModule extracts the username and password from their respective callbacks and assigns them to instance variables.
This method compares the username and password obtained in the instance variables in the previous step against the users stored in the datastore (in our example, in the USER_PASSWORDS map)
If they match, it is assumed to be a successful login to this point.
For the successfully authenticated user, the authorities are extracted with the use of the u� configured AuthorityGranter, which in our example is the custom class RoleGranterFromMap.
A new instance of u� org.springframework.security.authentication.jaas.JaasAuthenticationToken is created as the new fully authenticated Authentication object.
This new Authentication object contains the username and authorities, and it is a valid fully authenticated instance.
This instance is returned to the caller and will be used in the rest of the authorization process.
However, the main concepts are the ones I showed you, and the goal of the section is to show the building blocks for integrating it with Spring Security.
Central Authentication Service (CAS) Authentication As you can see from the Spring Security source code I presented a few times already, there is a module dedicated to CAS authentication.
It has a great supporting community and integrates into many Java projects.
Understanding the ideas behind CAS (and indeed any other single sign-on solution) is not difficult.
Although I’m not going to explore CAS in detail, there are a few main concepts you need to know about the CAS system to understand better how the upcoming example works.
This application offers certain APIs for handling requests from clients.
All the applications that want to use the single sign-on functionality exist as services from the point of view of the CAS server.
Normally, applications provide a callback URL when communicating with the CAS server so that the server can call back into the client application.
The URL is normally referred to as the service URL.
The ticket serves as an identifier that the client application uses for validating the service against CAS and to get the “success” login message back if that is the case.
Those three elements illustrate the concepts from the following examples and explanations.
One important characteristic of CAS is that it is designed to serve as a proxy to different authentication storage.
This means that it can be used in combination with LDAP, JDBC, or a few other user stores that contain the real user data.
This looks a lot like the way Spring Security leverages these same user data stores.
In this section, you will use CAS to authenticate your users in applications.
As of this writing, the current version of CAS is 3.5.1, and that is the one you will use here.
The first thing you will do is download the latest version from its home at http://www.jasig.org/
After you download it and uncompress the file, you will find a folder inside the main folder named modules.
In this folder, you will find a War file with the name cas-server-webapp-3.5.1.war if you are using the same version I am using.
You will be using Jetty here again and to make things simple, you will use Jetty from Maven the same way you have been doing all along.
However, this time you will run the war file that is provided by CAS.
To do this, create the pom.xml file from Listing 6-17 in a directory of your choosing.
Remember to replace the path to the war file with the one that applies to your installation.
A pom.xml file used to run the CAS war application.
Note N  Single sign-on is a scheme that allows related applications to share the same user login session.
A user authenticates once in the central single sign-on authentication provider and as long as she remains authenticated on the system, she can log in to all the other applications without being asked to provide her credentials again.
Also, the other applications don’t need to know the user password.
If you now execute mvn keytool:genkey followed by mvn jetty:deploy-war from the directory where you have this new pom.xml file, the default demo application of the CAS server will execute.
This war file demo application allows users to log in by matching their username and password.
For example, you can log in with the username car and the password car.
Log in with the username car and the password car, and you should get a successful login as shown in Figure 6-23
Let’s create an application now that supports CAS authentication with Spring Security.
First let’s set up the application , and then I will explain how everything works:
From the command line, execute the familiar Maven command to create a new web application:
Replace the generated pom.xml file with the one shown in Listing 6-18
This one contains the proper dependencies and the proper Jetty plugin configuration to run the application.
Create the web.xml file from Listing 6-19 in the WEB-INF directory of the created application.
This file, as we have seen many times, has the listener to set up the Spring context.
Create the servlet shown in Listing 6-20 in the package com.apress.pss.servlets.
This is a simple servlet that you will secure next.
Create the file applicationContext-security.xml shown in Listing 6-21 in the WEB-INF folder.
This file contains the configuration for CAS security that I will explain next.
I will explain the elements from the previous XML a bit later.
But first we need to make a couple of configuration changes in the SSL elements of our application to be able to run everything together:
First, from the root of the CAS runner you created (wherever the pom.xml from Listing 6-17 is), run the following command:
That command creates an X.509 certificate that you need to include in the trusted certificates of your JRE so that other applications using the same JRE automatically trust this certificate.
To import the certificate, run the following command from that directory:
Next, from the root of the application you will use to test, you need to run the following command so that it generates the key you need to set up its SSL environment:
Then in the root of the example application execute mvn jetty:run and wait for the application to start.
You will get the page shown in Figure 6-24 automatically, which means that the application redirected to the CAS web site to handle the authentication.
Look at the URL in that figure and notice how it contains information that points back to the URL of the example application.
This is the callback URL that CAS will call when authentication succeeds.
Now log in with the username car and the password car.
Now let’s see exactly what is happening under the hood:
When you first request the URL http://localhost:8080/hello, the request goes through the security filter chain, as always.
The FilterSecurityInterceptor sees that you are trying to access a secured resource, and it throws an AccessDeniedException exception because there is no authenticated user with the required role.
The ExceptionTranslationFilter calls this entry point because you configured applicationContext-security.xml.
Of course, you also defined a “casEntryPoint” bean in the same configuration file.
You can refer to this file back in Listing 6-21
It first constructs the URL of the service that looks something like That value is built using the configured org.springframework.security.cas.ServiceProperties that is injected into the CasAuthenticationEntryPoint.
You can see the definition of the ServiceProperties in the configuration file applicationContext-security.xml.
As you can also see in the built URL, the method concatenates the jsesssionid, of the current user session, into the callback URL.
The CasAuthenticationEntryPoint then creates the full CAS URL that the application needs to redirect to in order to authenticate.
The URL is built using the configured “loginUrl” property of the CasAuthenticationEntryPoint bean and then is concatenated with the service callback URL generated before.
The application then redirects to this URL, which shows the CAS login screen.
After you log in to CAS, you are redirected back to the callback URL.
The first thing it does is check whether the request needs to be authenticated.
In our current case, the check simply involves seeing if the requested URL is for the URL /j_spring_cas_security_check.
In the case of this example, running it on my Linux machine the request.
When attempting authentication, the CasAuthenticationFilter tries to extract the ‘ticket’ parameter from the request.
You can see from the previous step that the parameter does exist.
So the filter extracts this parameter and uses it as the value for the user password.
A new UsernamePasswordAuthenticationToken is created with that username and that password.
This UsernamePasswordAuthentication is then passed to the ProviderManager, which in turns passes it to the CasAuthenticationProvider for authentication.
UsernamePasswordAuthentication) and creates a new instance of CasAuthenticationToken, which is another Authentication implementation, which will replace the UsernamePasswordAuthenticationToken that arrives when the authentication process is over.
When this URL is called, the CAS server internally validates the ticket and the service and then it returns an XML like the one shown in Listing 6-22
AssertionImpl, which contains the successful status and the principal name.
The CAS authentication provider gets the org.jasig.cas.client.validation.AssertionImpl instance returned from the validator, wraps it in a CasAssertionAuthenticationToken, and calls the default configured org.springframework.security.provisioning.
InMemoryUserDetailsManager's loadUserByUsername method to retrieve the configured user and its authorities from the in-memory user store (the <security:user-service> element in our configuration file)
CasAuthenticationToken (which is an implementation of Authentication) with the details returned from both the CAS server and the UserDetailsService implementation (InMemoryUserDetailsManager)
After you have the fully authenticated Authentication object, the flow continues as normal.
The FilterSecurityInterceptor sees the secured resource and can match the required attributes for accessing it against the authorities in the Authentication.
Not everything is covered, just the most important parts in the interaction with the CAS server.
Integrating CAS with a Different Authentication Provider As I said before, CAS is designed to support the integration of different back-end user storage mechanisms, including JDBC, LDAP, and others.
Currently, we are using the demo version of CAS, which matches users anytime you use the same username and password as you have been doing with “car.”
Because I am not going to explain CAS in any more depth than necessary, this part can be thought of as a bonus.
Let’s configure CAS to use file system user storage, which is probably one of the easiest things to configure.
You will get a nice surprise when trying to configure CAS, and this surprise is that CAS is configured using Spring.
So, many of the things you have learned regarding core Spring apply to configuring the CAS server.
In the root of the downloaded CAS server, go to the directory ./cas-server-webapp/ src/main/webapp/WEB-INF.
In the deployerConfigContext.xml file, replace the bean property named "authenticationHandlers" of the bean authenticationManager with the contents of Listing 6-24
In the directory ./cas-server-webapp, execute mvn install to re-create the war file.
In the pom.xml of the CAS runner, replace the line that points to the war file with the path to the newly generated war.
The newly generated war should be in the directory relative to the CAS root ./cas-server-webapp/target/cas.war.
The CAS runner and the example application (remember to run them with the commands mvn jetty:deploy-war and mvn jetty:run, respectively)
Log in with the username car and the password scarvarez.
The same (but with different authentication handlers) can be done for LDAP, JDBC, and others.
Summary In this chapter, I showed you how you can use Spring Security’s modular architecture to integrate different authentication mechanisms with relative ease.
I explained some of the authentication mechanisms that come with the framework.
In particular, I showed you how to authenticate your users against a database, an LDAP server, and an OpenID provider, and by using Client X.509 Certificates and leveraging Java’s standard authentication system, JAAS.
This chapter focused on showing how all these different authentication providers relate to each other when they are used inside the framework.
The goal was to show you that integrating new providers into the framework is simple enough for you to try.
Of course, how easy it is depends on the authentication scheme that you want to plug in.
There are more authentication providers that I haven’t covered in the chapter, but the main ideas tend to remain the same: create a connector into Spring Security that deals with the particulars of the integrating protocol, and adapt it to use the Spring Security model of authentication and authorization.
This chapter will introduce access control lists (ACLs) in the context of Spring Security.
Access control lists can be thought of as an extension to the business-level security rules that we reviewed in.
In this case, however, we’ll be looking at more fine-grained rules to secure individual domain objects, instead of the relatively coarse-grained rules used to secure method calls on services.
What this means is that ACLs are in charge of securing instances of domain classes (such as a Forum class, a Cart class, and so on), while the standard method-level rules secure entry points determined by methods (like a Service method or a DAO method)
The idea is that any user will have a certain level of access (read, write, none, and so on) to each domain object.
A user’s level of access (permissions) to a particular domain object depends on the user, or the role or group to which the user belongs.
As in other chapters, I’ll try to explain each concept as I walk through an example.
The example I’ll be working on is, as usual, a very simple and not real-world application pared down to focus on the concepts relevant to understanding how ACLs work.
The Security Example Application The example application will be a simple forum system with two types of users: standard users and administrator users.
Any user can create a forum entry, but only the user who created the entry can edit it; the other standard users can only read it.
Administrator users can read or delete an entry, but they cannot edit it.
I think this give us all the combinations we need to show the full power of ACLs.
The action is shown with a solid line and permissions are shown with a dotted line.
The first thing we’ll do is review the required database schema to support ACLs in the application.
Spring Security’s ACL module comes with the SQL scripts necessary to define its own support in a file named createAclSchema.sql that currently targets the HSQL database.
There is also an alternative file called createAclSchemaPostgres.sql targeting the PostgreSQL database.) You can find this file in the source code of the Spring Security ACL module or inside the jar file itself: spring-security-acl-3.1.3.RELEASE.jar.
It will be in the src/main/resources folder in the source code, which means it will be in the root of the classpath.
The createAclSchema.sql that defines the needed tables for supporting ACL in Spring Security.
To understand the meaning of these tables, you need to appreciate the main abstractions in SpringSecurity’s ACL support:
A security identity can be a user, role, group, and so forth.
These are the entities on which the permissions are set.
Let’s break down the database tables into their main attributes to see their meaning.
I won’t explain the ID attributes because they are the surrogate identifiers of each row in the pertinent table, and they serve to, well, identify the particular entry.) Figure 7-2 shows the tables in graphical form followed by the explanation of the attributes.
Here are the main attributes (columns) in the tables from the previous figure:
It can be a username of a principal, a role name, and so on.
So permission can be shared between the objects in the hierarchy.
In code, the default permissions are defined in the class org.springframework.security.acls.domain.BasePermission, which is reproduced in Listing 7-2
You can easily create your own class and define extra permissions if you want to do so.
The BasePermission class with the default permissions to use in the ACL system.
You can see that there are not a lot of tables defined in the schema, but it is important that you understand them individually and their relationships.
Figure 7-3 shows the ER (Entity-Relationship) diagram for this data model to help you understand them better.
The diagram describes the meanings of the relationships between tables in simple terms.
This class can be replaced with a custom Permission implementation class that includes different permissions, or it can be extended to include more permissions.
In theory, working this way allows for the permissions to be easily combined to create composed permissions by adding two of them together.
For example, you could combine READ and WRITE permissions by summing their like this.
The class org.springframework.security.acls.domain.DefaultPermissionGrantingStrategy, which is the one in charge of evaluating the permissions required for an object against the permissions stored in the list of ACEs (Access Control Entries), will do comparisons for exact matches.
So you normally have to include an ACE for READ and another one for WRITE.
You should now have an understanding of the main concepts used in ACLs and how they map to the database schema that the framework itself provides.
You also need to include in the pom.xml file, the configuration for the jetty plugin we have been using up until now.
So, in the plugins section of your pom.xml file, add the code from Listing 7-4
The next file to create is the ACL configuration file, so let’s do that.
Later, I’ll show you that some things could be changed to adapt to different needs.
In the WEB-INF folder, create a file named applicationContext-acl.xml with the contents from Listing 7-6
After the listing, you will read a description of the relevant parts.
Let’s give an overview of each of the beans defined in Listing 7-7
Later, when using the application, I’ll offer a more in-depth explanation of the inner works of the framework and exactly what is going on both at startup and at execution time.
The bean that creates the database tables needed for working with ACLs.
The first three beans are not ACL specific because they simply define a data source, a JDBC template, and a transaction manager.
These beans will be used by the ACL infrastructure to access the ACL-specific tables and data in the schema.
Note N  The support beans for working with databases that we defined use classes from the Spring Framework core libraries.
If you have worked with Spring before, you most likely have encountered and used these classes.
You can find information about Spring database support on the official site http://static.springsource.org/spring/docs/3.0.x/reference/jdbc.html.
The next bean I defined is the one with the ID "aclCache"
You need to have a cache implementation for the ACL system to work.
Its function is to make ACL accesses faster by caching the ACLs and not accessing the database for every single query.
The implementation we are using in the bean definition (EhCacheBasedAclCache) is the only one defined currently in the ACL module, and it is a very simple implementation that delegates to EhCache (http://ehcache.org/)
The next bean is the one with the ID "lookupStrategy"
A lookup strategy is in charge of retrieving the object identities (as explained before) and the ACLs that apply to each of those object identities.
The implementation we are using (BasicLookupStrategy) is again the only one defined in the framework.
It will try to load the ACLs from the cache, and if they are not there, it will look them up on the database and cache the results.
The lookup to the database is done in batches so that many items can be loaded to the cache at the same time to improve performance.
The next bean, with the ID "aclAuthorizationStrategy", defines an org.springframework.security.acls.
The goal of an AclAuthorizationStrategy is to determine if a particular principal is able to execute administrative activities in the ACL infrastructure itself.
The default implementation we are using in the bean definition file receives in the constructor three instances of GrantedAuthority, which determine the entities that will have the permissions mentioned before.
The last bean, with the ID "aclService", is the main component of the whole framework.
The interfaces AclService and MutableAclService allow access to all the ACL-related operations, such as reading ACLs by ID, creating ACLs, deleting ACLs, and updating ACLs.
These are all the beans needed in the application to work with ACLs.
As always, you need to make the file from Listing 7-6 load up with the application.
You already know how to do this by modifying the "contextConfigLocation" context-param in the web.xml.
In case it is needed, the web.xml I provided already has the appropriate configuration.
Now let’s make a bean to create the database schema for ACL.
You normally will not do this in a standard application, but we’ll do it here just for convenience.
This class (which is named DatabaseSeeder) uses a copy of the provided "createAclSchema.sql" file with uncommented drop tables to create the required tables in the database.
The file is provided in the source code of the book.
Now we can create ACLs for domain objects, so let’s create our classes to set up the whole process.
This will involve a bit of coding because we’ll need a controller, service, domain object and JSP file.
A simple domain model that we’ll use for trying ACL rules.
The form.jsp file with a form for a new post and a list of existing posts.
The first version of the controller shown in Listing 7-9 allows us to show the form to create new posts and has the action to actually post these new posts for them to be saved.
Later, we’ll add to this controller to support more functionality.
Listing 7-10 has the core functionality for creating an ACL for a domain object instance.
In this case, we are creating a new Post object.
The Post instance is stored in a memory map (which is not a realistic example, but is enough to show the functionality)
The ACL is created using the hash code of the Post instance as the ID of the domain object.
Then we create three ACEs (access control entries) for the ACL.
In the first one, we specify that the ADMINISTRATION permission is granted to the creator of the Post, given by the SecurityContext’s principal.
You can also see that the method is marked as @Transactional.
This is a requirement of the JdbcMutableAclService so that it can execute all the SQLs in the context of a transaction.
The ForumService interface that is implemented by ForumServiceImpl is simply defined as the following:
Note N  Keep in mind that the last code sample of the class ForumServiceImpl is just an example of the functionality for populating ACLs for a particular domain object.
I'm saying this because in a real application, you would probably move the security-related code away from the core business methods and not mix them together the way we are doing here.
You could create an aspect to deal with this or simply another helper service you can call to take care of all the ACL functionality.
After you put the form.jsp file in the WEB-INF/views directory, the application is almost ready to run.
When you start the application, navigate to the URL http://localhost:8080/forum/ and log in with username car, and the password scarvarez.
You will be shown a very small form with just a text box.
When you submit the form, it will be stored on the map and the corresponding ACL will be stored on the database.
You won’t see that on the screen, but it is happening.
You could use a SQL client to look at it.) What is happening under the covers inside the framework is simply the execution of some SQL scripts that are in charge of populating the tables mentioned before with the corresponding data.
The ACL system offers the APIs that can be used to manipulate this data using classes, which you can see in the ForumServiceImpl class.
Internally, all the requests are translated to SQL instructions against the configured database.
It’s also worth mentioning that among the internal workings of the framework is the use of the authentication’s principal as the owner of the ACL and the caching of the ACLs after they have been persisted to the database.
JdbcMutableAclService internally uses Spring’s own JdbcTemplate and batch updates with prepared statements.
Accessing Secured Objects The next logical step is to make sure the rules are actually working by trying to access the created posts.
To do that, we’ll set up a couple more users and finish our service and controller so that they handle the new options.
Remember that we are re-creating the database every time we restart the app.
Again, that’s not what we want in a production environment.) Also, the posts are in an in-memory map, so they are lost when we shut down the application.
So let’s make all the code changes now step by step.
The first thing we’ll do is add an org.springframework.security.acls.AclEntryVoter to the configuration of our application.
AclEntryVoter is an implementation of AccessDecisionVoter like the ones you studied before (RoleVoter, and so forth), which votes whether to grant or deny access based on the rules given by the ACL configuration of domain objects.
You need to create an AclEntryVoter instance for each of the operations you want ACLs to vote on.
For example, in our case, we’ll create three voters: one for voting on reading access, one for voting on update permission, and one for voting on delete permission.
Listing 7-15 shows the definition of these three voters, followed by a more comprehensive explanation of their work.
The AclEntryVoter(s) that correspond to the delete, read, and update actions.
We have three voter beans; however, to analyze one is to analyze them all.
When you define an AclEntryVoter, you need to pass three arguments to its constructor.
The first argument is a reference to the AclService we defined earlier, and the second parameter will be mapped to a config attribute name.
I talked about config attributes earlier in the book, so here I’ll just say that they are the attributes that Spring Security looks for in the @Secured annotation in order to use them when intercepting methods.
The AccessDecisionManager has access to this value and as well as to the different voters that decide if they support a particular config attribute.
In the case of the AclEntryVoter, we are specifying exactly which config attribute that particular voter will support.
The third parameter that we pass to the AclEntryVoter constructor is the permission needed to allow access to the particular operation we are trying to perform on the object.
For example, the scenario for the first AclEntryVoter bean is as follows: We have a method annotated with @Secured("ACL_POST_DELETE") that receives a Post instance as a parameter.
When the method is called, the AclEntryVoter receives the Post object and then retrieves the principal from the authentication and evaluates its permissions against the Post’s ACL to see if it has the required permission—in this case, BasePermission.ADMINISTRATION.
If it does, it will vote to grant access; if it doesn’t, it will vote to deny access.
I’ll explain this in more depth a little later when executing the application.
For these voters to work, you need to add them to the AccessDecisionManager.
Currently, you are using the default AccessDecisionManager, so you need to define an explicit one in the application context with the voters injected so that you can use those voters in the application.
It’s as simple as adding the two beans shown in Listing 7-16
We are using an affirmative-based access decision manager, and we are injecting the three voters in the decisionVoters property.
Remember to update the ForumService interface as well with the new method.
If you recall our previous definition of the voters, you should be able to see that the invocation of this method will be supported by the first voter bean we defined (aclDeletePostVoter)
Before doing so, you need to update the ForumController, adding the method from Listing 7-18
You also need to replace the form.jsp file with the content of Listing 7-19
Then if I click the delete button, the application redirects me to the familiar login screen shown in Figure 7-5
This is what happened here: When I clicked the delete button, the request got all the way to the AffirmativeBased access decision manager, as I explained in previous chapters.
The access decision manager iterates through its configured AccessDecisionVoter(s)—in this case, the AclEntryVoter(s) we injected explicitly.
The voter traverses the MethodInvocation object of the method that was just intercepted, and it iterates through its parameters looking for parameters that are of the type configured in the processDomainObjectClass property of the AclEntryVoter, which in our case is com.apress.pss.acl.domain.Post.
If an object of this type isn’t found on the parameter list of the method, an AuthorizationServiceException is thrown informing you of this.
In our case, it is found, and it is actually the only parameter that the deletePost method expects.
If the object that arrives in this parameter is null, the voter will simply abstain from voting.
The next thing the voter does is try to retrieve an ObjectIdentity instance from the domain object.
It does this by using an ObjectIdentityRetrievalStrategy that is configured by default and whose only implementation is org.springframework.security.acls.domain.ObjectIdentityRetrievalStrategyImpl.
This strategy simply invokes the constructor of ObjectIdentityImpl that receives a domain object as its only parameter.
This constructor in ObjectIdentityImpl assumes that the domain object provides a getId method to be able to retrieve the identifier for it.
If the method is not there, a corresponding exception is thrown.
Our Post class has such a method, so this works fine—invoking that method and setting the return value as the identifier of the ObjectIdentity.
After obtaining the ObjectIdentity, the voter tries to retrieve the SIDs from the Authentication object.
For this, the voter uses a SidRetrievalStrategy, whose sole implementation (SidRetrievalStrategyImpl) retrieves both the authorities (for example, ROLE_USER) of the Authentication object plus the principal.
So it will have an instance of PrincipalSid and as many instances of GrantedAuthoritySid as the authenticated user has authorities.
The next step for the voter is to retrieve the actual ACL for that particular ObjectIdentity and the SIDs.
It does this with the help of the configured AclService, which I already talked about.
In the next step, the retrieved ACL is consulted by its isGranted method to see whether or not access should be granted.
This method receives the required permission (as defined by the third constructor argument of the beans of type AclEntryVoter, which in the case of DELETE had the value org.springframework.security.acls.
The ACL, in turn, delegates to an instance of PermissionGrantingStrategy (actually, to the implementation DefaultPermissionGrantingStrategy) to make the final call on whether the SIDs have the required permissions on the domain object.
PermissionGrantingStrategy’s sole implementation, DefaultPermissionGrantingStrategy, simply iterates through the list of permissions, the list of SIDs, and the list of ACEs in the ACL.
It compares the permissions one by one against the permissions on the ACE,
If it finds a match, it allows access; if it doesn’t find any match, it rejects access by throwing an exception, which is caught by the voter to return ACCESS_DENIED.
In our case, because the current authenticated user is ANONYMOUS, this whole flow is what happens.
On the login page, I log in now with the username car and the password scarvarez (which is one of the users I defined in the applicationContext-security.xml file) and try to delete the post.
The same thing as before is happening: the logged-in user car and its roles ROLE_USER don’t match the rules required to execute the deletePost action on that particular post.
As I said before, only a user with role ROLE_ADMIN can delete the post.
First I log out by visiting the URL http://localhost:8080/j_spring_security_logout, and then I log in with the username mon and the password scarvarez and try to delete the post again.
This time, the Acl.isGranted method returns true and the voter returns ACCESS_GRANTED because the match exists between the role of the authenticated user and the authorities required to perform the required action.
This means that the code execution will finally reach the deletePost method in the ForumServiceImpl.
This is a very simple method that removes the entry from the ACL for that object and, of course, deletes the object from the store.
Remember, we are using a java.util.Map as our in-memory store, which is not the most realistic simulation but works for the purposes of the example.) Figure 7-6 shows the most important aspects of the process I just explained.
Filtering Returned Objects So we successfully tested the DELETE action with a Post domain instance that should be allowed only to ROLE_ADMIN users.
Let’s secure the READ one so that only users with role ROLE_USER can read them.
In our example, we want to secure the method getPosts in the ForumServiceImpl class in such a way that when the posts are returned, they are filtered out by the rules explained in the last paragraph.
First, we need to add a new voter to the list of voters of our AccessDecisionManager.
The new voter is of type org.springframework.security.access.prepost.PreInvocationAuthorizationAdviceVoter and is shown in Listing 7-20
This voter is needed because even if we’ll be using only the @PostFilter annotation, Spring Security will try to evaluate the config attributes when it’s doing the voting, and it includes a PreInvocationAttribute in the list of config attributes that it will evaluate with the value permitAll, so the PreInvocationAuthorizationAdviceVoter will vote to grant access all the time.
The code in Listing 7-20 should be added in the file applicationContext-security.xml.
PreInvocationAuthorizationAdviceVoter needed to vote on the automatically generated permitAll expression.
Next, we need to change the return type of our getPosts method because the filter we’ll add works only with instances of java.util.Collection or arrays, and as we currently are returning a map from  that method, the implementation wouldn’t work.
If you are following along with the code, you should change all the classes and files that depend on this method, including the form.jsp file.
The getPosts method now returns a collection of posts and not the map.
Next, on top of the method from Listing 7-21, we add the annotation collection and READ is the permission that matches the BasePermission.READ that you saw before.
Next, I’ll explain how it works, in the context of an execution scenario.
However, first we need to configure a couple of beans manually in the application context to allow the correct evaluation of permission expressions.
This is needed because, by default, the SpEL expression evaluator configured in Spring Security will use an org.springframework.security.access.expression.DenyAllPermissionEvaluator which, as its name implies, will deny all permission evaluation requests.
That configuration is hardcoded in the class org.springframework.security.access.expression.AbstractSecurityExpressionHandler<T>, and we need to replace it with a proper evaluator.
Fortunately, Spring Security provides us with the proper evaluator in the form of the class org.springframework.security.acls.AclPermissionEvaluator.
We need a bit of work to configure it, but it is not that difficult.
First, we need to define the bean that will be the new ExpressionHandler.
We do that in the applicationContext-security.xml file by adding the code from Listing 7-22
If you are following through in the code, you should restart the application now.
After the application is restarted, if you visit the URL http://localhost:8080/forum/ and create a post, you will see that the post won’t be shown in the page.
This is because you created the post as an ANONYMOUS user.
Remember that posts now will show only for ROLE_USER users.
If you log in to the application with the username car and the password scarvarez and again go to the URL http://localhost:8080/forum/, you will see the post in the page and the delete button.
The following paragraphs explain how it all works under the hood.
As you might recall from previous chapters, the core of Spring Security is the concept of the SecurityInterceptor and its two personifications: FilterSecurityInterceptor and MethodSecurityInterceptor.
As you probably recall as well, the interceptors work in a pre-process, process, post-process flow.
The “pre-process” phase is taken care of mainly by the access decision managers and the access decision voters that decide whether or not access should be allowed to a particular resource (be it a method, a domain object, or a URL)
The “post-process” phase is handled by an AfterInvocationManager that is called from the SecurityInterceptor.
I explained this process before: the AfterInvocationProviderManager iterates through a list of AfterInvocationProvider, which takes the final decision of whether or not access to a particular domain object instance is allowed.
The important part in our current example is that the chain of calls ends in an instance of ExpressionBasedPostInvocationAdvice (through the PostInvocationAdviceProvider), which checks to see if there is a postFilter expression that needs to be handled.
If there is, it calls the DefaultMethodSecurityExpressionHandler that we defined in Listing 7-22
This handler checks that the returned value from the business method with the @PostFilter annotation was indeed a collection or an array (and throws an exception if it wasn’t)
Then it iterates through this collection, evaluating the SpEL expression on each object and discarding the object to which the evaluation of the expression gives the value false.
The expression we are using is an ACL expression and, like most of the other expressions, its backing method is defined in the class SecurityExpressionRoot.
This method (hasPermission) uses the permission evaluator we defined in Listing 7-22 to decide if the authentication has the required permissions on the object being passed.
This evaluator uses the same suites of classes and helpers that the AclEntryVoter uses to decide whether or not to grant access, such as the AclService and the method isGranted in the ACL interface.
When we tried to access the list with the anonymous user, the only existing post was discarded from the return elements because the user didn’t match the permissions required to read the object.
ACL’s isGranted method returned false.) When we logged in as car, scarvarez, we acquired the role ROLE_USER.
This role is indeed allowed to read post objects, as specified by the ACL rules that we created when we first created the post.
Let’s see how filtering works in an example with more than one post.
This time, we’ll create a post with a user with the role ROLE_ADMIN.
We’ll modify the post creation code so that when an Admin user creates a post, only other ROLE_ADMIN users can read that post.
To do that, change the createPost method in the ForumServiceImpl class to look like Listing 7-23
This listing (like many others in the book) takes an approach of preferring convenience over particularly good design.
For example, you might argue, and rightly, that the ACL mutation is not part of the core createPost method business functionality, and also that hardcoding role names in the code is not right.
Again, I’m doing this to illustrate concepts in a convenient way, without too much abstraction and directly to the point that I’m trying to show.
In a real environment, you should try to achieve a good separation of concerns, giving the security concerns their own space (whether using AOP or other methods) and leave the business method to handle, well, business concerns.
The createPost method that creates different ACLs depending on the user that is creating the post, along with a needed helper method to check whether the logged-in user has the ROLE_ADMIN role.
You can see in the listing that we added a conditional saying, basically, that if the logged-in user is an Administrator, the READ permission will be available only to other Administrators (users with the role ROLE_ADMIN)
If the logged-in user is not an Administrator, the READ permission will be available to any user with the ROLE_USER role.
I’ll now show an execution of this new configuration step by step.
Test Scenario 7-1 To execute this new configuration, I used the following steps:
I restarted the application, and then visited http://localhost:8080/spring_security_login and logged in with the username car and the password scarvarez.
The sceen that is generated after an admin user creates a post.
I visited the URL http://localhost:8080/j_spring_security_logout to log out of the application.
Then I visited the URL http://localhost:8080/spring_security_login and logged in with the username mon" and password scarvarez.
I visited the URL http://localhost:8080/j_spring_security_logout to log out of the application.
Then I visited the URL http://localhost:8080/spring_security_login and logged in with the username bea and the password scarvarez.
The screen that is generated after a user with the role ROLE_USER creates a post.
I visited the URL http://localhost:8080/j_spring_security_logout to log out of the application.
Then I visited the URL http://localhost:8080/spring_security_login and logged in with the username car and the password scarvarez.
As I said before, the pre-processing activities are taken care of by AccessDecisionVoter implementations.
In the case of the @PreFilter annotation, it is taken care of by the org.springframework.
I just showed you a simple walkthrough of how this ACLfiltering functionality works in practice.
You can see that by providing only the @PostFilter annotation with the hasPermission expression (which, as you know, internally calls a method in the SpEL context), we are instructing the framework what to do with the returned values of the method.
The diagram shows how parameters and return collections of domain objects are filtered out on the way in and out of the method.
A diagram showing the main classes and interfaces in the pre-processing phase of a method interception with ACL-based security.
A diagram showing the classes that participate in the post-processing phase of a method interception with ACL-based security.
You can see in the diagram that, at the end of the processing, both paths reach the essential elements in the SidRetrievalStrategy, ObjectIdentityRetrievalStrategy, and AclService.
In fact, the AclPermissionEvaluator and the AclEntryVoter perform very similar functions.
You can see that these two branches map almost one to one to the branches in the pre-processing phase.
Also, you can see that there is a high level of reuse in the system and that many classes are present in both the pre-processing and post-processing phases.
I covered two different ways to handle ACL security, with the two branches I talked about in the previous paragraph.
Securing the View Layer with ACLs Another option you have for using ACLs to secure applications is to use the view-layer JSP tags to filter out domain objects for users who don’t have the proper permissions to see them.
I talked a bit about these tags in the web security chapter, but I intentionally left the ACL tags for more thorough treatment here.
To use them in an example, let’s continue with our code from the previous section, but let’s make a couple of changes.
First, in the ForumServiceImpl class, comment out the @PostFilter annotation in the getPosts method so that it doesn’t filter out anything anymore.
Then change the form.jsp file to look like Listing 7-24
The form.jsp with taglib ACL security applied for filtering domain objects.
This listing shows how simply you can secure domain objects on the view layer.
In fact, it does a very similar job (in view terms) to what you get when you use the @PostFilter annotation.
It will work only if there is only one bean of this type configured in the application context, because it will try to retrieve the bean by type.
As you might recall, we have a configured PermissionEvaluator in our configuration of concrete type org.springframework.security.acls.AclPermissionEvaluator.
Now, if you restart the application and again execute the steps we defined in Test Scenario 7-1, you should have exactly the same behavior from a presentation layer point of view as you had before when you first executed that scenario.
Every time the tag is evaluated (in each iteration over the posts collection), the tag handler calls the PermissionEvaluator’s hasPermission method, which returns a Boolean indicating whether or not permission has been granted.
If permission is granted, the body of the tag is evaluated and rendered.
If permission is not granted, the body of the tag is skipped.
The Cost of ACLs The example we have been working on shows that working with ACLs imposes a good deal of overhead in terms of the operations and logic you need to implement on top of your standard business operations.
It’s clear that storing a post is affected by the extra work that is necessary to store the corresponding ACL for that object, and retrieving posts is affected by the need to filter out certain elements of the collection based on the permissions.
This brief section will go inside the core class of the ACL Spring Security support to see how it works internally and how it might affect your application.
JdbcMutableAclService is the class that deals with all the input and output to the database for everything regarding the ACL database schema.
It’s configured by default to work with HSQLDB, which is the database we have been using in our examples.
This class has different SQLs for the different things you do when you interact with the ACL system—like inserts into the different tables, deleting ACLs, updating values and, of course, selecting from the different tables.
All of these operations are done using Spring Core’s JdbcTemplate support.
Another important class is BasicLookupStrategy, the default implementation of LookupStrategy used in the framework to look up ACLs.
The first interesting operation  you see is the method readAclsById, which exists in JdbcMutableAclService and delegates to a method of the same name in BasicLookupStrategy.
This method tries to retrieve the requested Acl from the cache.
If it finds the ACL in cache the method will return this found ACL; if the ACL is not found in the cache, the implementation will query the database with a somewhat complex query with four joins, as  Listing 7-25 shows.
This query can get a bit more complex because the ACLs can be retrieved in batches of up to 50 elements (which is the default but is configurable by setting the property batchSize in the class BasicLookupStrategy) and, for each of these elements, the where clause adds an or operator to the query.
The result from this query is then stored in the cache, which then makes these ACLs available so that if another method calls readAclsById requesting one of the cached elements, the database doesn’t need to be hit.
When you create a new post, the readAclsById is called.
Also, another select query is performed to retrieve the primary key of the objectIdentity represented by the domain object.
Then all the caching entries for that Object Identity are cleared and a new call to  the readAclsById is executed which will query the database for the up to date information.
You can see how the cost of deleting a post has increased considerably with the use of ACLs.
Deleting Post objects is also more costly because now it involves deleting ACE entries, deleting object identities, and clearing the cache for the relevant objects.
This section is not meant to scare you away from using ACLs.
I simply want to make you aware that there is an extra cost (apart from the complexity of using it) you should take into consideration when creating your applications with the use of ACLs in mind.
The more domain objects you have, the more ACL entries you will have as well.
In a big application, you might be talking about millions of entries in the ACL support tables.
An acl retrieving query that you can find in the class org.springframework.security.acls.jdbc.
Summary In this chapter, I explained in detail how to use Spring Security’s support for ACLs.
We examined different ways to make sure that secured domain objects don’t show up in the presentation layer for a user who doesn’t have appropriate permissions.
You saw that this is achievable either with SpEL expressions at the @PostFilter business level or with the ACL Spring Security tag library directly in your JSP files.
I also gave a quick overview of the different SQLs that are used by the ACL framework and how they might impact your application.
This is primarily because the framework is built using object-oriented principles and design practices so that it is open for extension and closed for modification.
In the previous chapter, you saw one of the major extension points in Spring Security—namely, the pluggability of different authentication providers.
This chapter covers some other extension points in the framework that you can take advantage of to extend Spring Security’s functionality or to modify or customize functionality that doesn’t work exactly the way you need in your applications.
I also briefly cover the Spring Security Extensions project (http://static.springsource.org/spring-security/site/extensions.html), an environment you can use to create extension modules for the core Spring Security project.
The next section defines what I consider to be some of the major extension points in Spring Security and describes how to use them to add or modify behavior in your security solution.
Spring Security Extension Points Spring Security offers a comprehensive set of extension points that can be customized (or completely overridden) with your own implementations and still leverage the core of the framework.
Some of the extension points are evident, while some others are a bit more subtle and, in some cases, not even intended.
However, because the framework is so flexible, you can take advantage of that flexibility to tweak its configuration to fit your intentions.
Plug into the Spring Security Event System Spring Security supports an event model that is built on top of Spring Framework’s own event model.
You can use Spring’s event model to develop applications that can listen to different events that happen within the framework and act accordingly.
I won’t explain in any depth why an event model is such a powerful programming practice to have at your disposal.
Instead, I’ll just point out one big advantage: it allows you to decouple your applications, because in general the event producer or producers and the event consumer or consumers don’t need to know anything about each other in order to operate correctly.
In theory (and, indeed, in practice for events in general, although not for Spring events), you can have a completely heterogeneous application where you can write and evolve each module at its own pace without affecting other parts, and then integrate them all together through the exclusive use of events.
All Spring events should extend from the abstract class org.springframework.context.ApplicationEvent, and Spring Security’s own events are no exception.
One of the main concrete implementations of the ApplicationEvent abstract class is org.springframework.context.event.ApplicationContextEvent, which itself serves as the parent class of a series of events that involve the life cycle of the application context (ContextClosedEvent, ContextRefreshedEvent, ContextStartedEvent, ContextStoppedEvent)
This interface defines a single method, void onApplicationEvent(E event), that you can use to listen to a particular type of event in the application.
You only need to define a bean in your Spring application context that implements the interface org.springframework.context.ApplicationEventPublisherAware, which again defines only one method:
This method is called automatically by Spring when the application starts up, and an instance of ApplicationEventPublisher (an implementation of it because it is an interface) is passed in.
The instance of ApplicationEventPublisher that is passed in is normally the ApplicationContext instance itself that contains the application.
The default implementation of ApplicationEventPublisher’s publishEvent method (which lives in the class AbstractApplicationContext) delegates the publishing of the events to an implementation of ApplicationEventMulticaster—the only current implementation of which is org.springframework.context.event.SimpleApplicationEventMulticaster.
Broadcasting an event to all interested listeners is also straightforward.
You simply need to create an instance of one of the implementing classes of ApplicationEvent (any subclass of it will do as an event) and then call the ApplicationEventPublisher’s publishEvent(ApplicationEvent event) method, passing your ApplicationEvent instance to it.
Spring then takes care of ensuring that all the listeners registered for that particular event are notified of the event publication.
By default, all listeners are invoked on the same thread as the publisher; however, you also could configure an org.springframework.core.task.TaskExecutor (which is an interface, so you could use an implementation class like org.springframework.core.task.SimpleAsyncTaskExecutor) to call the listeners in different threads.
You will use this when you configure the listeners in our examples.
Spring Security comes with its own suite of ApplicationEvent implementations, so you can hook into different points of the security life cycle in an unobtrusive and decoupled way.
The ApplicationEvent implementations that Spring Security provides are categorized as Authorization, Authentication, or javax.servlet.http.Session types, and they have descriptive names that hint what they do and where they are published.
Here, I will give a concrete explanation of them and when they are published within the framework.
Authorization-Related Events These are events related to the different phases that an authorization process can go through—for example, informing a user when an authorization has failed.
It doesn’t really add any functionality on top of ApplicationEvent.
It is more like a marker identifying all its subclasses as authorization events.
This event is broadcasted from the AbstractSecurityInterceptor’s beforeInvocation method after it decides that an invocation should have security but the interceptor doesn’t find the required Authentication object in the security context.
Simply put, this event is executed if the condition SecurityContextHolder.
This event is published by the AbstractInterceptor’s beforeInvocation and afterInvocation methods when it catches an AccessDeniedException.
AccessDeniedException can be thrown by the org.springframework.security.access.AccessDecisionManager’s decide method in the pre-processing phase of the interceptor, and by the org.springframework.security.access.intercept.AfterInvocationProviderManager’s decide method in the post-process part of the interceptor.
This event is not published by default, and if you want it to be published, you need to set the property publishAuthorizationSuccess to true in the security interceptor.
In the case of method security, this means that when an object’s security proxy is invoked, if the particular invoked method is not configured with security metadata, it is then handled as a nonsecured public call.
However, instead of simply invoking the method, an event is broadcasted just before proceeding to inform to any listener interested in this fact that this (a public invocation) has happened.
This could point to a case when you actually need to secure the endpoint and, thanks to the event, you will be notified that you haven’t done so.
After the event is published, no more pre-processing or post-processing is executed for this invocation on the interceptor.
If the property rejectPublicInvocations is set to true in the interceptor (the property is part of the AbstractSecurityInterceptor class), the event will not be published, and instead an IllegalArgumentException will be thrown saying that the particular invocation cannot be done without the ConfigAttribute(s) configured.
This means that a configuration error needs to be taken care of.
Figure 8-2 shows these event classes and interfaces in UML (Unified Modeling Language) form.
Authentication-Related Events These events are related to the authentication process in the application and the different phases this process goes through, such as informing interested listeners of disabled accounts and expired credentials.
Authentication events are published by an implementation of org.springframework.security.authentication .AuthenticationEventPublisher, which is invoked by the org.springframework.security.authentication .ProviderManager class.
By default, the configured AuthenticationEventPublisher in the ProviderManager is an instance of NullEventPublisher, which is a private static class defined inside the ProviderManager class itself and which doesn’t publish any events.
There exists a default implementation of the interface AuthenticationEventPublisher that you can use if you are configuring the beans yourself, which is org.springframework.security.authentication.DefaultAuthenticationEventPublisher.
This instance is configured by default for the web-layer security when using the <http> element.
The DefaultAuthenticationEventPublisher works in the following way: It has only two public methods that it implements from the AuthenticationEventPublisher interface.
These are the possible two scenarios when attempting authentication; however, in the case of authentication failure, there can be many reasons for it, as you can see from the amount of AuthenticationFailureXXXEvent instances that I’ll show you next.
In the case of authentication failures, the DefaultAuthenticationEventPublisher will receive a call to the publishAuthenticationFailure method, and then it will query a mapping between the exception that was thrown when authentication was denied (like UsernameNotFoundException, for example) and the event that corresponds to such an exception (like AuthenticationFailureBadCredentialsEvent)
Then an instance of this event will be created by reflection and will be published.
It is possible to add more mapping into the default mappings between exceptions and events using the method provided by the DefaultAuthenticationEventPublisher: setAdditionalExceptionMappings.
The authentication-related events currently in the framework are the following:
It doesn’t introduce any particular functionality, and it serves the basic function of classifying authentication events.
AbstractAuthenticationFailureEvent This is the parent class of all the authentication failure events.
It extends AbstractAuthenticationEvent but adds a constructor that takes in the exception that was thrown when the authentication failure happened.
AuthenticationFailureBadCredentialsEvent This event is published when a BadCredentialsException is thrown by the system during authentication.
This exception is thrown by the different AuthenticationProvider implementations when a check for the credentials of an Authentication object is not valid.
The event is also published when a UsernameNotFoundException is thrown.
This is thrown normally by UserDetailsService implementations when they can’t find a user corresponding to the passed username and simply propagated by the AuthenticationProvider.
AuthenticationFailureCredentialsExpiredEvent This event is published when a CredentialsExpiredException is thrown.
This exception is thrown, for example, by an implementation of AbstractUserDetailsAuthenticationProvider when the UserDetails object representing the user returns false from the method isCredentialsNotExpired.
AuthenticationFailureDisabledEvent This event is published when a DisabledException is thrown.
This exception is thrown if the user account that is trying to log in has been disabled.
It is used by AbstractUserDetailsAuthenticationProvider and also AccountStatusUserDetailsChecker implementations evaluating if the UserDetails.isEnabled method returns false.
AuthenticationFailureExpiredEvent This event is published by the ProviderManager when an AccountExpiredException is thrown.
This exception is thrown following the same logic as the previous case, but this time the UserDetails.isAccountNonExpired method is the one that is called.
AuthenticationFailureLockedEvent This event is published when a LockedException is thrown.
This exception is thrown in the same places as the previous one (in pre-authentication checking scenarios) and is thrown when the UserDetails representing the user returns false from its method isAccountNonLocked.
AuthenticationFailureProviderNotFoundEvent This event is different than the previous ones in that it is not related directly with the user attempting to log in.
Instead, this event is published when a ProviderNotFoundException is thrown.
This exception is thrown by the ProviderManager itself if none of the configured AuthenticationProviders configured in the ProviderManager are able to handle the authentication request.
AuthenticationFailureServiceExceptionEvent This event gets published when an AuthenticationServiceException is thrown.
This exception can be thrown by different parts of the system (for example, UsernamePasswordAuthenticationFilter and DaoAuthenticationProvider), and it is generally used for communicating that the authentication could not be processed due to some sort of system error—for example, if the user repository cannot be accessed.
InteractiveAuthenticationSuccessEvent This event is published directly by different filters in the web-layer security part of the framework, and not by the DefaultAuthenticationEventPublisher.
It is published whenever a successful authentication is achieved by any of the filters that actively try authentication, like the UsernamePasswordAuthenticationFilter or the RememberMeAuthenticationFilter.
JaasAuthenticationEvent This is the parent event of both JaasAuthenticationFailedEvent and JaasAuthenticationSuccessEvent, and they are published by the JaasAuthenticationProvider.
Figure 8-3 shows the mentioned event classes in a UML class diagram.
Session-Related Events These events (org.springframework.security.core.session.SessionCreationEvent and org.springframework.security.core.session.SessionDestroyedEvent), which extend directly from ApplicationEvent, are related to the user session life cycle.
They are both published (actually, their concrete implementing subclasses HttpSessionCreatedEvent and HttpSessionDestroyedEvent) by an instance of HttpSessionEventPublisher, an implementation of the standard servlet interface HttpSessionListener, which allows the HttpSessionEventPublisher to create session life-cycle listeners.
The implementation needs to be referenced in the web.xml file like any other HttpSessionListener.
The two session-related events map one-to-one to the two methods defined by the HttpSessionListener interface.
This is all the theory you need to know about publishing and handling events in Spring Security.
Next you will see a very simple example where you put this knowledge into practice to add behavior to your application based on listening to events.
This example will listen to only one type of event, but the configuration needed to listen to more types is exactly the same.
You implement the same interface but type it differently in the generic type.
All you need do to start listening for events is implement the ApplicationListener interface and configure the implementing bean in the Spring application context.
Listing 8-1 shows a simple implementation that logs AuthenticationFailureBadCredentialsEvent events.
LOG.warn("An attempt to login with bad credentials was made with username "+
You need to implement only the interface and type it with the class of the event that you want to listen to.
Then if you define a bean instance of the class LoggerBadCredentialsEvents in the application context, it will automatically be wired into the Spring Framework event-handling system, and every time an AuthenticationFailureBadCredentialsEvent is published, this listener will be notified of it.
To define any other event handler, you do the same but type the handler class by the correct event that you want to listen to.
It should be simple enough to test this functionality for different event types.
Your Own AuthenticationProvider and UserDetailsService You have seen in the previous chapter that Spring comes equipped with quite a few authentication options to adjust to a lot of different application requirements that you might have in your application.
Looking at how these different authentication providers are set up in your application and the nice way they are contained in their own “modules,” you could think that you should be able to use your own authentication provider.
The truth is, of course, that you can, and here I will show you how with a simple example.
First of all, let’s review how the authentication providers work in your application.
The main authentication entry point in Spring Security is the AuthenticationManager interface—in particular,
ProviderManager’s main functionality is to iterate through a list of AuthenticationProvider implementations that are configured on it until one of them is able to authenticate the user (wrapped in one of the available Authentication implementation objects) or, in fact, until discovering that none of them can, at which point it throws an exception.
The standard way you saw in previous chapters for defining the ProviderManager and the AuthenticationProvider is the one shown in Listing 8-2
Although the class names and the names of the elements in the XML file don’t exactly match, the Spring Security namespace XML parsing mechanism takes care of matching the combination shown of the <authentication-manager> and <authentication-provider> elements to the classes mentioned before.) When you use the namespace to define an authentication manager and an authentication provider as shown in the listing, the framework instantiates two ProviderManager objects and sets one as the parent of the other.
This scheme is used by the ProviderManager which is able to establish a hierarchy of authentication managers.
The child AuthenticationManager (in form of the ProviderManager class) is queried first for authentication.
This parent–child relationship is managed by Spring at startup time.
Defining your own custom authentication provider is simple, as you just need to implement the interface org.springframework.security.authentication.AuthenticationProvider, which defines only two methods:
You could easily extend AbstractUserDetailsAuthenticationProvider (the way that DaoAuthenticationProvider works) if the implementation you want to create depends on the UserDetails abstraction for authentication.
The main method in the AuthenticationProvider is the public Authentication authenticate(Authentication authentication) method.
This method, as you can see, receives an authentication and returns an authentication.
The important difference between the two authentication objects (the one received and the one returned) is that the Authentication object it returns will return true in the method isAuthenticated (if authentication is successful, of course), indicating that a fully authenticated object is now in existence, while the Authentication object received in the method will have this method returning false.
This is the logical way to work, as this method in an Authentication object (isAuthenticated) and its return value are what conceptually differentiate an Authentication object that is fully authenticated from one that is used only to wrap the user details before actually applying the authentication logic; or, indeed, any Authentication object that hasn’t yet been fully authenticated and verified.
Sometimes, you might not need to implement a whole AuthenticationProvider, but instead you just might need to change the place from where the UserDetails is obtained.
That is the case, for example, when using the InMemoryUserDetailsManager for getting UserDetails stored in memory or using JdbcUserDetailsManager when getting UserDetails stored in a relational database.
Of course, you can create a new UserDetailsService to retrieve this UserDetails from some other source, and that is something I’ll show you in the upcoming examples.
Figure 8-4 illustrates the relationship between the AuthenticationProvider (actually, the AbstractUserDetailsAuthenticationProvider implementation) and the UserDetailsService.
In Figure 8-4, both AbstractAuthenticationProvider and UserDetailsService can be replaced by custom implementations.
The UserCache, by default, uses a NullUserCache implementation, which is a no-op cache.
It can also be replaced easily, but I don’t cover that here.
The idea of the cache is to keep the UserDetails objects cached in case they need to be retrieved again.
The authenticate method in the AbstractUserDetailsAuthenticationProvider will look first for UserDetails in this cache; if the authenticate method finds the UserDetails in the cache, it will use that UserDetails to try the authentication.
If the authenticate method doesn’t find UserDetails in the cache, it will query the configured UserDetailsService for the user and then store it on the cache for subsequent requests.
The first example I’ll show is how to create your own UserDetails service and plug it into the AuthenticationProvider.
For this, you will simply use the DaoAuthenticationProvider, whose functionality is precisely to delegate the retrieval of UserDetails to a UserDetailsService and authenticate the retrieved user.
In the example, I will also introduce the option to exchange password encoders in order to use different algorithms to cypher the passwords, instead of storing them in plain text.
The first thing we’ll do is get the code from Chapter 2, as you will use it as a base for all your examples in this chapter.
In my case, I changed the pom.xml a little bit to use a different project and artifact name.
If you do not, next is a quick step-by-step reminder on how to configure the applications from this chapter.) You can do the same with your configuration or simply start from scratch, remembering to copy the required dependencies in your pom.xml.
For you to have a running application and to not leave you guessing exactly what parts of Chapter 2 to grab here, I give you the step-by-step guide to get all the needed application setup.
I won’t explain the steps, as they have already been covered; I will just give a quick list of the steps to help you follow along with the examples.
In future sections when a new project is started to test some new functionality, you can refer to this part to create a new project from scratch:
In the pom.xml file, add the dependencies from Listing 8-3
In the pom.xml file, add the plugin from Listing 8-4 to the build section.
Create the applicationContext-security.xml from Listing 8-5, and put it in the WEB-INF folder of the application.
Create the simple servlet from Listing 8-7 in the package com.apress.pss.servlets.
Remember that security is currently configured, as shown in Listing 8-5
Let’s create a new UserDetailsService implementation that will look for users in a MongoDB database.
Like many other examples in this book, the implementation I’ll show you will be somewhat trivial, but it will serve to show you the steps you need to implement the UserDetailsService.
First of all, let’s add the MongoDB dependencies to our pom.xml.
You will be using Spring Data to set up and use MongoDB.
It is not really required, but because you are working with Spring it seems like a good idea.
The dependency you need to add to the pom.xml file is shown in Listing 8-8
You can download it from its official site at http://www.mongodb.org/downloads.
After you download it (and assuming you are working on either Linux or Mac OSX), you can simply unpack the file somewhere and it is ready to run.
To run the MongoDBserver, simply go to the bin directory of the directory you just unpacked and run the file ./mongod.
If you have Windows, you should find easy-to-follow instructions in the MongoDB website.
It is part of the many NoSQL solutions that have become so popular in the recent past.
Its main power comes from the fact (at least from my perspective) that it combines a very scalable storage solution with a very intuitive document model built on top of known technologies (like JSON and JavaScript in the command-line interface)
And it does this without forgetting about one of the best things of the SQL world, which is the flexibility given by the availability to execute dynamic queries, allowing you to query your database using very varied criteria and filtering options.
This contrasts with, for example, key-value storage solutions that allow searching only by the key.
As I said, MongoDB is a Document store, where the Documents are structured as JSON.
MongoDB stores its Documents in collections of documents called collections.
I won’t go into explaining MongoDB any further, except for what is needed to create and run the example.
If you are interested in learning more about it, there is a lot of bibliography online that can help you out, starting with the project’s website and, in particular, this link to current books on the topic: http://www.mongodb.org/display/DOCS/Books.
You now have the MongoDB server running and the needed dependencies in your project.
To do this, you need to implement only one method:
You can see how nice the Spring Data MongoDB solution looks, and you should be able to understand to some degree what the code is doing.
The MongoUserDetailsService is getting a MongoTemplate reference at construction time, which it then sets on an instance variable.
The loadUserByUsername method uses this template to retrieve the user from the Mongo database.
As you can see, the loadUserByUsername method calls the findOne method in the mongoTemplate to try and retrieve the user by username, telling it (in the second parameter to findOne) the class of the object it expects its result to be unmarshalled to and the Mongo collection where it is trying to find the specified document.
The User class, which is an implementation of UserDetails, is the class of the objects that we expect to get back from the method call.
That is all specified by the following simple method call:
A query that specifies the information you want to get using filtering.u� The class of the object you expect to be returned from the query.
Internally, the u� MongoTemplate and some helpers will take care of the conversion from the native Mongo objects to this object type.
It will use a set of mapping converters to help in this conversion.
The collection that you want to query with the template.
Remember that a collection is simply u� a, well, collection of documents.
You normally store similar documents in the same collection, and if you are familiar with relational databases, you can think of collections conceptually as tables from the relational world, although they are not the same.
You can also see in the code listing that you are throwing a UsernameNotFoundException in case the MongoDB query you are executing returns null.
With this, you remain consistent with the way other UserDetailsService implementations work and what the AuthenticationProvider expects.
The next thing you need to do is configure the application so that it is actually aware that it will be using MongoDB.
Then you must configure the new UserDetails service in the AuthenticationProvider.
First you create a new configuration file in the WEB-INF folder named applicationContext-mongodb.xml with the content from Listing 8-10
You can see that this file is using a <mongo:> namespace.
This is part of the Spring Data project’s MongoDB support.
More importantly, you can see that you are defining two converter instances inside a <mapping-converter> element and then using this converter in the mongoConverter property of the MongoTemplate.
You can use these two converters to map the documents from the Mongo database to and from the User objects you are using.
UserReadConverter makes sure you can read the MongoDB document into a User object.
The relevant data is extracted from the document and is transformed when needed (as with the GrantedAuthority) to set it as properties of the object, and of course it calls the correct constructor on the User class.
It takes a User object and extracts the values from its properties to store them on the MongoDB collection creating a Mongo DBObject, which ultimately will represent a Mongo document.
These converters are automatically invoked with the definition you wrote in Listing 8-10
Now you have to change the applicationContext-security.xml file in a couple of ways.
The first thing that needs to be done is to import the new applicationContext-mongodb.xml file.
The second thing is to define the new UserDetailsService bean and make it part of the security flow by injecting it in the AuthenticationProvider.
In the end, your applicationContext-security.xml file should look something like Listing 8-13
Although everything is configured right now, you still don’t have any users created in your users collection in your example1 Mongo database.
This interface has JDBC, LDAP, and InMemory implementations, but, of course, there isn’t a MongoDB one.
What you will do is modify your MongoUserDetailsService to implement this interface instead of the simple UserDetailsService.
Then you will create a simple program to store a user using this service.
You can see that Listing 8-14 added the method createUser to the class, which simply uses the MongoTemplate to store the user in one line.
The listing also has a lot of new methods, which you are not going to implement but which are required by the UserDetailsManager interface.
Then you are using your new UserDetailsManager (the MongoUserDetailsService) implementation to store the user in the Mongo database.
This is so that you have a user for your tests.
Run this main class as you would normally run any Java class with a main method to store the user.
After running this class, you should have the user created in the collection.
You can check this out by completing the following steps:
The application is ready to go; start it with mvn jetty:run and give it a go.
If you visit the URL http://localhost:8080/hello, you will be prompted for the username and password.
So you have created a new UserDetailsService implementation backed up by MongoDB, and you are using it in the AuthenticationProvider to retrieve the logged-in user.
Password Encryption One thing you might have noticed in this example and all the previous examples is that you are storing and retrieving passwords in plain text.
Spring Security offers an abstraction to encrypt passwords in the form of the interface org.springframework.security.authentication.encoding.PasswordEncoder in the core framework.
This interface is currently implemented by a series of classes that offer everything from plain-text encoders (such as the default one implemented in class PlaintextPasswordEncoder, which doesn’t do any encryption in the password) to hashing passwords that use recognized encryption algorithms (like Md5PasswordEncoder and ShaPasswordEncoder)
Another way of configuring the encoder is to use the ref attribute instead of the hash and specify a reference to a bean that holds a PasswordEncoder instance.
This, of course, can be an encoder implementation you create yourself.
I will do this to be able to reference the same encoder in the writing part of the UserInserter.
In doing so, I will be able to store the encoded value of the password, ensuring that I’m using exactly the same algorithm implementation as the one that will be used when logging in to the application.
So the passwords should match if they are the same.
To do this, I simply define a bean somewhere in the file, as Listing 8-17 shows, and then use the ID of that bean in the ref attribute of the.
Of course, as I mentioned in the previous paragraph, you now need to configure the insertion of the user to use the encoding algorithm as well so that Spring Security is able to match the password when retrieving the user from the database.
To do this, you will use the password encoder defined and retrieved from your UserInserter class before storing the password.
For that, you make the main method from the UserInserter class look like Listing 8-18
You need to add the import org.springframework.security.authentication.encoding.PasswordEncoder;  to the class from this listing)
If you execute this code now, you will insert the user with the password hashed with the SHA-256 algorithm.
You can check that by querying your MongoDB database, as explained in Figure 8-5 and its preceding paragraph.
You should be able to log in without any problems, with no apparent difference from a user interface point of view.
However, now, under the hood your passwords are not stored in plain text anywhere in the application, so they cannot be compromised easily.
As I said at the beginning of the section, sometimes you might want to replace the whole AuthenticationProvider implementation instead of simply the UserDetailsService.
You could also create another AuthenticationProvider implementation to combine with the existing ones because, if you remember, the AuthenticationManager default implementation (ProviderManager) is able to iterate through a list of AuthenticationProvider instances, and also, it is able to relate to other AuthenticationManager instances in a parent–child relationship.
There are many different implementations of AuthenticationProvider, as you saw in Chapter 7, including support for LDAP, JAAS and others.
You could implement your own AuthenticationProvider if you need to.
You simply need to define an <authentication-provider> element as a child of the.
Most of the AuthenticationProvider implementations decide if they can handle a particular authentication request by consulting the type of the Authentication object that is passed to the authenticate method, using the supports method to check.
I explained this process in detail in Chapter 7, so I won’t go into it any further here.
New Voters in AccessDecisionManager As I explained before, AccessDecisionManager’s default implementations (AffirmativeBased, UnanimousBased, and ConsensusBased) work by querying a set of configured AccessDecisionVoters to allow or deny access to a particular resource.
It is fairly straightforward to implement your own AccessDecisionVoter, and that is what I will show you here.
I will start again from the simple code I explained in the first example of this chapter (refer to that part of the.
Again, do any modifications required to the pom.xml file if you would like to name the application differently.
You will create an AccessDecisionVoter that will vote on attributes of the form USERNAME_XX, where it will grant access to any user whose username is XX.
You could implement this solution using a SpEL expression, but we want to show the use of custom voters, so this example will do.) The first thing you will do is create the voter implementation itself.
This code specifies that this voter supports any ConfigAttribute that starts with the string USERNAME_
Then, when it is time to vote on the authentication request, it will compare the username of the requesting Authentication with the ConfigAttribute substring (after the USERNAME_ prefix) to see if the user should be allowed access to the secured resource.
If it matches, access is granted; if it doesn’t, access is denied.
This is because, as you know, the UsernameVoter doesn’t read this property; instead, it simply queries the username property of the principal of the Authentication object.
Basically, this is an arbitrary string here as authorities is a required attribute of the <user-element>, but you know you are not using it in our example so you choose a descriptive name to point out this fact.
This is all the configuration you need to configure a custom AccessDecisionVoter.
Nonvoter AccessDecisionManager Implementations The previous sections show you that the current AccessDecisionManager implementations are based on the AccessDecisionVoter concept.
Basically, they work by iterating through a list of voters to which they delegate the intermediate decision of whether or not to allow access.
Depending on the result of the voters and the particular implementation of the AccessDecisionManager, they allow or deny access to a resource.
You can implement your own AccessDecisionManager that doesn’t need to follow the voter approach.
Again, this is not going to be a very common piece of the framework to customize, as the voter system is very flexible and well designed.
However, you also can extend the existing voter model with a custom AccessDecisionManager that handles the execution and priority of voters differently.
Actually, extracted directly from Spring Security’s own documentation, you find this line: “It is possible to implement a custom AccessDecisionManager that tallies votes differently.
For example, votes from a particular AccessDecisionVoter might receive additional weighting, whilst a deny vote from a particular voter might have a veto effect.”
So let’s create an AccessDecisionManager that allows access if the logged-in user has a granted authority with a name that matches the name of the URL being invoked with removed slash marks.
The class is a toy, so it would break if method security interception were enabled.
You can see the code is simply retrieving the URL from the FilterInvocation object and comparing it to the list of authorities that the authenticated user has.
If they match, access is granted; if they don’t, access is denied.
Figure 8-7 shows graphically what this simple AccessDecisionManager implementation does.
An example configuration file to go with this AccessDecisionManager can be found in Listing 8-22
In the previous listing, note the attribute access-decision-manager-ref in the <http> element.
Also note that I added the bean corresponding to the new AccessDecisionManager.
Note that SpEL is a general functionality provided by the core Spring Framework, which is available to other projects covered by the Spring suite of projects, including Spring Security.
I showed you before how to add some extra functionality to the SpEL processing by creating a different root with an extra method.
Specifically, you can look at Chapter 5, where I introduced SpEL and customized its support by defining new expressions.
Non-JDBC AclService The current support for access control lists (ACLs) in Spring Security is related to the use of relational databases, JDBC, and Spring’s JdbcTemplate.
There is no reason why you couldn’t implement ACLs on top of a different storage solution, and there could be many reasons why you would want to do that.
For example, it could be because the JDBC solution is too slow, or it can even be that your application doesn’t support relational databases at all.
As I explained in the ACL chapter, most of the ACL functionality resides in a couple of classes and services.
It is not trivial to implement, but the fact that the SQL support is encapsulated in just a few classes makes the change very focused.
The two main interfaces you need to implement to support a different solution than SQL are the AclService (and the MutableAclService) and LookupStrategy.
These interfaces are currently implemented by the BasicLookupStrategy and by JdbcMutableAclService and JdbcAclService.
You could think about implementing these services in many different ways, maybe using some of the NoSQL solutions that are so popular now, like MongoDB, CouchDB, or similar.
Custom Security Filter As you know, one of the main elements of Spring Security is the web-layer security support leveraged significantly by the Servlet Filter chain that it provides.
You can create your own filters and make them part of the security filter chain that processes the request that arrives in the application.
Say that you want to allow normal users to log in only through a Firefox web browser, while administrator users can log in with any browser they want.
This is, of course, an artificial example to show you how to use a custom filter, but there might be some legitimate reason why you would like to do something like this.
Maybe your application is verified just for one browser, but you want to allow administrator users to try other browsers to test them out and verify them later for widespread use.
You will be using the User-Agent http header to identify the browser that is making the request.
In the listing, you can see how the functionality is implemented.
One is for the administrator role that is allowed access from any browser.
In the other constant (FIREFOX_AGENT_CONTAINS), you specify what string to look for in the User-Agent header to grant access to logged-in users.
Anonymous authenticated users are allowed to use any browser because in the false theory of my application, the anonymous accessible parts (if any) are working for any browser.
You can also see that the filter extends from the class GenericFilterBean, which is a Spring-aware filter implementation.
You are also using a Spring Security provided class (AuthenticationTrustResolverImpl) that allows you to make queries over the Authentication object to determine if it belongs to a certain level of authentication—for example, to determine if it is an anonymous user or a remember-me user.
Next let’s define the custom filter in the applicationContext-security.xml file, and also create a new user that will have the role ROLE_ADMIN.
As you can see from Listing 8-24, it is pretty easy to configure a custom filter in the security filter chain.
You use the namespace element <custom-filter> and put in a reference to a filter implementation bean.
Also, you can specify where the filter will be within the chain.
In the example, you are specifying that it must execute before the FilterSecurityInterceptor filter, as at this point all the authentication filters have already run, which means you have a proper SecurityContext set up and authorization checking is about to begin.
An error you receive when logging in with Chrome instead of Firefox.
This was a simple example of configuring your own security filter to add additional behavior to the security implementation you are configuring in your application.
You could think of many different implementations in which you could improve or modify the security treatment through the filter chain.
Handling Errors and Entry Points Spring Security has a very nice error-handling mechanism built in.
It offers a comprehensive set of exceptions that map to the most common cases of security errors you could expect to have in a system.
Continuing with Spring Security’s great single-responsibility architecture, the handling of error conditions is mostly encapsulated in one single class.
This class is (and you have studied it before) the org.springframework.security.web.access.ExceptionTranslationFilter, and it basically deals with two types of exceptions: AccessDeniedException and AuthenticationException.
If any other exception is caught by this filter, it will simply rethrow it as a RuntimeException.
Spring Security offers a couple of extension points you can use to plug in functionality in the form of a custom entry point and a custom access-denied handler.
Basically, what happens is that when an AuthenticationException is caught by the filter, an AuthenticationEntryPoint’s “commence” method is called with the HTTP request, the HTTP response, and the exception.
The particular AuthenticationEntryPoint implementation that is configured in the application can decide what to do with the exception and, more importantly, what to do with the HTTP response.
By default, the implementation used is org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint, which redirects to the login URL, which as you already know is /spring_security_login in the root of your application.
The entry point is invoked when an AuthenticationException is thrown or when an AccessDeniedException is thrown and the current Authentication object is anonymous.
As another artificial example, you will implement an entry point that will add a cookie each time an authentication attempt is made from the client side and then show the Basic Authentication scheme in the browser.
This means you will set a cookie in the response that will increment its value every time the entry point is invoked.
Then the cookie is sent back to the server every time with the new value.
This means that the counter for the attempts is not stored in the server at all, it is stored just in the client cookie and is sent back and forth between the client and the server.
So the server receives the cookie, increments its value, and then sends it back.
It is not really innovative in any way, but it allows me, again, to show that you can override the entry point to do different things.
Most likely, the entry point is overridden when a different kind of authentication scheme is being used.
For example, one of the standard entry points applies when using authentication schemes that require to show a login page, while others (in particular the BasicAuthenticationEntryPoint) are used to set up particular values in the response to inform the browser how to treat it.
In most cases, the implementation of an entry point goes hand in hand with the implementation of a new security filter.
Basically, the entry points set the groundwork and then the filter processes the subsequent request.
Figure 8-9 shows the relationship between the ExceptionTranslationFilter and the AuthenticationEntryPoint.
It is a very simple implementation, but it is actually a little more complex than the standard BasicAuthenticationEntryPoint.
The code in Listing 8-25 has a lot in common with the code from org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint because it also tells the browser in the response to start a new basic authentication input process.
The main difference is, of course, in the retrieval and processing of the authentication_attempts cookie.
The cookie is first retrieved from the request in the private method getDeniesCookie.
Then the value of this cookie (which is assumed to be an integer) is increased by one and reset in the response header in the following line:
If a different kind of exception than the ones I mentioned before is thrown (particularly, an AccessDeniedException for a fully authenticated user), an AccessDeniedHandler is invoked instead of the AuthenticationEntryPoint.
However, you can also configure an errorPage property in the handler to determine that a forward (an internal dispatching mechanism inside the application,  different from a redirect) is made to a customized error page, which is probably the most common personalization you will do when using the AccessDeniedHandler.
You can also define your own implementation of AccessDeniedHandler, and that is what you will do here to illustrate the point, but you will also use a custom errorPage property much as you would use it in the AccessDeniedHandlerImpl.
The implementation, as in the previous example, will simply add an extra header in the response in the form of a cookie that specifies the number of “access-denied”responses received from the particular computer and browser from where the requests are coming.
Most of the code is copied and pasted from the AccessDeniedHandlerImpl.
As I said, the code is mostly the same as the AccessDeniedHandlerImpl.
I just added the cookie in the response, which will be set to incremental values every time this handler is invoked.
You can see that there is also the logic for processing the errorPage property in case it is set.
A servlet dispatcher forward will be done to this error page URL, which means that it will have access to the same request that is used inside this class.
Changing the Security Interceptor The security interceptor is a class you rarely find yourself modifying or replacing, as the default implementations cover the most common scenarios of filter security and method-level security.
However, you can extend it for use in different kinds of applications that don’t strictly fit into the web app-business method services scheme.
For example, Spring Integration has its own security interceptor implementation in the form of the org.springframework.integration.security.channel.ChannelSecurityInterceptor.
Instead of working with simple method invocations or filter invocations, it works with a different abstraction, which is the org.springframework.integration.security.channel.ChannelInvocation.
This means that it basically intercepts send and receive calls on a determined secured channel.
Spring Integration also uses the class org.springframework.integration.security.channel.ChannelSecurityMetadataSource as the org.springframework.security.access.SecurityMetadataSource implementation for message channels.
The creation of a different security interceptor, as the Spring Integration example shows, is basically for when you want to add Spring Security’s authorization support to applications that don’t follow the standard web-service way of doing things.
However, keep in mind that a previous authentication mechanism must be in place, as the security interceptor will look for the different components that it needs to grant access to a resource.
This means that an Authentication object must exist in the SecurityContext, the AccessDecisionManager must be configured, and so on.
Listing 8-28 shows the security interceptor implementation from Spring Integration.
You may obtain a copy of the License at *
See the License for the specific language governing permissions and * limitations under the License.
An AOP interceptor that enforces authorization for MessageChannel send and/or receive calls.
In the code, you can see that ChannelInvocation wraps a MethodInvocation before calling the beforeInvocation method on the parent class.
Apart from wrapping, it will also do some inner processing to make the current executing channel available to be queried for ConfigAttributes.
The ChannelSecurityMetadataSource that is being used in the code is the one that will be queried for obtaining the security metadata attributes.
It is the one that knows how to extract this information from Spring Integration Channels and the related org.springframework.integration.security.channel.ChannelAccessPolicy.
It is very unlikely you will override the security interceptor in your own applications.
However, it is good to know that you could do it and also understand why you would want to do it.
As the example for Spring Integration shows, one reason you would want to replace a security interceptor (or add an additional one) is because you have certain abstractions, to which you want to apply interception-based security, that don’t fit either URL interception or simple method interceptions.
You want to give a more meaningful name to your interception logic and also filter certain things that are not filtered by default with the default implementations.
It is intercepting MessageChannel communication, which is the domain element that makes sense in its context; However, in the end, it is basically intercepting methods and filtering to intercept only the methods send and receive, which again are the ones that make sense in the particular context.
Spring Security Extensions Project There is a whole project dedicated to the development of Spring Security extensions, where people from the community can develop their own extensions on top of Spring Security.
In this way, they can decouple these extensions from the main Spring Security project, allowing it to evolve independently.
If you visit that page, you will see that currently there are two extensions projects in existence: Kerberos integration and SAML2 integration.
There is also the OAuth integration, which lives on its own as an individual project.
Each project in Spring Security Extensions can implement as many parts of the framework as it needs in order to work correctly.
This means that many of the extension points that I defined in this chapter (and some others) could be overridden in a particular extension in order to do its work.
For example, OAuth uses a custom filter OAuth2AuthenticationProcessingFilter and a custom user details service (actually, a ClientDetailsService), among others.
Summary In this chapter, I showed you how the modularity in the architecture of Spring Security pays off when you want to customize or extend its behavior.
I showed some of the different and most common extension points that Spring Security offers so that you can adapt its functionality to your particular application while keeping the core functionality, making the work easier for you by leveraging this functionality.
After reading this chapter, and with all the theory and practice from previous chapters, you should feel confident enough to implement functionality that goes beyond the out-of-the-box offerings of the framework.
Note that this chapter does not include a comprehensive list of extension points in the framework.
Remember that you can get the source code of Spring Security, which means that you can change absolutely everything to adapt it to your own needs.
You won’t often need to change any core aspects of the framework, but it is good to know that you could.
Keep in mind that sometimes working with Spring Security is like putting together a puzzle.
In each case, you are assembling components, but in the case of Spring Security, you can replace some of the default components with customized ones to change its behavior.
This chapter will explore Spring Security in the context of other application frameworks and languages that run on the JVM.
You saw in previous chapters that the two main ways of using Spring Security are in the web layer in the shape of filters and in the business layer with Spring AOP.
This means that you could use Spring Security in any application that is built on top of the Servlet technology or in any application that is willing to use Spring and Spring AOP to handle its object life cycles and interactions.
In the following sections, you’ll see examples of both cases.
We’ll start by looking at a couple of popular Java frameworks (one which is also Spring based) and how to use Spring Security with them.
These frameworks are the popular Struts 2 web framework and Spring Web Flow, another member of the SpringSource suite.
After studying these two frameworks, we’ll take a brief look at a few Java Virtual Machine (JVM) programming languages (and some of their related frameworks) and how to use Spring Security with them.
We’ll be looking at Groovy in the context of its web-development framework Grails, JRuby in the context of Rails, and Scala embedded in a Spring web application.
I will not go into any of these frameworks or languages in much detail, because that would be beyond the scope of this book.
The purpose of this chapter is simply to explain how to use Spring Security in a wider context.
True, Struts is not as common as it used to be, with new and more friendly frameworks coming out all the time.
Even version 2 is getting rather old, although it is still well maintained.
Struts 2 is a popular Java web framework built by merging the original Struts project and the WebWork project.
Struts 2 was always intended to be a complete evolution from the original Struts framework, adapted to a new generation of powerful web frameworks, and it really kept little of the original Struts principles and implementations.
Struts 2 is an MVC (model view controller) framework built on top of the standard Java Servlets technology, so many of the web-based security principles you have read about in this book apply without modification.
If you want to use only the URL-level, web-based security you studied in Chapter 4, you just need to configure your web.xml and your Spring Security filter chain accordingly.
As with the rest of frameworks and languages in this chapter, I won’t explain Struts 2 in any depth (because there are many good books available on that subject)
I’ll explain just enough so that you can use Spring Security with it.
In fact, I assume that if you are reading this section it is probably because you are already using Struts 2 and want to integrate Spring Security with it.
When a request comes to the application, a front controller (http://en.wikipedia.org/wiki/Front_Controller_pattern) implemented in a Servlet filter takes care of the request.
It sends the request through a set of configured interceptors that perform different kinds of functionality before and after the action is invoked.
The action is then invoked, which carries with it all the business logic required by the current request.
After the action finishes, a result object representing the view is created and the interceptor stack is invoked in inverse order as before (while returning the result) until a response is finally returned to the client.
The first thing we’ll do is create a new project.
Then follow the prompts by selecting a new starter project at the first prompt and selecting some relevant groupId and artifactId names.
You could use the same to follow along in the examples easily)
Executing the last Maven command is a fantastic first step for creating our example because it creates a simple, functional Struts 2 web application with the components we need to create our test, including Spring integration (although it uses an old DTD version of the configuration XML file)
The file structure we have after executing that command is shown in Figure 9-2
In the preceding figure, you can see that there is already an applicationContext.xml file (the Spring configuration file) created for you inside the resources directory.
Struts 2 application file structure after executing the Maven command.
In Listing 9-1, the important part to note is the definition of the two actions.
In the first action, "index" you can see that in the class attribute of the action element, a class name is defined.
The second action, on the other hand, doesn’t define a class name on the attribute class.
In this case, it defines a simple string that identifies a Spring bean in the applicationContext.xml that you’ll see later.
When a request comes in, the framework looks at the definitions from this file to determine how to handle the particular request.
This definition is simplistic, but it’s good enough to make the point.) If it sees the name of a class in the action attribute, the framework instantiates a new object of that class to handle the request.
If the framework detects that it is not a class, it looks for a bean with that ID in the Spring configuration and gets the object from there.
Next, you need to add the Spring Security filter to the web.xml.
This filter should execute before the Struts 2 filter, so an authentication object is populated before reaching the action.
Remember that Struts 2 works with filters and not with servlets.
Listing 9-4 shows the web.xml file you can use as a test.
I also removed some filter definitions I don’t care to use in the example.
The web.xml with the Spring Security filter and Struts 2 filter.
Struts 2 has a built-in system to handle the exceptions that might be thrown in your application.
This mechanism would get in the way of Spring Security’s exception-handling system, which depends on AccessDeniedException, among other exceptions, to be thrown to alter the flow of execution.
For example, when showing a login form, you need to deactivate the Struts 2 exception-handling mechanism.
To do that in the file struts.xml, you add the line.
Now if you restart your application and visit http://localhost:8080/struts-example/helloWorld, you’ll be presented with the standard Spring Security login form.
If you use the login username car and password scarvarez, you’ll be able to access the page shown in Figure 9-3
Spring Security with Spring Web Flow Spring Web Flow is a framework, built on top of Spring MVC, that allows you to link different steps of a web-driven process into a fluent workflow.
In other words, it allows you to define in a declarative way the different steps that a web application can go through while you are interacting with it.
Basically, you use it to define a set of rules and transitions between the user interface (UI) parts of a web application and the back-end process that each transition should trigger.
Graphically, Spring Web Flow works, in a simplified form, as shown in Figure 9-4
The example is a fake web page for a simplified product.
The boxes represent various states (the View state, Action state, Decision state, Subflow state, and others), and the arrows represent transitions.
Simple Spring Web Flow scheme showing that, from a product page, you can go to the review page or buy the product.
To implement this simple flow with Spring Web Flow, we’ll create a new project.
As is the case for most of the examples, we’ll use Maven to build and manage our project.
From the command line in a place where you want to create your project, execute the following:
That will create a new project named webflow-example in the directory.
Replace the pom.xml file in the new project with the one shown in.
It also defines Spring’s DispatcherServlet servlet, which takes care of setting up Spring MVC by loading the appropriate configuration file.
Both the security filter and the dispatcher servlet are configured to handle every URL in the system.
Note N  In Spring MVC, the name of the DispatcherServlet servlet is important because that name will match the name of the Spring configuration file that will be used in the application to configure the application.
For example, in our case, by defining the DispatcherServlet with name “products”, Spring will expect to find a file with the name products-servlet.xml in the WEB-INF folder where the beans for the web layer should be defined.
This file is very simple, and its only job is to import another file (the example-webflow.xml file), which will contain the entire Spring Web Flow configuration.
This configuration will remain in a different file  just to keep it separated from the main servlet file.
This is another file you should be able to understand easily by now.
We are defining just a single user with role ROLE_USER, which will be enough for our tests.
We are not defining any URL security rules here because that is not what we want to do in this Spring Web Flow example.
We want to add security at the flow level (its states), and that is what I will show you how to do.
Now we need to define the web-flow configuration of the application as well as the actual web flows themselves.
Again, this will be a simplistic example just to show how the functionality works.
This file defines the general configuration for Spring Web Flow.
The main part of the file is the element flowregistry and its attribute flow-builder-services.
This element is  where the location of the flows in the application are defined.
Currently, we’ll define only one flow which will be in the product.xml file.
Also, note the way our views will get resolved when referenced in a view state in a flow.
By default, it will resolve view files by looking in the flow definition directory for files whose names are the names of the view states concatenated with .jsp at the end.
This simply means that if a view is named review, it will look for a file named review.jsp.
As I said before, each of these view states will map to a physical view file in the application.
The view files, by default behavior, should be located in the same directory as this flow file and should be named according to the view states concatenated with .jsp at the end.
So we should have, in the WEB-INF/flows/products directory files named main.jsp, review.jsp, and buy.jsp.
The buy.jsp for the buy view state of the flow.
In the previous three JSP files, we defined the three view states in our web flow.
So, in the case of the main state the first time you access the page, the value of.
If you visit http://localhost:8080/product, you’ll be taken to the main view state.
In a real application, you probably would want to allow anybody to read the product review but limit the ability to buy the product only to authenticated users.
Spring Security and Spring Web Flow integrate nicely because both are part of the Spring portfolio.
All you need to do now is decide which parts of the flow to secure and what constraints to define to secure them.
But before that, I’ll explain briefly what this SecurityFlowExecutionListener is doing for Spring Webflow.
Spring Web Flow offers an abstraction in the form of the interface org.springframework.webflow.execution.
FlowExecutionListener, which allows you to implement classes to listen to or observe the life cycle of a flow execution.
When a listener implementation is registered for the flows, it can intercept the flow execution at different points in its life cycle.
In that sense, it is similar to the AOP concepts you studied before.
In each of these interceptions, the listener delegates to a configured org.springframework.
If an AccessDecisionManager implementation is not provided when the bean is defined, a new role-based access decision manager will be created on the fly.
So now we want to secure the view-state "buy" and allow access to it only to authenticated users with role "buy"<view-state> element.
After you do that, if you restart the application and try to access the "buy" state, you’ll find yourself presented with the familiar Spring Security login screen.
If you log in with the username car and the password scarvarez, you’ll be able to reach the "buy" state.
The resulting "buy" state view is shown in Figure 9-6
The main.jsp, which is the entry point into the web flow.
This means that, to access any state of the flow, a user needs to have the required permissions.
Go ahead and try it yourself—it should be very straightforward.
This means that, by default, you can’t use SpEL expressions in your configuration.
However, defining your own support for SpEL expression–based security is straightforward.
To do this, you need to define a new AccessDecisionVoter, a new SecurityExpressionHandler, and a new SecurityExpressionRoot.
Let’s configure a custom AccessDecisionManager so that you can use SpEL expressions.
To configure it, simply add the bean definition from Listing 9-17 somewhere in the example-webflow.xml file.
Next, change the <secured> element you defined before with the.
Now you need to create the new classes to support expressions at the flow state level.
In Spring Web Flow, there is a new abstraction—the state (a view state in our case)
So you need to provide the support for Spring Security to be able to handle this.
As you saw in Chapter 8, Spring Security offers many extension points, both intentional and unintentional.
In this particular case, I am taking advantage of the knowledge of the internal application programming interfaces (APIs) to develop support for SpEL for Spring Web Flow.
You can see in the defined classes that I explicitly typed them with the org.springframework.webflow.engine.State class in the generics.
This is how I am making the framework aware of this class for evaluating SpEL against it.
The support I just created in this example is very simplified and might not be production ready, but it does a good job of showing the functionality.
If you now restart the application, you should get the same behavior as before.
The "buy" state will be secured, and you’ll need to log in with a user with the role ROLE_USER to access it.
Spring Security in Other JVM Languages I am not an expert in any of the languages that follow, and maybe I won’t be using them in the examples in the most idiomatic way.
I know Ruby best because I often use it both at work and during my leisure time.
It’s one of my favorite languages.) However, my objective is just to show that, with some tweaking, you can integrate Spring Security into your projects that are written in a language other than Java.
You’ll see that the support for Spring Security in other JVM languages is sometimes straightforward and integration solution to support it.
In the upcoming sections, I give a brief overview of how to integrate Spring Security into what I consider to be the three major JVM languages other than Java: Groovy, JRuby, and Scala.
Remember that ultimately Spring Security is no more than a set of Java libraries built on top of Spring Framework, which allows you to plug authentication/authorization security mechanisms into your applications.
So it should be possible to integrate it into any Java (Java JVM) application you have.
Of course, not all functionality will apply to any application.
For example, the filter chain won’t make sense in a non-web application.
Spring Security and Ruby (JRuby) Ruby is definitely one of my favorites languages, and I spend a lot of time working with it.
It combines great syntax with great language constructs, and it’s a pleasure to work with.
Ruby is an object-oriented dynamic language with a focus on productivity, concision, and simplicity.
The standard Ruby interpreter is written in C and was known as MRI Ruby until version 1.9
From version 1.9 forward, the official interpreter is known as the YARV interpreter.
Ruby is an incredibly popular language, and most of its popularity stems from the widespread use of its incredible web framework Ruby on Rails (RoR), also known simply as Rails.
Rails is an MVC framework that places great emphasis on convention over configuration practices.
It’s a very productive framework you can use to develop simple web applications in a fast and easy way if you follow the conventions enforced by the framework.
I won’t give an in-depth explanation of either Ruby or Rails because that would be beyond the scope of this book.
I also assume that if you’re reading this section, you probably know about them and just want to learn how to integrate Spring Security into them, or to learn if it’s at all possible.
However, I’ll try to give small explanations of Ruby concepts when I use them in the examples.
JRuby is a fully functional implementation of the Ruby programming language written in Java.
You can use it to run Ruby programs inside a Java virtual machine and interact with your other JVM languages—mainly, of course, Java.
What I’ll show in this section is a simple tutorial for integrating Spring Security into a Rails application and for deciding if it’s even worth doing.
In the JRuby case, there is no plugin like the one you find in Grails.
In fact, the integration between Java and Ruby is not as smooth as the integration between Java and Groovy.
Basically, we’ll have to roll our own implementation to make the integration work.
I’ll use the simple installation here, just downloading a file, uncompressing it, and adding its executables to the path.
Following is the procedure I use on my Mac (which should be similar to other operating systems):
Go to the directory you want to install JRuby in.
Go inside the new directory, and add the bin directory to your path in the .bash_profile:
As in the rest of the book, this will be an application with very little functionality just to show you how to use Spring Security.
From a directory of your choice, write the following command: rails new demo.
We now have a new basic Rails application in the system.
You can run it by going to the directory demo that you just created from the command line and entering rails s.
That command will start a WEBrick server and run the application on that server.
If you are following the example, you should be able to visit http://localhost:3000 in your computer and access the default Rails application home page.
In the process of creating the Rails application, a lot of infrastructure code and a well-defined directory structure was generated for us.
If you take a look at the demo directory (which is the root of your application), you’ll see what I mean.
Anyway, as I said before, I won’t go into any depth examining the Rails framework or Ruby itself.
I’ll simply show with a rudimentary example how you could approach integrating Spring Security into a Ruby on Rails application.
Web-Layer Security in Rails When we ran our Rails application in the previous section, we ran it with a Ruby server (WEbrick)
This server doesn’t know anything about Java Servlets, so you might guess that it’s not possible to run Spring Security web-layer security with this server—and you would be correct.
What we need to do is run our Rails application in a standard Java web container, and that is what we’ll do next.
First, we install warbler, a gem you use to create standard WAR files from our Rails application.
To install warbler, use the command jruby –S gem install warbler.
After warbler is installed, you can execute jruby –S warble in the root directory of our application and it will create demo.war.
Let’s add some functionality to it first, and then let’s add Spring Security–level security.
One will return the string SECURED and will be accessible only to logged-in users.
The other one will return the string UNSECURED and will be available to any user.
Let’s create a pair of controllers: one for admin users and one for standard users.
Type the following two commands in the root of our demo application to generate them:
The execution of those commands generates output describing the artifacts that got generated.
You can find the controllers in the standard Rails location in the app/controllers directory.
The next thing you need to do is to copy all the Java libraries you need to use into the lib directory of our Rails application:
The next step is to enable our Rails application to be run in a standard Java web server, such as Tomcat.
Warbler is a JRuby exclusive gem you use to convert different kinds of Ruby applications into standard Java packaging artifacts, such as Jar and War files.
In our case, we’ll obviously be creating a War file.
Warbler uses internally the gem jruby-rack and packs it into the War-based application.
It first initializes the Ruby part of the application with a Servlet listener (org.jruby.rack.rails.RailsServletContextListener), and then, on each request, it intercepts the calls to the server with a servlet filter, org.jruby.rack.RackFilter.
When this filter gets the HttpServletRequest, it will translate these Java based requests into Rack requests that will pass through to the Rails application, as these are the requests Rails will understand as it is built on the Rack model.
Of course, there is a lot more detail regarding warbler and jruby-rack, but for the moment, the explanations presented here should be enough for you to continue with the example.
In Figure 9-7, you can see a graphical illustration of how jruby-rack works.
To do this, you need to copy the web.xml.erb that comes with warbler (which resides in the gem installation directory of Ruby and which is ~/.rvm/gems/jruby-1.6.7/gems/warbler-1.3.6/web.xml.erb on my computer) into the.
Then you need to edit it and make it look like Listing 9-23
By doing this, you are including the Spring Security configuration in our web.xml file as you did in previous chapters.
Next, copy the applicationContext-security.xml file from Listing 9-24 into the root of our demo application.
Here we have our familiar Spring Security configuration from Chapter 2, with a few modifications.
We are simply securing the URL /admin/* for members of the Scarvarez family.
To do that, you execute the command "jruby –S warble config" in the root of our application.
That execution generates a warble.rb file inside the config directory of the application.
In the file, you are ensuring JRuby will be compatible with Ruby 1.9 and that the Spring configuration file will be included in the WEB-INF directory in the generated War file when warbler builds this file.
That’s all you need, so let’s create the War file again.
From the root directory of our application, execute JRUBY_ OPTS variable separately.) That generates the War file with our Rails application embedded on it.
After it is deployed, you can visit the corresponding URLs.
However, if I visit the URL http://localhost:8080/demo/admin/message, the familiar login page is shown.
We have secured our Rails application with basic web-layer security.
The web.xml.erb in the config folder, including configuration for Spring Security.
Spring Security, Groovy, and Grails Groovy is one of the strongest contenders for the number one spot in the non-Java JVM language space.
It has a great community and currently is supported and managed by the SpringSource people.
Groovy is a programming language that tries to combine the power of Java with the elegance and developerfriendly characteristics of some dynamic programming languages—taking ideas mainly from well-known and much-loved languages such as Python and Ruby.
Groovy successfully creates an environment where different kinds of programmers, with some practice, can feel at home (experienced Java developers and Ruby developers, for example)
Groovy has many advantages when you compare it with other JVM languages—the main ones being, in my opinion, the easy transition from Java to Groovy and the interoperability between the two languages.
With regard to the transition part, it is easy to take a Java program and make it a Groovy program.
As a matter of fact, you don’t have to do anything.
This is good from one point of view but bad from another.
Even when you can compile a Java program as a Groovy one, it doesn’t make sense.
Ultimately, you are using Groovy to take advantage of the great features it has compared to Java.
Those great features include a lot of metaprogramming techniques, new powerful constructs like closures, faster development cycles, and a clearer and more concise and developer-friendly syntax.
Grails is a web framework written in Groovy and intended to be used with Groovy.
It is built on top of the Spring Framework and is heavily influenced by Ruby on Rails.
Grails is an attempt to make a friendlier and lighter framework in a JVM-based language that can be picked up quickly.
Also, it offers better and more concise ways to develop applications.
At the same time, it is built upon some of the strongest Java libraries and frameworks, such as Spring and Hibernate.
Using Grails to Secure the Web Layer with URL Rules Grails and Spring Security integration is incredibly simple because Spring Security is the default security solution for Grails applications and a comprehensive plugin exists to support it.
Here, we’ll create a simple Grails application, and I’ll show you how to secure it with Spring Security.
As usual, I’ll introduce this application in a step-by-step process.
Download and install the latest version of Grails if you still don’t have it.
I am running this example with version 2.1.1 of Grails.
To install it, simply unzip the downloaded .zip file and then set the environment variable GRAILS_HOME to point to the new expanded directory.
Also, add to your PATH environment variable the path GRAILS_HOME/bin.
At the command line, go to any directory where you want to create the application and execute grails create-app demo-grails to create the application.
Next, let’s generate a couple of controllers: a secured controller and an unsecured controller.
These files are located in the directory grails-app/controllers/demo/grails of your application.
The next logical step is to secure the secured URL.
As I said before, Grails is built on top of Spring, so it’s only logical that an integration with Spring Security should be straightforward.
Grails is built in a clever modular way so that you can add functionality in the form of plugins.
Let’s install the Spring Security plugin by executing grails install-plugin spring-security-core (which, in my current version, installs the version 1.2.7.3)
Then execute the command "grails s2-quickstart demo.security User Role" to generate the needed models to support users and roles in the application.
Next, we’ll create a couple of test users to try out security.
Open the file BootStrap.groovy (in the grails-app/ conf directory), and make it look like the coding in Listing 9-28
You can see that this code uses the classes generated in the previous step, User and Role.
As with previous examples, we’ll secure certain URLs so that they are accessible only for users with a specific role.
To do this in Grails, you need to add the code from Listing 9-29 to the end of the file Config.groovy (which resides in the directory grails-app/conf)
It simply tells Grails to use an intercept URL map for security.
This map defines URL paths with wildcards (in Ant-style syntax, I already covered before for standard Java rules) and the roles that are allowed to access such URLs.
Run the application by executing the command grails run-app in the root directory.
If you log in with the username carlo and the password password, you’ll be granted access to the secured URL and not the unsecured one.
You can see that you have properly secured access to the URLs.
The first thing that is hard to see from this example is that you are actually using Spring Security.
I say this because you haven’t defined any filters, any authentication managers, any voters, any user service, or any authentication provider.
You could easily assume that something else is used under the covers because there is nothing specific to Spring Security here.
This is a good thing, and one of the nice features of Grails.
The use of plugins gives you sensible common defaults and leaves you only with the responsibility of defining the things that are exclusive to your business problem.
In the case of security, you need to define your users, their passwords, and the roles and access permissions for your application.
BootStrap.groovy setting up a couple of test users with security roles assigned to them.
An excerpt from Config.groovy, where we add the URLs that need to be secured.
Grails’ Spring Security plugin gives you more access to the functionality offered by Spring Security and, of course, it also allows you to customize it by overriding the defaults.
One of the things it supports is the use of SpEL for access rules.
In that listing, as you can see, we are using the security expression "hasRole", which you already studied in previous chapters.
Note that this is a simple example with "hasRole", but here you have access to the full suite of expressions offered by Spring Security SpEL support.
An excerpt from Config.groovy, which uses SpEL instead of simple roles.
Secured annotations (or the standard Spring Security @Secured annotation as well) in our controller classes and Spring Security will make sure they are secured according to those annotations.
First, replace the current content of the file Config.groovy (in the grails-app/conf directory) from the line that reads grails.plugins.springsecurity.
After you do this, if you restart the application, you should get the same access constraints that you got in the previous section when you secured the URLs.
In these last two sections, I just scratched the surface of the functionality available using Grails’ Spring Security plugin.
You can do virtually everything you can do using the standard Java support.
For a comprehensive guide to using the Grails plugin, take a look at its official page at http://grails-plugins.github.com/grails-spring-security-core/docs/manual/
Spring Security and Scala Scala is probably the strongest language (in the sense of number of adopters and the liveliness of the community around it) running on top of the Java Virtual Machine apart from Java itself.
Scala also has a version that runs on the .NET platform.) Scala is a very powerful, general-purpose programming language that tries to merge the best of the object-oriented and functional programming paradigms.
Scala is a language that aims to provide a concise and elegant alternative to the world of enterprise Java programming, while keeping the type safety of Java.
As I said, it comes with functional programming features built in, adding a whole new layer of power for the seasoned object-oriented programmer that increases productivity.
I am not an expert in Scala or functional programming (far from it as I have just recently started to look at them) but I will give you the core definitions and the main characteristics of both and show you how to use them with Spring and Spring Security.
Functional programming is a paradigm in which programs are composed of functions that receive inputs and produce outputs, while also avoiding the use of state and mutability.
This is in clear contrast to object-oriented programming, where the main abstraction is the object and its internal state, and mutability is a very common thing.
By not allowing mutability and state, functional programming presents itself as a good alternative for programming concurrent programs, because programmers don’t need to worry about synchronization between concurrent processes or threads.
In Scala, functions can be passed around (as function parameters or function return values) as simple values.
In this sense, they behave pretty much like any other simple value (for example, a string), and this is an important concept in a functional programming language.
According to the literature, Scala’s name comes from the words scalable language.
This implies that Scala supports object-oriented and functional programming paradigms and that it is suitable for simple scripting tasks or full enterprise applications.
Combining this capability with an elegant and concise syntax makes the language scalable in terms of the number of domains and uses that it can address.
Uncompress the downloaded file in your directory of choice (which I will call YOUR_SCALA_HOME from now on)
You have now set up Scala to be used from the command line.
You can try it a bit from the command line.
Figure 9-8 shows some interaction with this command-line REPL (read-eval-print loop) interpreter.
The preceding figure shows a simple set of commands in the Scala REPL interpreter.
First, you perform a simple sum operation using two integer values.
Then you define the value entero of type Int (implicit) and assign it the value 5
The next line defines a new function called suma that receives two Int parameters and returns an Int value.
Note N  Scala makes a distinction between values and variables.
Values are like constants in other programming languages, and they are values that can’t change.
Variables, on the other hand, are much like variables in any other language, and you can reassign values to them.
OK, that was your introduction to Scala! It was a very simple introduction, I know.
However, as I said, covering the language in depth is outside the scope of this book and there are a lot of great books dedicated to the topic.
I’m assuming here that you probably know the language better than me and you are just interested in how to use Spring Security with it.
The next thing we’ll do is create the project by combining Scala with Spring and Spring Security.
Again, we’ll use our old friend Maven to create and manage the project.
In the generated pom.xml file, add the Scala dependency shown in Listing 9-35
Next, of course, you need to add the Spring dependencies to the pom.xml file.
You also need to add the Scala plugin in the plugin sections.
In the end, your pom.xml file should look like Listing 9-36
This will be a simple web application with Spring MVC, and it will have a very simple Service layer.
The big difference from applications you saw in other chapters is that both the Controller layer and the Service layer will be written in Scala instead of Java.
I’ll show you how to add security to the method level, but as you’ll see it is almost the same as with Java.
In the package com.apress.pss.scala.web in a source folder with the path src/main/scala, create the ScalaController class shown in Listing 9-37
In the controller, we are defining a simple method that returns (writes on the response, actually) whatever the service returns.
You can see how we are using the annotation @RequestMapping in the example.
With Scala, we cannot use a simple string to set the value of array-based annotation values.
We need to set a real array with just one element as the value.
For the rest, the example is very much like the Java version, with some syntax modifications.
Then, in the package com.apress.pss.scala.service, we create the ScalaService class shown in Listing 9-38
It is a service class with a simple method that returns a string.
Again, we are using the Array function (actually  what we are indirectly calling here is the apply method of the Array companion object which allows us to create a new instance of the Array class) and passing the string that will be the only element of the array.
With Scala, we can’t use the convenient technique of passing a simple string for this value as we did in the Java version.
Note also the use of the trait just before the class definition and then the class extending that trait.
A trait in scala is somewhat the equivalent of the interfaces in Java, but it has a lot more power.
Although not shown in this example, a trait can have fully implemented methods as well as the traditional abstract (definition only) methods typical of Java interfaces, and your class can extend more than one trait ‘inheriting’ the functionality defined in all of them without needing to implement the already implemented methods.
This technique, also called mixin, is in no way exclusive to Scala because other languages also have constructs that fulfil the same purpose.
For example, in Ruby you can use modules to achieve more or less the same outcome that you get with Scala traits.
For our example, you can think of a trait simply as a Java interface that you use from the controller to access the service.
By now you should be very familiar with configuring a Spring Security web application.
So I will simply show you the files next and won’t go into the details of any of them.
Note that we are referencing Scala classes just as we used to reference Java classes before in our beans.
It is great that interoperability between Java and Scala is so nicely achieved.
All files will live under the WEB-IF directory of your application.
From the root of the project in the command line, execute the command mvn clean install jetty:run to run the application.
Next, if you try to access the URL http://localhost:8080/enter/scala, you’ll be presented with the login screen you have seen so many times before.
If you log in with the username car and the password scarvarez, you should be able to access the application and see the page shown in Figure 9-9
That’s all I am going to say about integrating with Scala.
You can see that for a simple application like this it’s not really that different than integrating with Java itself.
Actually, beyond the syntactic differences, it’s probably just about the same.
Of course, in this example you are starting with a Spring application and defining the different components (controllers and services) in Scala.
It could be more of a challenge to integrate if you are using a Scala-specific framework.
All you need to remember is that to secure methods, those methods need to belong to Spring-managed beans.
To secure URLs, the URLs need to be accessed in a Servlet-based web application.
Summary In this chapter, I showed you, at a fairly high level, how to integrate Spring Security into various frameworks and languages.
The chosen framework was Spring’s own Spring Web Flow, and the illustrative languages chosen were JRuby and Groovy, with their web frameworks Rails and Grails, respectively.
I showed you that integrating Spring Security into these different frameworks and languages can be straightforward (as with Grails) or not so straightforward (as with JRuby or Scala)
However, through the JVM, in theory, you could integrate Spring Security into anything you need to secure.
Here is the main takeaway from this chapter, regardless of the frameworks or languages used: Spring Security is, ultimately, just a Java library (a couple of simple jar files)
You can integrate it into any Java (as in JVM) project that you want.
You simply have to remember what you can do with it and use the parts that make sense for your particular problem.
For instance, using web-layer security wouldn’t make sense in a Swing application, or even in a web application that doesn’t use standard servlet filters (such as the Play framework)
OpenID authentication auto-register functionality, 174 configuration file for Spring Security.
All rights are reserved by the Publisher, whether the whole or part of the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microfilms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed.
Exempted from this legal reservation are brief excerpts in connection with reviews or scholarly analysis or material supplied specifically for the purpose of being entered and executed on a computer system, for exclusive use by the purchaser of the work.
Duplication of this publication or parts thereof is permitted only under the provisions of the Copyright Law of the Publisher’s location, in its current version, and permission for use must always be obtained from Springer.
Permissions for use may be obtained through RightsLink at the Copyright Clearance Center.
Violations are liable to prosecution under the respective Copyright Law.
Trademarked names, logos, and images may appear in this book.
Rather than use a trademark symbol with every occurrence of a trademarked name, logo, or image we use the names, logos, and images only in an editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the trademark.
The use in this publication of trade names, trademarks, service marks, and similar terms, even if they are not  identified as such, is not to be taken as an expression of opinion as to whether or not they are subject to proprietary rights.
While the advice and information in this book are believed to be true and accurate at the date of publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or omissions that may be made.
The publisher makes no warranty, express or implied, with respect to the material contained herein.
For information on translations, please e-mail rights@apress.com, or visit www.apress.com.
Apress and friends of ED books may be purchased in bulk for academic, corporate, or promotional use.
For more information, reference our Special Bulk Sales–eBook Licensing web page at www.apress.com/bulk-sales.
Any source code or other supplementary materials referenced by the author in this text is available to readers at www.apress.com.
For detailed information about how to locate your book’s source code, go to www.apress.com/source-code/
To my wife, Monica, for her constant support and love.
And to my aunt Marisol, who we all miss so much.
He has worked in many industry fields in three different countries and has over nine years’ experience.
Currently living and working in London, Carlo focuses mostly on Java and Ruby software development.
Carlo fell in love with The Spring Framework when he first used it more than five years ago, and now he can’t conceive starting a pure Java project without the aid of Spring and its related technologies.
He is very passionate about his work and is constantly searching for the best ways to solve problems and trying to learn new and better technologies.
He also likes to write on his blog as a way to give back something to the software community that he so much respects, and he is a DZone MVB (Most Valuable Blogger)
Manuel Jordan Elera is a self-taught developer and researcher who enjoys learning new technologies for his own experiments and creating new integrations.
In his scarce free time, he reads the Bible and composes music on his guitar.
Manuel is a Senior Member in the Spring Community Forums, where he is known as dr_pompeii.
Manuel was Technical Reviewer for these books (all published by Apress):
Read and contact him through his blog at http://manueljordan.wordpress.com/, and follow him on his Twitter account, @dr_pompeii.
This book is definitely the work of more than one person.
The people involved in the preparation of this book have brought so much experience and quality to the final version that the end product is many times better than if I had done all the work myself.
Their input ranged from improving text style, to introducing better ways to present concepts, to performing code reviews and suggesting general improvements that have made this book a much better reading experience.
I am talking, of course, about the great people at Apress who have been with me along the full journey of writing this book.
I’m talking about Steve Anglin, who initiated me into the project, kept an eye from afar on the progress of the book, and tried to make sure I kept on track as much as possible.
I’m talking about Kevin Shea, who was my main editorial contact and made sure that I stayed on schedule with the book and helped with advice and support.
I’m talking about Tom Welsh, who had the great responsibility of reading every chapter as I was writing them and gave great input on each section, including helping with my use of English grammar as well as ways to make the different parts more attractive to potential readers.
I am talking about Manuel Jordan, who not only read every single chapter in a very detailed way, but also took on the laborious job of evaluating and executing every single line of code and made sure that the book provides code samples that can be reproduced by the readers in their own environments.
His input is greatly appreciated, and it is the difference between having a full book or a half a book.
I would like to also thank the creators, committers and community of Spring and Spring Security for creating such an amazing piece of software and making it available to everyone.
A big thank you to them for letting all developers share their knowledge and ways of work by freely distributing the source code of the different projects covered by the SpringSource umbrella.
Finally, I want to thank my wife for being with me all the time and motivating me to keep going forward.
