The evolution of Java and C++ has slowed down considerably, and programmers who are eager to use more modern language features are looking elsewhere.
Scala is an attractive choice; in fact, I think it is by far the most attractive choice for programmers who want to move beyond Java or C++
Scala has a concise syntax that is refreshing after the Java boilerplate.
It runs on the Java virtual machine, providing access to a huge set of libraries and tools.
The Scala interpreter lets you run quick experiments, which makes learning Scala very enjoyable.
And, last but not least, Scala is statically typed, enabling the compiler to find errors, so that you don't waste time finding them later in running programs (or worse, don't find them)
I wrote this book for impatient readers who want to start programming with Scala right away.
I won't exhaustively list all features of the language, I won't lecture you about the superiority of one paradigm over another, and I won't make you suffer through long and contrived examples.
Instead, you will get the information that you need in compact chunks that you can read and review as needed.
Scala is a big language, but you can use it effectively without knowing all of its details intimately.
Martin Odersky, the creator of Scala, has identified the following levels of expertise for application programmers and library designers:
For each chapter (and occasionally for individual sections), I indicate the experience level.
Even if you don't want to design your own libraries, knowing about the tools that Scala provides for library designers can make you a more effective library user.
If you find errors or have suggestions for improvement, please visit http://horstmann.com/scala and leave a comment.
On that page, you will also find a link to an archive file containing all code examples from the book.
I am very grateful to Dmitry Kirsanov and Alina Kirsanova who turned my manuscript from XHTML into a beautiful book, allowing me to concentrate on the content instead of fussing with the format.
Finally, as always, my gratitude goes to my editor, Greg Doench, for encouraging me to write this book and for his insights during the development process.
We introduce a number of important Scala concepts and idioms along the way.
You will also learn how to browse the Scaladoc documentation at a beginner’s level.
Make sure that the scala/bin directory is on the PATH.
Depending on how you launched the interpreter, you may be able to use tab completion for method names.
If you can’t use tab completion in your environment, you’ll have to type the complete method name yourself.)
As you can see, the Scala interpreter reads an expression, evaluates it, prints it, and reads the next expression.
Behind the scenes, your input is quickly compiled into bytecode, and the bytecode is executed by.
Instant feedback encourages experimenting, and you will feel good whenever something works.
It is a good idea to keep an editor window open at the same time, so you can copy and paste successful code snippets for later use.
Also, as you try more complex examples, you may want to compose them in the editor and then paste them into the REPL.
A value declared with val is actually a constant—you can’t change its contents:
To declare a variable whose contents can vary, use a var:
In Scala, you are encouraged to use a val unless you really need to change the contents.
Perhaps surprisingly for Java or C++ programmers, most programs don’t need many var variables.
Note that you need not specify the type of a value or variable.
It is inferred from the type of the expression with which you initialize it.
It is an error to declare a value or variable without initializing it.)
NOTE: In Scala, the type of a variable or function is always written after the name of the variable or function.
This makes it easier to read declarations with complex types.
NOTE: You may have noticed that there were no semicolons after variable declarations or assignments.
In Scala, semicolons are only required if you have multiple statements on the same line.
You have already seen some of the data types of the Scala language, such as Int and Double.
There is no distinction between primitive types and class types in Scala.
For now, just view it as a collection of numbers.)
It is the job of the Scala compiler to convert between primitive types and wrappers.
For example, if you make an array of Int, you get an int[] array in the virtual machine.
However, it augments that class with well over a hundred operations in the StringOps class.
For example, the intersect method yields the characters that are common to two strings:
Similarly, there are classes RichInt, RichDouble, RichChar, and so on.
Each of them has a small set of convenience methods for acting on their poor cousins—Int, Double, or Char.
The to method that you saw above is actually a method of the RichInt class.
NOTE: In Scala, you use methods, not casts, to convert between numeric types.
Of course, as in Java, the toString method converts any object to a string.
To convert a string containing a number into the number, use toInt or toDouble.
Arithmetic operators in Scala work just as you would expect in Java or C++:
There is just one surprising aspect: These operators are actually methods.
There is one notable difference between Scala and Java or C++
Some people wonder if there is any deep reason for Scala’s refusal to provide a ++ operator.
Note that you can’t simply implement a method called ++
Since the Int class is immutable, such a method cannot change an integer value.) The Scala designers decided it wasn’t worth having yet another special rule just to save one keystroke.
You can use the usual mathematical operators with BigInt and BigDecimal objects:
It is simpler to use mathematical functions such as min or pow in Scala than in Java—you need not call static methods from a class.
We discuss the import statement in more detail in Chapter 7
For now, just use import packageName._ whenever you need to import a particular package.
Scala doesn’t have static methods, but it has a similar feature, called singleton objects, which we will discuss in detail in Chapter 6
Often, a class has a companion object whose methods act just like static methods do in Java.
For example, the BigInt companion object to the BigInt class has a method probablePrime that generates a random prime number with a given number of bits:
For example, the API of the StringOps class shows a method distinct, without (), to get the distinct letters in a string.
The rule of thumb is that a parameterless method that doesn’t modify the object has no parentheses.
In Scala, it is common to use a syntax that looks like a function call.
For example, if s is a string, then s(i) is the ith character of the string.
When you look at the documentation for the BigInt companion object, you will see apply methods that let you convert strings or numbers to BigInt objects.
It yields a new BigInt object, without having to use new.
Using the apply method of a companion object is a common Scala idiom for constructing objects.
Scala has its own variant, called Scaladoc (see Figure 1–1)
Scala classes tend to have many more convenience methods than Java classes.
Finally, some features are exposed as they are implemented, not as they are used.
The Scala team is working on improving the Scaladoc presentation, so that it can be more approachable to beginners in the future.)
Here are some tips for navigating Scaladoc, for a newcomer to the language.
Note the O and C symbols next to each class name.
They let you navigate to the class (C) or the companion object (O)
Remember to look into RichInt, RichDouble, and so on, if you want to know how to work with numeric types.
The mathematical functions are in the package scala.math, not in any class.
For example, the BigInt object has conversions from int and long to BigInt that are automatically called when needed.
For example, the count method in StringOps requires a function that returns true or false for a Char, specifying which characters should be counted:
You supply a function, often in a very compact notation, when you call the method.
We will discuss this style of programming in much more detail in Chapter 12
You’ll occasionally run into classes such as Range or Seq[Char]
They mean what your intuition tells you—a range of numbers, a sequence of characters.
You will learn all about these classes as you delve more deeply into Scala.
It’s the Scala way to provide lots of methods for every conceivable use case.
When you need to solve a particular problem, just look for a method that is useful.
More often than not, there is one that addresses your task, which means you don’t have to write so much code yourself.
Finally, don’t worry if you run into the occasional indecipherable incantation, such as this one in the StringOps class:
There is another version of patch that looks more reasonable:
And it’s easy to try it out in the REPL:
In the Scala REPL, compute the square root of 3, and then square that value.
By how much does the result differ from 3? (Hint: The res variables are your friend.)
In this chapter, you will learn how to implement conditions, loops, and functions in Scala.
You will encounter a fundamental difference between Scala and other programming languages.
An expression has a value; a statement carries out an action.
This feature can make programs more concise and easier to read.
A block has a value—the value of its last expression.
The Scala for loop is like an “enhanced” Java for loop.
Scala has an if/else construct with the same syntax as in Java or C++
However, in Scala, an if/else has a value, namely the value of the expression that follows the if or else.
NOTE: Scala has no switch statement, but it has a much more powerful pattern matching mechanism that we will discuss in Chapter 14
CAUTION: The REPL is more nearsighted than the compiler—it only sees one line of code at a time.
If you want to break the line before the else, use braces:
TIP: If you want to paste a block of code into the REPL without worrying about its nearsightedness, use paste mode.
The REPL will then analyze the block in its entirety.
However, if you want to have more than one statement on a single line, you need to separate them with semicolons.
In practice, long expressions usually involve function or method calls, and then you don’t need to worry much—after an opening (, the compiler won’t infer the end of a statement until it has seen the matching )
In the same spirit, Scala programmers favor the Kernighan & Ritchie brace style:
Many programmers coming from Java or C++ are initially uncomfortable about omitting semicolons.
If you prefer to have them, just put them in—they do no harm.
This feature can be useful if the initialization of a val takes more than one step.
In Scala, assignments have no value—or, strictly speaking, they have a value of type Unit.
Recall that the Unit type is the equivalent of the void type in Java and C++, with a single value written as ()
A block that ends with an assignment statement, such as.
In contrast, in Java and C++, the value of an assignment is the value that is being assigned.
To print a value, use the print or println function.
There is also a printf function with a C-style format string:
You can read a line of input from the console with the readLine function.
To read a numeric, Boolean, or character value, use readInt, readDouble, readByte, readShort, readLong, readFloat, readBoolean, or readChar.
The readLine method, but not the other ones, take a prompt string:
Scala has the same while and do loops as Java and C++
Scala has no direct analog of the for (initialize; test; update) loop.
If you need such a loop, you have two choices.
You saw the to method of the RichInt class in Chapter 1
Exactly how that traversal works depends on the type of the expression.
For a Scala collection, such as a Range, the loop makes i assume each value in turn.
NOTE: There is no val or var before the variable in the for loop.
The type of the variable is the element type of the collection.The scope of the loop variable extends until the end of the loop.
In that case, use the until method instead of the to method.
It returns a range that doesn’t include the upper bound.
In this example, there is actually no need to use indexes.
In Scala, loops are not used as often as in other languages.
As you will see in Chapter 12, you can often process the values in a sequence by applying a function to all of them, which can be done with a single method call.
NOTE: Scala has no break or continue statements to break out of a loop.What to do if you need a break? Here are a few options:
Use nested functions—you can return from the middle of a function.
Here, the control transfer is done by throwing and catching an exception, so you should avoid this mechanism when time is of the essence.
In the preceding section, you saw the basic form of the for loop.
However, this construct is much richer in Scala than in Java or C++
You can have multiple generators of the form variable <- expression.
Each generator can have a guard, a Boolean condition preceded by if:
When the body of the for loop starts with yield, then the loop constructs a collection of values, one for each iteration:
A method operates on an object, but a function doesn’t.
C++ has functions as well, but in Java, you have to imitate them with static methods.
However, as long as the function is not recursive, you need not specify the return type.
The Scala compiler determines the return type from the type of the expression to the right of the = symbol.
If the body of the function requires more than one expression, use a block.
The last expression of the block becomes the value that the function returns.
For example, the following function returns the value of r after the for loop.
There is no need for the return keyword in this example.
It is possible to use return as in Java or C++, to exit a function immediately, but that is not commonly done in Scala.
TIP: While there is nothing wrong with using return in a named function (except the waste of seven keystrokes), it is a good idea to get used to life without return.
Pretty soon, you will be using lots of anonymous functions, and there, return doesn’t return a value to the caller.
It breaks out to the enclosing named function.Think of return as a kind of break statement for functions, and only use it when you want that breakout functionality.
With a recursive function, you must specify the return type.
NOTE: Some programming languages (such as ML and Haskell) can infer the type of a recursive function, using the Hindley-Milner algorithm.
Extending the Hindley-Milner algorithm so it can handle subtypes is still a research problem.
If you supply fewer arguments than there are parameters, the defaults are applied from the end.
You can also specify the parameter names when you supply the arguments.
Note that the named arguments need not be in the same order as the parameters.
They are also useful if a function has many default parameters.
You can call this function with as many arguments as you like.
The function receives a single parameter of type Seq, which we will discuss in Chapter 13
For now, all you need to know is that you can use a for loop to visit each element.
If you already have a sequence of values, you cannot pass it directly to such a function.
If the sum function is called with one argument, that must be a single integer, not a range of integers.
The remedy is to tell the compiler that you want the parameter to be considered an argument sequence.
Here, the head of a sequence is its initial element, and tail is a sequence of all other elements.
That’s again a Seq, and we have to use : _* to convert it to an argument sequence.
This is the case for any Object parameter, but I mention it here because it is most common with varargs methods.
Scala has a special notation for a function that returns no value.
If the function body is enclosed in braces without a preceding = symbol, then the return type is Unit.
A procedure returns no value, and you only call it for its side effect.
For example, the following procedure prints a string inside a box, like.
Some people (not me) dislike this concise syntax for procedures and suggest that you always use an explicit return type of Unit:
They can also deal with other initialization issues, such as circular dependencies.
You can think of lazy values as halfway between val and def.
Every time a lazy value is accessed, a method is called that checks, in a threadsafe manner, whether the value has already been initialized.
Scala exceptions work the same way as in Java or C++
NOTE: In Java, “checked” exceptions are checked at compile time.
If your method might throw an IOException, you must declare it.
This forces programmers to think where those exceptions should be handled, which is a laudable goal.
Many Java programmers detest this feature and end up defeating it by either catching exceptions too early or using excessively general exception classes.
The Scala designers decided against checked exceptions, recognizing that thorough compile-time checking isn’t always a good thing.
If one branch has type Nothing, the type of the if/else expression is the type of the other branch.
The syntax for catching exceptions is modeled after the pattern-matching syntax (see Chapter 14)
Note that you can use _ for the variable name if you don’t need it.
The try/finally statement lets you dispose of a resource whether or not an exception has occurred.
The finally clause is executed whether or not the process function throws an exception.
This code is a bit subtle, and it raises several issues.
What if the URL constructor or the openStream method throws an exception? Then the try block is never entered, and neither is the finally clause.
That’s just as well—in was never initialized, so it makes no sense to invoke close on it.
What if in.close() throws an exception? Then that exception is thrown out of the statement, superseding any earlier one.
This is just like in Java, and it isn’t very nice.
Ideally, the old exception would stay attached to the new one.)
The try/catch statement handles exceptions, and the try/finally statement takes some action (usually cleanup) when an exception is not handled.
It is possible to combine them into a single try/catch/finally statement:
Write a procedure countdown(n: Int) that prints the numbers from n to 0
Write a for loop for computing the product of the Unicode codes of all letters in a string.
For example, the product of the characters in "Hello" is 825152896
Write a function product(s : String) that computes the product, as described in the preceding exercises.
Make the function of the preceding exercise a recursive function.
In this chapter, you will learn how to work with arrays in Scala.
Java and C++ programmers usually choose an array or its close relation (such as array lists or vectors) when they need to collect a bunch of elements.
In Scala, there are other choices (see Chapter 13), but for now, I’ll assume you are impatient and just want to get going with arrays.
Scala and Java arrays are interoperable; with ArrayBuffer, use scala.collection.
If you need an array whose length doesn’t change, use the Array type in Scala.
An array of Int, Double, or another equivalent of the Java primitive types is a primitive type array.
Java has ArrayList and C++ has vector for arrays that grow and shrink on demand.
Conversely, call a.toBuffer to convert the array a to an array buffer.
In Java and C++, there are several syntactical differences between arrays and array lists/vectors.
Most of the time, you can use the same code for both.
Here is how you traverse an array or array buffer with a for loop:
The until method belongs to the RichInt class, and it returns all numbers up to (but not including) the upper bound.
To visit the elements starting from the end of the array, traverse.
If you don’t need the array index in the loop body, visit the array elements directly, like this:
In the preceding sections, you saw how to work with arrays just like you would in Java or C++
It is very easy to take an array (or array buffer) and transform it in some way.
Such transformations don’t modify the original array, but they yield a new one.
The for (...) yield loop creates a new collection of the same type as the original collection.
If you started with an array, you get another array.
If you started with an array buffer, that’s what you get from for (...) yield.
The result contains the expressions after the yield, one for each iteration of the loop.
Oftentimes, when you traverse a collection, you only want to process the elements that match a particular condition.
This is achieved with a guard: an if inside the for.
Here we double every even element, dropping the odd ones:
Keep in mind that the result is a new collection—the original collection is not affected.
Then we visit the indexes in reverse, except for indexes(0)
The key observation is that it is better to have all index values together instead of seeing them one by one.
It is often said that a large percentage of business computations are nothing but computing sums and sorting.
Similarly, the min and max methods yield the smallest and largest element in an array or array buffer.
The sorted method sorts an array or array buffer and returns the sorted array or array buffer, without modifying the original:
You can sort an array, but not an array buffer, in place:
For the min, max, and quickSort methods, the element type must have a comparison operation.
This is the case for numbers, strings, and other types with the Ordered trait.
There are lots of useful methods on arrays and array buffers, and it is a good idea to browse the Scala documentation to get an idea of what’s there.
NOTE: The methods for the Array class are listed under ArrayOps.
Technically, an array is converted to an ArrayOps object before any of the operations is applied.
Because Scala has a richer type system than Java, you may encounter some strange-looking syntax as you browse the Scala documentation.
Fortunately, you don’t have to understand all nuances of the type system to do useful work.
This method takes a predicate, a function from A to Boolean.
It counts for how many elements the function is true.
This method takes zero or more arguments of type A.
The xs parameter can be any collection with the TraversableOnce trait, the most general trait in the Scala collections hierarchy.
Other common traits that you may encounter in Scaladoc are Traversable and Iterable.
All Scala collections implement these traits, and the difference between them is academic for library users.
However, the Seq trait requires element access by an integer index.
If someone forms a subclass of ArrayBuffer, then the return type of += is that subclass.
Here, B is allowed to be a supertype of A.
Such an ordering exists for numbers, strings, and other types with the Ordered trait, as well as for classes that implement the Java Comparable interface.
This declaration happens when the method creates a new collection.
Skip it and look for the simpler alternative, in this case.
Like in Java, multidimensional arrays are implemented as arrays of arrays.
Since Scala arrays are implemented as Java arrays, you can pass them back and forth between Java and Scala.
Then you can use Scala buffers in your code, and they automatically get wrapped into Java lists when calling a Java method.
The Scala buffer is wrapped into an object of a Java class that implements the java.util.List interface.
If the Java method returns a wrapped Scala buffer, then the implicit conversion unwraps the original object.
Write a code snippet that sets a to an array of n random integers between 0
Write a loop that swaps adjacent elements of an array of integers.
Repeat the preceding assignment, but produce a new array with the swapped values.
Given an array of integers, produce a new array that contains all positive values of the original array, in their original order, followed by all values that are zero or negative, in their original order.
Write a code snippet that produces all values from an array with duplicates removed.
As you will see in this chapter, Scala makes it particularly easy to use them.
Scala has a pleasant syntax for creating, querying, and traversing maps.
By default, you get a hash map, but you can also get a tree map.
If you want to start out with a blank map, you have to pick a map implementation and supply type parameters:
A pair is simply a grouping of two values, not necessarily of the same type, such as ("Alice", 10)
The -> operator is just a little easier on the eyes than the parentheses.
It also supports the intuition that a map data structure is a kind of function that maps keys to values.
The difference is that a function computes values, and a map just looks them up.
In Scala, the analogy between functions and maps is particularly close because you use the () notation to look up key values.
If the map doesn’t contain a value for the requested key, an exception is thrown.
To check whether there is a key with the given value, call the contains method:
Since this call combination is so common, there is a shortcut:
Finally, the call map.get(key) returns an Option object that is either Some(value for key) or None.
In a mutable map, you can update a map value, or add a new one, with a () to the left of an = sign:
Alternatively, you can use the += operation to add multiple associations:
To remove a key and its associated value, use the -= operator:
You can’t update an immutable map, but you can do something that’s just as useful—obtain a new map that has the desired update:
The newScores map contains the same associations as scores, except that "Bob" has been updated and "Fred" added.
Instead of saving the result as a new value, you can update a var:
Similarly, to remove a key from an immutable map, use the - operator to obtain a new map without the key:
The following amazingly simple loop iterates over all key/value pairs of a map:
The magic here is that you can use pattern matching in a Scala for loop.
Chapter 14 has all the details.) That way, you get the key and value of each pair in the map without any tedious method calls.
If for some reason you just want to visit the keys or values, use the keySet and values methods, as you would in Java.
The values method returns an Iterable that you can use in a for loop.
When working with a map, you need to choose an implementation—a hash table or a balanced tree.
You might want a tree map if you don’t have a good hash function for the keys, or if you need to visit the keys in sorted order.
To get an immutable tree map instead of a hash map, use.
Unfortunately, there is (as of Scala 2.9) no mutable tree map.
Your best bet is to adapt a Java TreeMap, as described in Chapter 13
TIP: If you want to visit the keys in insertion order, use a LinkedHashMap.
If you get a Java map from calling a Java method, you may want to convert it to a Scala map so that you can use the pleasant Scala map API.
This is also useful if you want to work with a mutable tree map, which Scala doesn’t provide.
Then trigger the conversion by specifying the Scala map type:
Conversely, to pass a Scala map to a method that expects a Java map, provide the opposite implicit conversion.
Pairs are the simplest case of tuples— aggregates of values of different types.
A tuple value is formed by enclosing individual values in parentheses.
Usually, it is better to use pattern matching to get at the components of a tuple, for example.
You can use a _ if you don’t need all components:
One reason for using tuples is to bundle together values so that they can be processed together.
TIP: The toMap method turns a collection of pairs into a map.
If you have a collection of keys and a parallel collection of values, then zip them up and turn them into a map like this:
At the end, print out all words and their counts.
Repeat the preceding exercise with a sorted map, so that the words are printed in sorted order.
Write a function minmax(values: Array[Int]) that returns a pair containing the smallest and largest values in the array.
Write a function lteqgt(values: Array[Int], v: Int) that returns a triple containing the counts of values less than v, equal to v, and greater than v.
Use the @BeanProperty annotation to generate the JavaBeans getXxx/setXxx methods.
In its simplest form, a Scala class looks very much like its equivalent in Java or C++:
To use this class, you construct objects and invoke methods in the usual way:
You can call a parameterless method (such as current) with or without parentheses:
Which form should you use? It is considered good style to use () for a mutator method (a method that changes the object state), and to drop the () for an accessor method (a method that does not change the object state)
You can enforce this style by declaring current without ():
A getter/setter pair such as this one is often called a property.
We say that the class Person has an age property.
But if that becomes a problem, we can guard against it:
In Scala, the getter and setter methods are called age and age_=
NOTE: To see these methods with your own eyes, compile the Person class and then look at the bytecode with javap:
As you can see, the compiler created methods age and age_$eq.
The user of your class still accesses fred.age, but now Fred can’t get younger:
Sometimes, however, you want a property that a client can’t set at will, but that is mutated in some other way.
Conceptually, the counter has a current property that is updated when the increment method is called, but there is no setter for the property.
NOTE: In Scala, you cannot have a write-only property (that is, a property with a setter and no getter)
Accessing other.value is legal because other is also a Counter object.
Table 5–1 shows which methods are generated in all cases.
To implement a property that is publicly accessible and backed by a field.
To confine the field to the methods of this class, just like in Java.
To confine the field to methods invoked on the same object.
As in Java or C++, a Scala class can have as many constructors as you like.
However, a Scala class has one constructor that is more important than all the others, called the primary constructor.
In addition, a class may have any number of auxiliary constructors.
You can construct objects of this class in three ways:
The parameters of the primary constructor are placed immediately after the class name.
Half a line of Scala is the equivalent of seven lines of Java:
NOTE: If there are no parameters after the class name, then the class has a primary constructor with no parameters.
That constructor simply executes all statements in the body of the class.
TIP: You can often eliminate auxiliary constructors by using default arguments in the primary constructor.
Primary constructor parameters can have any of the forms in Table 5–1
Construction parameters can also be regular method parameters, without val or var.
How these parameters are processed depends on their usage inside the class.
Martin Odersky suggests to think about it this way: In Scala, classes take parameters, just like methods do.
TIP: The Scala designers think that every keystroke is precious, so they let you combine a class with its primary constructor.
When reading a Scala class, you need to disentangle the two.
NOTE: To make the primary constructor private, place the keyword private like this:
A class user must then use an auxiliary constructor to construct a Person object.
NOTE: This is different from Java, where an inner class belongs to the outer class.
For example, to make a new inner object, you simply use new with the type name: new chatter.Member.
In Java, you need to use a special syntax, chatter.new Member()
In our network example, you can add a member within its own network, but not across networks.
If you like, you can establish an alias for that reference with the following syntax:
Write a class BankAccount with methods deposit and withdraw, and a read-only property balance.
Write a class Time with read-only properties hours and minutes and a method before(other: Time): Boolean that checks whether this time comes before the other.
Make a class Student with read-write JavaBeans properties name (of type String) and id (of type Long)
A class can have a companion object with the same name.
The apply method of an object is usually used for constructing new instances of the companion class.
To avoid the main method, use an object that extends the App trait.
There is just one exception: You cannot provide constructor parameters.
You use an object in Scala whenever you would have used a singleton object in Java or C++:
When a single instance is required to coordinate some service (the singleton design pattern)
NOTE: Many people view the singleton design pattern with disdain.
Scala gives you the tools for both good and bad design, and it is up to you to use them wisely.
In Java or C++, you often have a class with both instance methods and static methods.
In Scala, you achieve this by having a class and a “companion” object of the same name.
NOTE: The companion object of a class is accessible, but it is not in scope.
One useful application is to specify default objects that can be shared.
For example, consider a class for undoable actions in a program.
The DoNothingAction object can be shared across all places that need this default.
It is common to have objects with an apply method.
The apply method is called for expressions of the form.
Typically, such an apply method returns an object of the companion class.
Why doesn’t one just use a constructor? Not having the new keyword is handy for nested expressions, such as.
Instead of providing a main method for your application, you can extend the App trait and place the program code into the constructor body:
If you need the command-line arguments, you can get them from the args property:
If you invoke the application with the scala.time option set, then the elapsed time is displayed when the program exits.
The App trait extends another trait, DelayedInit, that gets special handling from the compiler.
All initialization code of a class with that trait is moved into a delayedInit method.
The main of the App trait method captures the command-line arguments, calls the delayedInit method, and optionally prints the elapsed time.
NOTE: Older versions of Scala had an Application trait for the same purpose.
That trait carried out the program’s action in the static initializer, which is not optimized by the just-in-time compiler.
Unlike Java or C++, Scala does not have enumerated types.
However, the standard library provides an Enumeration helper class that you can use to produce enumerations.
Each call to the Value method returns a new instance of an inner class, also called Value.
Alternatively, you can pass IDs, names, or both to the Value method:
See Chapter 7 for more information on importing members of a class or object.)
The ID of an enumeration value is returned by the id method, and its name by the toString method.
Finally, you can look up an enumeration value by its ID or name.
Write a Scala application, using the App trait, that prints the command-line arguments in reverse order, separated by spaces.
Implement a function that checks whether a card suit value from the preceding exercise is red.
IDs, use the color values (for example, 0xff0000 for Red)
A chain x.y.z in a package clause leaves the intermediate packages x and x.y invisible.
To add items to a package, you can include them in package statements, such as:
In Scala, the scope rules for packages are more consistent than those in Java.
This code takes advantage of the fact that the scala package is always imported.
One solution is to use absolute package names, starting with _root_, for example:
Another approach is to use “chained” package clauses, as detailed in the next section.
A package clause can contain a “chain,” or path segment, for example:
Imports let you use short names instead of long ones.
If you don’t mind long names, you’ll never need them.
You can also import all members of a class or object.
Java programmers seem to live in fear of this variant, but in Scala it is commonly used.
Once you import a package, you can access its subpackages with shorter names.
The event package is a member of java.awt, and the import brings it into scope.
This is a very useful feature, particularly with wildcard imports.
It is always a bit worrisome to import lots of names from different sources.
In fact, some Java programmers dislike wildcard imports so much that they never use them, but let their IDE generate long lists of imported classes.
If you want to import a few members from a package, use a selector like this:
These could equally well have been placed into the scala package object, but Predef was introduced before Scala had package objects.)
Since the scala package is imported by default, you never need to write package names that start with scala.
Write a package random with functions nextInt(): Int, nextDouble(): Double, and setSeed(seed: Int): Unit.
Why do you think the Scala language designers provided the package object syntax instead of simply letting you add functions and variables to a package?
Write a program that copies all elements from a Java hash map into a Scala hash map.
In the preceding exercise, move all imports into the innermost scope possible.
Apart from StringBuilder, what other members of java.lang does the scala package override?
In this chapter, you will learn the most important ways in which inheritance in Scala differs from its counterparts in Java and C++
Only the primary constructor can call the primary superclass constructor.
In this chapter, we only discuss the case in which a class inherits from another class.
You extend a class in Scala just like you would in Java—with the extends keyword:
When you misspell the name of the method that you are overriding.
When you accidentally provide a wrong parameter type in the overriding method.
When you introduce a new method in a superclass that clashes with a subclass method.
In Java, one is often advised to “solve” this problem by declaring all methods as final unless they are explicitly designed to be overridden.
That sounds good in theory, but programmers hate it when they can’t make even the most innocuous changes to a method (such as adding a logging call)
Invoking a superclass method in Scala works exactly like in Java, with the keyword super:
The call super.toString invokes the toString method of the superclass—that is, the Person.toString method.
To test whether an object belongs to a given class, use the isInstanceOf method.
If the test succeeds, you can use the asInstanceOf method to convert a reference to a subclass reference:
If you want to test whether p refers to a Employee object, but not a subclass, use.
Table 8–1 shows the correspondence between Scala and Java type checks and casts.
However, pattern matching is usually a better alternative to using type checks and casts.
Recall from Chapter 5 that a class has one primary constructor and any number of auxiliary constructors, and that all auxiliary constructors must start with a call to a preceding auxiliary constructor or the primary constructor.
As a consequence, an auxiliary constructor can never invoke a superclass constructor directly.
The auxiliary constructors of the subclass eventually call the primary constructor of the subclass.
Here, the Employee class has three parameters: name, age, and salary, two of which it “passes” to the superclass.
In Java, the equivalent code is quite a bit more verbose:
NOTE: In a Scala constructor, you can never call super(params), as you would in Java, to call the superclass constructor.
Its primary constructor must invoke one of the constructors of the Java superclass.
A val can only override another val or a parameterless def.
Only if the superclass var is abstract (see Section 8.8)
NOTE: In Chapter 5, I said that it’s OK to use a var because you can always change your mind and reimplement it as a getter/setter pair.
However, the programmers extending your class do not have that choice.
In other words, if you provide a var, all subclasses are stuck with it.
Here we say that every person has an ID, but we don’t know how to compute it.
Each concrete subclass of Person needs to specify an id method.
In Scala, unlike Java, you do not use the abstract keyword for an abstract method.
As in Java, a class with at least one abstract method must be declared abstract.
For simplicity, we assume the creature lives in a one-dimensional world, and the sensory data are represented as integers.
The Ant constructor calls the Creature constructor before doing its own construction.
The Creature constructor, in order to initialize the env array, calls the range() getter.
The moral is that you should not rely on the value of a val in the body of a constructor.
In Java, you have a similar issue when you call a method in a superclass constructor.
The method might be overridden in a subclass, and it might not do what you want it to do.
In fact, that is the root cause of our problem—the expression range calls the getter method.)
NOTE: At the root of the construction order problem lies a design decision of the Java language—namely, to allow the invocation of subclass methods in a superclass constructor.
In C++, an object’s virtual function table pointer is set to the table of the superclass when the superclass constructor executes.
Afterwards, the pointer is set to the subclass table.Therefore, in C++, it is not possible to modify constructor behavior through overriding.The Java designers felt that this subtlety was unnecessary, and the Java virtual machine does not adjust the virtual function table during construction.
The classes that correspond to the primitive types in Java, as well as the type Unit, extend AnyVal.
All other classes are subclasses of the AnyRef class, which is a synonym for the Object class from the Java or .NET virtual machine.
Both AnyVal and AnyRef extend the Any class, the root of the hierarchy.
The AnyRef class adds the monitor methods wait and notify/notifyAll from the Object class.
It also provides a synchronized method with a function parameter.
That method is the equivalent of a synchronized block in Java.
NOTE: Just like in Java, I suggest you stay away from wait, notify, and synchronized unless you have a good reason to use them instead of higher-level concurrency constructs.
All Scala classes implement the marker interface ScalaObject, which has no methods.
At the other end of the hierarchy are the Nothing and Null types.
Null is the type whose sole instance is the value null.
You can assign null to any reference, but not to one of the value types.
For example, setting an Int to null is not possible.
This is better than in Java, where it would be possible to set an Integer wrapper to null.
CAUTION: The Nothing type is not at all the same as void in Java or C++
In Scala, void is represented by the Unit type, the type with the sole value ()
Note that Unit is not a supertype of any other type.
However, the compiler still allows any value to be replaced by a ()
When you implement a class, you should consider overriding the equals method to provide a natural notion of equality for your situation.
This is a different method that does not override the equals method of AnyRef.
TIP: You are not compelled to override equals and hashCode.
For many classes, it is appropriate to consider distinct objects unequal.
For example, if you have two distinct input streams or radio buttons, you will never consider them equal.
In an application program, you don’t generally call eq or equals.
For reference types, it calls equals after doing the appropriate check for null operands.
Extend the following BankAccount class to a CheckingAccount class that charges $1
Consult your favorite Java or C++ textbook that is sure to have an example of a toy inheritance hierarchy, perhaps involving employees, pets, graphical shapes, or the like.
Design a class Point whose x and y coordinate values can be provided in a constructor.
Provide a subclass LabeledPoint whose constructor takes a label value and x and y coordinates, such as.
Provide appropriate constructors for the subclasses and override the centerPoint method in each subclass.
Hint: Review the discussion of private constructors in Chapter 5.)
To convert a string into a number, use the toInt or toDouble method.
Use """...""" if your regular expression contains backslashes or quotes.
You can use it to process the lines one at a time:
Or you can put the lines into an array or array buffer by applying the toArray or toBuffer method to the iterator:
CAUTION: Call close when you are done using the Source object.
Then you can peek at the next input character with the head method without consuming it.
Finally, note that you can read numbers from the console:
CAUTION: These methods assume that the next input line contains a single number, without leading or trailing whitespace.
CAUTION: When you read from a URL, you need to know the character set in advance, perhaps from an HTTP header.
When you pass a number to printf, the compiler will complain that you need to convert it to an AnyRef:
NOTE: The printf method of the Console class does not suffer from this problem.You can use.
It is simple to write a function that produces an iterator through all subdirectories of a directory:
With this function, you can visit all subdirectories like this:
In Java, serialization is used to transmit objects to other virtual machines or for short-term storage.
For long-term storage, serialization can be awkward—it is tedious to deal with different object versions as classes evolve over time.)
Here is how you declare a serializable class in Java and Scala.
NOTE: You can omit the @SerialVersionUID annotation if you are OK with the default ID.
The Scala collections are serializable, so you can have them as members of your serializable classes:
Scala was designed to scale from humble scripting tasks to massive programs.
You can write your shell scripts in Scala, with all the power that the Scala language puts at your disposal.
The sys.process package contains an implicit conversion from strings to ProcessBuilder objects.
You can pipe the output of one program into the input of another, using the #| operator:
NOTE: As you can see, the process library uses the commands of the underlying operating system.
If you need to run a process in a different directory, or with different environment variables, construct the ProcessBuilder with the apply method of the Process object.
Supply the command, the starting directory, and a sequence of (name, value) pairs for environment settings.
When you process input, you often want to use regular expressions to analyze it.
To construct a Regex object, use the r method of the String class:
If the regular expression contains backslashes or quotation marks, then it is a good idea to use the “raw” string syntax, """..."""
To check whether the beginning of a string matches, use findPrefixOf:
Add parentheses around the subexpressions that you want to extract, for example:
If you want to extract groups from multiple matches, use a for statement like this:
Write a Scala program that prints the src attributes of all img tags of a web page.
