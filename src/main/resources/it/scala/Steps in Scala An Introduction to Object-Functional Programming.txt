Scala is the most prominent representative of this exciting approach to programming, both in the small and in the large.
In this book we show how Scala proves to be a highly expressive, concise, and scalable language, which grows with the needs of the programmer, whether professional or hobbyist.
Use Scala for fun, for professional projects, for research ideas.
His research interests focus on computability theory, category theory, fuzzy set theory, and digital typography.
He has authored or co-authored six books, was co-editor of a multi-author volume, and has published more than 50 papers and articles.
Subject to statutory exception and to the provision of relevant collective licensing agreements, no reproduction of any part may take place without the written permission of Cambridge University Press.
Cambridge University Press has no responsibility for the persistence or accuracy of urls for external or third-party internet websites referred to in this publication, and does not guarantee that any content on such websites is, or will remain, accurate or appropriate.
To Katerina, who is always here and is constantly making me a better person CKKL.
Scala is a relatively new programming language that was designed by Martin Odersky and released in 2003
The distinguishing features of Scala include a seamless integration of functional programming features into an otherwise objectoriented language.
Scala owes its name to its ability to scale, that is, it is a language that can grow by providing an infrastructure that allows the introduction of new constructs and data types.
In addition, Scala is a concurrent programming language, thus, it is a tool for today as well as tomorrow! Scala is a compiled language.
Its compiler produces bytecode for the Java Virtual Machine, thus allowing the (almost) seamless use of Java tools and constructs from within scala.
The language has been used to rewrite Twitter’s1 back-end services.
In addition, almost all of Foursquare’s2 infrastructure has been coded in Scala.
This infrastructure is used by several companies worldwide (for example, Siemens, Sony Pictures Imageworks)
Sections describing such topics are marked with an asterisk (*)
In Chapter 5 we discuss how one can create and manipulate XML content using Scala.
In addition, we show how to perform a number of important operations such as searching and printing.
Also, we show how to produce XHTML content with Scala.
In particular, we show how to use a number of GUI components such as frames, all sorts of.
It was said above that Scala is a concurrent programming language in the sense that it includes a number of features that facilitate concurrent programming.
In particular, we discuss threads and synchronization, animation using threads, mailboxes (a precursor of actors), and actors.
Chapter 12 introduces and analyzes the expression problem, a not so widely known software design problem.
Since its essence lies at the frontier of combining data with operations, we feel that this particular problem should be brought to the attention of a wider audience.
Based on work by well-known researchers (including the creator of Scala, Martin Odersky) we build a small code library that follows a consistent set of naming conventions in order to help us tackle the expression problem.
Chapter 13 is a short chapter that shows how one can easily construct a relatively simple computer algebra system.
The fourth and last appendix presents the wealth of command line options of Scala’s compiler and interpreter.
Each chapter contains a number of exercises that have been designed to help readers obtain a deeper understanding of the topics presented.
There are no solutions to exercises, though in some cases material that follows the exercises contains the solution.
In most cases these are not easy and some of them are quite challenging.
All of the examples presented in the following pages have been tested to work under OpenSolaris and MacOS X [Snow] Leopard.
We do not expect that readers who use different computer platforms will encounter any kind of problem, as long as they use the latest version of Java’s JDK from Oracle.
The book has been typeset using a Unicode-aware extension of LATEX that runs atop of a novel typesetting engine created by Jonathan Kew.
We have used Minion Pro to set the text of the book and GFS Neohellenic (by the Greek Font Society) to set captions.
In addition, we have used UM Typewriter (created by Apostolos) to typeset code snippets.
Asana Math (also by Apostolos) has been used to set mathematical text in this book.
First of all we would like to thank Heather Bergman, a former computer science editor of CUP’s New York branch, who believed in this project.
Heather has helped us during the writing of the book in every possible way! Also,we would like to thank Clare Dennison, our pre-production editor, and Jonathan Ratcliffe, our production editor.
It turns out that these simple ideas are the core of what is now known as object-orientation.
Usually, objects are related with an “isa” relationship, that is, if A and B are two objects such.
Without worrying about the details, let us see by means of an example how these principles are realized in the language that is presented in this book.
An ant has six legs and let us assume it has two eyes.
The declaration that follows creates an ant object that corresponds to an ant:
Althoughwe cannot alter the number of feet or the number of eyes of an ant object, we can inspect these values.
Note that we have intentionally left out various checks that should be performed (for example, we cannot pop something from an empty stack) just to keep things simple.
We just specify the height of the stack as shown below:
Another method to describe a function is to specify a single rule:
Then the composition of these solutions gives a solution to the original problem.
In order to ensure that procedure functions can be composed as their mathematical counterparts, one must avoid the so-called side effects.
To understand what we mean by side effects, consider the following code:
Here the keyword val signals that the value of the variable declared cannot be changed.
On the other hand, variables declared with the var keyword are real variables, that is, they can change their value in the course of time.
What is really surprising about this function is that when it is invoked, both pre and post can be pieces of real code! Here is a simple usage example of this function:
Admitedly, the Java programming language is a very popular programming language.
The language owes its popularity to a number of reasons that include the following.
Java’s compiler produces code for the JavaVirtualMachine (JVM),4 whichhas beenported.
Java has a huge application programming interface (API) that provides support from computer-telephony integrated call control to advanced image handling andmp3playing.
A virtual machine is a computer program that simulates a computer architecture and is able to run machine code for this particular computer architecture.
Scala can easily be used as a scripting language since Scala’s distribution includes a compiler as well as an interpreter.
For example, one can assign an XML tree to a variable as follows:
These and a number of other features have made Scala a popular programming language that is currently used by many enterprises.
Our sincere hope is that this brief overview of the key features of Scala has whetted your appetite for more Scala!
The program can be executed by entering the following command:
The two versions presented do not produce exactly the same output.
For example, the second version will print the following message.
This program can be executed from a CMD shell by entering a command like the following one:
Starting the Scala interpreter is easy: just type scala in your command prompt.
The next few lines show a typical session with the Scala interpreter.
A typical Scala program describes the interaction between objects, which interchange messages.
For example, things like numbers, character sequences, and character strings or just strings, are objects that can interact with other objects.
Table 2.1 Basic types supported by the Scala programming language.
Objects with no internal structure, that is with no components, are said to be of a basic type.
In what follows the Scala interpreter is used to demonstrate the properties of the basic types.
When declaring a variable or a constant, we write either the keyword var or the keyword val, the name of a variable or a constant, an equals sign (i.e., the symbol =), and then the value the variable or the constant will assume.
Optionally, we can specify the type of a variable or a constant by writing, after its name, a colon (:) and then its type:
If the value does not agree with the type, a type error occurs:
Mixing an Int with a Long results in a Long:
As it stands, one cannot assign to a character variable a single quotation mark:
We can solve this problem by using an escape sequence, that is, a sequence of easily accessible characters that represent other characters.
Unicode characters having the corresponding code point (see Table 2.2):
Note that println prints its arguments on the computer screen.
A String is a sequence of Chars that is enclosed in double quotes:
Multiline strings can be typed in using the \n escape sequence:
However, this is not convenient and so Scala provides a better way to type in multiline strings – one starts a string with three consecutive double quotes, then the string follows with embedded new lines and the string closes with three consecutive double quotes.
The literals true and false denote truth and untruth, respectively.
Type Unit has only one value, which is designated by two parentheses:
When a function does not return a result (for example, when it merely assigns values to variables), then it yields a value of type Unit.
If the return type is omitted, then Scala infers the return type of the method by examining the body of the method.
The expression new is used to construct an instance of a class.
For example, here is how one can construct a new object of class cell:
As in the previous case, for all objects that are instances of this class, method getColor will print yellow.
Now, suppose that for some reason we alter the color of a lemon:
This commandwill change the color of all objects old andnew.
The last example is a typical example of an assignment command, that is, a command that updates the value of a variable.
Note also that one can use parentheses for clarity or to override the default way operations are performed.
But we will come back to this matter at the end of this section.
Therefore, it does make sense to multiply or add characters.
For Strings Scala uses the usual lexicographic order and for numbers the usual number order:
Exercise 2.7 What is the result of the following comparisons:
Associativity of operators whose Operator precedence of operator name ends with the corresponding whose name starts with characters.
Table 2.3 describes the operator precedence and associativity of the operators supported by Scala.
In this section, we are going to describe some basic built-in control structures.
In both cases, the optional part appears only if the else keyword is present.
In addition, in either part if one wants to execute more than one command, these commands must be enclosed in curly brackets.
Also, note that if one wants to have more than one command in one line, these commands must be terminated by a semicolon (;)
However, note that the last “command” of each clause of a conditional expression must be of the same type and they should yield a value not of type Unit.
Clearly, if they return a value of type Unit, it is better to transform the conditional expression to a conditional command.
Here is a relatively simple example that demonstrates these points:
Table 2.4 Methods for reading values from the terminal provided by object Console.
Note that method print does not add a new line character to the values being printed.
The error was reported by the runtime environment which, in general, is a virtual machine state that provides software services for processes or programs.
However, it is an indication of really poor programdesign to rely on the runtime environment to catch our programming errors.
The careful reader may have noted that the if expression yields either an exception or an integer.
Clearly, this is not correct since the if expression should yield an integer value in both cases.
However, exceptions are of type Nothing, which is a subtype of every other Scala type.
Thus, the whole expression is well typed (i.e., does not violate the type rules of Scala)
Exercise 2.11 Modify this code so it can compute the largest as well as the smallest numbers given.
Note that the keyword extends is used to designate that class Lemon is a subclass of class Fruit.
Exercise 2.12 What will be printed on the computer screen when the commands.
Although f and l are of different types, nevertheless, Lemon is a subtype of type Fruit.
This principle can be stated as: If L is a subtype of F , then one can replace objects of type F with objects of type L without altering the meaning of a program.
Exercise 2.14 What will be the output of the following commands:
We have seen what to do when declaring a subclass that has the same number of members initialized when constructing an object of this subclass.
The question is: How can we declare a subclass with a different number of members which are.
Can you explain why the code is correct and why you get this output?
If we have two or more classes, it is not possible to create a new class that is a subclass of all these classes.
Technically, Scala does not supportmultiple inheritance, nevertheless, it does support tools to achieve the same effect without the problems of multiple inheritance.
It is possible to create an extension of a class while creating an instance of an existing class.
This can be achieved only for classes that do not have “parameters,” like the following simple class:
The following class instantiation shows exactly how this can be done:
This facility is extremely useful and more realistic examples using this facility are presented in Chapter 6
Thus, Q is invoked only when P is invoked and when it is invoked it will assign values to two variables and it will print the values of these variables.
Exercise 2.16 Write an anonymous function which will compute the maximum of three integer numbers.
For example, one can import function curried with the following command:
Here the character _ plays the role of a wildcard character that can be substituted with anything.
Now, let us present the functionality of curried and uncurried.
Function uncurried takes a function that returns a function and transforms it into a function that takes as argument an n-tuple, as the following shows:
On the other hand, function curried does exactly the opposite.
The following is a demonstration of its usage and its capabilities:
Observe that function curried actually takes two arguments, the second being the character _ because the function expects as argument a partially applied function.
One can compose all these functions and the following code snippet shows how this can be done:
Here z is declared as an array of Strings that may hold up to three elements.
In most cases we can simplify the declaration as follows:
If one wants to assign values to individual elements or to get access to individual elements, one can do so by using commands like the following:
As is evident, in this case we simply specify the elements after the keyword Array.
Note that the elements are separated by commas and they are enclosed in parentheses.
Assume that A and B are two arrays that represent two vectors.
If we have a tuple T that has as elements only integers and we want to compute their sum, then we should use the following code snippet:
If we replace method to with method until, we can safely delete the minus one part.
This method produces a range that does not include the last element.
To return to the original example,method asInstanceOf is a method that performs type casting, that is, a method that changes an object of one data type into another.
Actually, this is not an arbitrary method that changes any type to any other type.
On the contrary, the two classes should be related with the subclassing relationship (see Section 3.6.6)
Method productElement yields objects of type Any, which explains why we need typecasting.
Exercise 2.21 Write a function that can be used to compute the double factorial of any integer number.
Some readers may come up with a solution that uses while commands, whereas others may have opted to use the for command with some test in the body of the command.
However, it is possible to attach the tests to a for command as our solution to this problem shows:
This is an array that has three elements each being an array of integers that has three elements.
The code that follows shows how one can process a multi-dimensional array:
The expression A(i)(j) refers to the jth element of the ith array.
Since A(i) is an array, the following assignment is legal:
Exercise 2.23 Write a for command that prints all the elements of array A.
You should consider printing it as a real matrix, that is, one row on each line.
Given two arrays A and B that have elements of the same type, then the expression A ++= B appends to A all the elements of B:
Surprisingly, the same problem can be solved with the following expression:
The example presented above shows the basic characteristics of array args as well as a simple usage example.
However, it would be far more interesting to present an example where the command line argument is processed.
Thus each occurrence of the word “tato” should be replaced by a recursive call, or in Scala:
What is left is to show how one should handle the command line argument.
Obviously, the user has to specify only one command line argument which has to be a positive integer.
For reasons of simplicity let us assume that the user may enter only.
Table 2.5 Methods that parse a string as a literal of some basic type and return an object of this type.
Here isEmpty returns true if the the array contains no elements.
Method toInt is one of a family of methods that parse a string as a literal of some basic type and return an object that corresponds to this literal (see Table 2.5)
Exercise 2.24 The following code handles better the command line argument:
The type annotation is necessary as the system needs to assign a concrete type to variable y.
On the other hand, when declaring a nonempty set, the type annotation is not necessary:
Given two sets, one should be able to compute their union and their intersection.3
As expected, operator subsetOf checks whether the left operand is a subset of the right operand; method isEmpty returns.
It is also possible to create a set by successively adding elements to it as the following example shows:
The rest of this section presents two simple set manipulation examples.
Assume that we have a skiing competition4 and we want to determine the order.
In Greece, owing to the greenhouse effect, we do not expect to see much snow in the years to come.
In fact, we are more likely to see warm winters and very hot summers.
If humanity as a whole does not understand the severity of the current situation, and if therefore drastic measures are not taken, we will only be able to dream of winters, snow, and skiing competitions.
The expression B -= entrant removes the element on the right from the set on the left.
Exercise 2.27 The previous program is static, that is, every time it is executed it will print the same output.
Many popular languages, like Perl and Ruby, provide a generalization of arrays that are called hash tables.
Instead of having as index only natural numbers, hash tables can have as index strings or any other object.
Note that in Perl indices can only be strings while in Ruby any kind of object can serve as an index.
In Scala hash tables can have objects of any type as indices, but, obviously, all indices have to have the same type.
For some reason hash tables are called maps in Scala, but we will stick to the generally accepted term.
We can initialize hash tables either by creating an empty table or by initializing a new table.
The following command creates a new empty hash table whose keys are strings and whose values are integers:
Exercise 2.28 If you try this code, you will discover that Scala will complain about some illegal characters.
Which are these illegal characters and why are they illegal?
Here method foreach scans all keys, thus, d takes the value of all keys in the table.
Obviously, it is very straightforward to use this function as the following usage example shows:
One can check whether there is a particular key by using method contains as shown in the example that follows:
If we want to remove one or more pairs from a hash table, we can use the operator minus as is shown in the example that follows:
The condition evaluates to true and, consequently, a message is printed on the computer screen.
Although it is not particularly useful to delete all entries from a hash table, the following code achieves this task:
Method keys generates a special data structure from all the keys of the table.
One can easily process the elements of such a data structure, which is known as an iterator exactly for this reason.
In fact, even a hash table is an iterator, but one that returns pairs.
Thus, the code that follows does exactly what the previous command does:
If a hash table is empty, then method isEmpty will return true.
For example, if the following code is executed after the previous command has been executed.
Method values returns an iterator data structure that contains all values that are stored in a hash table.
Exercise 2.29 The expression x.toInt yields the Unicode code point of a Char object x.
Create a hash table that has as keys the letters of a string and as values their Unicode code points.
Assume that the hash table from the previous exercise is called letters.
Then the following code sums up the values of the table:
Method elements creates an iterator that consists of all pairs that make up a particular hash table.
Following the previous example, we can print all pairs of table letters with this command:
Figure 2.1 A memorized version of a function that computes the Fibonacci numbers.
The last two commands compute nothing since the corresponding Fibonacci numbers had been computed by the second command.
Writing down explicitly the elements of a list is not the best way to create a list.
As an alternative solution, one can use a for comprehension to specify the elements of a list implicitly.
For example, the following code creates a list that contains all whole numbers from one to ten:
Here the keyword by is used to specify the iteration step.
An easier way to create the same list is shown below:
After the execution of this code, what will be printed on the computer screen?
Given a list A, its length is computed by A.length, nevertheless, we present this example for purely pedagogical reasons.
This function examines the list and if it is empty (method isEmpty returns true if the list is empty), it returns zero since the length of an empty list is zero.
If the list is not empty, then it returns one plus the length of the tail.
Methods head and tail return the head and the tail of a.
Exercise 2.32 Write down a function that sums up the elements of a list of integers.
Let us now see a more challenging problem: to write a function that reverses the order of the elements in a list.
One way to solve this problem is by thinking that the head of the list has to be the last element of the list and this would apply to the head of the tail of the list, etc.
In order to implement this idea, we need to use the ::: operator, which is pronounced prepend.
The result of the expression A:::B is to have A prepended to B (remember that all operators whose name ends with : are right-to-left associative, see Table 2.3; this implies that A:::B is syntactic sugar for B.:::(A))
We are now ready to present a solution to our problem:
The method count returns the number of elements of a list that have a particular property.
The following command prints the number of even elements of A:
Variable e is a dummy variable that successively assumes the value of each element of the list, examines the condition that follows the => symbol and if it yields true, then it increases the value of a hidden counter.
In the end, it returns the value of this counter.
This means that if for some reason we need to modify a list we practically have to create a new list from the original.
Now, if we want to remove a number of consecutive elements from the right-hand side of a list, we can use the method dropRight.
This method takes one argument which is the number of elements to be removed.
Method exists can be used to check whether some element of a list has a particular property.
On the other hand, method forall examines all elements of a list and if all of them have a property, then it returns true.
Method filter yields a list that includes all elements that have a particular property.
For example, the following function implements the quicksort sorting algorithm of Tony Hoare.
The function that follows is not really quicksort, but in a way looks like quicksort.
The reason is that quicksort relies on destructive assignments, while the style of this function is functional.
At any rate, this function does what it claims to do – it returns a list that contains the elements of its argument sorted.
Method foreach has the same functionality as the corresponding method used by arrays.
However, method map, which functions as method foreach, takes as argument a function that returns a type other than Unit, which is the type of all arguments of foreach.
Here is an example that shows exactly what we mean:
Here the character _ stands for an anonymous variable that is supplied to this function by the operator from the list.
In certain cases, instead of the foreach method one can use a for expression.
A for expression differs from a for comprehension in that the former yields a value.
For example, the following shows how one can use a for expression:
Method reverse returns the elements of the list with their order reversed.
Method remove yields a list that does not contain the elements that satisfy a certain condition.
This method can be used just like most of the methods described above.
Method init returns all but the last element of a list, or in Scala parlance:
Let us repeat that two objects are equal when they have exactly the same structure.
Obviously, if they have different types, the comparison is always false, unless the type of one is a subtype of the other.
Method last returns the last element of a list, or in Scala parlance:
Although it is uncommon to ask for the nth element of some list, Scala provides the method apply which can be used to obtain an arbitrary element of some list:
If we have a list whose elements are lists, then function flatten can be used to concatenate the elements of this list as shown below:
Exercise 2.35 Explain how one could obtain the standard Scala string representation of lists using mkString.
In certain cases it would be useful to be able to copy a list to an array.
Method copyToArray has two arguments – an array and the starting position, which implies that we can copy part of a list.
Note that List[Int]() is an annotated version of Nil, the empty list.
Exercise 2.37 Explain why function rev computes the reverse of a list.
In the case of strings, the rightmost empty string "" is considered to occur at the index value that is equal to the length of the string.
Exercise 2.38 Write a function to recognize palindromes, that is,words that read the same backwards as forwards.
A man, a plan, a canal: Panama! Evil rats on no star live.
Hint: Use replace to eliminate all punctuation marks, transform all sentences to lowercase, and use the fact that for any string A:
This is a knownbug in the language implementation and springs fromScala’s dependence on Java’s basic types and the desire of Scala’s designers and implementors to provide a really complete set of methods for each basic type.
Since regular expressions are like tiny language processors, it is far better to compile them into some internal representation and then use them.
Table 2.7 Special characters that can appear in regular expressions.
The most simple regular expression is a sequence of characters (for example, the string bar) that will match any substring that contains the characters of the pattern in this order.
Thus, the pattern bar will match the “bar” in string Babar.
If for any reason we cannot directly type a particular character or need to use a character that has a reserved meaning, then one should consult Table 2.7
Character classes Assume we want to check whether a string contains either the string bar or the string par.
By placing the symbol ^ just after the left square bracket we specify that we are looking for strings that do not contain the characters in the character class.
Thus, in the expression ((A)(B(C))), the subexpression B(C) is in group 2
Exercise 2.40 Assume we have the following regular expression and input string:
What do you expect to see on your computer screen when the code.
We can specify alternatives with classes, but we can employ a special notation involving groups.
In particular, we can specify the alternatives in a group where alternatives are separated by the symbol |
For example, the pattern (\+|-)? will match either a plus or a minus sign.
If we place a backslash (\) in front of any special character, then it is turned into a normal character.
Also, if for some reason we want to refer to a subpattern that forms a subgroup and which has been matched already, then we can do so by using \n, where n is the subgroup’s number.
Note that everything that has beenmatched is stored inmemory for future reference.
Boundary matchers These are special symbols that should be used when it matters where the string that will be matched is located.
For example, when one analyzes an input string it matters whether some token is in the beginning or the end of the string.
The various boundary matchers that are available are shown in Table 2.10
The beginning of a line $ The end of a line.
X) X as a noncapturing group Y(?=X) A zero-width positive lookahead; matches a Y that is not followed by an X.
Y(?!X) A zero-width negative lookahead; matches a Y and a trailing X while.
The following two tests will both print OK, thus verifying that our function works as expected:
But Scala packages differ from Java packages in that Scala has incorporated ideas borrowed fromC#
In particular, it is possible to declare one package inside another, thus forming a hierarchy of nested packages.
Packages may affect the visibility of members of a class in a different way.When a member of a class is declared as private[this], this means that it can be accessed.
The command offers some options that can be used to control which classes, methods, objects, etc., will be imported.
In the simplest case, we can specify exacly what to import.
In addition, it is quite possible to give a new name to a member as shown below:
As was noted in Chapter 1, one can place comments in code by placing the symbol // anywhere in the source code.
In general, comments can be used to force a language processor to ignore a section of the source code and/or to include text that of course is ignored but explains the functionality of the source code.
In many cases, these comments serve as a basis for the construction of a reference manual.
To facilitate the construction of such documents, the designers of the Java programming language introduced the.
Finally, the @deprecated tag followed by text adds a comment indicating that what is commented should no longer be used.
Annotations are comments of a special kind that do not directly affect the intended meaning of any program, but they supply information about how a program should be compiled, deployed or executed.
For example, the annotation @deprecated before a method as shown below.
Since Scala does have checked exceptions, if one wants to write code that interoperates with Java code, then Scala methods must be annotated with one or more @throws annotations such that Java code can catch exceptions thrown by a Scala method.
Instances of recursive data types are easily manipulated with recursive functions.
If we want to list the nodes of a binary tree, there are three different strategies.
Exercise 3.1 Write two functions that implement the pre-order and post-order tree traversal strategies.
We assume that we are going to build a binary search tree from data that are stored in a list.
The following code shows how one can build a list from data that are supplied interactively by a user.
On page 37 we showed how one can write a loop that inputs from the keyboard a sequence of numbers.
The skeleton code snippet that follows shows how we can build a list from input supplied from the keyboard:
Figure 3.1 A function that builds a binary search tree from a list.
Exercise 3.2 Write a function reflect that will take a binary tree and return a second binary tree whose left subtree is the right subtree of the original tree and whose right subtree is the left subtree of the original tree.
A problem whose solution is reminiscent of in-order tree traversal is the problem of the Towers of Hanoi.
This problem can be stated as follows (see Apostolos’s web page for more information)
The problem can be solved by a simple problem-reduction approach.
One way of reducing the original problem, that is, that of moving a tower of n disks from pole A to pole B by using pole C , to a set of of simpler problems involves the following chain of reasoning.
In this way we have reduced the problem of moving a tower to the problem of moving a tower with height one less and that of moving the largest disk.
This solution can be most effectively rendered as a recursive function.
Function hanoi implements the recursive solution suggested by the solution above:
An s-expression is a data structure which forms the basis of pure Lisp.
Nevertheless, the function that follows can be used to build an s-expression interactively:
Exercise 3.4 Write a function printSExp that will print its only argument fully parenthesized.
In the previous chapter, in general, and the previous section, in particular, we discussed the various forms of patterns, without giving the whole picture.
In this section, we are going to present systematically all types of patterns as well as sealed classes and optional values.
The simplest pattern is the wildcard pattern _, that is, a pattern that matches anything.
For example, here is a simple function that examines whether a binary tree is empty or not:
For example, if we want to print the information stored in the topmost or root node of a binary tree, we could use the following function:
The code will print “matches” since A is a list whose second element is the number two.
In conclusion, the pattern _* cannot be used with general patterns that involve the :: operator.
We can even use tuples as expressions to be matched by and tuples patterns to match expressions.
Tn], where Ti is the type of the ith element of the tuple.
Another interesting thing about this function is the use of pattern guards.
This is a feature of Scala that is activated if a pattern is matched.
In this case, some additional tests are performed and depending on the outcome of the test, the pattern matches or fails.
Thus, only if the value of the third element of the triple is greater than or equal to 1.65, does the pattern.
This is a type of pattern that can be used to match not only values but also types.
This is achieved by attaching a type to the pattern.
For example, the following function can be used to check whether its argument is a number or not:
Note that the argument of this function is of type Any, since any object is of this type.
The expression ifNum(M), where M is the triple from the previous example, evaluates to false, while isNum(4) evaluates to true.
Exercise 3.6 Write a function that returns the length of (a) strings, (b) hash tables, and (c) lists.
Hint: You do not need to care about the type of hash tables and lists.)
Let us now see whether we can write a function that tests whether its argument is a list of integers or something similar.
The reason is that Scala, following the lead of the Java programming language,“forgets” the type of elements that make up a structured type.
Thus, it is almost impossible to have some sort of type violation.
Therefore, function isIntListwill always return true whenever it is supplied with any list structure.
There are cases where one wants to be able to match a part of a constructor, but then needs to refer to this part as a single entity.
For instance, assume that we have a tree and we want to obtain its left subtree only if in the topmost node is stored a number less than zero.
Although the examples presented so far are simple and they do not involve many cases, still in most real-world applications a case-class will have many subclasses.
In situations like this, one needs to make sure that in a typical match expression all possible cases are covered.
For this reason, the designer of Scala introduced the notion of a sealed class.
In order to play with sealed classes all we have to do is to declare the top class as such.
The meaning of this annotation is that an exhaustive check of the patterns that follow is turned off.
In this case the result will be the word problems, while the expression.
Figure 3.3 Single inheritance makes it impossible to create a class that describes a locked and short door.
Figure 3.4 Mix-in composition allows the composition of classes and traits and so one can describe locked doors, short doors, and locked doors that are short too.
So far we have showed how to extend the behavior of a class, but nothing has been said or even implied about the ability to extend the behavior of objects (i.e., class instances)
Not so surprisingly, Scala makes it easy to extend the behavior of objects.
Of course one should not get too excited as the behavior of objects cannot change while they are in use.
To make things clear, let us give a simple example.
The last command will print the following on the computer screen:
In many cases when declaring a new class it is imperative to be able to compare instances of this particular class.
However, it is not at all obvious how one can implement a generic method by which object comparison can be a straightforward task.
Fortunately, one can use Scala’s trait mechanism to implement such a mechanism.
In fact, the standard Scala implementation provides a trait that provides the required functionality.
Every class becomes comparable when it mixes in with trait Ordered.
To understand how this trait achieves this remarkable functionality, it is necessary to study its source code:
Functions in Scala are modules that have a special apply method.
In addition, an application of a function is actually a method invocation.
Now, it is legitimate to use D in commands like the following one:
In general, an expression of the form S=>T denotes a function whose domain consists of all elements of type S and whose codomain consists of all elements of type T.
Thus, the type expression R=>S=>T, where R is yet another type, is the type of some higher-order function.
A function that takes two arguments is one that actually takes one argument which is a pair (i.e., a 2-tuple),
Parameter passing Arguments are passed to functions which use them to compute a number, a string, etc.
Although this is absolutely obvious, it is not obvious at all how these arguments are passed to functions.
There are several ways to pass arguments to a function, but we will discuss only those relevant to Scala.
Typically, when a variable is passed by-name, it can be both accessed and updated, nevertheless, Scala does not allow variables to be updated, thus avoiding side effects.
Functions as patterns In Section 3.2.1 we presented the various forms of patterns supported by Scala, but we did not say anything about functions.
Unfortunately, functions are not represented by case classes and this prohibits their use as patterns.
Here method unapply implicitly introduces case classes since Some and None are a case class and a case object, respectively.
The following code snippet shows how these two function-objects can be used:
When a programming language has functions, methods, structures, etc., that can have a unique type, they are called monomorphic.
On the other hand, if a programming language has functions, methods, procedures, etc., whose arguments can have more than one type not at the same time but at different moments, then they are called polymorphic.
Inclusion polymorphism was introduced tomodel subtypes and inheritance,which are necessary to deal with object orientation.
Parametric polymorphism achieves uniformity by using the idea of type parameters, nevertheless, this is not the only way to achieve uniformity and in this respect parametric polymorphism is a special case of universal polymorphism.
For example, inclusion polymorphism assumes that an object belongs to many different classes that may form a hierarchy of subclasses.
Note that functions, methods, procedures that exhibit parametric polymorphism are usually characterized as generic.
A typical example of a generic method is the length method that computes the length of any list structure.
Whenwe say that a function or an operator is overloaded, then we typicallymean that the same name or operator symbol is used to denote different functions and it depends on the context to say which particular function or operator is denoted.
A coercion is the operation of converting an argument or an operand to the type expected by a function or an operator, where otherwise a type error would have been detected.
To understand the difference between overloading and coercion, consider the following operations:
Subtyping is a form of inclusion polymorphism and, roughly, the idea that some type is a subtype of another type.
We have encountered this notion already when we talked about the type hierarchy of numerical types in Section 2.4
In addition, since any class is a type, a subclass of some class is a subtype of this type.
In certain programming languages the same constant value is shared by a number of different types.
This type of polymorphism, which is known as value sharing, is a special case of parametric polymorphism.
Thus, subtyping is an example of true polymorphism whereas parametric polymorphism is the purest form of polymorphism.
Since we have already presented a complete example of operator overloading, we will use this example todescribe the various aspects of operator overloading in Scala.
In general, a real number, and for that matter an integer number, is a complex number whose imaginary part is equal to zero.
Exercise 3.11 The output we get is not aesthetically correct.
The following two examples show how this can be done:
If we want to have more than one implicit parameter, then we have to declare them in a similar way and make sure they all have different type.
Otherwise, the language processor will complain about ambiguous implicit values.
Here is an example of a function with three implicit parameters:
If we leave the [Int] part out, the language processor will complain that a type mismatch occurred.
We can now use this function in the following way:
However, it is possible to omit the second argument of the function, since the language processor can automatically infer which object it has to use.
The reason is that the proper value is chosen from those available.
We treat the concept of monoid again in Section 8.10.2 when dealing with the path abstraction.
In general, relation <:, which is termed the conformance relation, must satisfy the following properties.
Butwhy is such the varianceof these classes?The reason is explainedby the following two short arguments.
Contravariance of functions Assume we have an object f of type Function1[A,B]
If B <: D, then, by subsumption, f produces also results of type D.
Exercise 3.16 Provide a simple argument for the invariance of mutable pairs.
In other words, it will not try to “expand” type names.
Here the wildcard type _ is a shorthand for the most simple existential type:
An even more interesting example is the following case class hierarchy that can be used to implement an algebraic type that can be either a generic value or a pair that consists of a function that can take any kind of argument and returns a value of some generic type and a value of this generic value:
The part of existential type that appears in curly brackets is called the binding clause.
The binding clause can contain more than one type declaration that must be separated by semicolons.
In addition, a binding clause may also contain value declarations.
The Singleton type is a type that has two values: null and the single value stored to a variable p.
Because of type erasure the implementors of Scala devised a mapping from generic types to nongeneric types in order to ensure the proper functionality of any.
In addition, one can use method erasure that returns an object that corresponds to the run time erasure of the Scala type represented by the manifest:
The idea behind hylomorphisms is to be able to express (functional) programs as instances of common patterns, rather than inventing the wheel every time we have to solve a particular problem.
Thus, one could say that hylomorphisms are a sort of design pattern for functional programming.
Since Scala is both an object-oriented and a functional programming language, both hylomorphisms and design patterns shouldmatter for the Scala programmer.
Gibbons prefers the term origami programming (from origami (from oru, folding, + kami, paper) the Japanese art of paper folding) over hylomorphism.
In the examples below we will use lists to show what hylomorphisms can achieve.
The function that follows is a typical example of a catamorphism:
Function bubble is the one that places an element in the proper position:
Function bsort can be used to sort a list using the bubble sort algorithm:
The following command creates a new list that contains the elements of list L sorted using bubble sort:
As noted above, if we compose the fold and the unfold functions, we get a hylomorphism.
A simple example of a hylomorphism is given by a function that computes.
The following function is the fold function for natural numbers:
The reader should be aware that since Scala does not support higher-ranked types, they have been encoded by wrapping methods in objects.
The following command shows how to write down lists using this new tool and how the function can be used:
The keyword lazy designates that the value assigned to the constant N should not be evaluated.
Streams have their own print method that outputs elements of this stream one by one and separated by commas.
If for some reason we need a different separator symbol, we can supply one as an argument of method print.
In addition,methods foldRight and foldLeft are the stream equivalents of /: and :/
Also, one can get a list from a stream using the force method.
Figure 3.11 A generic representation of a memo function of one argument.
Finally, class invariants describe what must be true about each instance of a class.
In Scala preconditions and postconditions can be asserted with the two forms of the assume method:
The following example shows how this method can be used:
The invariants can be better served with the two forms of method assert:
The following example shows how one could use method assert:
Finally, method exit should be used to stop program execution.
This is useful if there is no other way to stop program execution.
These two methods have nothing to do with assertions, but they are presented here for reasons of completeness.
By default assertions are on, that is, their conditions are examined and if they fail an exception is thrown.
Exercise 3.23 Make class pricemore useful by adding support formore currencies (Japanese yen, Canadian dollars, etc.)
A functor is away to go fromone category to another that preserves the categorical structure of its domain.
The next notion that we need to introduce is the natural transformation.
Assume thatA andB are two categories and thatBA is the collection of all functors from A andB.
Then if we form a category whose objects are the functors that belong toBA , the morphisms of this category are natural transformations.
Monads in Scala Method map (see Section 2.13) has some really interesting properties.
Before discussing these properties, it is better to review the following interaction with Scala’s interpreter:
Note that this equality cannot be expressed directly in Scala.
Another function that has a similar property is function unit that takes an object and returns a singleton list with this object as its only element.
The following shows the essence of this property of unit:
Examples of monads List comprehensions, that is,for comprehensions that create lists, can be expressed in terms of the monad presented above:
Note that here s(A,B) = (tail(A),B) and by applying the technique just described we create a tail recursive version of this function:
Figure 3.12 An implementation of the continuation monad in Scala.
In simple cases, it is possible either to enumerate the strings that belong to a language or to write down a set-comprehension that describes the elements of a language.
For example, the following set includes all the sequences of zeros followed by ones:
In other words, a B is a sequence of binary digits.
A major problem of rules like the second one is that they cannot be used for the construction of a parser.
Thus, we need a way to eliminate left recursion from production rules.
An easy way to eliminate left recursion is to replace it with right recursion and by introducing a rule that expands to nothing:
These symbols enclose terminal or nonterminal symbols that can be repeated zero or more times.
Thus, a far more readable way to specify the above production is the following formula:
This metanotation can be used to describe the grammar of any programming language.
There are several conventional techniques that can be used to construct a parser.
For example, the readermay consult [78] for a lucid account of parser construction.
We can construct a parser,which can recognize assignment commands, using parser builders as follows:
If you have guessed that regular expressions are a kind of parser builder, then you have guessed correctly.
In fact, all regular expressions can be described with EBNF.
Moreover, it returns f applied to the result of p.
If f is not applicable, error (the result of p) should explain why.
The obvious way to write a parser for this production follows.
A better way to achieve the same functionality without the drawback just mentioned is:
If we want to specify repetition, we need to use the rep parser combinator.
The following RAM++ program reads two numbers and computes their sum:
Another interesting thing about the RAM++ parser is that it shows how one can handle optional syntactic constructs.
By inspecting the parser’s code, the reader may notice that the optElse parser returns either a None value or a Some(m)
A None value indicates that an optional construct was not there and, obviously, a Some value indicates that the parser has found the optional syntactic structure.
Obviously, the error message must be informative and explain why the parser has failed.
As shown below, the code for the ouput command is more complicated:
As in the case of the output command, it is necessary to ensure that the variable used is in the symbol table.
Next, we use a standard Scala method to input the value of the variable which must be an integer greater than or equal to zero.
Exercise 4.5 Instead of relying on readInt’s way to deal with erroneous input, use method readLine and a regular expression to verify that the user enters only valid input.
There is nothing special about the “assignment” command except that when a variable is equal to zero, its value cannot be decreased further:
The if-command together with the while-command are the only choice and repetition constructs available in RAM++
Their meaning is standard and so their implementation is almost straightforward.
The code does the usual check and then checks whether the variable is equal to zero.
If it is, the then-part of the command is executed.
Exercise 4.6 If the elsePart.cmds is an empty list, then eval is invoked with an empty list and so it does nothing.
The implementation of the while-command is very simple – it is implemented by a while loop as shown below:
SQL, the structured query language, is considered by many a DSL.
A DSL can be easily implemented using Scala’s parser builders.
To make the general idea clear, assume that we have created a program that allows users to load images.
Users can instruct the program to generate a web page which will show the image as if there is a camera that maneuvers above it (this camera is usually called a viewport and this is basically something like the virtual camera system of many video games)
Now, a user can specify the viewport size, the initial camera position as well subsequent moves with commands like the following set of commands:
In general, white space is ignored but here it cannot be ignored so we explicitly specify that it should be preserved.
Most, if not all,XML applications assume that data are organized in a hierarchical datamodel, that is, data are organized in a tree-like structure.
For example, consider a set of tags designed to describe people.
The description of any person will form a structure of XML tags that will form a hierarchy, which is just a general tree structure.
An attribute is a piece of information expressed as a name-value pair attached to the start-tag of an element.
Also, when writing songs, that is, poems of a special kind, there are usually refrain verses and/or stanzas.
Unicode is the default character set of XML.Almost every legalUnicode character may appear in an XML document.
However, not all characters can be used in all different cases.
An element name as well as any other XML name may contain any alphanumeric character.
There are a few characters whose use is reserved and, therefore, they cannot be used for any other purpose.
If it is absolutely necessary to use these characters, then one should use an entity reference.
In case it is absolutely necessary to include some XML markup verbatim in another XML document, then one can use a CDATA section.
Usually an XML document starts with a line that has either the form.
The easiest way to have XML content in a Scala program is to assign some XML content directly to a variable.
The following piece of code shows how this can be done:
However, in the second case the output will look quite different:
In other words, white space before and after element content has been removed and the whole content is printed on one line.
Although this is not human readable, one should bear in mind that XML has been designed to be processed by machines not humans.
Obviously, this example is not very dynamic, but the following code snippet is more dynamic (can you guess what will be the result in either case?):
If n is greater than 9, then the second line of the result will be transformed to.
On the other hand, if n is less than or equal to 9, then the same line will look as follows:
As is obvious, if z evaluates to None, then the attribute is not included since it makes no sense to have an attribute with no value.
In the second case the attribute is included since it takes a valid value.
If for some reason we need to have curly brackets in a tag or attribute, then we have to write the curly brackets twice, as, for example, is shown below:
There are a few other classes that can be proved useful in certain cases.
Class Atom should be used when raw text that contains no tags and no children elements has to be used somewhere.
Class Comment can be used to embed comments in XML content.
Similarly, one can use class EntityRef to specify entity references.
If we use the following code snippet in our code.
The class Unparsed should be used when it is absolutely necessary to leave as is some entity.
Finally, class Group should be used to make a list of elements.
The next thing to do is to store the body of the XHTML source to a variable:
In addition, if some string contains XML content, then one can use method loadString to create an Elem object from it.
Obviously, these commands solve the problemof extracting information fromXML content.
If one wants to print subelements of a particular element, one can use the following idiom:
Exercise 5.3 Examine the output produced by the following command.
Readers familiar with XQuery may see some resemblance between XQuery queries and this code.
In other words, when dealing with real XML content, curly brackets are used to interpolate Scala code in it, while in an XML pattern, the curly brackets can be used to interpolate Scala patterns in the XML content.
Let us begin our discussion with a rather complex example that shows how to match an attribute:
The code snippet that follows shows how to store all these strings in an array of strings:
Here is an explanation of what the long expression does: the pretty printer object yields a string from a Node.
This string is split into words, that is, substrings that are surrounded by spaces.
If m was a sequence of Nodes, then we would have to use method formatNodes.
Let us examine a similar problem to the one just described.
Assume that there is a tag that surrounds a sequence of other tags, that is, one has to handle XML content that looks like the content that is assigned to the following variable:
Most “real” programs have a graphical user interface (GUI for short)
Therefore, any serious modern programming language should provide tools for GUI programming.
Scala provides such tools through the scala.swing package, which is an interface to Java’s JFC/Swing packages.
The ambitious goal of this chapter is to teach you how to build GUI applications in Scala.
The ouput produced by this program is shown in Figure 6.2
Let us now turn our attention to the description of the code in Figure 6.1
So, you can safely assume that it is always null.
If we comment out the following line from the code in Figure 6.3
The four arguments specify the inset from the bottom, the left, the right, and the top.
If you have tried the previous exercise, you may have noticed that the button goes exactly under the label, while in the screenshot shown in Figure 6.5 there is clearly some white space between the two components.
This additional space can be inserted by adding an invisible component.
There are two kinds of invisible components: glues and struts.
A glue is a component which can be stretched either horizontally or vertically and is useful in cases where components have a maximum width or height, respectively.
Methods Swing.HGlue and Swing.VGlue yield a horizontal and a vertical glue, respectively.
On the other hand, a strut should be used to adjust the space between components.
A strut takes an argument that forces the layout manager to leave a certain amount of space between two components.
Methods Swing.HStrut and Swing.VStrut yield a horizontal and a vertical strut, respectively.
Note that a horizontal strut has no height and no depth,while a vertical strut has no width.
Figure 6.6 A window with a label and two buttons.
In this section we will describe how to build a rudimentary desktop calculator, that is, we are going to describe how to build an application that will look like the one shown in Figure 6.8
The declaration of each button looks like the following declaration:
Once all buttons are declared, they must be packed into a grid container.
The code that follows shows how this can be done:
First of all note how we add components to this container: we just “increase” the value of contents.
Since components are placed on a grid and all componets occupy the same space, it makes no sense to specify constraints on the placement of components.
The numbers in parentheses after GridPanel specify the number of rows and columns of the grid.
If either number is equal to zero, then the system calculates the optimal number of rows or columns, respectively.
Fields” hGap and vGap are used to specify the horizontal and vertical space between the columns and the rows of the grid, respectively.
Field isDecimal is used to handle the button with the period:
Field leftOperand is used to store the left operand of an operation.
The following code shows what should be done when the plus button is pressed:
The following code shows what should be done when the square root button is pressed:
Programming project 6.1 Using the description of this section build your own calculator.
Add more buttons that compute the trigonometric functions, logarithms, etc.
In addition, add a button that can be used to close the calculator.
For most applications an instance of Graphics can be used to solve most problems.
However, there are cases that can be dealt with better using Graphics2D.
This class, which is a subclass of Graphics, provides more sophisticated control over geometry, coordinate transformations, color management, and text layout.
Although, we do not need these additional features for this particular example, still we show how it is possible to use it.
Figure 6.9 A simple graphics example in which the user presses the mouse button and in response it draws a little circle.
Figure 6.10 The standard coordinate system used in Scala/Java graphics.
The x coordinate increases to the right, and the y coordinate increases downward, as shown in Figure 6.10
First of all, note that we specify that the system should listen to a particular event category (for example, Mouse.clicks) and not to any event that may happen on a component.
This event category should be used when the mouse is clicked, pressed, or released.
In addition, the event categories Mouse.moves and Mouse.wheel should be used when the mouse enters, exits, moves, and drags, or when the mouse wheel moves, respectively.
Each event can be handled one by of the following event handlers:
When the user clicks the mouse, then the current mouse position is grabbed and the coordinates are stored in two variables, variable mouseclicked becomes true, and method repaint is invoked, The result of the invocation is to reexecute method paintComponent.
Use the following method to print the coordinates on the canvas:
Although this example is quite instructive, still it does not show all the things one can do.
The next example will reveal some other capabilities and it will show how one can solve problems in unexpected ways.
A simple paint-like application Let us now construct a simple paint-like application (i.e., an application that allows users to sketch simple curves, see Figure 6.11)
Change the drawing color after user has // clicked the mouse on the color palette.
Called when mouse is pressed and user clicks //on the drawing area.
Method drawRect draws a rectangle (i.e., four perpendicular lines in a particular color)
However, in order to make the button more realistic, we leave some space outside the “button” that is painted black.
The last thing we have to do is to put the label on the “button”;
The last thing that needs to be done is to draw a border around the color “button” that is currently active:
By invoking method dispose we free the corresponding graphics context and, consequently, release any system resources that it is using.
It just sets up the graphics context in the current color:
Now let us see what should happen when the user clicks on the white drawing area.
In order to draw a curve, the application needs to “remember” the previous coordinates of the mouse:
The last thing we need to handle is the motion of the mouse while a mouse button is held down.
If the user is drawing, the program should draw a line segment from the previous mouse location to the current mouse location:
Method drawLine draws a line in the current color from one point to another.
Programming project 6.2 Create a pen palette from which the user can choose pens with different strokes.
The code that follows creates the image shown in Figure 6.13
Method getBytes encodesthis string into a sequenceof bytes using theplatform’s default character set.
In addition, each of the tree output commands inside the repetition construct must be replaced with a command like the following one:
Graphics context no longer needed so dispose it G.dispose return bufferedImage.
As an exercise, we will show how to draw the Mandelbrot set with Scala.
We use the distance estimator method [62] to draw the Mandelbrot set.
Figure 6.17 Function MSetDist which is used in function drawMandelbrot.
Figure 6.18 The Mandelbrot set as drawn with the distance estimator method.
Figure 6.22 A dialog window with an alternative decoration icon.
Figure 6.23 A dialog window with a customized button text.
In many cases it is necessary to be able to customize what appears on the buttons.
For example, when constructing a GUI application for Greek users, the buttons should look like the those of the dialog window shown in Figure 6.23
Method showOptions can be used to create such customized buttons:
Method showMessage should be used when we want just to display a message.
If we replace the code above in the GUI application with the code that follows.
In certain cases it is useful to be able to get input from the user.
For example, if one programs a network diagnostic tool, which needs to ask users to enter their network connection, then method showInput can be used to get input from the user.
The code that follows can be used to create the dialog window shown in Figure 6.25:
Method showInput returns a Some(v) value, if a value is selected or None if Cancel is pressed.
The entries appear as a pull-down menu from which the user can choose a value.
The last argument of the method is the default value.
In rare cases, one may need to let the user type a response instead of choosing one from a set of possible answers.
In this case, one can simply replace the sixth argument with Nil and so when the dialog window pops up, the user can enter the preferred value.
Typically, a menu is a list of options displayed on a window (for example, as a pull-down window) and from which the user may make a choice.
There are several forms of menus and in this section we will present all the different forms of menus.
Here BoxPanel is a panel that lays out its contents one after the other, either horizontally or vertically.
The next thing we need to know is how to respond to a user selection in a radio button group.
Figure 6.26 A simple GUI application with a radio buttons group.
Assume that a user has to press an ordinary button after selecting a radio button.
Then the following code shows exactly how to program a response to a user selection:
And the code that follows shows what should be done in order to place the button in the panel and how to program the behavior of the application:
Exercise 6.9 Complete the code above and verify that it works in the expected way.
These are GUI components that allow users to make multiple selections from a number of options.
For example, a restaurant menu can be easily described with check boxes.
First of all we need to create an instance of class CheckBox for each check box:
The check boxes will be enclosed in a compound border (i.e., a border that allows multiple border objects) with a title drawn in etched border style.
In addition,we set the color of the background of each check box as well as the color of the background of the panel.
Observe how we add all the components in the panel and compare it with the way we added the button group in the same panel:
After arranging the buttons, we need to see how to handle the events that occur on these buttons:
The two ordinary buttons that are shown in Figure 6.27 become part of a box panel:
Although putting all the components together is easy and the reader should be able to write the corresponding code, we still believe it makes sense to show one more time how things should be done.
The code snippet that follows shows how to put all the components together:
Now let us see what should happen when each of the ordinary buttons is pressed.
In the case of the leftmost button, all we need to do is to display the total calories in the specially designated label:
Also, the code shows how to make the action listener listen to the events that occur on a combo box and how to handle these events:
Figure 6.28 A simple GUI application that uses combo boxes.
Exercise 6.10 Enclose the combo boxes in a border, like the one in the previous example.
Once the combo boxes have been arranged, we need to specify how to handle the events that occur on them:
As is evident, we simply assign to the auxiliary members, the values selected by the user.
The two buttons in the lower part of the application can be programmed easily:
Exercise 6.11 All componenents and subpanels are arranged in a GridBagPanel.
Write the code that arranges all these components in the panel.
The last thing we need to take care of is what should happen when the user presses either button.
In the code that follows we have used a different coding technique to show that one should experiment and not learn by heart all the programming idioms presented in this chapter, unless, of course, it is absolutely necesary:
Exercise 6.12 Add a label that will display how many correct and how many wrong answers the player has given.
Especially for combo boxes it is possible to have images instead of strings.
The simple GUI application shown in Figure 6.29 demonstrates the use of images in a combo box.
Since creating such a combo box is not straightforward, we will explain in detail what should be done in order to create similar combo boxes.
Figure 6.29 A simple GUI application that uses combo boxes with images.
And this exactly is the reason why the formation of the combo box is part of a try expression:
Remember that all GUI related classes are actually wrappers around Java’s JFC/Swing classes, thus, trait SuperMixin is used to redirect certain calls from the peer to the wrapper and back.
If we replace the code that creates the button shown in Figure 6.1 with the following code.
Figure 6.30 A simple GUI application with a button that bears an image instead of some text.
As expected, the string argument is the corresponding title of each menu and menu item.
Class Separator creates a horizontal line that separates menu items.
If currentFile is not null, then the program will save the data to the file stored to this member:
When the user chooses New, the program must take care of the current contents (if any) of the text area:
Now we can easily implement the menu item for Exit:
Exercise 6.15 Implement the functionality of the Close menu item.
Printing the contents of the text area is very simple:
The easiest way to allow the user to enter the word (pattern) to be searched is by using an showInput dialog with an empty list of entries and no initial choice:
Search text for:", "Search text for a word", Message.Plain, Swing.EmptyIcon, Nil, "")
Once the user has closed the dialog window, we need to check whether some input has been provided:
Method isDefined returns true if s is not equal to None.
In the case when we want to check whether an option value is None, we should use isEmpty.
Since we are sure that s is not None, there is no reason to use pattern matching to obtain its value.
However, if we are not sure whether an option value is None, it is better to use getOrElse, if we insist on not using pattern matching.
This method returns the value if the option value is nonempty, otherwise it returns its argument evaluated.
Now that we are sure that the user has entered a “word,”we prepare the pattern matcher to start searching the text stored in the text area:
Object caret is a wrapper around a Java class that implements the idea of a place within a document view (roughly, the part of a document that is visible to a user) where things can be inserted.
Generally,we can say that a caret is the cursor and its.
If the user chooses thismenu itemwhile the patternmatcher has not been initialized, then we must ensure that our program will not crash.
This is exactly the reason why we need to make sure that m is not equal to null.
In addition, we could use highlighting, but this requires extensive Java programming, so we skip it.
Exercise 6.16 Assume that the user will enter simple words not regular expressions.
Implement the searching mechanism using method indexOf (see Section 2.14)
Aswas explained above, there is provision for changing a tab panel (i.e., by removing a tab)
However, what is missing are GUI components for the removal and/or insertion of tabs.
Typically, applications that provide this functionality include a menu item for the insertion of tabs and a button on the tab title for removing the tab.
In order to have this button, we need to redesign a new component to replace.
The following commands are executed every-time a new instance of this class is created:
In this case we create a simple stroke whose width is 2 units.
This code snippet changes the color of the “X” mark when the mouse is over it.
In particular, method isRollover returns true when the mouse is over the button.
These commands draw the two lines that make up the “X”mark.
When the mouse is on the tip of a tab and is pressed, it should remove the tab.
When the mouse is not over the button, then the border of the button will lose its painting:
The following code implements something that is obvious for a user but not always for a programmer – when the user clicks on the label, the program should make this tab the one in the foreground.
This is something that is handled automatically (try the previous example and you will see what we mean), but from the moment we placed a label over it, things are not the same:
Figure 6.35 An application with tabs, sliders, and GUI lists.
Figure 6.37 A application with a slider that has ticks and labels.
There are three different kinds of events that may happen in our application: the user may slide the knob of the slider component, or the user may select a tab, or choose an element from the GUI list.
Therefore, the application must listen to all these events and adjust itself accordingly.
Note that member adjusting is set to true when the knob moves and this is why we check whether it is false.
In the end, the value of the slider, which is stored in member value, is used to set the current tab.
In Section 6.7.4 we used a TextArea component to build a rudimentary text editor.
However, this is not the only text-based component – Scala supports simple text.
Our code is very simple since we assume that there is only one user and, naturally, only one password.
In addition, the password is stored unencrypted in a simple member something that is not safe at all (for more information about data.
Indeed, it lacks some features that will make it more realistic.
First of all, our application prints an error message when the user fails to enter the correct combination of user name and password, but it does not print a message inviting the user to retry.
Before presenting the other problem, let us see how we can solve this problem.
In order to print the error message and then prompt the user to retry, we need to insert some code that will delay the appearance of the second message, or else only the second will appear.
Obviously, method requestFocus moves the focus to the component it is called from.
Table 6.1 Special characters that may appear in a MaskFormatter mask.
Any valid decimal digit (i.e., c.isDigit, where c is a Char and method isDigit returns true if c is a decimal digit,will return true)
Escape character, used to escape any of the special formatting characters.
A Any letter or digit character ? Any letter character.
A table is a GUI component that can be used to display data in a tabular form (for example, think of a spreadsheet, which is the archetypal application that displays data in a tabular form)
Usually, one cannot modify the contents of any cell, but, optionally, program designers may allow users to edit the data.
Obviously, the data displayed by a table are not part of the table as, for example, one can use the same table to display different sets of data.
By design there can be at most three <author> elements.
The XML content will be loaded with the following command.
An applet is a program written in any language that runs atop the JVM and which can be included in anHTML page, just like an image can be included in such a page.
In order to include an applet in an HTML page, one needs to know the basics of the HTML <APPLET> tag.
However, for our needs the following general form of the tag is enough:
Building applets is similar to the construction of ordinary GUI applications.
The skeleton code that follows shows the general structure of an applet:
However, there are cases where the two methods have different roles to play (for example, see Section 7.2)
This way, readers with some experience in Java programming will be able to translate their applets easily in Scala, while readers with no familiarity with Java will see how to construct real applets.
Figure 6.40 is a screenshot that shows this applet in action.
Here ComponentResized is cached when the applet or, more generally, a component is resized.
Other such events are described by the classes ComponentHidden, ComponentMoved , and ComponentRemoved.
The code that follows is the body of method paintComponent:
The code above erases the old square and redraws a new one in a new random position.
The code that follows is executed every time the mouse button is pressed:
Finally, method showStatus takes a string as argument and “forces” the browser to show its argument in the statusbar.
Today’s computers have multi-core processors (i.e., integrated circuits to which two or more processors have been attached), which, in principle, allow the concurrent execution of computer instructions.
In other words, today’s computers are able to perform two or more tasks at the same time.
Concurrent programming refers to the design and implementation of programs that consist of interacting computational processes that should be executed in parallel.
In addition, concurrent programming is not only the next logical step in software development, but the next necessary step.
Thus, all modern programming languages must provide constructs and libraries that will ease the construction of concurrent programs.
Scala allows users to design and implement concurrent programs using either threads, or mailboxes or actors.
Unfortunately, programming with threads is a cumbersome task, thus, concurrent applications in Scala are usually implemented using the actor model of programming.
Figure 7.1 Creating a threaded application by extending class Thread.
Figure 7.1 shows how one can construct a threaded class by extending class Thread.
Figure 7.2 Creating a threaded application by using trait Runnable.
Also, it is possible to name a thread by supplying a string variable as the second argument of this class constructor.
In both examples presented so far the two threads do not interact.
In fact, even if we add one or two or even more threads, nothing will change the essence of our application.
However, things will get really interesting if two or more threads have.
These articles are included in the technical library section of Java technology’s part of IBM’s developerWorks web pages.
When a lock is acquired on an object, this has to be temporary in order to allow other threads to acquire a lock.
In other words, the execution of two synchronized threads must be mutually exclusive.
Each thread owns its own locks and so it is not possible to have nested locks, that is, a synchronized method that is called from another synchronized method cannot block execution.
A thread that is waiting should always execute a method that has to look like the following one:
By uncommenting the commented commands, the user can see the values received and dispatched by a thread that runs an instance of this class.
The code that doubles the number stored in the cell follows:
This is necessary in order to avoid a situation that is known as a deadlock.
In simple terms, a deadlock is a situation where there are two threads and each one waits for the other to complete in order to get a lock.
Since neither thread can get a lock, neither one will be able to run.
The following code completes our example and shows how the classes just presented can be used:
Exercise 7.2 Verify that by changing the body of method run of class halveCell as follows.
Threads have been used extensively in applets that draw images or include animations.
So the next step is to present such a usage example.
Animation in Scala should always occur in a separate thread of execution.
This way, users can interact with the animation program without perceptibly degrading performance.
In practice, all we have to do is to mix in a module that extends.
There is also a variable that holds the current x-coordinate of the yellow bullet.
The code that follows is the body of method paintComponent:
Method run checks whether the thread is alive and if it is, it paints the bullet and then computes the next position of the bullet.
By increasing or decreasing the time the thread sleeps, the animation becomes slower or faster, respectively.
To create an off-screen image one needs to invoke the drawing component’s createImage method.
These numbers correspond to the width and the height of the drawing area.
One can invoke this object’s getGraphicsmethod to get the image’s graphics context.
The last difference between the code of this applet and that of the old one is in method run:
As is evident, the only difference is that the method waits until the off-screen drawing is ready.
Package scala.concurrent provides an abstraction layer over the “traditional” concurrency constructs that have been described so far.
Roughly, method send places the message to be sent in a mailqueue if the receiver is not available; otherwise, the message is delivered to a mailbox.
Figure 7.7 shows how one could rewrite class cell using mailboxes.
Initially, we need to drop to the mailbox the value by which the class will be instantiated.
When method get receives a Nonemptymessage, then it replaces the message with an Empty message and returns the value received.
This means that there are two kinds of messages that correspond to the states of a mailbox (i.e., being empty or nonempty)
Similarly, when the mailbox receives the empty message (i.e., when it is empty), a full message should be dropped to the mailbox.
This is exactly what method set describes and the content of the message is the only argument of the method.
If we replace class cell of Section 7.1 with the one presented here, then.
Figure 7.7 Class cell rewritten in a message passing style.
Programming project 7.1 Try to reimplement spawn using the Executor trait.
The actor model of concurrent computation has its roots in ideas that have been put forth by Carl Hewitt, Peter Bishop, and Richard Steiger [33]
Important milestones in the development of the theory include the work done byWilliam Douglas.
Thus, the inclusion of actors into the Scala programming language was a wise decision.
In other words, the code of method run becomes the argument of method Actor.actor.
The simple examples shown so far did not demonstrate the real capabilities of actors.
Nevertheless, we have included them to show how one can construct and start actors.
In the rest of this chapter we are going to discuss the real capabilities of actors.
Method receive, which is the most typical message handler, takes as argument a partial function.
Method ! sends asynchronously a message to the calling actor.
Assume that we want to create another actor that can handle many and different types of objects.
For example, function isNum (see page 106) could be used as a basis for the construction of such an actor.
The following code shows how we should rewrite the actor in order to be able to handle these new kinds of messages:
When this program is executed it will handle all cases and only then will it stop.
Method ! is not the only one that can be used to send messages.
Of course our example is totally useless, but it shows what is involved.
Method reply is used to send back a message from an actor to its sender.
If everything an actor is doing is included in the body of the message handler, it is better to use react instead of receive since the former consumes far less resources.
The real use of futures is in what is called fork/join parallelism.
The most typical application of fork/join parallelism is a parallel version of the merge sort algorithm.
However, in order to keep things simple we will describe a simpler example.
In order to compute the hundredth power of an integer we will use the following (simple) function:
One may wonder what is the speed that is gained by this technique.
We have “benchmarked” our program by modifying the code snippet presented above as follows:
In other words, the parallel version is 2.33 times faster.
Method nanoTime measures time elapsed since the program has started.
Now we can use this actor to compute the factorial of some number:
Figure 7.10 A purely iterative actor that computes the factorial of some number.
The following actor is something like a front-end to the actor shown in Figure 7.10:
Again actor factorial can be used as in the previous example.
Exercise 7.7 Modify the actors presented to compute the Fibonacci numbers.
It is quite probable that most of us are not consciously aware of an ever-appearing design pattern, which goes far beyond the design patterns in the normal sense of [24]
This pattern has to do with how we organize our data and, sometimes as a consequence, how we access these data.
What we are talking about is the hierarchical data organization pattern that we can abbreviate in short as:Hierarchies are everywhere!
Strangely enough, hierarchical databases have not survived, but probably XML strikes back on their behalf.
Also, another striking difference is the separation of a child-path from its parent.
It is common knowledge and already evident from the above that / applies to Unix and \ applies to Windows.
Apart from Windows, the Samba software stack also uses it to represent network resource names.
There must already be a lot of source code lines that just concatenate strings to create relative paths:
The example above demonstrates some string concatenation to obtain the directory where the local copy of a maven-managed library resides (Apache Maven is a software project management and comprehension tool)
By typefull, we mean that it is best to avoid using plain strings.
Even if the lowlevel representation that either makes more sense or seems more obvious than the others is the String, do not expose strings at the user level directly.
Clearly, our codemust be behaviorally equivalent, nomatter what the underlying running environment is.
Although running under the JVM certainly gives a sense of uniformity, the JVM itself has to communicate with the operating system at some point.
There is the “opportunity” for an API to break and we actually need our path API to be platform independent.
In an epoch where the need for and fuss about concurrency constantly increases, designing with immutability in mind can be an asset for a software engineer.
If your object has no complex business logic and simple state, consider adopting an immutable implementation.
Also, in addition to the above, we would like the String representation of the paths to be normalized, especially when it comes to the appearance of (back)slashes.
Only the / character will be the separator of path elements.
More than one consecutive occurrence of / will be collapsed to just one /
The second requirement will be relaxed for the beginning of UNC paths and our convention is that in their normalized form they start with two slashes.
We just follow here the convention of the java.io.File API where the related method, following the JavaBeans convention, is getName.
Figure 8.1 A path API given as a trait with partial implementation.
The two methods with this name are the means to compose paths.
The Path(_) factory call is made on the companion object, which we will start implementing shortly.
Notice also howwe have implemented isRelative and isAbsolute bymutual recursion.
A subclass of Path is expected to provide an alternative implementation for one of them, whichever is more suitable for the particular case.
Empty paths play a special role and are represented by EmptyPath in Figure 8.2
They arise when, for example, we ask for the parent of a root path.
One could say that they adhere to the canonical design.
There is only one root and one type of absolute path, so the implementation is rather straightforward and is shown in Figure 8.3
We are somewhat careful with the implementation of methods parent and paths.
Regarding parent, when the path is the root (/) then, as discussed previously, we get the EmptyPath.
For all other cases, we must check where the last / resides.
This is clearly the case, since if / is at zero index, then the path is in the form /somePath.
First, we split the full name into parts, using / as the separator.
We must keep in mind that split returns an array, so the transformation to a list is necessary.
Then, we need to take care of the special nature of /
If we split the string "/usr/bin" according to the same rule, then the result will contain an empty string at the beginning of the generated array:
Unfortunately, the three string parts in the generated array, do not correctly represent paths.
Just to remedy the situation, we resort to a simple transformation, the one shown above, via the higher-order function map.
Windows paths are a bit more complicated because of their variety.
Exercise 8.1 Under Windows and to the best of our knowledge, there are two more cases one has to consider.
In particular, there are directory relative paths, which are in the form \somePath and drive relative paths that look like C:somePath.
Notice the missing drive letter in the former case and the missing backslash in the latter case.
After studying the implementations we give for the path types mentioned above, implement these two missing path types.
If we would like to reuse the implementation of UnixPaths for simple (relative) Windows paths, of course we need to take care of the slash-backslash difference.
For that reason, we will for now assume and later show how to implement our paths in some normalized form, where only forward slashes appear.
There is actually no pragmatic problem with this approach, since we can easily verify that java.io.File under Windows, when given a path with forward slashes, will properly handle it as if they were backslashes:
Notice the automatic transformation of / to \ in the above interactive session, performed on a Windows machine.
As in UnixPath, the most interesting methods are parent and parts.
For example, parent has to see where exactly the last / resides and break the path string representation accordingly.
Also, parts checks whether the UNCPath just represents "//", in which case it is just a root.
We consider an UNCPath to be a root path if and only if the length of its string representation equals two.
Notice howwe follow the general rule of normalized paths, according to which slashes are the sole path separators, regardless of the underlying platform.
Drive absolute paths are implemented using DriveAbsPath in Figure 8.5
If it is exactly three characters long, then it is a root path:
It is time to work out the implementation of the Path companion object.
The other methods are checks that decide whether a character is a slash or backslash.
The last one, getSlashF is actually a method that returns a function.
We can discover the exact type by using the interpreter:
Question 8.1 If, in the above interpreter session, we issue the command:
But what is the purpose of getSlashF? The implementation clearly shows that it selects the proper check for a forward slash or backslash character.
In the second case, isSlash is selected as the slash check.
As we will see shortly, under Windows any slash, either a forward one or a backslash, counts as a path separator.
Under Unix, the (forward) slash character is the only separator.
The / part has been “created” by the F switch in ls -alF.
Since our path string representation is going to be normalized, we will need two more utility methods:
What we do here is to track the place where we see a slash, remember consecutive slash positions and collapse consecutive slashes to one /
The heart of the Path object is its apply method:
It simply consults the value of isWindows, in order to call the appropriate algorithm that will build a normalized path out of a string value.
Of the two algorithms, parseUnixPath is, as expected, the most straightforward one:
For the life of a call to parseWinPath, we always use true as the value to anySlash, since under Windows we assume that both / and \ are separators for.
The initial decision-making procedure is around the length of the input string.
If the length is just one, then we delegate to parseSimplePath.
Otherwise, meaning that the string is at least two characters long, we must see the exact character value at the initial positions.
Otherwise, if the length is at least three characters, such that the initial three characters form an absolute drive designator in the form #:\, then an AbsDrivePath is parsed.
The interpreter session demonstrates that the path of a URI may start with a /
Let us assume that some client code manipulates the path part of a URI, translating it to an absolute path using a simple string concatenation.
But now remember thatwe are underWindows,our library has created an UNCPath, since uri.getPath already starts with a /
The above example is simple but the same simple, or rather innocent, thinking can lead to bugs.
And if it can, then according toMurphy’s Law it most certainlywill.
We always have to think of the path semantics we need when transforming strings to paths.
The introduction of the UnixPath factory gives us one more alternative to take into account.
The truth is that there is a particular piece of code that has been repeated in a few places without any attempt on our part to factor it out in some trait.
We can even go a bit further and save one keystroke per path part:
Another characteristic of the composition is that just as with high-school algebra.
This very property of associativity alone is a rather important one and deserves special credit.
Informally, a semigroup is a collection of objects and an associative binary operation that we use to combine these objects.
A binary operation takes two objects of the same kind and produces a third object of the same kind.
Then an object of type A belonging to a semigroup can mix in IamInASemigroup[A] and the composition is achieved by providing an extra parameter, the actual semigroup.
The careful reader might already be thinking that only relative paths guarantee that their combination will not fail.
Returning to our paths, the relevant semigroup can be coded as.
The word structure here means the way our objects are organized and how their organization is revealed by the permitted operations.
The structure of a semigroup, as expressed by the needed associative operation, is a minimal one.
Several other, more complicated “things” can be built on it or independent of it, if we wish to be precise about the meaning of our words.
In our implementation of paths, there is one particular path that stands out.
Let us again take a look at Figure 8.2 and consider the role of EmptyPath:
We say the identity and not just an identity, because it can be proved that there is only one object with this particular property.
Now we are ready for the introduction of another algebraic structure.
For example, the integers with addition as the binary operation form a monoid and the identity is the number zero.
For integers with multiplication, the identity is the number one.
Paths form a monoid with EmptyPath as the identity path.
Interestingly, the VFS notion and accompanying terminology is nowadays ubiquitous in operating systems.
But the truth is that although we clearly expect a VFS to play a fundamental role in the implementation, the most important user-viewable entity is that of a VFile.
So, we express a VFS in terms of what it provides:
Notice the declared type, in the spirit of our previous discussion:
This may sound unnecessary in that we could always directly call the path constructor Path(_), thus letting our path library handle the different underlying operating system (OS) semantics.
But we aremissing one point here: Path(_) can surely handle the OS semantics, although now we are one design layer above that.
Our interest, having resolved the path issues, has shifted to some other functionality on top of the provided one.
For this particular reason, it is wise to anticipate new semantics for the extra design layer.
The underscore in VFile[_]means that we do not actually care about the exact type.
At any particular moment, where we use it, it is some type and in Scala it is called an existential type.
Just because we do not name this type, we cannot explicitly reuse it.
The conceptually derived method isContained is implemented using container by checking the returned Option value.
This way we would lose the opportunity to let the VFS construct the path, using mkpath, which is exactly what the implementation of newFile with a String parameter does:
Let us now turn our attention to the VFile API, shown in Figure 9.2
Implementations are free to compute the names either using children directly.
This returns a newVFile whose path is the path of this VFile composed with the given argument.
Of course, for folders, the return value is expected to be None.
Note also that the equalitymethod is crafted so that onlyVFiles of exactly the same class and with the same paths are considered equal.
Under these two assumptions, it could have been written as.
Representing it as a singleton seems a reasonable choice, although there are other use-cases where a singleton-based design might not be the most appropriate.
So, we map a possible null value to Scala’s Array(), which is the empty array constructor.
Of course, all the needed types, for example the type for the Array() constructor, are inferred by the scala compiler.
There is an extra method in NativeFile that does not exist in VFile: nativeJavaFile.
It returns the underlying java.io.File as a convenience to client code that might need it.
Programming project 9.1 Try to make the API more complete, exposing as much functionality as possible from the Java APIs.
The ultimate goal is not to have to expose Java APIs anymore, as we did with the nativeJavaFile method.
It is not mandatory that each Java method should be translated to an exact method in the new API.
After all, the java.io.File API leaves a lot to be desired from a design perspective.
Just to get an idea of how poor it is, the delete method mentioned above returns just a Boolean to indicate success or failure.
It would be better for the user to get some idea of what exactly is going on in the case of failure, for example an exception might be more indicative of the execution status.
Since this is common to all instances of MemFS, it would be a good idea to refactor it into some singleton object.
The same semantics as with newFile hold here as well.
The sole purpose of MemFile is to provide the method combinedwhich takes care of path composition.
The details, although easy to follow, are a bit more complex than what we have usually seen.
Creating an input stream is merely constructing a new byte array input stream.
Creating an output stream is just a bit more involved, since we need to update the underlying byte array when the stream is closed.
Of course, closing the stream is solely a responsibility of client code.
The method that returns the children contained in the folder.
The requirement for ischildOf is that it must return true if the current path (this) is a path contained in the immediate children hierarchy of the passed argument.
Exercise 9.4 Redesign MemFS so that cache is not needed as it is.
Instead, take a hierarchical approach, where each MemoryFolder directly stores its children, so that information is kept in a more local manner.
We will not re-invent the wheel but will try to take advantage of existing JDK APIs.
So, it is clear that in order to reach generality, any VFile which will be used as the archive has to be transformed to a java.io.File or, in our library, to a NativeFile.
Before delving into the implementation of ZipFS, we need to say a few words about the approach we take.
The general idea is that on instantiation of a ZipFS, we load the archive and create a cache of its entries.
But this is not such a straightforward approach as it may seem initially.
Next, we iterate over all entries and update the caching map.
This procedure gives us a global view of what is in the archive.
But we are not done yet, since we need to create any missing entries synthetically.
The nested utility method mkAllPaths takes a path as input and generates a List of all the path’s hierarchy.
We then check this hierarchy of parent paths and record any part that was not discovered when we iterated the archive entries.
This procedure that checks a path hierarchy is repeated for all the discovered paths of the archive, as we can see by the outer loop.
The loop is over the path2vfile map entries and, of course, from the entry tuple we only consider the path.
The remaining methods are the usual VFS methods that must be implemented.
During the implementation of ZipFS and in particular its newFile method the need has arisen to return a nonexistent VFile.
In Scala, singletons have their own type which is distinct from the type of the class they extend.
Recall that we create synthetic entries in the ZipFS cache for all missing directory entries of the archive.
The above command gives us all subdirectories of the current one.
For what it is worth, find is really a very helpful command.
The reader is invited to search theWeb for more information on the find utility.
Returning to the VFile API, the task seems almost straightforward.
The children of a folder are already available, so we just need to pick the right ones:
These higher-order functions, like filter that we are using here, are fundamental building blocks.
These blocks act like small components ready to be composed by the programmer.
All we need to do is provide them with the appropriate input.
The input itself can be as simple as _.isFolder is or it can be the outcome of a more compositional approach, for example.
Then, a VFile matcher can be represented as Matcher[VFile[_]] or, since we have already introduced the type alias.
It can be even shorter by writing it as file.children filter matcher.matches, that is in the form object method parameter.
Exercise 10.1 Consult the Unix man page for the C function fnmatch in order to see the full potential of glob patterns.
Under a Unix shell this is normally achieved by executing the command man fnmatch.
The relevant piece of information can also be easily found on the Internet.
Then augment the current glob pattern implementation borrowing ideas from fnmatch.
Instead, in order to interpret a glob pattern,we leverage the power of regular expressions.We transform the pattern into a regular expression directly by following a few rules.
We use the (?i) special construct, which instructs the underlying regular expression engine to be case insensitive.
Alternatively, we can leave this piece off and just support case sensitivity as the default.
Usually, Java programmers either forget about this behavior or are totally unaware of it.
In any case, the relevant method of Matcher and the Java documentation is clear:
Resetting amatcher discards all of its explicit state information and sets its append position to zero…
Now we have already introduced regular expressions in Section 2.15
Everything seems in place and ready for immediate use, yet the observant reader may think that we have crossed language borders or, phrasing it more realistically, that we have crossed library borders.
We are so used to programming in Java that the necessary ingredients for an algorithm are almost seen in front of our eyes in JDK terms.
This kind of behavior may persist even after one goes beyond the level of a beginner Scala programmer.
Although there is no study to analyze the relevant behavior, a possible factor playing a key role is how much is the percentage of coding divided between Java and Scala.
We are new to Scala programming, coming immediately from a Java background.
As in the previous case, familiar classes from the JDK and relevant coding idioms are recalled easily and on-the-spot.
In fact, one may argue that Scala still needs more libraries to reach a critical mass that would make it “feature-full.” In such a case, we will inevitably have to resort either to the JDK or to some external Java library.
The Scala library incorporates the necessary features, but in a not very satisfactory way.
This deviates from the standard Java collections library, so that it can embrace the general programming style that Scala promotes.
This is evident in the use of higher-order functions (HOFs) like map and filter.
Since Scala provides such a comprehensive library, it is considered bad style to use Java collections when programming algorithms in pure Scala.
Of course, the mix with pure Java implementation is inevitable when dealing with the real world, but exactly for that reason appropriate wrappers exist, which bridge the gap between the two worlds.
On the other hand, there are some features that can be considered lower level.
The interface CharSequence is the common parent of String, StringBuffer and StringBuilder, the ubiquitous Java classes.
So, it is natural to transfer this interface to our Scala coding practice.
Yet, the truth is that time will tell exactly which coding patterns will survive.
First, we need to augment the VFileWithStar object with one more implicit conversion:
Second, we need to import the implicit conversion and we are ready to try again.
We can verify the correctness of the result, based on the previous directory listing.
It is not necessary to reproduce the above directory structure exactly, which resembles a tiny part of the authors’ hard disk, in order to test our library.
In fact, using different directory layouts and different search patterns can generally help in catching bugs! Testing algorithms with other than the usual inputs can be advantageous in professional programming.
Once more, the result reassures us of the expressiveness of Scala.
There is also just one subtle point that can usually come up in three ways:
Then, it just becomes a matter of a few keystrokes.
Evidently, the emerging pattern is that of boolean expressions, which is ubiquitous in programming.
So we need to provide support for boolean expressions at the matching level, which opts for an extension of Matcher[T]
In fact, the situation helps us a little towards a more object-functional path.
What we have are objects, which we wish to treat as values via their boolean composition.
The object-oriented nature (the matchers being instances of a class) and the functional nature (the boolean values that can be composed) seem so nicely.
Returning to the problem at hand and Figure 10.7, the common structure of the binary boolean relations is abstracted by method binop.
Exercise 10.5 Implement the aforementioned feature, in order to save memory resources.
Hint:Youmust be careful not to reject folders as soon as possible, so some special treatment of them is needed.Will it be advantageous to use scala.Stream, so that the constructed lists are lazy? Explore possible alternatives with and without streams.
For our exploration, we assume a general knowledge of the.
Implementing this interface allows an object to be the target of the “foreach” statement.
Scala mimics this functionality with its Iterable and Iterator traits, both under the top-level scala package:
Collection classesmixing in this class provide amethod elements,which returns an iterator over all the elements contained in the collection.
The idea, in all three languages, is to return anobject thatwe canuse to iterate over all the elements of the underlying collection.
Also,while an Iterator is normally a one-off utility, an Iterable plays the role of a generator for iterators.
So, referring to the Scala version, one can repeatedly call elements and always get a fresh object to work on.
The usual programming pattern deals with some tedious code, like the following:
But we already know that Scala promotes another style of iteration, the one using the for construct:
With this approach, we provide the list with a code block to execute for each one of its elements.
Note that Java also provides a foreach construct which is syntactically similar to the above but is, in effect, translated by the compiler to equivalent code of the hasNext/next style.
In this programming style, the programmer is not responsible for checking whether there are more items in the collection and for.
The role of each node in the tree, apart from holding domain data, is to point to its children.
So, we model this directly, using the Iterable programming interface.
The idea is to model nodes generically that act as placeholders of other nodes and this should be applied recursively.
Beware that this power comes with a price, as having too many implicits in scope can render the code not only less understandable but also incorrect.
Exercise 11.1 In the above example, the compiler needed some extra assistance by having us provide an explicit type parameter.
No matter how powerful and time-saving implicits may be, the previous solution can be charged as guilty of over-wrapping.
For every node in the hierarchy we create a wrapper, so it is as if we double the whole tree structure.
Although not stated explicitly, we have silently assumed that nodes are of the same or.
As is typical in the usual implementation scenarios, a node will provide some way, that is someAPI, to expose its children.
It is obvious that different kinds of nodes have different ways of providing their children, but the most important thing is the existence of such a facility.
What do we want to do with the tree? Iterate over the nodes.
What does iterate over the nodes mean? Iterate over them and their children.
So, we have a set of similar nodes, the node as an entity can provide us with its children and we wish to iterate over all nodes.
It is a plausible strategy, so let us start abstracting over the ingredients.
There is no special handling here, as the prescribed idea of type T parameter is the one to follow.
We have stated that all kinds of nodes, that is nodes for each type T as given above, will have a way to expose their children.
The only detail that remains in order to handle them uniformly, is to give a unifying API that does exactly that:
For example, a children provider for plain Java Files is coded as:
Skeleton implementation Figure 11.5 presents a skeleton implementation of a tree iterator.
It returns true if and only if there is some node to report and sets _next according to the previous rule.
This point will be clearer when presenting the actual DFS and BFS implementations.
One implementation detail about iterators, that new programmers usually ignore, is the fact that hasNext must not assume a subsequent call to next and vice versa.
A good question to ask in order to get into the heart of the problem is: How will the iterator behave if we continuously call hasNext (next) without ever calling next (hasNext)? Although it is an abuse of the programming interface, one may insist on getting all the nodes out of the iterator by just calling next, until an exception is thrown, which will signal the end of iteration.
So, ill-behaving clients may exist and our responsibility is to provide a robust implementation.
Keeping state We will implement our generic iterator using one of the DFS, BFS techniques.
Discovering each node does not necessarily mean that we will immediately report it as the next item to return from the iterator.
Figure 11.6 An abstract interface that models the idea of node buffering.
So, it is clear we will need some sort of buffering, the main idea of which is captured by the programming interface in Figure 11.6
Wewill need two concrete implementations for NodeStore, namely LIFOStore and FIFOStore:
In fact, different implementations will lead to other variations of iteration and this is the reason behind our introduction of the addChildrenOf method.
For the FIFOStore, on the other hand,we directly use a Queue, which represents the canonical example of a FIFO data structure:
So far,we have dealt with the ubiquitous Iterable and Iterator interfaces.
As a quick reminder, it contains just one method, foreach:
Another issue is that it feels as if we are missing.
What the above programming interface says, is: give me a node and I will process all of its children using function f.
We, the users of the API, drive the whole process.
We control when and whether to continue seeing the items, if more of them still exist.
On the other hand, we have no control on the iteration itself with a for, unless of course we force some kind of an abnormal exit, via throwing an exception.
Is should be evident by now that using hasNextperforms the iteration externally , while using for performs the iteration internally.
It is amatter of who is responsible for doing it.
Iteration with hasNext/next has been used traditionally in an object-oriented context, whereas the other form is ubiquitous in functional programming.
It is believed that the latter is so because of the need to have closures in order to support.
Instead of passing a closure around, we can pass the implementation of the interface but depending on the programming language we may have to take care of the free variables.
In a language with support for closures, free variables are handled by the language itself, i.e., the compiler.
It is just that closures make our programming experience a lot easier and certainly more concise.
We might wonder, for instance: Can we derive one approach from the other? If that is the case, then we say that the approaches are isomorphic, that is there is always an algorithm so that given one of the approaches we can derive the other.
Exercise 11.6 Derive a traversal-based implementation from an iterator-based implementation.
These conditions need not necessarily be all true and they are by no means exhaustive.
Of course, separation of concerns is only half the truth.We can identify our concerns and successfully separate them, but at some point we will need to recombine them: after all, they are parts of the original problem.
In the following, we will see how the expression problem appears in the setting of a common and well understood problem space: the design of an interpreter for a minimalistic expression language.
We will study the problem by applying several techniques, using along the way several features of Scala.
The intention rather is to explore the design space and see alternative attacks.
Also, unless stated otherwise, from now on the acronym ExP refers to the Expression Problem.
The requirements for our minimalistic expression language are that we need to model a set of operations over a set of data and we want to design both in an extensible way.
Our data, which represent expressions, may come in the form of integer literals or combinations of other expressions, as for example in the case of the addition basic operation.
Operations can be like the obviously needed evaluation or the string representation for each expression form.
A grammar that describes the small language is the following:
Note the functional appeal of EvalOp: since the visitor’s role is to evaluate expressions, we introduce an apply method.
New data mean new methods in every visitor, starting from the BaseOp trait and following down all the visitor hierarchy.
Having this consistent notation, any code snippet can be mentally partitioned to its semantic parts rather quickly, without having to resort to the accompanying text right away.
Also, we have kept the data naming the same for both the data-centric and the operation-centric approaches.
Obviously, looking at the methods supported by BaseD, namely eval in the data-centric approach and perform in the operation-centric approach respectively, reveals the nature of the approach.
This is unfortunate: we may not have touched the source code of our BaseD trait but we cannot reuse pre-existing library code that generates instances of type BaseD and we cannot directly reuse instances of type BaseD produced by our code.
Imagine that we have a library which was compiled before the introduction of the ReprSomeD data variants:
It is expected to return the // tax percentage scale for my income.
The above issue could be resolved if we could have our code produce the correct instance type, namely ReprNumD instead of its super type NumD.
Of course, we will have to provide one implicit conversion per data type transformation.
Another idea is to provide auxiliary constructors in the ReprSomeD variants that take the respective base traits as parameters:
On the constructor of ReprPlusD Let us take another look at the primary constructor of ReprPlusD.
The quick answer is, of course, it would not compile.
Not because the constructor is erroneous, but we need the a and b instances to have a repr method, in order for the repr method of ReprPlusD to compile:
A somewhat trivial observation one may note, but actually a fruitful one.
The question is: Can we constrain the constructor parameters in any way, so as to ensure they have a repr method and at the same time be BaseD instances?
Exercise 12.4 Try to model, in Scala, an answer to the above question.
Hint: You may have to decide whether something stronger is needed than the abstractions we have used so far.
After using subclassing for the data-centric approach, it is tempting to try it for the case of operations as well.
Let us say that we insert this new kind of data:
Destructive cast applications, like the one seen previously, may lead to runtime errors and we do not want our application to fail suddenly, in a way that cannot not be predicted.
In fact, if we think of Murphy’s Law, it will most certainly lead to runtime errors!
On the other hand, casts may appear in the form of conditionals:
Consecutive ifs reveal a procedure style, while under object-orientation polymorphism should be preferred.
Generally speaking, it is not rare in the application libraries landscape, even after the advent of generics into the Java platform, to use type casts while implementing a library.
The casts in the library are used to make the life of the application programmer easier.
In effect, they absorb all the small unsafe details, making them.
The following snippets from the Scala library implementation reveal exactly this fact:1
After all, casts exist in our code just because the language allows them to.
The examples are from revision 16570 of the Scala subversion trunk repository.
After this change, it is straightforward to add the new data PlusD in a statically type-safe manner.
Figure 12.4 Operation-centric approach to ExP with generics and Torgersen’s self parameter.
Our code example has become a little more verbose but at least we have gained static type-safety by providing an extra parameter of the needed type.
Let us now turn to a somewhat dual design by trying to incorporate generics in a data-centric approach.
The need for generics in this case will emerge from the simple data-centric approach of Section 12.3 and especially our remarks on the following constructor:
If, instead of ReprD we use BaseD, the problem, as discussed previously, is that we cannot call repr on a or b because repr does not exist in BaseD.
How do we patch them in order to get the extra repr method? Our line of thought is the following.
Then, we ask how to “parameterize” BaseD in a way that guarantees the extra features.
Inobject-oriented terminology, subtyping constraintswhere the type tobebounded (BaseD in this case) is used in the constraint itself, are traditionally called Fbounds [12]
Notice how we now constrain the abstract type T to be a subtype of the data supporting the new operation repr, in accordance of course with the general.
The respective concrete implementations for NumD and PlusD are the fully type-safe extensions.
Notice how, once again, Scala’s design decision to provide a primary constructor saves us from extra keystrokes and unnecessary verbosity.
In Java, we would have to provide an implementation for the constructor and in there issue a super constructor call.
Now, abstract types need an enclosing type and since we are modeling a small expression language with operations, we start like this:
To correct the situation, we make Data equal to BaseD.
What saved us previously was just the intentional type we gave to n1
In fact, if we try to compile without the n1 immutable value.
The reason is exactly the fact that type Data has not been assigned a known value (BaseD in this case)
Inside ReprPlusLang, the Data type refers to trait BaseD of ReprLang, so the parameters a and b already contain a repr method.
Exercise 12.5 So far, our operations return primitive types, for example, Int and String.
Note that the requirement is that negate does not just return an Int but an expression of our mini language.
For example, a NumD instance is expected to return another NumD instance with the underlying Int value negated.
Figure 12.6 Base language for an operation-centric decomposition of the ExPwith abstract type members.
This way we constrain the type of any instance of EvalOp actually to be a subtype of our abstract type Operation, which is absolutely necessary for the following code inside EvalOp to type check:
Actually, this is a point where Scala’s expressiveness really shines.
Had we not used the explicit self-type, this would just be of type BaseOp and not of type Operation, as expected by the signature of method perform in BaseOp.
The situation is similar to the one we faced in the context of the generic operation-centric approach developed in Section 12.5
There, the trick of an extra self parameter with the correct type was used.
Here, we constrain, by design, instances of BaseOp to be instances of Operation and we let the compiler enforce this constraint and either accept our program or complain accordingly.
Exercise 12.6 Explore the design decision of using self-types in the context of the generic operation-centric approach.
Generally speaking, with Scala, feel free to experiment in any direction that seems suitable.
The language is so expressive that even slight deviations from established knowledge may either lead to interesting results or at least provide a rewarding (in itself) working path.
Also, in Figure 12.6 an abstract factory method is provided, namely newEvalOp, that will be used to create, on demand, new instances of the evaluation operation.
The return type mixes EvalOp with Operation so that the self-type of EvalOp’s.
Again, the explicit self-type reference is mandatory, in order to preserve the correct semantics, and we have used the same recipe with the factory method newReprOp and the functional object repr.
Exercise 12.7 Create a second operation extension and provide a combination of the two operations by a proper mixin.
Exercise 12.8 Provide a combination of a data extension with an operation extension.
We have presented the expression problem, which we believe is a fundamental design issue any software engineer should be aware of.
While tackling the problem,we have progressively used language features existing in.
The latter reveal the undeniably rich expressiveness of the Scala language.
In order to follow the examples presented in this chaptermore easily,we have used a common language thatmodels our problem domain, namely a small expression language.
In this direction, the naming of our traits and classes is consistent across all of the presented attacks on the expression problem.
In our opinion, the essence of the expression problem reveals a fundamental need: to come up with expressive designs that can model it; designs that should be based on reusable and extensible components.
Symbolic computation refers to the use of machines, such as computers, to manipulate mathematical content (i.e., equations, expressions, etc.) in symbolic form and deliver a result in this form.A classical example of such a system is one that can compute the derivative of a function expressed in some symbolic form (i.e., sin(x)+1)
In this chapter we will explain why symbolic computation is interesting and what it can achieve, and then we are going to present a simple system that can differentiate functions.
A consequence of this proof was that the dream of a fully mechanized mathematical science was not feasible.
Nevertheless, certain problems of mathematics can be solved by purely mechanical methods.
For example, it has been demonstrated that certain operations like differentiation and integration can be performed mechanically.
In general, such systems are known as symbolic computation or computer algebra systems.
MathematicaTM and MapleTM are two very popular symbolic computation systems that are used by many people almost every day.
The reader interested in the details of this and related issues should consult a specialized book (for example, see [72])
Systems of symbolic computation are similar to modern programming language processors.
First of all, they read strings that belong to some language (for example, a language describing functions)
Second, they transform these strings into an internal representation (for example, some sort of parse tree)
After this, they transform the input using transformation and rewrite rules.
In the end, they ought to deliver their result in a form that is at least as readable as the strings of the input language.
For example, if someone uses a system that differentiates functions, when one enters.
Let us now outline what are the steps involved in the construction of a rudimentary symbolic computation system.
Inmost cases users expect new systems to be able to understand input in some standard form.
For example, it is quite realistic to expect that a system that performs symbolic differentiation will be able to understand input in either TEX’s notation or the notation employed in most programming languages.
Again to keep things simple, we will use a subset of the notation employed by most programming languages.
In addition, since most common programming languages do not include.
Exercise 13.2 Write down a parser for the grammar above.
We have decided not to distinguish numbers and so to have only one class for numbers:
If we want to introduce more features, then we can augment this hierarchy accordingly.
Clearly, we have not instructed Scala how to mix #s with numbers.
As expected, an implicit conversion (see Section 3.6.3) will do the job:
Table 13.1 Derivatives of basic functions and combinations of functions.
Although this table is by no means complete, it includes the necessary information for our little programming project.
This means that we have to simplify the result produced by this function.
First of all, we need to get rid of zeros and ones in additions and multiplications, respectively.
As is evident, the bigger the return value the higher the precedence of the operator.
Next we need to use these functions in order to decide whether a subexpression must be enclosed in parentheses when it is printed.
The idea is very simple – we compute the precedence of a subexpression and if its precedence is less than the precedence of the operator, then we enclose the subexpresion in parentheses.
And the following functions implement the same idea for unary operators:
Now that we have solved all the subproblems involved (we assume that the reader has constructed the parser of Exercise 13.2), we can proceed and complete our programming project.
Again, we need to use some standard Java classes to handle input:
The skeleton code that follows shows how we have implemented the changes just described.
In this chapter we have used Scala’s facilities to design and implement a simple algebraic system.The approach taken for differentiation is straightforward andprobably.
In fact, it is common practice to do it in this way in programming courses teaching Prolog and/or functional programming languages.
Our main symbolic manipulation has concentrated on differentiation but one should expect a computer algebra system to treat integration as well.
Unfortunately, as opposed to the exact differentiation rules, integration does not enjoy such a generic treatment.
Nevertheless, the set of known functions that are integrated exactly is not small.
Unfortunately, the JMF is not up-to-date and a better solution would be to use native libraries.
For example, one can use the libmpg123, which was developed by Michael Hipp and Thomas Orgis.
An easy way to do this is to use the Java Native Access framework.
But we do not plan to explain how this can be done.
Readers are very welcome to use all these tools to implement a simple MP3 player.
Let us assume that we have programmed our Scala application and the next major task is to provide it for download, so that people may try it.
What are our options? In fact, there are several parameters to consider.
One such parameter relates to whether we will use an installer creator in order to make a click-and-go executable.
Providing an installer is quite common if indeed what we have is an application and less common if our product is just a library.
Another parameter to consider is what assumptions we make on the requirements for the end-user’s client machine.
In this appendix we will concentrate on that last point and in particular what to do if a Scala installation at the client’s machine is not always a true assumption (an assumption that not always evaluates to true)
Distributing an application to an end user is different from distributing it to a developer.
Scala is not at the moment an integrated part of any operating system and so we cannot rely on the user’s open mind, curiosity and even a tendency for language exploration in order to assume that Scala is installed at people’s computers.
Proguard1 is an open-source program that can shrink, optimize, obfuscate and preverify Java classes.
Obfuscation prevents reverse engineering by stripping off any debugging information and.
Here,we have searched for executables in the PATH that contain the string“exe.”The command was actually executed in one of the authors’MacBook, with the macports suite installed under folder /opt/local.
The second missing implementation part, and the most interesting one, selects only the nonempty directories in the PATH:
Now that the implementation is complete, the script can be run using.
For the rest of the world (Windows, Linux, etc.), the standard conventions of a SUN JDK apply and the entry should read like this:
By using -forceprocessing, we make our intentions clear that we always want proguard to do its normal processing.
In this appendix, we show how to use both the Scala compiler (scalac) and the Scala interpreter (scala) by experimenting with their command line arguments.
Part of our presentation is based on the man pages coming with every Scala distribution.
The good news is that Scala is indeed scalable in many ways and, after all, there is no harm in advertising features that already exist.
One such dimension of scalability has to do with the provided tools and how they can be used to increase the overall experience of programming in Scala.
We will see that the features provided give a pleasant feeling that the language “grows” to our needs.
For the following, we assume that Scala is installed under a folder denoted by the value of the environment variable SCALA_HOME.
It is good practice to set this variable, since other applications that use Scala may depend on it.
Even the interpreter uses it internally in order to give the impression of a scripting environment.
As expected, it is packed with a wealth of command line options.
Using scalac with no options and parameters informs us of all the options.
In the following, we describe the functionality provided by the majority of the options.
Table C.1 The options of scalac, as reported when we call the executable with no command line arguments.
Option -verbose is used when we want to inspect what the compiler is doing.
For example, adding a -verbose to the previous command line generates a series of lines:
Option -deprecation is a boolean one, accepting these values: on, off, yes and no.
Deprecated APIs should be marked as such by using the @deprecated annotation.
The idea behind the -unchecked option is to inform the user about conditions related to type erasure.
Using our sample code in testwarn.scala, we can compile with -unchecked and observe the extra information that scalac provides:
Option -bootclasspath should provide a class path that will be used to locate the standard Scala classes, as for example scala.List.
If no value is given in the command line, then jvm-1.5 is assumed.
For this to succeed, the type of the value we try to assign to strListmust be either the exact type of strList, that is List[String], or a subtype of it.
But, clearly, this does not hold and so scalac complains with a type mismatch error.
Note that in these debug messages, scalac is a bit inconsistent with what operator represents subtyping.
Table C.2 A subset of the advanced options of scalac.
Here we will mainly discuss options related to compiler phases.
We can obtain a list of all the available phases by using the -Xshow-phases option:
Providing a description of the purpose and inner workings of all these phases is beyond the scope of this book.More information can be found at the Scala web site.
After parsing, the source code is transformed to an intermediate AST representation.
Each phase then transforms this abstract syntax tree, potentially altering information on the symbols the tree contains, augmenting the tree with extra nodes or pruning existing nodes.
Using -Xprint:namer The namer phase is responsible for declaring compiler internal symbols from our source code:
In the implementation of factorial, the call x.$less$eq(0) uses the internal,
Respectively, the subtraction operator - is transformed to a call to method $minus.
The above is a function of two Int arguments, producing an Int result.
These compiler plugins are software components that can be injected between the several compiler phases and whose role is to provide some new functionality.
From Table C.2, all the plugin-related options start with -Xplugin.
Disabling assertions Assertions, that is conditions that are checked and for which an exception is thrown if not found to hold, are enabled by default.
Everyday practice, however, shows that people usually do not follow this advice and prefer to retain assertions all the time.
The correct way to achieve the same functionality is to have a simpler script.
They are either meant to be used by the compiler development team for debugging or are considered experimental.
In any case they are subject to change without any notice.
Nevertheless, as we will see, they can be very useful.
Table C.3 A subset of the private options of scalac.
Option -e treats the next argument as inline Scala code, which is evaluated at once.
The expression problem revisited – four new solutions using generics.
Subtle type inferring issues Can we do better than wrapping?
